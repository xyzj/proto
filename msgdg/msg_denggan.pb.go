// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: msg_denggan.proto

package wlst_dg

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// rabbitmq过滤器命名规则：
//    下行：[wlst-micro].devdown.[dataparser-dgsensor].[mq标识，默认0].dg-sensor-[8fxx].[12位设备地址].[tra]
//    上行：[wlst-micro].devuplink.[devmanager-dgsensor].[mq标识，默认0].dg-sensor-[8fxx].[12位设备地址].[tra]
//
type MsgDengGan struct {
	// 指令序号，0-255
	Idx int32 `protobuf:"varint,1,opt,name=idx,proto3" json:"idx,omitempty"`
	// 设备地址
	Addr int64 `protobuf:"varint,2,opt,name=addr,proto3" json:"addr,omitempty"`
	// 设备命令，同结构体名称，如dg.sensor.8f80
	Cmd string `protobuf:"bytes,3,opt,name=cmd,proto3" json:"cmd,omitempty"`
	// 灯杆传感器主报
	DgSensor_8F80 *DG_Sensor_8F80 `protobuf:"bytes,11,opt,name=dg_sensor_8f80,json=dgSensor8f80,proto3" json:"dg_sensor_8f80,omitempty"`
}

func (m *MsgDengGan) Reset()         { *m = MsgDengGan{} }
func (m *MsgDengGan) String() string { return proto.CompactTextString(m) }
func (*MsgDengGan) ProtoMessage()    {}
func (*MsgDengGan) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b148735db0017c6, []int{0}
}
func (m *MsgDengGan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDengGan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDengGan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDengGan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDengGan.Merge(m, src)
}
func (m *MsgDengGan) XXX_Size() int {
	return m.Size()
}
func (m *MsgDengGan) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDengGan.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDengGan proto.InternalMessageInfo

func (m *MsgDengGan) GetIdx() int32 {
	if m != nil {
		return m.Idx
	}
	return 0
}

func (m *MsgDengGan) GetAddr() int64 {
	if m != nil {
		return m.Addr
	}
	return 0
}

func (m *MsgDengGan) GetCmd() string {
	if m != nil {
		return m.Cmd
	}
	return ""
}

func (m *MsgDengGan) GetDgSensor_8F80() *DG_Sensor_8F80 {
	if m != nil {
		return m.DgSensor_8F80
	}
	return nil
}

// 灯杆传感器
// 自动上传数据
type DG_Sensor_8F80 struct {
	// 通讯模式,0自动 1手动
	CommunicationMode int32 `protobuf:"varint,1,opt,name=communication_mode,json=communicationMode,proto3" json:"communication_mode,omitempty"`
	// 通讯速率 范围1~255（s）
	CommunicationRate int32 `protobuf:"varint,2,opt,name=communication_rate,json=communicationRate,proto3" json:"communication_rate,omitempty"`
	// 倾角x 报警，0-正常，1-报警，下同
	AlarmX int32 `protobuf:"varint,3,opt,name=alarm_x,json=alarmX,proto3" json:"alarm_x,omitempty"`
	// 倾角y 报警
	AlarmY int32 `protobuf:"varint,4,opt,name=alarm_y,json=alarmY,proto3" json:"alarm_y,omitempty"`
	// 倾角z 报警
	AlarmZ int32 `protobuf:"varint,5,opt,name=alarm_z,json=alarmZ,proto3" json:"alarm_z,omitempty"`
	// 温度上限 报警
	AlarmTemperatureUplimit int32 `protobuf:"varint,6,opt,name=alarm_temperature_uplimit,json=alarmTemperatureUplimit,proto3" json:"alarm_temperature_uplimit,omitempty"`
	// 温度下限 报警
	AlarmTemperatureLowlimit int32 `protobuf:"varint,7,opt,name=alarm_temperature_lowlimit,json=alarmTemperatureLowlimit,proto3" json:"alarm_temperature_lowlimit,omitempty"`
	// 湿度下限 报警
	AlarmHumidityUplimit int32 `protobuf:"varint,9,opt,name=alarm_humidity_uplimit,json=alarmHumidityUplimit,proto3" json:"alarm_humidity_uplimit,omitempty"`
	// 气压上限 报警
	AlarmPressureUplimit int32 `protobuf:"varint,10,opt,name=alarm_pressure_uplimit,json=alarmPressureUplimit,proto3" json:"alarm_pressure_uplimit,omitempty"`
	// 气压下限 报警
	AlarmPerssureLowlimit int32 `protobuf:"varint,11,opt,name=alarm_perssure_lowlimit,json=alarmPerssureLowlimit,proto3" json:"alarm_perssure_lowlimit,omitempty"`
	// 照度上限 报警
	AlarmLuxUplimit int32 `protobuf:"varint,12,opt,name=alarm_lux_uplimit,json=alarmLuxUplimit,proto3" json:"alarm_lux_uplimit,omitempty"`
	// 照度下限 报警
	AlarmLuxLowlimit int32 `protobuf:"varint,13,opt,name=alarm_lux_lowlimit,json=alarmLuxLowlimit,proto3" json:"alarm_lux_lowlimit,omitempty"`
	// 倾角X（度）
	AngleX float64 `protobuf:"fixed64,14,opt,name=angle_x,json=angleX,proto3" json:"angle_x,omitempty"`
	// 倾角Y
	AngleY float64 `protobuf:"fixed64,15,opt,name=angle_y,json=angleY,proto3" json:"angle_y,omitempty"`
	// 倾角Z
	AngleZ float64 `protobuf:"fixed64,16,opt,name=angle_z,json=angleZ,proto3" json:"angle_z,omitempty"`
	// 温度（摄氏度）
	Temperature float64 `protobuf:"fixed64,17,opt,name=temperature,proto3" json:"temperature,omitempty"`
	// 湿度（%）
	Humidity float64 `protobuf:"fixed64,18,opt,name=humidity,proto3" json:"humidity,omitempty"`
	// 气压（pa）
	Pressure float64 `protobuf:"fixed64,19,opt,name=pressure,proto3" json:"pressure,omitempty"`
	// 照度（lux）
	Lux float64 `protobuf:"fixed64,20,opt,name=lux,proto3" json:"lux,omitempty"`
}

func (m *DG_Sensor_8F80) Reset()         { *m = DG_Sensor_8F80{} }
func (m *DG_Sensor_8F80) String() string { return proto.CompactTextString(m) }
func (*DG_Sensor_8F80) ProtoMessage()    {}
func (*DG_Sensor_8F80) Descriptor() ([]byte, []int) {
	return fileDescriptor_2b148735db0017c6, []int{1}
}
func (m *DG_Sensor_8F80) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DG_Sensor_8F80) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DG_Sensor_8F80.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DG_Sensor_8F80) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DG_Sensor_8F80.Merge(m, src)
}
func (m *DG_Sensor_8F80) XXX_Size() int {
	return m.Size()
}
func (m *DG_Sensor_8F80) XXX_DiscardUnknown() {
	xxx_messageInfo_DG_Sensor_8F80.DiscardUnknown(m)
}

var xxx_messageInfo_DG_Sensor_8F80 proto.InternalMessageInfo

func (m *DG_Sensor_8F80) GetCommunicationMode() int32 {
	if m != nil {
		return m.CommunicationMode
	}
	return 0
}

func (m *DG_Sensor_8F80) GetCommunicationRate() int32 {
	if m != nil {
		return m.CommunicationRate
	}
	return 0
}

func (m *DG_Sensor_8F80) GetAlarmX() int32 {
	if m != nil {
		return m.AlarmX
	}
	return 0
}

func (m *DG_Sensor_8F80) GetAlarmY() int32 {
	if m != nil {
		return m.AlarmY
	}
	return 0
}

func (m *DG_Sensor_8F80) GetAlarmZ() int32 {
	if m != nil {
		return m.AlarmZ
	}
	return 0
}

func (m *DG_Sensor_8F80) GetAlarmTemperatureUplimit() int32 {
	if m != nil {
		return m.AlarmTemperatureUplimit
	}
	return 0
}

func (m *DG_Sensor_8F80) GetAlarmTemperatureLowlimit() int32 {
	if m != nil {
		return m.AlarmTemperatureLowlimit
	}
	return 0
}

func (m *DG_Sensor_8F80) GetAlarmHumidityUplimit() int32 {
	if m != nil {
		return m.AlarmHumidityUplimit
	}
	return 0
}

func (m *DG_Sensor_8F80) GetAlarmPressureUplimit() int32 {
	if m != nil {
		return m.AlarmPressureUplimit
	}
	return 0
}

func (m *DG_Sensor_8F80) GetAlarmPerssureLowlimit() int32 {
	if m != nil {
		return m.AlarmPerssureLowlimit
	}
	return 0
}

func (m *DG_Sensor_8F80) GetAlarmLuxUplimit() int32 {
	if m != nil {
		return m.AlarmLuxUplimit
	}
	return 0
}

func (m *DG_Sensor_8F80) GetAlarmLuxLowlimit() int32 {
	if m != nil {
		return m.AlarmLuxLowlimit
	}
	return 0
}

func (m *DG_Sensor_8F80) GetAngleX() float64 {
	if m != nil {
		return m.AngleX
	}
	return 0
}

func (m *DG_Sensor_8F80) GetAngleY() float64 {
	if m != nil {
		return m.AngleY
	}
	return 0
}

func (m *DG_Sensor_8F80) GetAngleZ() float64 {
	if m != nil {
		return m.AngleZ
	}
	return 0
}

func (m *DG_Sensor_8F80) GetTemperature() float64 {
	if m != nil {
		return m.Temperature
	}
	return 0
}

func (m *DG_Sensor_8F80) GetHumidity() float64 {
	if m != nil {
		return m.Humidity
	}
	return 0
}

func (m *DG_Sensor_8F80) GetPressure() float64 {
	if m != nil {
		return m.Pressure
	}
	return 0
}

func (m *DG_Sensor_8F80) GetLux() float64 {
	if m != nil {
		return m.Lux
	}
	return 0
}

func init() {
	proto.RegisterType((*MsgDengGan)(nil), "wlst.dg.MsgDengGan")
	proto.RegisterType((*DG_Sensor_8F80)(nil), "wlst.dg.DG_Sensor_8F80")
}

func init() { proto.RegisterFile("msg_denggan.proto", fileDescriptor_2b148735db0017c6) }

var fileDescriptor_2b148735db0017c6 = []byte{
	// 491 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x64, 0x93, 0xcf, 0x6e, 0xd3, 0x40,
	0x10, 0x87, 0xb3, 0xa4, 0x49, 0xe8, 0xa4, 0xa4, 0xc9, 0x52, 0xc8, 0x92, 0x83, 0x65, 0xf5, 0x14,
	0x21, 0x88, 0x2a, 0x40, 0x28, 0x42, 0x70, 0x41, 0x15, 0xed, 0xa1, 0x95, 0x90, 0x01, 0xa9, 0xed,
	0xc5, 0x32, 0xd9, 0xc5, 0x58, 0xf2, 0xda, 0xd1, 0x7a, 0xad, 0x3a, 0xbd, 0xf2, 0x02, 0x3c, 0x16,
	0xc7, 0x1e, 0x39, 0xa2, 0xe4, 0xc2, 0x63, 0x54, 0x9e, 0xf5, 0xbf, 0xb6, 0xb7, 0x19, 0x7f, 0xbf,
	0xcf, 0x33, 0xf6, 0x6a, 0x61, 0x24, 0x13, 0xdf, 0xe5, 0x22, 0xf2, 0x7d, 0x2f, 0x9a, 0x2d, 0x55,
	0xac, 0x63, 0xda, 0xbb, 0x0c, 0x13, 0x3d, 0xe3, 0xfe, 0xfe, 0x2f, 0x02, 0x70, 0x9a, 0xf8, 0x87,
	0x22, 0xf2, 0x8f, 0xbc, 0x88, 0x0e, 0xa1, 0x1d, 0xf0, 0x8c, 0x11, 0x9b, 0x4c, 0x3b, 0x4e, 0x5e,
	0x52, 0x0a, 0x5b, 0x1e, 0xe7, 0x8a, 0x3d, 0xb0, 0xc9, 0xb4, 0xed, 0x60, 0x9d, 0xa7, 0x16, 0x92,
	0xb3, 0xb6, 0x4d, 0xa6, 0xdb, 0x4e, 0x5e, 0xd2, 0x0f, 0x30, 0xe0, 0xbe, 0x9b, 0x88, 0x28, 0x89,
	0x95, 0x3b, 0xff, 0x31, 0x3f, 0x60, 0x7d, 0x9b, 0x4c, 0xfb, 0xaf, 0xc6, 0xb3, 0x62, 0xd0, 0xec,
	0xf0, 0xc8, 0xfd, 0x52, 0xe0, 0x4f, 0xf3, 0x03, 0x67, 0x87, 0xfb, 0xa6, 0xcd, 0xc3, 0xfb, 0xff,
	0x3b, 0x30, 0xb8, 0x1d, 0xa0, 0x2f, 0x81, 0x2e, 0x62, 0x29, 0xd3, 0x28, 0x58, 0x78, 0x3a, 0x88,
	0x23, 0x57, 0xc6, 0x5c, 0x14, 0x8b, 0x8d, 0x6e, 0x91, 0xd3, 0x98, 0x8b, 0xfb, 0x71, 0xe5, 0x69,
	0x81, 0x4b, 0xdf, 0x8d, 0x3b, 0x9e, 0x16, 0x74, 0x0c, 0x3d, 0x2f, 0xf4, 0x94, 0x74, 0x33, 0xfc,
	0x8a, 0x8e, 0xd3, 0xc5, 0xf6, 0xac, 0x06, 0x2b, 0xb6, 0xd5, 0x00, 0xe7, 0x35, 0xb8, 0x62, 0x9d,
	0x06, 0xb8, 0xa0, 0xef, 0xe0, 0x99, 0x01, 0x5a, 0xc8, 0xa5, 0x50, 0x9e, 0x4e, 0x95, 0x70, 0xd3,
	0x65, 0x18, 0xc8, 0x40, 0xb3, 0x2e, 0x46, 0xc7, 0x18, 0xf8, 0x5a, 0xf3, 0x6f, 0x06, 0xd3, 0xf7,
	0x30, 0xb9, 0xef, 0x86, 0xf1, 0xa5, 0x91, 0x7b, 0x28, 0xb3, 0xbb, 0xf2, 0x49, 0xc1, 0xe9, 0x1b,
	0x78, 0x6a, 0xec, 0x9f, 0xa9, 0x0c, 0x78, 0xa0, 0x57, 0xd5, 0xd8, 0x6d, 0x34, 0xf7, 0x90, 0x1e,
	0x17, 0xb0, 0x9c, 0x59, 0x59, 0x4b, 0x25, 0x92, 0xa4, 0xb9, 0x2c, 0x34, 0xac, 0xcf, 0x05, 0x2c,
	0xad, 0xb7, 0x30, 0x2e, 0x2c, 0xa1, 0x8c, 0x55, 0xad, 0xd9, 0x47, 0xed, 0x89, 0xd1, 0x0a, 0x5a,
	0xed, 0xf8, 0x1c, 0x46, 0xc6, 0x0b, 0xd3, 0xac, 0x1a, 0xb4, 0x83, 0xc6, 0x2e, 0x82, 0x93, 0x34,
	0x2b, 0x67, 0xbc, 0x00, 0x5a, 0x67, 0xab, 0xd7, 0x3f, 0xc2, 0xf0, 0xb0, 0x0c, 0x57, 0x6f, 0xce,
	0x0f, 0x24, 0xf2, 0x43, 0xe1, 0x66, 0x6c, 0x60, 0x93, 0x29, 0x71, 0xba, 0xd8, 0x9e, 0xd5, 0x60,
	0xc5, 0x76, 0x1b, 0xe0, 0xbc, 0x06, 0x57, 0x6c, 0xd8, 0x00, 0x17, 0xd4, 0x86, 0x7e, 0xe3, 0x00,
	0xd8, 0x08, 0x61, 0xf3, 0x11, 0x9d, 0xc0, 0xc3, 0xf2, 0x27, 0x33, 0x8a, 0xb8, 0xea, 0x73, 0x56,
	0xfe, 0x4a, 0xf6, 0xd8, 0xb0, 0xb2, 0xcf, 0x6f, 0x4a, 0x98, 0x66, 0x6c, 0x0f, 0x1f, 0xe7, 0xe5,
	0xc7, 0xc9, 0x9f, 0xb5, 0x45, 0xae, 0xd7, 0x16, 0xf9, 0xb7, 0xb6, 0xc8, 0xef, 0x8d, 0xd5, 0xba,
	0xde, 0x58, 0xad, 0xbf, 0x1b, 0xab, 0x75, 0x4c, 0xbe, 0x77, 0xf1, 0x72, 0xbe, 0xbe, 0x09, 0x00,
	0x00, 0xff, 0xff, 0x60, 0x94, 0xb1, 0x17, 0xb1, 0x03, 0x00, 0x00,
}

func (m *MsgDengGan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDengGan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDengGan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DgSensor_8F80 != nil {
		{
			size, err := m.DgSensor_8F80.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgDenggan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Cmd) > 0 {
		i -= len(m.Cmd)
		copy(dAtA[i:], m.Cmd)
		i = encodeVarintMsgDenggan(dAtA, i, uint64(len(m.Cmd)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Addr != 0 {
		i = encodeVarintMsgDenggan(dAtA, i, uint64(m.Addr))
		i--
		dAtA[i] = 0x10
	}
	if m.Idx != 0 {
		i = encodeVarintMsgDenggan(dAtA, i, uint64(m.Idx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DG_Sensor_8F80) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DG_Sensor_8F80) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DG_Sensor_8F80) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Lux != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Lux))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa1
	}
	if m.Pressure != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Pressure))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x99
	}
	if m.Humidity != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Humidity))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x91
	}
	if m.Temperature != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Temperature))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x89
	}
	if m.AngleZ != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.AngleZ))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x81
	}
	if m.AngleY != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.AngleY))))
		i--
		dAtA[i] = 0x79
	}
	if m.AngleX != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.AngleX))))
		i--
		dAtA[i] = 0x71
	}
	if m.AlarmLuxLowlimit != 0 {
		i = encodeVarintMsgDenggan(dAtA, i, uint64(m.AlarmLuxLowlimit))
		i--
		dAtA[i] = 0x68
	}
	if m.AlarmLuxUplimit != 0 {
		i = encodeVarintMsgDenggan(dAtA, i, uint64(m.AlarmLuxUplimit))
		i--
		dAtA[i] = 0x60
	}
	if m.AlarmPerssureLowlimit != 0 {
		i = encodeVarintMsgDenggan(dAtA, i, uint64(m.AlarmPerssureLowlimit))
		i--
		dAtA[i] = 0x58
	}
	if m.AlarmPressureUplimit != 0 {
		i = encodeVarintMsgDenggan(dAtA, i, uint64(m.AlarmPressureUplimit))
		i--
		dAtA[i] = 0x50
	}
	if m.AlarmHumidityUplimit != 0 {
		i = encodeVarintMsgDenggan(dAtA, i, uint64(m.AlarmHumidityUplimit))
		i--
		dAtA[i] = 0x48
	}
	if m.AlarmTemperatureLowlimit != 0 {
		i = encodeVarintMsgDenggan(dAtA, i, uint64(m.AlarmTemperatureLowlimit))
		i--
		dAtA[i] = 0x38
	}
	if m.AlarmTemperatureUplimit != 0 {
		i = encodeVarintMsgDenggan(dAtA, i, uint64(m.AlarmTemperatureUplimit))
		i--
		dAtA[i] = 0x30
	}
	if m.AlarmZ != 0 {
		i = encodeVarintMsgDenggan(dAtA, i, uint64(m.AlarmZ))
		i--
		dAtA[i] = 0x28
	}
	if m.AlarmY != 0 {
		i = encodeVarintMsgDenggan(dAtA, i, uint64(m.AlarmY))
		i--
		dAtA[i] = 0x20
	}
	if m.AlarmX != 0 {
		i = encodeVarintMsgDenggan(dAtA, i, uint64(m.AlarmX))
		i--
		dAtA[i] = 0x18
	}
	if m.CommunicationRate != 0 {
		i = encodeVarintMsgDenggan(dAtA, i, uint64(m.CommunicationRate))
		i--
		dAtA[i] = 0x10
	}
	if m.CommunicationMode != 0 {
		i = encodeVarintMsgDenggan(dAtA, i, uint64(m.CommunicationMode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintMsgDenggan(dAtA []byte, offset int, v uint64) int {
	offset -= sovMsgDenggan(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgDengGan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Idx != 0 {
		n += 1 + sovMsgDenggan(uint64(m.Idx))
	}
	if m.Addr != 0 {
		n += 1 + sovMsgDenggan(uint64(m.Addr))
	}
	l = len(m.Cmd)
	if l > 0 {
		n += 1 + l + sovMsgDenggan(uint64(l))
	}
	if m.DgSensor_8F80 != nil {
		l = m.DgSensor_8F80.Size()
		n += 1 + l + sovMsgDenggan(uint64(l))
	}
	return n
}

func (m *DG_Sensor_8F80) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CommunicationMode != 0 {
		n += 1 + sovMsgDenggan(uint64(m.CommunicationMode))
	}
	if m.CommunicationRate != 0 {
		n += 1 + sovMsgDenggan(uint64(m.CommunicationRate))
	}
	if m.AlarmX != 0 {
		n += 1 + sovMsgDenggan(uint64(m.AlarmX))
	}
	if m.AlarmY != 0 {
		n += 1 + sovMsgDenggan(uint64(m.AlarmY))
	}
	if m.AlarmZ != 0 {
		n += 1 + sovMsgDenggan(uint64(m.AlarmZ))
	}
	if m.AlarmTemperatureUplimit != 0 {
		n += 1 + sovMsgDenggan(uint64(m.AlarmTemperatureUplimit))
	}
	if m.AlarmTemperatureLowlimit != 0 {
		n += 1 + sovMsgDenggan(uint64(m.AlarmTemperatureLowlimit))
	}
	if m.AlarmHumidityUplimit != 0 {
		n += 1 + sovMsgDenggan(uint64(m.AlarmHumidityUplimit))
	}
	if m.AlarmPressureUplimit != 0 {
		n += 1 + sovMsgDenggan(uint64(m.AlarmPressureUplimit))
	}
	if m.AlarmPerssureLowlimit != 0 {
		n += 1 + sovMsgDenggan(uint64(m.AlarmPerssureLowlimit))
	}
	if m.AlarmLuxUplimit != 0 {
		n += 1 + sovMsgDenggan(uint64(m.AlarmLuxUplimit))
	}
	if m.AlarmLuxLowlimit != 0 {
		n += 1 + sovMsgDenggan(uint64(m.AlarmLuxLowlimit))
	}
	if m.AngleX != 0 {
		n += 9
	}
	if m.AngleY != 0 {
		n += 9
	}
	if m.AngleZ != 0 {
		n += 10
	}
	if m.Temperature != 0 {
		n += 10
	}
	if m.Humidity != 0 {
		n += 10
	}
	if m.Pressure != 0 {
		n += 10
	}
	if m.Lux != 0 {
		n += 10
	}
	return n
}

func sovMsgDenggan(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMsgDenggan(x uint64) (n int) {
	return sovMsgDenggan(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgDengGan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgDenggan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDengGan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDengGan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			m.Idx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgDenggan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Idx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			m.Addr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgDenggan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Addr |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgDenggan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgDenggan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgDenggan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cmd = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DgSensor_8F80", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgDenggan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgDenggan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgDenggan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DgSensor_8F80 == nil {
				m.DgSensor_8F80 = &DG_Sensor_8F80{}
			}
			if err := m.DgSensor_8F80.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgDenggan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgDenggan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DG_Sensor_8F80) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgDenggan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DG_Sensor_8F80: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DG_Sensor_8F80: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommunicationMode", wireType)
			}
			m.CommunicationMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgDenggan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommunicationMode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommunicationRate", wireType)
			}
			m.CommunicationRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgDenggan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommunicationRate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlarmX", wireType)
			}
			m.AlarmX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgDenggan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlarmX |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlarmY", wireType)
			}
			m.AlarmY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgDenggan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlarmY |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlarmZ", wireType)
			}
			m.AlarmZ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgDenggan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlarmZ |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlarmTemperatureUplimit", wireType)
			}
			m.AlarmTemperatureUplimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgDenggan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlarmTemperatureUplimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlarmTemperatureLowlimit", wireType)
			}
			m.AlarmTemperatureLowlimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgDenggan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlarmTemperatureLowlimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlarmHumidityUplimit", wireType)
			}
			m.AlarmHumidityUplimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgDenggan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlarmHumidityUplimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlarmPressureUplimit", wireType)
			}
			m.AlarmPressureUplimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgDenggan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlarmPressureUplimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlarmPerssureLowlimit", wireType)
			}
			m.AlarmPerssureLowlimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgDenggan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlarmPerssureLowlimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlarmLuxUplimit", wireType)
			}
			m.AlarmLuxUplimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgDenggan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlarmLuxUplimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlarmLuxLowlimit", wireType)
			}
			m.AlarmLuxLowlimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgDenggan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlarmLuxLowlimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AngleX", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.AngleX = float64(math.Float64frombits(v))
		case 15:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AngleY", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.AngleY = float64(math.Float64frombits(v))
		case 16:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AngleZ", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.AngleZ = float64(math.Float64frombits(v))
		case 17:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Temperature", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Temperature = float64(math.Float64frombits(v))
		case 18:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Humidity", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Humidity = float64(math.Float64frombits(v))
		case 19:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pressure", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Pressure = float64(math.Float64frombits(v))
		case 20:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lux", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Lux = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipMsgDenggan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgDenggan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMsgDenggan(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMsgDenggan
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMsgDenggan
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMsgDenggan
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMsgDenggan
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMsgDenggan
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMsgDenggan
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMsgDenggan        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMsgDenggan          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMsgDenggan = fmt.Errorf("proto: unexpected end of group")
)
