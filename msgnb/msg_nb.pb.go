// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: msg_nb.proto

package wlst_nbiot

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type MsgNBiot struct {
	CmdIdx int64 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// GoWork or GoWorkTask
	CmdName string `protobuf:"bytes,2,opt,name=cmd_name,json=cmdName,proto3" json:"cmd_name,omitempty"`
	// 0xdad9 or 0xdad0
	CmdFlag int32   `protobuf:"varint,3,opt,name=cmd_flag,json=cmdFlag,proto3" json:"cmd_flag,omitempty"`
	Imei    []int64 `protobuf:"varint,4,rep,packed,name=imei,proto3" json:"imei,omitempty"`
	// hex string
	RawData []int32 `protobuf:"varint,5,rep,packed,name=raw_data,json=rawData,proto3" json:"raw_data,omitempty"`
}

func (m *MsgNBiot) Reset()         { *m = MsgNBiot{} }
func (m *MsgNBiot) String() string { return proto.CompactTextString(m) }
func (*MsgNBiot) ProtoMessage()    {}
func (*MsgNBiot) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{0}
}
func (m *MsgNBiot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgNBiot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgNBiot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgNBiot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgNBiot.Merge(m, src)
}
func (m *MsgNBiot) XXX_Size() int {
	return m.Size()
}
func (m *MsgNBiot) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgNBiot.DiscardUnknown(m)
}

var xxx_messageInfo_MsgNBiot proto.InternalMessageInfo

func (m *MsgNBiot) GetCmdIdx() int64 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *MsgNBiot) GetCmdName() string {
	if m != nil {
		return m.CmdName
	}
	return ""
}

func (m *MsgNBiot) GetCmdFlag() int32 {
	if m != nil {
		return m.CmdFlag
	}
	return 0
}

func (m *MsgNBiot) GetImei() []int64 {
	if m != nil {
		return m.Imei
	}
	return nil
}

func (m *MsgNBiot) GetRawData() []int32 {
	if m != nil {
		return m.RawData
	}
	return nil
}

//数据服务和通讯服务传输格式
type MsgNBOpen struct {
	// 设备imei（云平台不填充，只填充device_id）
	Imei int64 `protobuf:"varint,1,opt,name=imei,proto3" json:"imei,omitempty"`
	// 数据接收时间
	DtReceive int64 `protobuf:"varint,2,opt,name=dt_receive,json=dtReceive,proto3" json:"dt_receive,omitempty"`
	// 数据类型:
	// 1-设备最新数据，
	// 2-控制应答，
	// 3-参数设置/读取应答,
	// 4-登录主报，
	// 5-时间应答，
	// 6-即时控制应答，
	// 7-复位应答，
	// 8-本地控制方案应答,
	// 9-版本读取，
	// 10-运行参数，
	// 11-网络参数,
	// 12-漏电参数，
	// 13-事件参数，
	// 14-读取历史数据，
	// 15-读取事件记录
	// 16-数据透传上行
	DataType int32 `protobuf:"varint,3,opt,name=data_type,json=dataType,proto3" json:"data_type,omitempty"`
	// 内部命令名称: 选测 wlst.vslu.b900,
	DataCmd string `protobuf:"bytes,9,opt,name=data_cmd,json=dataCmd,proto3" json:"data_cmd,omitempty"`
	// 设备最新数据
	SluitemData *SluitemData `protobuf:"bytes,10,opt,name=sluitem_data,json=sluitemData,proto3" json:"sluitem_data,omitempty"`
	// 控制应答
	SluitemReply *SluitemReply `protobuf:"bytes,11,opt,name=sluitem_reply,json=sluitemReply,proto3" json:"sluitem_reply,omitempty"`
	// 参数设置/读取
	SluitemConfig *SluitemConfig `protobuf:"bytes,12,opt,name=sluitem_config,json=sluitemConfig,proto3" json:"sluitem_config,omitempty"`
	// 网络参数设置/读取
	NbSlu_3100 *NBSlu_3100 `protobuf:"bytes,13,opt,name=nb_slu_3100,json=nbSlu3100,proto3" json:"nb_slu_3100,omitempty"`
	// 登录信息数据主报
	NbSlu_3700 *NBSlu_3700 `protobuf:"bytes,14,opt,name=nb_slu_3700,json=nbSlu3700,proto3" json:"nb_slu_3700,omitempty"`
	// 时间设置/读取
	NbSlu_1400 *NBSlu_1400 `protobuf:"bytes,15,opt,name=nb_slu_1400,json=nbSlu1400,proto3" json:"nb_slu_1400,omitempty"`
	// 版本读取
	NbSlu_5100 *NBSlu_5100 `protobuf:"bytes,16,opt,name=nb_slu_5100,json=nbSlu5100,proto3" json:"nb_slu_5100,omitempty"`
	// 运行参数设置/读取
	NbSlu_5200 *NBSlu_5200 `protobuf:"bytes,17,opt,name=Nb_slu_5200,json=NbSlu5200,proto3" json:"Nb_slu_5200,omitempty"`
	// 即时控制
	NbSlu_5400 *NBSlu_5400 `protobuf:"bytes,18,opt,name=Nb_slu_5400,json=NbSlu5400,proto3" json:"Nb_slu_5400,omitempty"`
	// 复位
	NbSlu_5500 *NBSlu_5500 `protobuf:"bytes,19,opt,name=Nb_slu_5500,json=NbSlu5500,proto3" json:"Nb_slu_5500,omitempty"`
	// 本地控制方案设置/读取
	NbSlu_5600 *NBSlu_5600 `protobuf:"bytes,20,opt,name=Nb_slu_5600,json=NbSlu5600,proto3" json:"Nb_slu_5600,omitempty"`
	// deviceid，与imei对应
	DeviceId string `protobuf:"bytes,21,opt,name=device_id,json=deviceId,proto3" json:"device_id,omitempty"`
	// 升级
	// 序号（升级协议用）
	Seq int32 `protobuf:"varint,4,opt,name=seq,proto3" json:"seq,omitempty"`
	// 执行状态（升级协议用），0-成功
	Status int32 `protobuf:"varint,5,opt,name=status,proto3" json:"status,omitempty"`
	// 查询版本
	NbSluFf05 *NBSlu_FF05 `protobuf:"bytes,22,opt,name=Nb_slu_ff05,json=NbSluFf05,proto3" json:"Nb_slu_ff05,omitempty"`
	// 升级状态
	NbSluFf07 *NBSlu_FF07 `protobuf:"bytes,23,opt,name=Nb_slu_ff07,json=NbSluFf07,proto3" json:"Nb_slu_ff07,omitempty"`
	// 升级完成
	NbSluFf01 *NBSlu_FF01 `protobuf:"bytes,24,opt,name=Nb_slu_ff01,json=NbSluFf01,proto3" json:"Nb_slu_ff01,omitempty"`
	// 0xda or 0xd9
	DataFlag int32 `protobuf:"varint,25,opt,name=data_flag,json=dataFlag,proto3" json:"data_flag,omitempty"`
	// 漏电参数设置/读取
	NbSlu_5800 *NBSlu_5800 `protobuf:"bytes,26,opt,name=Nb_slu_5800,json=NbSlu5800,proto3" json:"Nb_slu_5800,omitempty"`
	// 历史数据读取
	NbSlu_6100 *NBSlu_6100 `protobuf:"bytes,27,opt,name=Nb_slu_6100,json=NbSlu6100,proto3" json:"Nb_slu_6100,omitempty"`
	// 事件参数设置/读取
	NbSlu_6200 *NBSlu_6200 `protobuf:"bytes,28,opt,name=Nb_slu_6200,json=NbSlu6200,proto3" json:"Nb_slu_6200,omitempty"`
	// 事件读取
	NbSlu_6400 *NBSlu_6400 `protobuf:"bytes,29,opt,name=Nb_slu_6400,json=NbSlu6400,proto3" json:"Nb_slu_6400,omitempty"`
	// ota升级
	// ascii透传
	NbSlu_4C00 *NBSlu_4C00 `protobuf:"bytes,30,opt,name=Nb_slu_4c00,json=NbSlu4c00,proto3" json:"Nb_slu_4c00,omitempty"`
	// 升级控制
	NbSlu_4E00 *NBSlu_4E00 `protobuf:"bytes,31,opt,name=Nb_slu_4e00,json=NbSlu4e00,proto3" json:"Nb_slu_4e00,omitempty"`
	// 升级状态读取/主报
	NbSlu_4F00 *NBSlu_4F00 `protobuf:"bytes,32,opt,name=Nb_slu_4f00,json=NbSlu4f00,proto3" json:"Nb_slu_4f00,omitempty"`
}

func (m *MsgNBOpen) Reset()         { *m = MsgNBOpen{} }
func (m *MsgNBOpen) String() string { return proto.CompactTextString(m) }
func (*MsgNBOpen) ProtoMessage()    {}
func (*MsgNBOpen) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{1}
}
func (m *MsgNBOpen) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgNBOpen) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgNBOpen.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgNBOpen) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgNBOpen.Merge(m, src)
}
func (m *MsgNBOpen) XXX_Size() int {
	return m.Size()
}
func (m *MsgNBOpen) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgNBOpen.DiscardUnknown(m)
}

var xxx_messageInfo_MsgNBOpen proto.InternalMessageInfo

func (m *MsgNBOpen) GetImei() int64 {
	if m != nil {
		return m.Imei
	}
	return 0
}

func (m *MsgNBOpen) GetDtReceive() int64 {
	if m != nil {
		return m.DtReceive
	}
	return 0
}

func (m *MsgNBOpen) GetDataType() int32 {
	if m != nil {
		return m.DataType
	}
	return 0
}

func (m *MsgNBOpen) GetDataCmd() string {
	if m != nil {
		return m.DataCmd
	}
	return ""
}

func (m *MsgNBOpen) GetSluitemData() *SluitemData {
	if m != nil {
		return m.SluitemData
	}
	return nil
}

func (m *MsgNBOpen) GetSluitemReply() *SluitemReply {
	if m != nil {
		return m.SluitemReply
	}
	return nil
}

func (m *MsgNBOpen) GetSluitemConfig() *SluitemConfig {
	if m != nil {
		return m.SluitemConfig
	}
	return nil
}

func (m *MsgNBOpen) GetNbSlu_3100() *NBSlu_3100 {
	if m != nil {
		return m.NbSlu_3100
	}
	return nil
}

func (m *MsgNBOpen) GetNbSlu_3700() *NBSlu_3700 {
	if m != nil {
		return m.NbSlu_3700
	}
	return nil
}

func (m *MsgNBOpen) GetNbSlu_1400() *NBSlu_1400 {
	if m != nil {
		return m.NbSlu_1400
	}
	return nil
}

func (m *MsgNBOpen) GetNbSlu_5100() *NBSlu_5100 {
	if m != nil {
		return m.NbSlu_5100
	}
	return nil
}

func (m *MsgNBOpen) GetNbSlu_5200() *NBSlu_5200 {
	if m != nil {
		return m.NbSlu_5200
	}
	return nil
}

func (m *MsgNBOpen) GetNbSlu_5400() *NBSlu_5400 {
	if m != nil {
		return m.NbSlu_5400
	}
	return nil
}

func (m *MsgNBOpen) GetNbSlu_5500() *NBSlu_5500 {
	if m != nil {
		return m.NbSlu_5500
	}
	return nil
}

func (m *MsgNBOpen) GetNbSlu_5600() *NBSlu_5600 {
	if m != nil {
		return m.NbSlu_5600
	}
	return nil
}

func (m *MsgNBOpen) GetDeviceId() string {
	if m != nil {
		return m.DeviceId
	}
	return ""
}

func (m *MsgNBOpen) GetSeq() int32 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *MsgNBOpen) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *MsgNBOpen) GetNbSluFf05() *NBSlu_FF05 {
	if m != nil {
		return m.NbSluFf05
	}
	return nil
}

func (m *MsgNBOpen) GetNbSluFf07() *NBSlu_FF07 {
	if m != nil {
		return m.NbSluFf07
	}
	return nil
}

func (m *MsgNBOpen) GetNbSluFf01() *NBSlu_FF01 {
	if m != nil {
		return m.NbSluFf01
	}
	return nil
}

func (m *MsgNBOpen) GetDataFlag() int32 {
	if m != nil {
		return m.DataFlag
	}
	return 0
}

func (m *MsgNBOpen) GetNbSlu_5800() *NBSlu_5800 {
	if m != nil {
		return m.NbSlu_5800
	}
	return nil
}

func (m *MsgNBOpen) GetNbSlu_6100() *NBSlu_6100 {
	if m != nil {
		return m.NbSlu_6100
	}
	return nil
}

func (m *MsgNBOpen) GetNbSlu_6200() *NBSlu_6200 {
	if m != nil {
		return m.NbSlu_6200
	}
	return nil
}

func (m *MsgNBOpen) GetNbSlu_6400() *NBSlu_6400 {
	if m != nil {
		return m.NbSlu_6400
	}
	return nil
}

func (m *MsgNBOpen) GetNbSlu_4C00() *NBSlu_4C00 {
	if m != nil {
		return m.NbSlu_4C00
	}
	return nil
}

func (m *MsgNBOpen) GetNbSlu_4E00() *NBSlu_4E00 {
	if m != nil {
		return m.NbSlu_4E00
	}
	return nil
}

func (m *MsgNBOpen) GetNbSlu_4F00() *NBSlu_4F00 {
	if m != nil {
		return m.NbSlu_4F00
	}
	return nil
}

type SluitemConfig struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 控制器条码（4字节）
	SluitemIdx int64 `protobuf:"varint,2,opt,name=sluitem_idx,json=sluitemIdx,proto3" json:"sluitem_idx,omitempty"`
	// 参数读取标识
	DataMark *SluitemConfig_DataMark `protobuf:"bytes,4,opt,name=data_mark,json=dataMark,proto3" json:"data_mark,omitempty"`
	// 控制器回路数量
	LoopCount int32 `protobuf:"varint,5,opt,name=loop_count,json=loopCount,proto3" json:"loop_count,omitempty"`
	// 控制器时钟(read_timer)
	SluitemTime int64 `protobuf:"varint,7,opt,name=sluitem_time,json=sluitemTime,proto3" json:"sluitem_time,omitempty"`
	// 控制器运行参数(read_args)
	SluitemPara *SluitemConfig_SluitemPara `protobuf:"bytes,8,opt,name=sluitem_para,json=sluitemPara,proto3" json:"sluitem_para,omitempty"`
	// 控制器版本(read_ver)
	SluitemVer *SluitemConfig_SluitemVer `protobuf:"bytes,10,opt,name=sluitem_ver,json=sluitemVer,proto3" json:"sluitem_ver,omitempty"`
	// 控制器当日日出日落(read_sunriseset)
	SluitemSunriseset *SluitemConfig_SluitemSunriseset `protobuf:"bytes,11,opt,name=sluitem_sunriseset,json=sluitemSunriseset,proto3" json:"sluitem_sunriseset,omitempty"`
	// 控制器定时控制参数(read_timetable)
	SluitemRuntime []*SluitemConfig_SluitemRuntime `protobuf:"bytes,12,rep,name=sluitem_runtime,json=sluitemRuntime,proto3" json:"sluitem_runtime,omitempty"`
	// 设置状态0-失败，1-成功
	Status int32 `protobuf:"varint,14,opt,name=status,proto3" json:"status,omitempty"`
	// 参数设置标识
	SetMark *SluitemConfig_SetMark `protobuf:"bytes,15,opt,name=set_mark,json=setMark,proto3" json:"set_mark,omitempty"`
}

func (m *SluitemConfig) Reset()         { *m = SluitemConfig{} }
func (m *SluitemConfig) String() string { return proto.CompactTextString(m) }
func (*SluitemConfig) ProtoMessage()    {}
func (*SluitemConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{2}
}
func (m *SluitemConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SluitemConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SluitemConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SluitemConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SluitemConfig.Merge(m, src)
}
func (m *SluitemConfig) XXX_Size() int {
	return m.Size()
}
func (m *SluitemConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_SluitemConfig.DiscardUnknown(m)
}

var xxx_messageInfo_SluitemConfig proto.InternalMessageInfo

func (m *SluitemConfig) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *SluitemConfig) GetSluitemIdx() int64 {
	if m != nil {
		return m.SluitemIdx
	}
	return 0
}

func (m *SluitemConfig) GetDataMark() *SluitemConfig_DataMark {
	if m != nil {
		return m.DataMark
	}
	return nil
}

func (m *SluitemConfig) GetLoopCount() int32 {
	if m != nil {
		return m.LoopCount
	}
	return 0
}

func (m *SluitemConfig) GetSluitemTime() int64 {
	if m != nil {
		return m.SluitemTime
	}
	return 0
}

func (m *SluitemConfig) GetSluitemPara() *SluitemConfig_SluitemPara {
	if m != nil {
		return m.SluitemPara
	}
	return nil
}

func (m *SluitemConfig) GetSluitemVer() *SluitemConfig_SluitemVer {
	if m != nil {
		return m.SluitemVer
	}
	return nil
}

func (m *SluitemConfig) GetSluitemSunriseset() *SluitemConfig_SluitemSunriseset {
	if m != nil {
		return m.SluitemSunriseset
	}
	return nil
}

func (m *SluitemConfig) GetSluitemRuntime() []*SluitemConfig_SluitemRuntime {
	if m != nil {
		return m.SluitemRuntime
	}
	return nil
}

func (m *SluitemConfig) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *SluitemConfig) GetSetMark() *SluitemConfig_SetMark {
	if m != nil {
		return m.SetMark
	}
	return nil
}

type SluitemConfig_DataMark struct {
	// 读取时钟
	ReadTimer int32 `protobuf:"varint,2,opt,name=read_timer,json=readTimer,proto3" json:"read_timer,omitempty"`
	// 读取运行参数
	ReadArgs int32 `protobuf:"varint,3,opt,name=read_args,json=readArgs,proto3" json:"read_args,omitempty"`
	// 读取版本
	ReadVer int32 `protobuf:"varint,5,opt,name=read_ver,json=readVer,proto3" json:"read_ver,omitempty"`
	// 读取当天日出日落
	ReadSunriseset int32 `protobuf:"varint,6,opt,name=read_sunriseset,json=readSunriseset,proto3" json:"read_sunriseset,omitempty"`
	// 读取定时控制参数
	ReadTimetable int32 `protobuf:"varint,7,opt,name=read_timetable,json=readTimetable,proto3" json:"read_timetable,omitempty"`
}

func (m *SluitemConfig_DataMark) Reset()         { *m = SluitemConfig_DataMark{} }
func (m *SluitemConfig_DataMark) String() string { return proto.CompactTextString(m) }
func (*SluitemConfig_DataMark) ProtoMessage()    {}
func (*SluitemConfig_DataMark) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{2, 0}
}
func (m *SluitemConfig_DataMark) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SluitemConfig_DataMark) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SluitemConfig_DataMark.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SluitemConfig_DataMark) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SluitemConfig_DataMark.Merge(m, src)
}
func (m *SluitemConfig_DataMark) XXX_Size() int {
	return m.Size()
}
func (m *SluitemConfig_DataMark) XXX_DiscardUnknown() {
	xxx_messageInfo_SluitemConfig_DataMark.DiscardUnknown(m)
}

var xxx_messageInfo_SluitemConfig_DataMark proto.InternalMessageInfo

func (m *SluitemConfig_DataMark) GetReadTimer() int32 {
	if m != nil {
		return m.ReadTimer
	}
	return 0
}

func (m *SluitemConfig_DataMark) GetReadArgs() int32 {
	if m != nil {
		return m.ReadArgs
	}
	return 0
}

func (m *SluitemConfig_DataMark) GetReadVer() int32 {
	if m != nil {
		return m.ReadVer
	}
	return 0
}

func (m *SluitemConfig_DataMark) GetReadSunriseset() int32 {
	if m != nil {
		return m.ReadSunriseset
	}
	return 0
}

func (m *SluitemConfig_DataMark) GetReadTimetable() int32 {
	if m != nil {
		return m.ReadTimetable
	}
	return 0
}

type SluitemConfig_SetMark struct {
	// 设置时钟
	SetTimer int32 `protobuf:"varint,1,opt,name=set_timer,json=setTimer,proto3" json:"set_timer,omitempty"`
	// 设置运行参数
	SetArgs int32 `protobuf:"varint,2,opt,name=set_args,json=setArgs,proto3" json:"set_args,omitempty"`
	// 复位设备
	SetReset int32 `protobuf:"varint,4,opt,name=set_reset,json=setReset,proto3" json:"set_reset,omitempty"`
	// 设置定时控制参数
	SetTimetable int32 `protobuf:"varint,5,opt,name=set_timetable,json=setTimetable,proto3" json:"set_timetable,omitempty"`
}

func (m *SluitemConfig_SetMark) Reset()         { *m = SluitemConfig_SetMark{} }
func (m *SluitemConfig_SetMark) String() string { return proto.CompactTextString(m) }
func (*SluitemConfig_SetMark) ProtoMessage()    {}
func (*SluitemConfig_SetMark) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{2, 1}
}
func (m *SluitemConfig_SetMark) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SluitemConfig_SetMark) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SluitemConfig_SetMark.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SluitemConfig_SetMark) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SluitemConfig_SetMark.Merge(m, src)
}
func (m *SluitemConfig_SetMark) XXX_Size() int {
	return m.Size()
}
func (m *SluitemConfig_SetMark) XXX_DiscardUnknown() {
	xxx_messageInfo_SluitemConfig_SetMark.DiscardUnknown(m)
}

var xxx_messageInfo_SluitemConfig_SetMark proto.InternalMessageInfo

func (m *SluitemConfig_SetMark) GetSetTimer() int32 {
	if m != nil {
		return m.SetTimer
	}
	return 0
}

func (m *SluitemConfig_SetMark) GetSetArgs() int32 {
	if m != nil {
		return m.SetArgs
	}
	return 0
}

func (m *SluitemConfig_SetMark) GetSetReset() int32 {
	if m != nil {
		return m.SetReset
	}
	return 0
}

func (m *SluitemConfig_SetMark) GetSetTimetable() int32 {
	if m != nil {
		return m.SetTimetable
	}
	return 0
}

type SluitemConfig_SluitemPara struct {
	// 控制器状态 0-停运，1-投运
	SluitemStatus int32 `protobuf:"varint,2,opt,name=sluitem_status,json=sluitemStatus,proto3" json:"sluitem_status,omitempty"`
	// 控制器主报 0-禁止主报，1-允许主报
	SluitemEnableAlarm int32 `protobuf:"varint,3,opt,name=sluitem_enable_alarm,json=sluitemEnableAlarm,proto3" json:"sluitem_enable_alarm,omitempty"`
	// 控制器上电开灯 1-开灯，0-关灯
	SluitemPowerTurnon []int32 `protobuf:"varint,4,rep,packed,name=sluitem_power_turnon,json=sluitemPowerTurnon,proto3" json:"sluitem_power_turnon,omitempty"`
	// 经度
	Longitude float64 `protobuf:"fixed64,6,opt,name=longitude,proto3" json:"longitude,omitempty"`
	// 纬度
	Latitude float64 `protobuf:"fixed64,7,opt,name=latitude,proto3" json:"latitude,omitempty"`
	// 1-4回路额定功率
	RatedPower []int32 `protobuf:"varint,8,rep,packed,name=rated_power,json=ratedPower,proto3" json:"rated_power,omitempty"`
	// nb主报间隔，(0～127)*5
	UplinkTimer int32 `protobuf:"varint,9,opt,name=uplink_timer,json=uplinkTimer,proto3" json:"uplink_timer,omitempty"`
	// nb主报需要主站应答，0-不需要，1-需要
	UplinkReply int32 `protobuf:"varint,10,opt,name=uplink_reply,json=uplinkReply,proto3" json:"uplink_reply,omitempty"`
	// 1-4回路是否反向调光，0-正向，1-反向
	SluitemReverseDimming []int32 `protobuf:"varint,12,rep,packed,name=sluitem_reverse_dimming,json=sluitemReverseDimming,proto3" json:"sluitem_reverse_dimming,omitempty"`
}

func (m *SluitemConfig_SluitemPara) Reset()         { *m = SluitemConfig_SluitemPara{} }
func (m *SluitemConfig_SluitemPara) String() string { return proto.CompactTextString(m) }
func (*SluitemConfig_SluitemPara) ProtoMessage()    {}
func (*SluitemConfig_SluitemPara) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{2, 2}
}
func (m *SluitemConfig_SluitemPara) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SluitemConfig_SluitemPara) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SluitemConfig_SluitemPara.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SluitemConfig_SluitemPara) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SluitemConfig_SluitemPara.Merge(m, src)
}
func (m *SluitemConfig_SluitemPara) XXX_Size() int {
	return m.Size()
}
func (m *SluitemConfig_SluitemPara) XXX_DiscardUnknown() {
	xxx_messageInfo_SluitemConfig_SluitemPara.DiscardUnknown(m)
}

var xxx_messageInfo_SluitemConfig_SluitemPara proto.InternalMessageInfo

func (m *SluitemConfig_SluitemPara) GetSluitemStatus() int32 {
	if m != nil {
		return m.SluitemStatus
	}
	return 0
}

func (m *SluitemConfig_SluitemPara) GetSluitemEnableAlarm() int32 {
	if m != nil {
		return m.SluitemEnableAlarm
	}
	return 0
}

func (m *SluitemConfig_SluitemPara) GetSluitemPowerTurnon() []int32 {
	if m != nil {
		return m.SluitemPowerTurnon
	}
	return nil
}

func (m *SluitemConfig_SluitemPara) GetLongitude() float64 {
	if m != nil {
		return m.Longitude
	}
	return 0
}

func (m *SluitemConfig_SluitemPara) GetLatitude() float64 {
	if m != nil {
		return m.Latitude
	}
	return 0
}

func (m *SluitemConfig_SluitemPara) GetRatedPower() []int32 {
	if m != nil {
		return m.RatedPower
	}
	return nil
}

func (m *SluitemConfig_SluitemPara) GetUplinkTimer() int32 {
	if m != nil {
		return m.UplinkTimer
	}
	return 0
}

func (m *SluitemConfig_SluitemPara) GetUplinkReply() int32 {
	if m != nil {
		return m.UplinkReply
	}
	return 0
}

func (m *SluitemConfig_SluitemPara) GetSluitemReverseDimming() []int32 {
	if m != nil {
		return m.SluitemReverseDimming
	}
	return nil
}

type SluitemConfig_SluitemVer struct {
	// 控制器回路
	SluitemLoop int32 `protobuf:"varint,1,opt,name=sluitem_loop,json=sluitemLoop,proto3" json:"sluitem_loop,omitempty"`
	// 节能方式
	EnergySaving int32 `protobuf:"varint,2,opt,name=energy_saving,json=energySaving,proto3" json:"energy_saving,omitempty"`
	// 有漏电模块
	ElectricLeakageModule int32 `protobuf:"varint,3,opt,name=electric_leakage_module,json=electricLeakageModule,proto3" json:"electric_leakage_module,omitempty"`
	// 有温度检测模块
	TemperatureModule int32 `protobuf:"varint,4,opt,name=temperature_module,json=temperatureModule,proto3" json:"temperature_module,omitempty"`
	// 有时钟
	TimerModule int32 `protobuf:"varint,5,opt,name=timer_module,json=timerModule,proto3" json:"timer_module,omitempty"`
	// 型号 0-unknow,1-wj2090j
	SluitemType string `protobuf:"bytes,6,opt,name=sluitem_type,json=sluitemType,proto3" json:"sluitem_type,omitempty"`
	// 软件版本
	Ver string `protobuf:"bytes,7,opt,name=ver,proto3" json:"ver,omitempty"`
}

func (m *SluitemConfig_SluitemVer) Reset()         { *m = SluitemConfig_SluitemVer{} }
func (m *SluitemConfig_SluitemVer) String() string { return proto.CompactTextString(m) }
func (*SluitemConfig_SluitemVer) ProtoMessage()    {}
func (*SluitemConfig_SluitemVer) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{2, 3}
}
func (m *SluitemConfig_SluitemVer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SluitemConfig_SluitemVer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SluitemConfig_SluitemVer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SluitemConfig_SluitemVer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SluitemConfig_SluitemVer.Merge(m, src)
}
func (m *SluitemConfig_SluitemVer) XXX_Size() int {
	return m.Size()
}
func (m *SluitemConfig_SluitemVer) XXX_DiscardUnknown() {
	xxx_messageInfo_SluitemConfig_SluitemVer.DiscardUnknown(m)
}

var xxx_messageInfo_SluitemConfig_SluitemVer proto.InternalMessageInfo

func (m *SluitemConfig_SluitemVer) GetSluitemLoop() int32 {
	if m != nil {
		return m.SluitemLoop
	}
	return 0
}

func (m *SluitemConfig_SluitemVer) GetEnergySaving() int32 {
	if m != nil {
		return m.EnergySaving
	}
	return 0
}

func (m *SluitemConfig_SluitemVer) GetElectricLeakageModule() int32 {
	if m != nil {
		return m.ElectricLeakageModule
	}
	return 0
}

func (m *SluitemConfig_SluitemVer) GetTemperatureModule() int32 {
	if m != nil {
		return m.TemperatureModule
	}
	return 0
}

func (m *SluitemConfig_SluitemVer) GetTimerModule() int32 {
	if m != nil {
		return m.TimerModule
	}
	return 0
}

func (m *SluitemConfig_SluitemVer) GetSluitemType() string {
	if m != nil {
		return m.SluitemType
	}
	return ""
}

func (m *SluitemConfig_SluitemVer) GetVer() string {
	if m != nil {
		return m.Ver
	}
	return ""
}

type SluitemConfig_SluitemSunriseset struct {
	// 当日日出日落时间 hhmm->int32
	Sunrise int32 `protobuf:"varint,1,opt,name=sunrise,proto3" json:"sunrise,omitempty"`
	Sunset  int32 `protobuf:"varint,2,opt,name=sunset,proto3" json:"sunset,omitempty"`
}

func (m *SluitemConfig_SluitemSunriseset) Reset()         { *m = SluitemConfig_SluitemSunriseset{} }
func (m *SluitemConfig_SluitemSunriseset) String() string { return proto.CompactTextString(m) }
func (*SluitemConfig_SluitemSunriseset) ProtoMessage()    {}
func (*SluitemConfig_SluitemSunriseset) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{2, 4}
}
func (m *SluitemConfig_SluitemSunriseset) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SluitemConfig_SluitemSunriseset) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SluitemConfig_SluitemSunriseset.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SluitemConfig_SluitemSunriseset) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SluitemConfig_SluitemSunriseset.Merge(m, src)
}
func (m *SluitemConfig_SluitemSunriseset) XXX_Size() int {
	return m.Size()
}
func (m *SluitemConfig_SluitemSunriseset) XXX_DiscardUnknown() {
	xxx_messageInfo_SluitemConfig_SluitemSunriseset.DiscardUnknown(m)
}

var xxx_messageInfo_SluitemConfig_SluitemSunriseset proto.InternalMessageInfo

func (m *SluitemConfig_SluitemSunriseset) GetSunrise() int32 {
	if m != nil {
		return m.Sunrise
	}
	return 0
}

func (m *SluitemConfig_SluitemSunriseset) GetSunset() int32 {
	if m != nil {
		return m.Sunset
	}
	return 0
}

type SluitemConfig_SluitemRuntime struct {
	// 本地控制数据类型0-基本类型（6字节），1-扩展类型（6+20字节）
	DataType int32 `protobuf:"varint,1,opt,name=data_type,json=dataType,proto3" json:"data_type,omitempty"`
	// 输出类型0-继电器，1-pwm输出，2-485
	OutputType int32 `protobuf:"varint,2,opt,name=output_type,json=outputType,proto3" json:"output_type,omitempty"`
	// 操作类型1-定时操作，2-经纬度操作，3-即时操作
	OperateType int32 `protobuf:"varint,3,opt,name=operate_type,json=operateType,proto3" json:"operate_type,omitempty"`
	// 有效日期，0-6～周日-周6
	DateEnable []int32 `protobuf:"varint,4,rep,packed,name=date_enable,json=dateEnable,proto3" json:"date_enable,omitempty"`
	// 开关灯操作时间 hhmm->int32
	OperateTime int32 `protobuf:"varint,5,opt,name=operate_time,json=operateTime,proto3" json:"operate_time,omitempty"`
	// 操作偏移 -720~+720
	OperateOffset int32 `protobuf:"varint,6,opt,name=operate_offset,json=operateOffset,proto3" json:"operate_offset,omitempty"`
	// 继电器操作回路1-4, 0x0-不操作，0x3-开灯，0xc-关灯
	RelayOperate []int32 `protobuf:"varint,7,rep,packed,name=relay_operate,json=relayOperate,proto3" json:"relay_operate,omitempty"`
	// PWM操作回路
	PwmLoop []int32 `protobuf:"varint,8,rep,packed,name=pwm_loop,json=pwmLoop,proto3" json:"pwm_loop,omitempty"`
	// PWM操作占空比
	PwmPower int32 `protobuf:"varint,9,opt,name=pwm_power,json=pwmPower,proto3" json:"pwm_power,omitempty"`
	// PWM频率 (1~255) * 100
	PwmBaudrate int32 `protobuf:"varint,10,opt,name=pwm_baudrate,json=pwmBaudrate,proto3" json:"pwm_baudrate,omitempty"`
}

func (m *SluitemConfig_SluitemRuntime) Reset()         { *m = SluitemConfig_SluitemRuntime{} }
func (m *SluitemConfig_SluitemRuntime) String() string { return proto.CompactTextString(m) }
func (*SluitemConfig_SluitemRuntime) ProtoMessage()    {}
func (*SluitemConfig_SluitemRuntime) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{2, 5}
}
func (m *SluitemConfig_SluitemRuntime) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SluitemConfig_SluitemRuntime) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SluitemConfig_SluitemRuntime.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SluitemConfig_SluitemRuntime) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SluitemConfig_SluitemRuntime.Merge(m, src)
}
func (m *SluitemConfig_SluitemRuntime) XXX_Size() int {
	return m.Size()
}
func (m *SluitemConfig_SluitemRuntime) XXX_DiscardUnknown() {
	xxx_messageInfo_SluitemConfig_SluitemRuntime.DiscardUnknown(m)
}

var xxx_messageInfo_SluitemConfig_SluitemRuntime proto.InternalMessageInfo

func (m *SluitemConfig_SluitemRuntime) GetDataType() int32 {
	if m != nil {
		return m.DataType
	}
	return 0
}

func (m *SluitemConfig_SluitemRuntime) GetOutputType() int32 {
	if m != nil {
		return m.OutputType
	}
	return 0
}

func (m *SluitemConfig_SluitemRuntime) GetOperateType() int32 {
	if m != nil {
		return m.OperateType
	}
	return 0
}

func (m *SluitemConfig_SluitemRuntime) GetDateEnable() []int32 {
	if m != nil {
		return m.DateEnable
	}
	return nil
}

func (m *SluitemConfig_SluitemRuntime) GetOperateTime() int32 {
	if m != nil {
		return m.OperateTime
	}
	return 0
}

func (m *SluitemConfig_SluitemRuntime) GetOperateOffset() int32 {
	if m != nil {
		return m.OperateOffset
	}
	return 0
}

func (m *SluitemConfig_SluitemRuntime) GetRelayOperate() []int32 {
	if m != nil {
		return m.RelayOperate
	}
	return nil
}

func (m *SluitemConfig_SluitemRuntime) GetPwmLoop() []int32 {
	if m != nil {
		return m.PwmLoop
	}
	return nil
}

func (m *SluitemConfig_SluitemRuntime) GetPwmPower() int32 {
	if m != nil {
		return m.PwmPower
	}
	return 0
}

func (m *SluitemConfig_SluitemRuntime) GetPwmBaudrate() int32 {
	if m != nil {
		return m.PwmBaudrate
	}
	return 0
}

type SluitemReply struct {
	// 开关灯调光操作结果，0-失败，1-成功
	Status int32 `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *SluitemReply) Reset()         { *m = SluitemReply{} }
func (m *SluitemReply) String() string { return proto.CompactTextString(m) }
func (*SluitemReply) ProtoMessage()    {}
func (*SluitemReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{3}
}
func (m *SluitemReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SluitemReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SluitemReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SluitemReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SluitemReply.Merge(m, src)
}
func (m *SluitemReply) XXX_Size() int {
	return m.Size()
}
func (m *SluitemReply) XXX_DiscardUnknown() {
	xxx_messageInfo_SluitemReply.DiscardUnknown(m)
}

var xxx_messageInfo_SluitemReply proto.InternalMessageInfo

func (m *SluitemReply) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

type SluitemData struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 型号
	ModelInfo *SluitemData_ModelInfo `protobuf:"bytes,2,opt,name=model_info,json=modelInfo,proto3" json:"model_info,omitempty"`
	// 回路数据(最大4个)
	LightData []*SluitemData_LightData `protobuf:"bytes,3,rep,name=light_data,json=lightData,proto3" json:"light_data,omitempty"`
	// 漏电流
	LeakageCurrent float64 `protobuf:"fixed64,4,opt,name=leakage_current,json=leakageCurrent,proto3" json:"leakage_current,omitempty"`
	// 控制器状态
	SluitemStatus *SluitemData_SluitemStatus `protobuf:"bytes,5,opt,name=sluitem_status,json=sluitemStatus,proto3" json:"sluitem_status,omitempty"`
	// 时钟故障
	TimeFault *SluitemData_TimeFault `protobuf:"bytes,6,opt,name=time_fault,json=timeFault,proto3" json:"time_fault,omitempty"`
	// 自复位次数
	ResetCount int32 `protobuf:"varint,7,opt,name=reset_count,json=resetCount,proto3" json:"reset_count,omitempty"`
	// 时间
	DateTime int64 `protobuf:"varint,8,opt,name=date_time,json=dateTime,proto3" json:"date_time,omitempty"`
	// 控制器运行参数
	SluitemPara *SluitemData_SluitemPara `protobuf:"bytes,9,opt,name=sluitem_para,json=sluitemPara,proto3" json:"sluitem_para,omitempty"`
	// 参考信号接收功率
	Rsrp int64 `protobuf:"varint,10,opt,name=rsrp,proto3" json:"rsrp,omitempty"`
	// 接收信号强度等级
	Rssi int64 `protobuf:"varint,11,opt,name=rssi,proto3" json:"rssi,omitempty"`
	// 信噪比
	Snr int64 `protobuf:"varint,12,opt,name=snr,proto3" json:"snr,omitempty"`
	// 物理小区标识
	Pci int64 `protobuf:"varint,13,opt,name=pci,proto3" json:"pci,omitempty"`
	// 参考信号接收质量
	Rsrq int64 `protobuf:"varint,14,opt,name=rsrq,proto3" json:"rsrq,omitempty"`
	// 终端发射功率
	Txpower int64 `protobuf:"varint,15,opt,name=txpower,proto3" json:"txpower,omitempty"`
	// 频点号
	Earfcn int64 `protobuf:"varint,16,opt,name=earfcn,proto3" json:"earfcn,omitempty"`
	// 信号覆盖等级
	Ecl int32 `protobuf:"varint,17,opt,name=ecl,proto3" json:"ecl,omitempty"`
	// 信号强度值
	Csq int32 `protobuf:"varint,18,opt,name=csq,proto3" json:"csq,omitempty"`
	// 主动上报原因，0-非主动上报，1-登录，2-开关灯状态变化，3-故障发生/消除，4-定时主动上报
	Reson int32 `protobuf:"varint,19,opt,name=reson,proto3" json:"reson,omitempty"`
	// 重连次数
	Retry int32 `protobuf:"varint,20,opt,name=retry,proto3" json:"retry,omitempty"`
	// 日出时间
	Sunrise int32 `protobuf:"varint,21,opt,name=sunrise,proto3" json:"sunrise,omitempty"`
	// 日落时间
	Sunset int32 `protobuf:"varint,22,opt,name=sunset,proto3" json:"sunset,omitempty"`
}

func (m *SluitemData) Reset()         { *m = SluitemData{} }
func (m *SluitemData) String() string { return proto.CompactTextString(m) }
func (*SluitemData) ProtoMessage()    {}
func (*SluitemData) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{4}
}
func (m *SluitemData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SluitemData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SluitemData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SluitemData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SluitemData.Merge(m, src)
}
func (m *SluitemData) XXX_Size() int {
	return m.Size()
}
func (m *SluitemData) XXX_DiscardUnknown() {
	xxx_messageInfo_SluitemData.DiscardUnknown(m)
}

var xxx_messageInfo_SluitemData proto.InternalMessageInfo

func (m *SluitemData) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *SluitemData) GetModelInfo() *SluitemData_ModelInfo {
	if m != nil {
		return m.ModelInfo
	}
	return nil
}

func (m *SluitemData) GetLightData() []*SluitemData_LightData {
	if m != nil {
		return m.LightData
	}
	return nil
}

func (m *SluitemData) GetLeakageCurrent() float64 {
	if m != nil {
		return m.LeakageCurrent
	}
	return 0
}

func (m *SluitemData) GetSluitemStatus() *SluitemData_SluitemStatus {
	if m != nil {
		return m.SluitemStatus
	}
	return nil
}

func (m *SluitemData) GetTimeFault() *SluitemData_TimeFault {
	if m != nil {
		return m.TimeFault
	}
	return nil
}

func (m *SluitemData) GetResetCount() int32 {
	if m != nil {
		return m.ResetCount
	}
	return 0
}

func (m *SluitemData) GetDateTime() int64 {
	if m != nil {
		return m.DateTime
	}
	return 0
}

func (m *SluitemData) GetSluitemPara() *SluitemData_SluitemPara {
	if m != nil {
		return m.SluitemPara
	}
	return nil
}

func (m *SluitemData) GetRsrp() int64 {
	if m != nil {
		return m.Rsrp
	}
	return 0
}

func (m *SluitemData) GetRssi() int64 {
	if m != nil {
		return m.Rssi
	}
	return 0
}

func (m *SluitemData) GetSnr() int64 {
	if m != nil {
		return m.Snr
	}
	return 0
}

func (m *SluitemData) GetPci() int64 {
	if m != nil {
		return m.Pci
	}
	return 0
}

func (m *SluitemData) GetRsrq() int64 {
	if m != nil {
		return m.Rsrq
	}
	return 0
}

func (m *SluitemData) GetTxpower() int64 {
	if m != nil {
		return m.Txpower
	}
	return 0
}

func (m *SluitemData) GetEarfcn() int64 {
	if m != nil {
		return m.Earfcn
	}
	return 0
}

func (m *SluitemData) GetEcl() int32 {
	if m != nil {
		return m.Ecl
	}
	return 0
}

func (m *SluitemData) GetCsq() int32 {
	if m != nil {
		return m.Csq
	}
	return 0
}

func (m *SluitemData) GetReson() int32 {
	if m != nil {
		return m.Reson
	}
	return 0
}

func (m *SluitemData) GetRetry() int32 {
	if m != nil {
		return m.Retry
	}
	return 0
}

func (m *SluitemData) GetSunrise() int32 {
	if m != nil {
		return m.Sunrise
	}
	return 0
}

func (m *SluitemData) GetSunset() int32 {
	if m != nil {
		return m.Sunset
	}
	return 0
}

type SluitemData_ModelInfo struct {
	// 控制器回路数量
	SluitemLoop int32 `protobuf:"varint,1,opt,name=sluitem_loop,json=sluitemLoop,proto3" json:"sluitem_loop,omitempty"`
	// 节能方式 0-无控制，1-只有开关灯，4-RS485，5-PWM，6-0~10V
	PowerSaving int32 `protobuf:"varint,2,opt,name=power_saving,json=powerSaving,proto3" json:"power_saving,omitempty"`
	// 漏电流测量 0-无，1-有
	HasLeakage int32 `protobuf:"varint,3,opt,name=has_leakage,json=hasLeakage,proto3" json:"has_leakage,omitempty"`
	// 温度采集 0-无，1-有
	HasTemperature int32 `protobuf:"varint,4,opt,name=has_temperature,json=hasTemperature,proto3" json:"has_temperature,omitempty"`
	// 时钟 0-无，1-有
	HasTimer int32 `protobuf:"varint,5,opt,name=has_timer,json=hasTimer,proto3" json:"has_timer,omitempty"`
	// 型号 0-unknow（V0.2改为协议版本）
	Model int32 `protobuf:"varint,6,opt,name=model,proto3" json:"model,omitempty"`
	// 字符串型号（V0.2改为协议版本）
	SluitemType string `protobuf:"bytes,7,opt,name=sluitem_type,json=sluitemType,proto3" json:"sluitem_type,omitempty"`
	// 实际使用回路数（V0.2增加）
	UseLoop int32 `protobuf:"varint,8,opt,name=use_loop,json=useLoop,proto3" json:"use_loop,omitempty"`
}

func (m *SluitemData_ModelInfo) Reset()         { *m = SluitemData_ModelInfo{} }
func (m *SluitemData_ModelInfo) String() string { return proto.CompactTextString(m) }
func (*SluitemData_ModelInfo) ProtoMessage()    {}
func (*SluitemData_ModelInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{4, 0}
}
func (m *SluitemData_ModelInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SluitemData_ModelInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SluitemData_ModelInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SluitemData_ModelInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SluitemData_ModelInfo.Merge(m, src)
}
func (m *SluitemData_ModelInfo) XXX_Size() int {
	return m.Size()
}
func (m *SluitemData_ModelInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SluitemData_ModelInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SluitemData_ModelInfo proto.InternalMessageInfo

func (m *SluitemData_ModelInfo) GetSluitemLoop() int32 {
	if m != nil {
		return m.SluitemLoop
	}
	return 0
}

func (m *SluitemData_ModelInfo) GetPowerSaving() int32 {
	if m != nil {
		return m.PowerSaving
	}
	return 0
}

func (m *SluitemData_ModelInfo) GetHasLeakage() int32 {
	if m != nil {
		return m.HasLeakage
	}
	return 0
}

func (m *SluitemData_ModelInfo) GetHasTemperature() int32 {
	if m != nil {
		return m.HasTemperature
	}
	return 0
}

func (m *SluitemData_ModelInfo) GetHasTimer() int32 {
	if m != nil {
		return m.HasTimer
	}
	return 0
}

func (m *SluitemData_ModelInfo) GetModel() int32 {
	if m != nil {
		return m.Model
	}
	return 0
}

func (m *SluitemData_ModelInfo) GetSluitemType() string {
	if m != nil {
		return m.SluitemType
	}
	return ""
}

func (m *SluitemData_ModelInfo) GetUseLoop() int32 {
	if m != nil {
		return m.UseLoop
	}
	return 0
}

type SluitemData_LightData struct {
	// 电压
	Voltage float64 `protobuf:"fixed64,1,opt,name=voltage,proto3" json:"voltage,omitempty"`
	// 电流
	Current float64 `protobuf:"fixed64,2,opt,name=current,proto3" json:"current,omitempty"`
	// 有功功率
	ActivePower float64 `protobuf:"fixed64,3,opt,name=active_power,json=activePower,proto3" json:"active_power,omitempty"`
	// 无功功率
	ReactivePower float64 `protobuf:"fixed64,4,opt,name=reactive_power,json=reactivePower,proto3" json:"reactive_power,omitempty"`
	// 视在功率
	ApparentPower float64 `protobuf:"fixed64,5,opt,name=apparent_power,json=apparentPower,proto3" json:"apparent_power,omitempty"`
	// 电量
	Electricity float64 `protobuf:"fixed64,6,opt,name=electricity,proto3" json:"electricity,omitempty"`
	// 运行时间
	ActiveTime float64 `protobuf:"fixed64,7,opt,name=active_time,json=activeTime,proto3" json:"active_time,omitempty"`
	// 灯状态
	LightStatus *SluitemData_LightStatus `protobuf:"bytes,8,opt,name=light_status,json=lightStatus,proto3" json:"light_status,omitempty"`
	// 节能档位
	PowerLevel int32 `protobuf:"varint,9,opt,name=power_level,json=powerLevel,proto3" json:"power_level,omitempty"`
	// 控制器上电开灯 1-开灯，0-关灯
	SluitemPowerTurnon int32 `protobuf:"varint,10,opt,name=sluitem_power_turnon,json=sluitemPowerTurnon,proto3" json:"sluitem_power_turnon,omitempty"`
	// 1-4回路额定功率
	RatedPower int32 `protobuf:"varint,11,opt,name=rated_power,json=ratedPower,proto3" json:"rated_power,omitempty"`
}

func (m *SluitemData_LightData) Reset()         { *m = SluitemData_LightData{} }
func (m *SluitemData_LightData) String() string { return proto.CompactTextString(m) }
func (*SluitemData_LightData) ProtoMessage()    {}
func (*SluitemData_LightData) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{4, 1}
}
func (m *SluitemData_LightData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SluitemData_LightData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SluitemData_LightData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SluitemData_LightData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SluitemData_LightData.Merge(m, src)
}
func (m *SluitemData_LightData) XXX_Size() int {
	return m.Size()
}
func (m *SluitemData_LightData) XXX_DiscardUnknown() {
	xxx_messageInfo_SluitemData_LightData.DiscardUnknown(m)
}

var xxx_messageInfo_SluitemData_LightData proto.InternalMessageInfo

func (m *SluitemData_LightData) GetVoltage() float64 {
	if m != nil {
		return m.Voltage
	}
	return 0
}

func (m *SluitemData_LightData) GetCurrent() float64 {
	if m != nil {
		return m.Current
	}
	return 0
}

func (m *SluitemData_LightData) GetActivePower() float64 {
	if m != nil {
		return m.ActivePower
	}
	return 0
}

func (m *SluitemData_LightData) GetReactivePower() float64 {
	if m != nil {
		return m.ReactivePower
	}
	return 0
}

func (m *SluitemData_LightData) GetApparentPower() float64 {
	if m != nil {
		return m.ApparentPower
	}
	return 0
}

func (m *SluitemData_LightData) GetElectricity() float64 {
	if m != nil {
		return m.Electricity
	}
	return 0
}

func (m *SluitemData_LightData) GetActiveTime() float64 {
	if m != nil {
		return m.ActiveTime
	}
	return 0
}

func (m *SluitemData_LightData) GetLightStatus() *SluitemData_LightStatus {
	if m != nil {
		return m.LightStatus
	}
	return nil
}

func (m *SluitemData_LightData) GetPowerLevel() int32 {
	if m != nil {
		return m.PowerLevel
	}
	return 0
}

func (m *SluitemData_LightData) GetSluitemPowerTurnon() int32 {
	if m != nil {
		return m.SluitemPowerTurnon
	}
	return 0
}

func (m *SluitemData_LightData) GetRatedPower() int32 {
	if m != nil {
		return m.RatedPower
	}
	return 0
}

type SluitemData_LightStatus struct {
	// 灯具漏电 0-正常，1-漏电
	Leakage int32 `protobuf:"varint,1,opt,name=leakage,proto3" json:"leakage,omitempty"`
	// 故障 0-正常，1-光源故障，2-补偿电容故障，3-意外灭灯，4-意外亮灯，5-自熄灯
	Fault int32 `protobuf:"varint,2,opt,name=fault,proto3" json:"fault,omitempty"`
	// 工作状态 0-正常亮灯，1-保留，2-调光节能，3-关灯
	WorkingOn int32 `protobuf:"varint,3,opt,name=working_on,json=workingOn,proto3" json:"working_on,omitempty"`
}

func (m *SluitemData_LightStatus) Reset()         { *m = SluitemData_LightStatus{} }
func (m *SluitemData_LightStatus) String() string { return proto.CompactTextString(m) }
func (*SluitemData_LightStatus) ProtoMessage()    {}
func (*SluitemData_LightStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{4, 2}
}
func (m *SluitemData_LightStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SluitemData_LightStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SluitemData_LightStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SluitemData_LightStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SluitemData_LightStatus.Merge(m, src)
}
func (m *SluitemData_LightStatus) XXX_Size() int {
	return m.Size()
}
func (m *SluitemData_LightStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_SluitemData_LightStatus.DiscardUnknown(m)
}

var xxx_messageInfo_SluitemData_LightStatus proto.InternalMessageInfo

func (m *SluitemData_LightStatus) GetLeakage() int32 {
	if m != nil {
		return m.Leakage
	}
	return 0
}

func (m *SluitemData_LightStatus) GetFault() int32 {
	if m != nil {
		return m.Fault
	}
	return 0
}

func (m *SluitemData_LightStatus) GetWorkingOn() int32 {
	if m != nil {
		return m.WorkingOn
	}
	return 0
}

type SluitemData_SluitemStatus struct {
	// flash故障 0-正常 1-故障
	FlashFault int32 `protobuf:"varint,1,opt,name=flash_fault,json=flashFault,proto3" json:"flash_fault,omitempty"`
	// 主动报警禁止 0-正常 1-禁止
	EnableAlarm int32 `protobuf:"varint,2,opt,name=enable_alarm,json=enableAlarm,proto3" json:"enable_alarm,omitempty"`
}

func (m *SluitemData_SluitemStatus) Reset()         { *m = SluitemData_SluitemStatus{} }
func (m *SluitemData_SluitemStatus) String() string { return proto.CompactTextString(m) }
func (*SluitemData_SluitemStatus) ProtoMessage()    {}
func (*SluitemData_SluitemStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{4, 3}
}
func (m *SluitemData_SluitemStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SluitemData_SluitemStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SluitemData_SluitemStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SluitemData_SluitemStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SluitemData_SluitemStatus.Merge(m, src)
}
func (m *SluitemData_SluitemStatus) XXX_Size() int {
	return m.Size()
}
func (m *SluitemData_SluitemStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_SluitemData_SluitemStatus.DiscardUnknown(m)
}

var xxx_messageInfo_SluitemData_SluitemStatus proto.InternalMessageInfo

func (m *SluitemData_SluitemStatus) GetFlashFault() int32 {
	if m != nil {
		return m.FlashFault
	}
	return 0
}

func (m *SluitemData_SluitemStatus) GetEnableAlarm() int32 {
	if m != nil {
		return m.EnableAlarm
	}
	return 0
}

type SluitemData_TimeFault struct {
	// 本地时钟故障 0-正常 1-故障
	ClockFault int32 `protobuf:"varint,1,opt,name=clock_fault,json=clockFault,proto3" json:"clock_fault,omitempty"`
	// 本地时钟超差故障 0-正常 1-故障
	ClockOutFault int32 `protobuf:"varint,2,opt,name=clock_out_fault,json=clockOutFault,proto3" json:"clock_out_fault,omitempty"`
	// 校时超差故障 0-正常 1-故障
	ClockOutAlarm int32 `protobuf:"varint,3,opt,name=clock_out_alarm,json=clockOutAlarm,proto3" json:"clock_out_alarm,omitempty"`
}

func (m *SluitemData_TimeFault) Reset()         { *m = SluitemData_TimeFault{} }
func (m *SluitemData_TimeFault) String() string { return proto.CompactTextString(m) }
func (*SluitemData_TimeFault) ProtoMessage()    {}
func (*SluitemData_TimeFault) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{4, 4}
}
func (m *SluitemData_TimeFault) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SluitemData_TimeFault) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SluitemData_TimeFault.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SluitemData_TimeFault) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SluitemData_TimeFault.Merge(m, src)
}
func (m *SluitemData_TimeFault) XXX_Size() int {
	return m.Size()
}
func (m *SluitemData_TimeFault) XXX_DiscardUnknown() {
	xxx_messageInfo_SluitemData_TimeFault.DiscardUnknown(m)
}

var xxx_messageInfo_SluitemData_TimeFault proto.InternalMessageInfo

func (m *SluitemData_TimeFault) GetClockFault() int32 {
	if m != nil {
		return m.ClockFault
	}
	return 0
}

func (m *SluitemData_TimeFault) GetClockOutFault() int32 {
	if m != nil {
		return m.ClockOutFault
	}
	return 0
}

func (m *SluitemData_TimeFault) GetClockOutAlarm() int32 {
	if m != nil {
		return m.ClockOutAlarm
	}
	return 0
}

type SluitemData_SluitemPara struct {
	// 经度
	Longitude float64 `protobuf:"fixed64,1,opt,name=longitude,proto3" json:"longitude,omitempty"`
	// 纬度
	Latitude float64 `protobuf:"fixed64,2,opt,name=latitude,proto3" json:"latitude,omitempty"`
	// 是否允许主报 1-允许 0-不允许
	HasEnableAlarm int32 `protobuf:"varint,3,opt,name=has_enable_alarm,json=hasEnableAlarm,proto3" json:"has_enable_alarm,omitempty"`
	// 是否投运 1-投运 0-停运
	IsRunning int32 `protobuf:"varint,4,opt,name=is_running,json=isRunning,proto3" json:"is_running,omitempty"`
	// 主动报警间隔 单位分钟 0表示30分钟
	AlarmInterval int32 `protobuf:"varint,5,opt,name=alarm_interval,json=alarmInterval,proto3" json:"alarm_interval,omitempty"`
	// nb主报需要主站应答，0-不需要，1-需要
	UplinkReply int32 `protobuf:"varint,6,opt,name=uplink_reply,json=uplinkReply,proto3" json:"uplink_reply,omitempty"`
}

func (m *SluitemData_SluitemPara) Reset()         { *m = SluitemData_SluitemPara{} }
func (m *SluitemData_SluitemPara) String() string { return proto.CompactTextString(m) }
func (*SluitemData_SluitemPara) ProtoMessage()    {}
func (*SluitemData_SluitemPara) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{4, 5}
}
func (m *SluitemData_SluitemPara) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SluitemData_SluitemPara) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SluitemData_SluitemPara.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SluitemData_SluitemPara) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SluitemData_SluitemPara.Merge(m, src)
}
func (m *SluitemData_SluitemPara) XXX_Size() int {
	return m.Size()
}
func (m *SluitemData_SluitemPara) XXX_DiscardUnknown() {
	xxx_messageInfo_SluitemData_SluitemPara.DiscardUnknown(m)
}

var xxx_messageInfo_SluitemData_SluitemPara proto.InternalMessageInfo

func (m *SluitemData_SluitemPara) GetLongitude() float64 {
	if m != nil {
		return m.Longitude
	}
	return 0
}

func (m *SluitemData_SluitemPara) GetLatitude() float64 {
	if m != nil {
		return m.Latitude
	}
	return 0
}

func (m *SluitemData_SluitemPara) GetHasEnableAlarm() int32 {
	if m != nil {
		return m.HasEnableAlarm
	}
	return 0
}

func (m *SluitemData_SluitemPara) GetIsRunning() int32 {
	if m != nil {
		return m.IsRunning
	}
	return 0
}

func (m *SluitemData_SluitemPara) GetAlarmInterval() int32 {
	if m != nil {
		return m.AlarmInterval
	}
	return 0
}

func (m *SluitemData_SluitemPara) GetUplinkReply() int32 {
	if m != nil {
		return m.UplinkReply
	}
	return 0
}

// 网络参数 (不进行设置的参数的值下发时置零)
type NBSlu_3100 struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// APN
	Apn string `protobuf:"bytes,2,opt,name=apn,proto3" json:"apn,omitempty"`
	// 用户名
	UserName string `protobuf:"bytes,3,opt,name=user_name,json=userName,proto3" json:"user_name,omitempty"`
	// 密码
	Password string `protobuf:"bytes,4,opt,name=password,proto3" json:"password,omitempty"`
	// 接入运营商
	Operater int32 `protobuf:"varint,5,opt,name=operater,proto3" json:"operater,omitempty"`
	// ip (每1字节分别代表地址中1个数字)
	IpAddress []int32 `protobuf:"varint,6,rep,packed,name=ip_address,json=ipAddress,proto3" json:"ip_address,omitempty"`
	// 远程端口
	Teleport int32 `protobuf:"varint,7,opt,name=teleport,proto3" json:"teleport,omitempty"`
	// 本地端口
	Localport int32 `protobuf:"varint,8,opt,name=localport,proto3" json:"localport,omitempty"`
	// 虚连接时间 (单位为分)
	VlinkTime int32 `protobuf:"varint,9,opt,name=vlink_time,json=vlinkTime,proto3" json:"vlink_time,omitempty"`
	// 组入网间隔 (单位为秒)
	GroupAccessInterval int32 `protobuf:"varint,10,opt,name=group_access_interval,json=groupAccessInterval,proto3" json:"group_access_interval,omitempty"`
	// 组内设备个数
	GroupDeviceCount int32 `protobuf:"varint,11,opt,name=group_device_count,json=groupDeviceCount,proto3" json:"group_device_count,omitempty"`
	// 扇区最大允许接入设备总数
	MaxDeviceCount int32 `protobuf:"varint,12,opt,name=max_device_count,json=maxDeviceCount,proto3" json:"max_device_count,omitempty"`
	// IMEI
	Imei string `protobuf:"bytes,13,opt,name=imei,proto3" json:"imei,omitempty"`
	// IMSI
	Imsi string `protobuf:"bytes,14,opt,name=imsi,proto3" json:"imsi,omitempty"`
	// ICCID
	Iccid string `protobuf:"bytes,15,opt,name=iccid,proto3" json:"iccid,omitempty"`
	// 应答状态 (0x35为成功，其它失败)
	Status int32 `protobuf:"varint,16,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *NBSlu_3100) Reset()         { *m = NBSlu_3100{} }
func (m *NBSlu_3100) String() string { return proto.CompactTextString(m) }
func (*NBSlu_3100) ProtoMessage()    {}
func (*NBSlu_3100) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{5}
}
func (m *NBSlu_3100) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NBSlu_3100) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NBSlu_3100.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NBSlu_3100) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NBSlu_3100.Merge(m, src)
}
func (m *NBSlu_3100) XXX_Size() int {
	return m.Size()
}
func (m *NBSlu_3100) XXX_DiscardUnknown() {
	xxx_messageInfo_NBSlu_3100.DiscardUnknown(m)
}

var xxx_messageInfo_NBSlu_3100 proto.InternalMessageInfo

func (m *NBSlu_3100) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *NBSlu_3100) GetApn() string {
	if m != nil {
		return m.Apn
	}
	return ""
}

func (m *NBSlu_3100) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

func (m *NBSlu_3100) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *NBSlu_3100) GetOperater() int32 {
	if m != nil {
		return m.Operater
	}
	return 0
}

func (m *NBSlu_3100) GetIpAddress() []int32 {
	if m != nil {
		return m.IpAddress
	}
	return nil
}

func (m *NBSlu_3100) GetTeleport() int32 {
	if m != nil {
		return m.Teleport
	}
	return 0
}

func (m *NBSlu_3100) GetLocalport() int32 {
	if m != nil {
		return m.Localport
	}
	return 0
}

func (m *NBSlu_3100) GetVlinkTime() int32 {
	if m != nil {
		return m.VlinkTime
	}
	return 0
}

func (m *NBSlu_3100) GetGroupAccessInterval() int32 {
	if m != nil {
		return m.GroupAccessInterval
	}
	return 0
}

func (m *NBSlu_3100) GetGroupDeviceCount() int32 {
	if m != nil {
		return m.GroupDeviceCount
	}
	return 0
}

func (m *NBSlu_3100) GetMaxDeviceCount() int32 {
	if m != nil {
		return m.MaxDeviceCount
	}
	return 0
}

func (m *NBSlu_3100) GetImei() string {
	if m != nil {
		return m.Imei
	}
	return ""
}

func (m *NBSlu_3100) GetImsi() string {
	if m != nil {
		return m.Imsi
	}
	return ""
}

func (m *NBSlu_3100) GetIccid() string {
	if m != nil {
		return m.Iccid
	}
	return ""
}

func (m *NBSlu_3100) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

// 登录信息数据主报
type NBSlu_3700 struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// IMEI
	Imei string `protobuf:"bytes,2,opt,name=imei,proto3" json:"imei,omitempty"`
	// IMSI
	Imsi string `protobuf:"bytes,3,opt,name=imsi,proto3" json:"imsi,omitempty"`
	// ICCID 集成电路卡识别码
	Iccid string `protobuf:"bytes,4,opt,name=iccid,proto3" json:"iccid,omitempty"`
	// 频段
	Band int32 `protobuf:"varint,5,opt,name=band,proto3" json:"band,omitempty"`
	// 参考信号接收功率
	Rsrp int64 `protobuf:"varint,6,opt,name=rsrp,proto3" json:"rsrp,omitempty"`
	// 信噪比
	Snr int64 `protobuf:"varint,7,opt,name=snr,proto3" json:"snr,omitempty"`
}

func (m *NBSlu_3700) Reset()         { *m = NBSlu_3700{} }
func (m *NBSlu_3700) String() string { return proto.CompactTextString(m) }
func (*NBSlu_3700) ProtoMessage()    {}
func (*NBSlu_3700) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{6}
}
func (m *NBSlu_3700) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NBSlu_3700) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NBSlu_3700.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NBSlu_3700) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NBSlu_3700.Merge(m, src)
}
func (m *NBSlu_3700) XXX_Size() int {
	return m.Size()
}
func (m *NBSlu_3700) XXX_DiscardUnknown() {
	xxx_messageInfo_NBSlu_3700.DiscardUnknown(m)
}

var xxx_messageInfo_NBSlu_3700 proto.InternalMessageInfo

func (m *NBSlu_3700) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *NBSlu_3700) GetImei() string {
	if m != nil {
		return m.Imei
	}
	return ""
}

func (m *NBSlu_3700) GetImsi() string {
	if m != nil {
		return m.Imsi
	}
	return ""
}

func (m *NBSlu_3700) GetIccid() string {
	if m != nil {
		return m.Iccid
	}
	return ""
}

func (m *NBSlu_3700) GetBand() int32 {
	if m != nil {
		return m.Band
	}
	return 0
}

func (m *NBSlu_3700) GetRsrp() int64 {
	if m != nil {
		return m.Rsrp
	}
	return 0
}

func (m *NBSlu_3700) GetSnr() int64 {
	if m != nil {
		return m.Snr
	}
	return 0
}

// 时间
type NBSlu_1400 struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 时间
	SluitemTime int64 `protobuf:"varint,2,opt,name=sluitem_time,json=sluitemTime,proto3" json:"sluitem_time,omitempty"`
	// 星期
	Week int32 `protobuf:"varint,3,opt,name=week,proto3" json:"week,omitempty"`
	// 应答状态 (0x35为成功，其它失败)
	Status int32 `protobuf:"varint,4,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *NBSlu_1400) Reset()         { *m = NBSlu_1400{} }
func (m *NBSlu_1400) String() string { return proto.CompactTextString(m) }
func (*NBSlu_1400) ProtoMessage()    {}
func (*NBSlu_1400) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{7}
}
func (m *NBSlu_1400) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NBSlu_1400) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NBSlu_1400.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NBSlu_1400) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NBSlu_1400.Merge(m, src)
}
func (m *NBSlu_1400) XXX_Size() int {
	return m.Size()
}
func (m *NBSlu_1400) XXX_DiscardUnknown() {
	xxx_messageInfo_NBSlu_1400.DiscardUnknown(m)
}

var xxx_messageInfo_NBSlu_1400 proto.InternalMessageInfo

func (m *NBSlu_1400) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *NBSlu_1400) GetSluitemTime() int64 {
	if m != nil {
		return m.SluitemTime
	}
	return 0
}

func (m *NBSlu_1400) GetWeek() int32 {
	if m != nil {
		return m.Week
	}
	return 0
}

func (m *NBSlu_1400) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

// 版本
type NBSlu_5100 struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 版本
	Ver string `protobuf:"bytes,2,opt,name=ver,proto3" json:"ver,omitempty"`
	// 应答状态 (0x35为成功，其它失败)
	Status int32 `protobuf:"varint,3,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *NBSlu_5100) Reset()         { *m = NBSlu_5100{} }
func (m *NBSlu_5100) String() string { return proto.CompactTextString(m) }
func (*NBSlu_5100) ProtoMessage()    {}
func (*NBSlu_5100) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{8}
}
func (m *NBSlu_5100) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NBSlu_5100) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NBSlu_5100.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NBSlu_5100) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NBSlu_5100.Merge(m, src)
}
func (m *NBSlu_5100) XXX_Size() int {
	return m.Size()
}
func (m *NBSlu_5100) XXX_DiscardUnknown() {
	xxx_messageInfo_NBSlu_5100.DiscardUnknown(m)
}

var xxx_messageInfo_NBSlu_5100 proto.InternalMessageInfo

func (m *NBSlu_5100) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *NBSlu_5100) GetVer() string {
	if m != nil {
		return m.Ver
	}
	return ""
}

func (m *NBSlu_5100) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

// 运行参数
type NBSlu_5200 struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 经度
	Longitude float64 `protobuf:"fixed64,2,opt,name=longitude,proto3" json:"longitude,omitempty"`
	// 纬度
	Latitude float64 `protobuf:"fixed64,3,opt,name=latitude,proto3" json:"latitude,omitempty"`
	// 控制器状态 0-停运，1-投运
	SluitemStatus int32 `protobuf:"varint,4,opt,name=sluitem_status,json=sluitemStatus,proto3" json:"sluitem_status,omitempty"`
	// 控制器上电开灯 1-开灯，0-关灯
	SluitemPowerTurnon []int32 `protobuf:"varint,5,rep,packed,name=sluitem_power_turnon,json=sluitemPowerTurnon,proto3" json:"sluitem_power_turnon,omitempty"`
	// 控制器主报 0-禁止主报，1-允许主报
	SluitemEnableAlarm int32 `protobuf:"varint,6,opt,name=sluitem_enable_alarm,json=sluitemEnableAlarm,proto3" json:"sluitem_enable_alarm,omitempty"`
	// 1-4回路额定功率
	RatedPower []int32 `protobuf:"varint,7,rep,packed,name=rated_power,json=ratedPower,proto3" json:"rated_power,omitempty"`
	// nb主报间隔，(0～127)*5
	UplinkTimer int32 `protobuf:"varint,8,opt,name=uplink_timer,json=uplinkTimer,proto3" json:"uplink_timer,omitempty"`
	// nb主报需要主站应答，0-不需要，1-需要
	UplinkReply int32 `protobuf:"varint,9,opt,name=uplink_reply,json=uplinkReply,proto3" json:"uplink_reply,omitempty"`
	// 实际使用回路数
	UseLoop int32 `protobuf:"varint,10,opt,name=use_loop,json=useLoop,proto3" json:"use_loop,omitempty"`
	// 应答状态 (0x35为成功，其它失败)
	Status int32 `protobuf:"varint,11,opt,name=status,proto3" json:"status,omitempty"`
	// 1-4回路是否反向调光，0-正向，1-反向
	SluitemReverseDimming []int32 `protobuf:"varint,12,rep,packed,name=sluitem_reverse_dimming,json=sluitemReverseDimming,proto3" json:"sluitem_reverse_dimming,omitempty"`
	// 历史数据保存间隔，默认30分钟
	RecordTimer int32 `protobuf:"varint,13,opt,name=record_timer,json=recordTimer,proto3" json:"record_timer,omitempty"`
}

func (m *NBSlu_5200) Reset()         { *m = NBSlu_5200{} }
func (m *NBSlu_5200) String() string { return proto.CompactTextString(m) }
func (*NBSlu_5200) ProtoMessage()    {}
func (*NBSlu_5200) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{9}
}
func (m *NBSlu_5200) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NBSlu_5200) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NBSlu_5200.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NBSlu_5200) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NBSlu_5200.Merge(m, src)
}
func (m *NBSlu_5200) XXX_Size() int {
	return m.Size()
}
func (m *NBSlu_5200) XXX_DiscardUnknown() {
	xxx_messageInfo_NBSlu_5200.DiscardUnknown(m)
}

var xxx_messageInfo_NBSlu_5200 proto.InternalMessageInfo

func (m *NBSlu_5200) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *NBSlu_5200) GetLongitude() float64 {
	if m != nil {
		return m.Longitude
	}
	return 0
}

func (m *NBSlu_5200) GetLatitude() float64 {
	if m != nil {
		return m.Latitude
	}
	return 0
}

func (m *NBSlu_5200) GetSluitemStatus() int32 {
	if m != nil {
		return m.SluitemStatus
	}
	return 0
}

func (m *NBSlu_5200) GetSluitemPowerTurnon() []int32 {
	if m != nil {
		return m.SluitemPowerTurnon
	}
	return nil
}

func (m *NBSlu_5200) GetSluitemEnableAlarm() int32 {
	if m != nil {
		return m.SluitemEnableAlarm
	}
	return 0
}

func (m *NBSlu_5200) GetRatedPower() []int32 {
	if m != nil {
		return m.RatedPower
	}
	return nil
}

func (m *NBSlu_5200) GetUplinkTimer() int32 {
	if m != nil {
		return m.UplinkTimer
	}
	return 0
}

func (m *NBSlu_5200) GetUplinkReply() int32 {
	if m != nil {
		return m.UplinkReply
	}
	return 0
}

func (m *NBSlu_5200) GetUseLoop() int32 {
	if m != nil {
		return m.UseLoop
	}
	return 0
}

func (m *NBSlu_5200) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *NBSlu_5200) GetSluitemReverseDimming() []int32 {
	if m != nil {
		return m.SluitemReverseDimming
	}
	return nil
}

func (m *NBSlu_5200) GetRecordTimer() int32 {
	if m != nil {
		return m.RecordTimer
	}
	return 0
}

// 即时控制
type NBSlu_5400 struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 输出类型0-继电器，1-pwm输出
	OutputType int32 `protobuf:"varint,2,opt,name=output_type,json=outputType,proto3" json:"output_type,omitempty"`
	// 继电器操作回路1-4, 0x0-不操作，0x3-开灯，0xc-关灯
	RelayOperate []int32 `protobuf:"varint,3,rep,packed,name=relay_operate,json=relayOperate,proto3" json:"relay_operate,omitempty"`
	// PWM操作回路
	PwmLoop []int32 `protobuf:"varint,4,rep,packed,name=pwm_loop,json=pwmLoop,proto3" json:"pwm_loop,omitempty"`
	// PWM操作占空比
	PwmPower int32 `protobuf:"varint,5,opt,name=pwm_power,json=pwmPower,proto3" json:"pwm_power,omitempty"`
	// PWM频率 (1~15) * 100 默认为4
	PwmBaudrate int32 `protobuf:"varint,6,opt,name=pwm_baudrate,json=pwmBaudrate,proto3" json:"pwm_baudrate,omitempty"`
	// 应答状态 (0x35为成功，其它失败)
	Status int32 `protobuf:"varint,7,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *NBSlu_5400) Reset()         { *m = NBSlu_5400{} }
func (m *NBSlu_5400) String() string { return proto.CompactTextString(m) }
func (*NBSlu_5400) ProtoMessage()    {}
func (*NBSlu_5400) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{10}
}
func (m *NBSlu_5400) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NBSlu_5400) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NBSlu_5400.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NBSlu_5400) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NBSlu_5400.Merge(m, src)
}
func (m *NBSlu_5400) XXX_Size() int {
	return m.Size()
}
func (m *NBSlu_5400) XXX_DiscardUnknown() {
	xxx_messageInfo_NBSlu_5400.DiscardUnknown(m)
}

var xxx_messageInfo_NBSlu_5400 proto.InternalMessageInfo

func (m *NBSlu_5400) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *NBSlu_5400) GetOutputType() int32 {
	if m != nil {
		return m.OutputType
	}
	return 0
}

func (m *NBSlu_5400) GetRelayOperate() []int32 {
	if m != nil {
		return m.RelayOperate
	}
	return nil
}

func (m *NBSlu_5400) GetPwmLoop() []int32 {
	if m != nil {
		return m.PwmLoop
	}
	return nil
}

func (m *NBSlu_5400) GetPwmPower() int32 {
	if m != nil {
		return m.PwmPower
	}
	return 0
}

func (m *NBSlu_5400) GetPwmBaudrate() int32 {
	if m != nil {
		return m.PwmBaudrate
	}
	return 0
}

func (m *NBSlu_5400) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

// 复位
type NBSlu_5500 struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// MCU复位 0-不勾选 1-勾选
	Mcu int32 `protobuf:"varint,2,opt,name=mcu,proto3" json:"mcu,omitempty"`
	// 初始化MCU硬件配置 0-不勾选 1-勾选 (暂不使用)
	InitializeMcu int32 `protobuf:"varint,3,opt,name=initialize_mcu,json=initializeMcu,proto3" json:"initialize_mcu,omitempty"`
	// 初始化RAM区所有变量 0-不勾选 1-勾选 (暂不使用)
	InitializeRam int32 `protobuf:"varint,4,opt,name=initialize_ram,json=initializeRam,proto3" json:"initialize_ram,omitempty"`
	// EEPROM全部清零 0-不勾选 1-勾选 (暂不使用)
	InitializeEeprom int32 `protobuf:"varint,5,opt,name=initialize_eeprom,json=initializeEeprom,proto3" json:"initialize_eeprom,omitempty"`
	// 电能计量值清零 0-不勾选 1-勾选
	InitializeElec int32 `protobuf:"varint,6,opt,name=initialize_elec,json=initializeElec,proto3" json:"initialize_elec,omitempty"`
	// 应答状态 (0x35为成功，其它失败)
	Status int32 `protobuf:"varint,7,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *NBSlu_5500) Reset()         { *m = NBSlu_5500{} }
func (m *NBSlu_5500) String() string { return proto.CompactTextString(m) }
func (*NBSlu_5500) ProtoMessage()    {}
func (*NBSlu_5500) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{11}
}
func (m *NBSlu_5500) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NBSlu_5500) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NBSlu_5500.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NBSlu_5500) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NBSlu_5500.Merge(m, src)
}
func (m *NBSlu_5500) XXX_Size() int {
	return m.Size()
}
func (m *NBSlu_5500) XXX_DiscardUnknown() {
	xxx_messageInfo_NBSlu_5500.DiscardUnknown(m)
}

var xxx_messageInfo_NBSlu_5500 proto.InternalMessageInfo

func (m *NBSlu_5500) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *NBSlu_5500) GetMcu() int32 {
	if m != nil {
		return m.Mcu
	}
	return 0
}

func (m *NBSlu_5500) GetInitializeMcu() int32 {
	if m != nil {
		return m.InitializeMcu
	}
	return 0
}

func (m *NBSlu_5500) GetInitializeRam() int32 {
	if m != nil {
		return m.InitializeRam
	}
	return 0
}

func (m *NBSlu_5500) GetInitializeEeprom() int32 {
	if m != nil {
		return m.InitializeEeprom
	}
	return 0
}

func (m *NBSlu_5500) GetInitializeElec() int32 {
	if m != nil {
		return m.InitializeElec
	}
	return 0
}

func (m *NBSlu_5500) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

// 本地控制方案
type NBSlu_5600 struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 是否清除原方案 0-保留 1-清除
	ClearOldRuntime int32 `protobuf:"varint,2,opt,name=clear_old_runtime,json=clearOldRuntime,proto3" json:"clear_old_runtime,omitempty"`
	// 是否含有后续数据
	DataContinue int32 `protobuf:"varint,3,opt,name=data_continue,json=dataContinue,proto3" json:"data_continue,omitempty"`
	// 后续方案个数
	SluitemRuntimeCount int32 `protobuf:"varint,4,opt,name=sluitem_runtime_count,json=sluitemRuntimeCount,proto3" json:"sluitem_runtime_count,omitempty"`
	// 方案
	SluitemRuntime []*NBSlu_5600_SluitemRuntime `protobuf:"bytes,5,rep,name=sluitem_runtime,json=sluitemRuntime,proto3" json:"sluitem_runtime,omitempty"`
	// 应答状态 (0x35为成功，其它失败)
	Status int32 `protobuf:"varint,6,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *NBSlu_5600) Reset()         { *m = NBSlu_5600{} }
func (m *NBSlu_5600) String() string { return proto.CompactTextString(m) }
func (*NBSlu_5600) ProtoMessage()    {}
func (*NBSlu_5600) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{12}
}
func (m *NBSlu_5600) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NBSlu_5600) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NBSlu_5600.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NBSlu_5600) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NBSlu_5600.Merge(m, src)
}
func (m *NBSlu_5600) XXX_Size() int {
	return m.Size()
}
func (m *NBSlu_5600) XXX_DiscardUnknown() {
	xxx_messageInfo_NBSlu_5600.DiscardUnknown(m)
}

var xxx_messageInfo_NBSlu_5600 proto.InternalMessageInfo

func (m *NBSlu_5600) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *NBSlu_5600) GetClearOldRuntime() int32 {
	if m != nil {
		return m.ClearOldRuntime
	}
	return 0
}

func (m *NBSlu_5600) GetDataContinue() int32 {
	if m != nil {
		return m.DataContinue
	}
	return 0
}

func (m *NBSlu_5600) GetSluitemRuntimeCount() int32 {
	if m != nil {
		return m.SluitemRuntimeCount
	}
	return 0
}

func (m *NBSlu_5600) GetSluitemRuntime() []*NBSlu_5600_SluitemRuntime {
	if m != nil {
		return m.SluitemRuntime
	}
	return nil
}

func (m *NBSlu_5600) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

type NBSlu_5600_SluitemRuntime struct {
	// 输出类型0-继电器，1-pwm输出
	OutputType int32 `protobuf:"varint,1,opt,name=output_type,json=outputType,proto3" json:"output_type,omitempty"`
	// 操作类型1-定时操作，2-经纬度操作
	OperateType int32 `protobuf:"varint,2,opt,name=operate_type,json=operateType,proto3" json:"operate_type,omitempty"`
	// 有效日期，0-6～周日-周6
	DateEnable []int32 `protobuf:"varint,3,rep,packed,name=date_enable,json=dateEnable,proto3" json:"date_enable,omitempty"`
	// 开关灯操作时间 hhmm->int32
	OperateTime int32 `protobuf:"varint,4,opt,name=operate_time,json=operateTime,proto3" json:"operate_time,omitempty"`
	// 操作偏移 -720~+720
	OperateOffset int32 `protobuf:"varint,5,opt,name=operate_offset,json=operateOffset,proto3" json:"operate_offset,omitempty"`
	// 继电器操作回路1-4, 0x0-不操作，0x3-开灯，0xc-关灯
	RelayOperate []int32 `protobuf:"varint,6,rep,packed,name=relay_operate,json=relayOperate,proto3" json:"relay_operate,omitempty"`
	// PWM操作回路
	PwmLoop []int32 `protobuf:"varint,7,rep,packed,name=pwm_loop,json=pwmLoop,proto3" json:"pwm_loop,omitempty"`
	// PWM操作占空比
	PwmPower int32 `protobuf:"varint,8,opt,name=pwm_power,json=pwmPower,proto3" json:"pwm_power,omitempty"`
	// PWM频率 (1~15) * 100 默认为4
	PwmBaudrate int32 `protobuf:"varint,9,opt,name=pwm_baudrate,json=pwmBaudrate,proto3" json:"pwm_baudrate,omitempty"`
}

func (m *NBSlu_5600_SluitemRuntime) Reset()         { *m = NBSlu_5600_SluitemRuntime{} }
func (m *NBSlu_5600_SluitemRuntime) String() string { return proto.CompactTextString(m) }
func (*NBSlu_5600_SluitemRuntime) ProtoMessage()    {}
func (*NBSlu_5600_SluitemRuntime) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{12, 0}
}
func (m *NBSlu_5600_SluitemRuntime) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NBSlu_5600_SluitemRuntime) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NBSlu_5600_SluitemRuntime.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NBSlu_5600_SluitemRuntime) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NBSlu_5600_SluitemRuntime.Merge(m, src)
}
func (m *NBSlu_5600_SluitemRuntime) XXX_Size() int {
	return m.Size()
}
func (m *NBSlu_5600_SluitemRuntime) XXX_DiscardUnknown() {
	xxx_messageInfo_NBSlu_5600_SluitemRuntime.DiscardUnknown(m)
}

var xxx_messageInfo_NBSlu_5600_SluitemRuntime proto.InternalMessageInfo

func (m *NBSlu_5600_SluitemRuntime) GetOutputType() int32 {
	if m != nil {
		return m.OutputType
	}
	return 0
}

func (m *NBSlu_5600_SluitemRuntime) GetOperateType() int32 {
	if m != nil {
		return m.OperateType
	}
	return 0
}

func (m *NBSlu_5600_SluitemRuntime) GetDateEnable() []int32 {
	if m != nil {
		return m.DateEnable
	}
	return nil
}

func (m *NBSlu_5600_SluitemRuntime) GetOperateTime() int32 {
	if m != nil {
		return m.OperateTime
	}
	return 0
}

func (m *NBSlu_5600_SluitemRuntime) GetOperateOffset() int32 {
	if m != nil {
		return m.OperateOffset
	}
	return 0
}

func (m *NBSlu_5600_SluitemRuntime) GetRelayOperate() []int32 {
	if m != nil {
		return m.RelayOperate
	}
	return nil
}

func (m *NBSlu_5600_SluitemRuntime) GetPwmLoop() []int32 {
	if m != nil {
		return m.PwmLoop
	}
	return nil
}

func (m *NBSlu_5600_SluitemRuntime) GetPwmPower() int32 {
	if m != nil {
		return m.PwmPower
	}
	return 0
}

func (m *NBSlu_5600_SluitemRuntime) GetPwmBaudrate() int32 {
	if m != nil {
		return m.PwmBaudrate
	}
	return 0
}

// 远程升级相关
// 查询版本
type NBSlu_FF05 struct {
	// 版本号
	Ver string `protobuf:"bytes,1,opt,name=ver,proto3" json:"ver,omitempty"`
}

func (m *NBSlu_FF05) Reset()         { *m = NBSlu_FF05{} }
func (m *NBSlu_FF05) String() string { return proto.CompactTextString(m) }
func (*NBSlu_FF05) ProtoMessage()    {}
func (*NBSlu_FF05) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{13}
}
func (m *NBSlu_FF05) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NBSlu_FF05) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NBSlu_FF05.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NBSlu_FF05) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NBSlu_FF05.Merge(m, src)
}
func (m *NBSlu_FF05) XXX_Size() int {
	return m.Size()
}
func (m *NBSlu_FF05) XXX_DiscardUnknown() {
	xxx_messageInfo_NBSlu_FF05.DiscardUnknown(m)
}

var xxx_messageInfo_NBSlu_FF05 proto.InternalMessageInfo

func (m *NBSlu_FF05) GetVer() string {
	if m != nil {
		return m.Ver
	}
	return ""
}

// 查询升级状态
type NBSlu_FF07 struct {
	// 数据包总数
	DatapackTotal int32 `protobuf:"varint,1,opt,name=datapack_total,json=datapackTotal,proto3" json:"datapack_total,omitempty"`
	// 数据包状态
	DatapackStatus []int32 `protobuf:"varint,2,rep,packed,name=datapack_status,json=datapackStatus,proto3" json:"datapack_status,omitempty"`
}

func (m *NBSlu_FF07) Reset()         { *m = NBSlu_FF07{} }
func (m *NBSlu_FF07) String() string { return proto.CompactTextString(m) }
func (*NBSlu_FF07) ProtoMessage()    {}
func (*NBSlu_FF07) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{14}
}
func (m *NBSlu_FF07) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NBSlu_FF07) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NBSlu_FF07.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NBSlu_FF07) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NBSlu_FF07.Merge(m, src)
}
func (m *NBSlu_FF07) XXX_Size() int {
	return m.Size()
}
func (m *NBSlu_FF07) XXX_DiscardUnknown() {
	xxx_messageInfo_NBSlu_FF07.DiscardUnknown(m)
}

var xxx_messageInfo_NBSlu_FF07 proto.InternalMessageInfo

func (m *NBSlu_FF07) GetDatapackTotal() int32 {
	if m != nil {
		return m.DatapackTotal
	}
	return 0
}

func (m *NBSlu_FF07) GetDatapackStatus() []int32 {
	if m != nil {
		return m.DatapackStatus
	}
	return nil
}

// 升级完成通知
type NBSlu_FF01 struct {
	// 旧版本
	OldVer string `protobuf:"bytes,1,opt,name=old_ver,json=oldVer,proto3" json:"old_ver,omitempty"`
	// 新版本
	NewVer string `protobuf:"bytes,2,opt,name=new_ver,json=newVer,proto3" json:"new_ver,omitempty"`
}

func (m *NBSlu_FF01) Reset()         { *m = NBSlu_FF01{} }
func (m *NBSlu_FF01) String() string { return proto.CompactTextString(m) }
func (*NBSlu_FF01) ProtoMessage()    {}
func (*NBSlu_FF01) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{15}
}
func (m *NBSlu_FF01) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NBSlu_FF01) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NBSlu_FF01.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NBSlu_FF01) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NBSlu_FF01.Merge(m, src)
}
func (m *NBSlu_FF01) XXX_Size() int {
	return m.Size()
}
func (m *NBSlu_FF01) XXX_DiscardUnknown() {
	xxx_messageInfo_NBSlu_FF01.DiscardUnknown(m)
}

var xxx_messageInfo_NBSlu_FF01 proto.InternalMessageInfo

func (m *NBSlu_FF01) GetOldVer() string {
	if m != nil {
		return m.OldVer
	}
	return ""
}

func (m *NBSlu_FF01) GetNewVer() string {
	if m != nil {
		return m.NewVer
	}
	return ""
}

// 设置/读取漏电参数
type NBSlu_5800 struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 应答状态 (0x35为成功，其它失败)
	Status int32 `protobuf:"varint,2,opt,name=status,proto3" json:"status,omitempty"`
	// 漏电报警延时,1-65535毫秒，默认30
	AlarmDelay int32 `protobuf:"varint,3,opt,name=alarm_delay,json=alarmDelay,proto3" json:"alarm_delay,omitempty"`
	// 漏电报警限值，10-65530毫安，必须是10的倍数，默认30
	AlarmLimit int32 `protobuf:"varint,4,opt,name=alarm_limit,json=alarmLimit,proto3" json:"alarm_limit,omitempty"`
	// 漏电分匝延时，1-65535毫秒，默认30
	OptDelay int32 `protobuf:"varint,5,opt,name=opt_delay,json=optDelay,proto3" json:"opt_delay,omitempty"`
	// 漏电分匝限值，0,10-65530毫安，必须是10的倍数，0-不分匝
	OptLimit int32 `protobuf:"varint,6,opt,name=opt_limit,json=optLimit,proto3" json:"opt_limit,omitempty"`
	// 补偿电容（Compensation capacitor）报警功率因数限值，0-100,前端/100显示，默认85，低于85报警
	CcAlarm int32 `protobuf:"varint,7,opt,name=cc_alarm,json=ccAlarm,proto3" json:"cc_alarm,omitempty"`
	// 补偿电容（Compensation capacitor）消警功率因数限值，0-100,前端/100显示，默认90，高于90消警
	CcNormal int32 `protobuf:"varint,8,opt,name=cc_normal,json=ccNormal,proto3" json:"cc_normal,omitempty"`
}

func (m *NBSlu_5800) Reset()         { *m = NBSlu_5800{} }
func (m *NBSlu_5800) String() string { return proto.CompactTextString(m) }
func (*NBSlu_5800) ProtoMessage()    {}
func (*NBSlu_5800) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{16}
}
func (m *NBSlu_5800) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NBSlu_5800) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NBSlu_5800.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NBSlu_5800) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NBSlu_5800.Merge(m, src)
}
func (m *NBSlu_5800) XXX_Size() int {
	return m.Size()
}
func (m *NBSlu_5800) XXX_DiscardUnknown() {
	xxx_messageInfo_NBSlu_5800.DiscardUnknown(m)
}

var xxx_messageInfo_NBSlu_5800 proto.InternalMessageInfo

func (m *NBSlu_5800) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *NBSlu_5800) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *NBSlu_5800) GetAlarmDelay() int32 {
	if m != nil {
		return m.AlarmDelay
	}
	return 0
}

func (m *NBSlu_5800) GetAlarmLimit() int32 {
	if m != nil {
		return m.AlarmLimit
	}
	return 0
}

func (m *NBSlu_5800) GetOptDelay() int32 {
	if m != nil {
		return m.OptDelay
	}
	return 0
}

func (m *NBSlu_5800) GetOptLimit() int32 {
	if m != nil {
		return m.OptLimit
	}
	return 0
}

func (m *NBSlu_5800) GetCcAlarm() int32 {
	if m != nil {
		return m.CcAlarm
	}
	return 0
}

func (m *NBSlu_5800) GetCcNormal() int32 {
	if m != nil {
		return m.CcNormal
	}
	return 0
}

// 设置/读取漏电事件
type NBSlu_6200 struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 应答状态 (0x35为成功，其它失败)
	Status int32 `protobuf:"varint,2,opt,name=status,proto3" json:"status,omitempty"`
	// 事件有效标识，填写有效事件编号，如[1,4,5]，会记录
	EventsAvailable []int32 `protobuf:"varint,3,rep,packed,name=events_available,json=eventsAvailable,proto3" json:"events_available,omitempty"`
	// 事件重要标识，填写有效事件编号，如[4,5]，记录后会上报
	EventsReport []int32 `protobuf:"varint,4,rep,packed,name=events_report,json=eventsReport,proto3" json:"events_report,omitempty"`
}

func (m *NBSlu_6200) Reset()         { *m = NBSlu_6200{} }
func (m *NBSlu_6200) String() string { return proto.CompactTextString(m) }
func (*NBSlu_6200) ProtoMessage()    {}
func (*NBSlu_6200) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{17}
}
func (m *NBSlu_6200) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NBSlu_6200) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NBSlu_6200.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NBSlu_6200) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NBSlu_6200.Merge(m, src)
}
func (m *NBSlu_6200) XXX_Size() int {
	return m.Size()
}
func (m *NBSlu_6200) XXX_DiscardUnknown() {
	xxx_messageInfo_NBSlu_6200.DiscardUnknown(m)
}

var xxx_messageInfo_NBSlu_6200 proto.InternalMessageInfo

func (m *NBSlu_6200) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *NBSlu_6200) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *NBSlu_6200) GetEventsAvailable() []int32 {
	if m != nil {
		return m.EventsAvailable
	}
	return nil
}

func (m *NBSlu_6200) GetEventsReport() []int32 {
	if m != nil {
		return m.EventsReport
	}
	return nil
}

// 读取历史数据
type NBSlu_6100 struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,15,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 起始时间，unix时间戳(下行)
	DtStart int64 `protobuf:"varint,1,opt,name=dt_start,json=dtStart,proto3" json:"dt_start,omitempty"`
	// 结束时间，unix时间戳（下行）
	DtEnd int64 `protobuf:"varint,2,opt,name=dt_end,json=dtEnd,proto3" json:"dt_end,omitempty"`
	// 历史数据 (上行)
	DataRecord []*NBSlu_6100_Data_Record `protobuf:"bytes,3,rep,name=data_record,json=dataRecord,proto3" json:"data_record,omitempty"`
}

func (m *NBSlu_6100) Reset()         { *m = NBSlu_6100{} }
func (m *NBSlu_6100) String() string { return proto.CompactTextString(m) }
func (*NBSlu_6100) ProtoMessage()    {}
func (*NBSlu_6100) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{18}
}
func (m *NBSlu_6100) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NBSlu_6100) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NBSlu_6100.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NBSlu_6100) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NBSlu_6100.Merge(m, src)
}
func (m *NBSlu_6100) XXX_Size() int {
	return m.Size()
}
func (m *NBSlu_6100) XXX_DiscardUnknown() {
	xxx_messageInfo_NBSlu_6100.DiscardUnknown(m)
}

var xxx_messageInfo_NBSlu_6100 proto.InternalMessageInfo

func (m *NBSlu_6100) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *NBSlu_6100) GetDtStart() int64 {
	if m != nil {
		return m.DtStart
	}
	return 0
}

func (m *NBSlu_6100) GetDtEnd() int64 {
	if m != nil {
		return m.DtEnd
	}
	return 0
}

func (m *NBSlu_6100) GetDataRecord() []*NBSlu_6100_Data_Record {
	if m != nil {
		return m.DataRecord
	}
	return nil
}

type NBSlu_6100_Data_Record struct {
	// 记录时间
	DtRecord int64 `protobuf:"varint,1,opt,name=dt_record,json=dtRecord,proto3" json:"dt_record,omitempty"`
	// 电压,2路
	Voltage []float64 `protobuf:"fixed64,2,rep,packed,name=voltage,proto3" json:"voltage,omitempty"`
	// 电流,2路
	Current []float64 `protobuf:"fixed64,3,rep,packed,name=current,proto3" json:"current,omitempty"`
	// 有功功率,2路
	ActivePower []float64 `protobuf:"fixed64,4,rep,packed,name=active_power,json=activePower,proto3" json:"active_power,omitempty"`
	// 功率因数,2路
	PowerFactor []float64 `protobuf:"fixed64,5,rep,packed,name=power_factor,json=powerFactor,proto3" json:"power_factor,omitempty"`
	// 漏电流
	LeakageCurrent float64 `protobuf:"fixed64,6,opt,name=leakage_current,json=leakageCurrent,proto3" json:"leakage_current,omitempty"`
	// 光照度
	Lux float64 `protobuf:"fixed64,7,opt,name=lux,proto3" json:"lux,omitempty"`
	// 信号强度
	Csq int32 `protobuf:"varint,8,opt,name=csq,proto3" json:"csq,omitempty"`
	// 信噪比
	Snr int64 `protobuf:"varint,9,opt,name=snr,proto3" json:"snr,omitempty"`
	// 参考信号接收功率
	Rsrp int64 `protobuf:"varint,10,opt,name=rsrp,proto3" json:"rsrp,omitempty"`
	// 基站小区标识
	Cellid int64 `protobuf:"varint,11,opt,name=cellid,proto3" json:"cellid,omitempty"`
	// 物理小区标识
	Pci int64 `protobuf:"varint,12,opt,name=pci,proto3" json:"pci,omitempty"`
	// 频点
	Earfcn int64 `protobuf:"varint,13,opt,name=earfcn,proto3" json:"earfcn,omitempty"`
	// 设备通讯状态
	StatusCommunication int32 `protobuf:"varint,14,opt,name=status_communication,json=statusCommunication,proto3" json:"status_communication,omitempty"`
}

func (m *NBSlu_6100_Data_Record) Reset()         { *m = NBSlu_6100_Data_Record{} }
func (m *NBSlu_6100_Data_Record) String() string { return proto.CompactTextString(m) }
func (*NBSlu_6100_Data_Record) ProtoMessage()    {}
func (*NBSlu_6100_Data_Record) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{18, 0}
}
func (m *NBSlu_6100_Data_Record) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NBSlu_6100_Data_Record) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NBSlu_6100_Data_Record.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NBSlu_6100_Data_Record) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NBSlu_6100_Data_Record.Merge(m, src)
}
func (m *NBSlu_6100_Data_Record) XXX_Size() int {
	return m.Size()
}
func (m *NBSlu_6100_Data_Record) XXX_DiscardUnknown() {
	xxx_messageInfo_NBSlu_6100_Data_Record.DiscardUnknown(m)
}

var xxx_messageInfo_NBSlu_6100_Data_Record proto.InternalMessageInfo

func (m *NBSlu_6100_Data_Record) GetDtRecord() int64 {
	if m != nil {
		return m.DtRecord
	}
	return 0
}

func (m *NBSlu_6100_Data_Record) GetVoltage() []float64 {
	if m != nil {
		return m.Voltage
	}
	return nil
}

func (m *NBSlu_6100_Data_Record) GetCurrent() []float64 {
	if m != nil {
		return m.Current
	}
	return nil
}

func (m *NBSlu_6100_Data_Record) GetActivePower() []float64 {
	if m != nil {
		return m.ActivePower
	}
	return nil
}

func (m *NBSlu_6100_Data_Record) GetPowerFactor() []float64 {
	if m != nil {
		return m.PowerFactor
	}
	return nil
}

func (m *NBSlu_6100_Data_Record) GetLeakageCurrent() float64 {
	if m != nil {
		return m.LeakageCurrent
	}
	return 0
}

func (m *NBSlu_6100_Data_Record) GetLux() float64 {
	if m != nil {
		return m.Lux
	}
	return 0
}

func (m *NBSlu_6100_Data_Record) GetCsq() int32 {
	if m != nil {
		return m.Csq
	}
	return 0
}

func (m *NBSlu_6100_Data_Record) GetSnr() int64 {
	if m != nil {
		return m.Snr
	}
	return 0
}

func (m *NBSlu_6100_Data_Record) GetRsrp() int64 {
	if m != nil {
		return m.Rsrp
	}
	return 0
}

func (m *NBSlu_6100_Data_Record) GetCellid() int64 {
	if m != nil {
		return m.Cellid
	}
	return 0
}

func (m *NBSlu_6100_Data_Record) GetPci() int64 {
	if m != nil {
		return m.Pci
	}
	return 0
}

func (m *NBSlu_6100_Data_Record) GetEarfcn() int64 {
	if m != nil {
		return m.Earfcn
	}
	return 0
}

func (m *NBSlu_6100_Data_Record) GetStatusCommunication() int32 {
	if m != nil {
		return m.StatusCommunication
	}
	return 0
}

// 读取事件记录
type NBSlu_6400 struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 本次数据数量
	EventsCount int32 `protobuf:"varint,2,opt,name=events_count,json=eventsCount,proto3" json:"events_count,omitempty"`
	// 事件内容
	EventData []*NBSlu_6400_Event_Data `protobuf:"bytes,3,rep,name=event_data,json=eventData,proto3" json:"event_data,omitempty"`
}

func (m *NBSlu_6400) Reset()         { *m = NBSlu_6400{} }
func (m *NBSlu_6400) String() string { return proto.CompactTextString(m) }
func (*NBSlu_6400) ProtoMessage()    {}
func (*NBSlu_6400) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{19}
}
func (m *NBSlu_6400) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NBSlu_6400) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NBSlu_6400.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NBSlu_6400) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NBSlu_6400.Merge(m, src)
}
func (m *NBSlu_6400) XXX_Size() int {
	return m.Size()
}
func (m *NBSlu_6400) XXX_DiscardUnknown() {
	xxx_messageInfo_NBSlu_6400.DiscardUnknown(m)
}

var xxx_messageInfo_NBSlu_6400 proto.InternalMessageInfo

func (m *NBSlu_6400) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *NBSlu_6400) GetEventsCount() int32 {
	if m != nil {
		return m.EventsCount
	}
	return 0
}

func (m *NBSlu_6400) GetEventData() []*NBSlu_6400_Event_Data {
	if m != nil {
		return m.EventData
	}
	return nil
}

// 事件
type NBSlu_6400_Event_Data struct {
	// 事件代码 1-开关/调光，2-意外灭灯，3-意外亮灯，4-自熄灯，5-光源故障，6-补偿电容故障，7-漏电分匝，8-校时，9-远程升级
	EventId int32 `protobuf:"varint,1,opt,name=event_id,json=eventId,proto3" json:"event_id,omitempty"`
	// 事件时间,unix时间戳
	EventTime int64 `protobuf:"varint,2,opt,name=event_time,json=eventTime,proto3" json:"event_time,omitempty"`
	// 事件内容
	EventMsg string `protobuf:"bytes,3,opt,name=event_msg,json=eventMsg,proto3" json:"event_msg,omitempty"`
}

func (m *NBSlu_6400_Event_Data) Reset()         { *m = NBSlu_6400_Event_Data{} }
func (m *NBSlu_6400_Event_Data) String() string { return proto.CompactTextString(m) }
func (*NBSlu_6400_Event_Data) ProtoMessage()    {}
func (*NBSlu_6400_Event_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{19, 0}
}
func (m *NBSlu_6400_Event_Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NBSlu_6400_Event_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NBSlu_6400_Event_Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NBSlu_6400_Event_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NBSlu_6400_Event_Data.Merge(m, src)
}
func (m *NBSlu_6400_Event_Data) XXX_Size() int {
	return m.Size()
}
func (m *NBSlu_6400_Event_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_NBSlu_6400_Event_Data.DiscardUnknown(m)
}

var xxx_messageInfo_NBSlu_6400_Event_Data proto.InternalMessageInfo

func (m *NBSlu_6400_Event_Data) GetEventId() int32 {
	if m != nil {
		return m.EventId
	}
	return 0
}

func (m *NBSlu_6400_Event_Data) GetEventTime() int64 {
	if m != nil {
		return m.EventTime
	}
	return 0
}

func (m *NBSlu_6400_Event_Data) GetEventMsg() string {
	if m != nil {
		return m.EventMsg
	}
	return ""
}

// ascii数据透传
type NBSlu_4C00 struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// ascii 字符串
	Sdata string `protobuf:"bytes,2,opt,name=sdata,proto3" json:"sdata,omitempty"`
}

func (m *NBSlu_4C00) Reset()         { *m = NBSlu_4C00{} }
func (m *NBSlu_4C00) String() string { return proto.CompactTextString(m) }
func (*NBSlu_4C00) ProtoMessage()    {}
func (*NBSlu_4C00) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{20}
}
func (m *NBSlu_4C00) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NBSlu_4C00) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NBSlu_4C00.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NBSlu_4C00) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NBSlu_4C00.Merge(m, src)
}
func (m *NBSlu_4C00) XXX_Size() int {
	return m.Size()
}
func (m *NBSlu_4C00) XXX_DiscardUnknown() {
	xxx_messageInfo_NBSlu_4C00.DiscardUnknown(m)
}

var xxx_messageInfo_NBSlu_4C00 proto.InternalMessageInfo

func (m *NBSlu_4C00) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *NBSlu_4C00) GetSdata() string {
	if m != nil {
		return m.Sdata
	}
	return ""
}

// ota远程升级
type NBSlu_4E00 struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 控制类型 0-停止升级，1-升级开始，2-升级暂停
	CtrlType int32 `protobuf:"varint,2,opt,name=ctrl_type,json=ctrlType,proto3" json:"ctrl_type,omitempty"`
	// 最新版本信息,ascii格式\0结束
	NewVer string `protobuf:"bytes,3,opt,name=new_ver,json=newVer,proto3" json:"new_ver,omitempty"`
}

func (m *NBSlu_4E00) Reset()         { *m = NBSlu_4E00{} }
func (m *NBSlu_4E00) String() string { return proto.CompactTextString(m) }
func (*NBSlu_4E00) ProtoMessage()    {}
func (*NBSlu_4E00) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{21}
}
func (m *NBSlu_4E00) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NBSlu_4E00) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NBSlu_4E00.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NBSlu_4E00) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NBSlu_4E00.Merge(m, src)
}
func (m *NBSlu_4E00) XXX_Size() int {
	return m.Size()
}
func (m *NBSlu_4E00) XXX_DiscardUnknown() {
	xxx_messageInfo_NBSlu_4E00.DiscardUnknown(m)
}

var xxx_messageInfo_NBSlu_4E00 proto.InternalMessageInfo

func (m *NBSlu_4E00) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *NBSlu_4E00) GetCtrlType() int32 {
	if m != nil {
		return m.CtrlType
	}
	return 0
}

func (m *NBSlu_4E00) GetNewVer() string {
	if m != nil {
		return m.NewVer
	}
	return ""
}

// ota升级状态查询/主报
type NBSlu_4F00 struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 状态
	// 0-99 下载进度 0
	// 101 下载完成 0
	// 104 升级超时
	// 207 下载完成,校验失败 0
	// 204 文件头校验错误 0
	// 205 文件内部版本和升级指令中目标版本不一致 0
	// 201 升级成功 0
	// 400 上报版本返回错误 0
	// 401 检查升级任务返回错误 见注 3
	// 402 下载固件返回错误 见注 4
	// 403 上报进度返回错误 0
	// 404 上报下载完毕返回错误 0
	// 405 上报升级成功返回错误 0
	// 406 获取设备 devID 时返回错误
	Status int32 `protobuf:"varint,2,opt,name=status,proto3" json:"status,omitempty"`
	// 原因，对应status
	// status == 104:
	//  20 固件头校验错误
	//  21 固件头部版本和下发的升级指令中版本不一致
	//  其他 返回最新的 oneNET 错误码
	// status == 401:
	//  0 设备存在升级任务,token 值为文件映射路径(设置有效期,详情见设计文档),token有效期 2 天。
	//  1 鉴权失败(当设备不存在时)。
	//  2 请求参数错误。
	//  7 OneNET 内部错误。
	//  8 检测失败,设备存在升级任务,但是因为 manuf 或者 model 不一致,会将任务进入失败状  态。
	//  9 检测失败,设备存在升级任务,但是因为 version 不一致导致任务进入失败状态(差分包  升级才有此流程)。
	//  11 没有检测到升级任务,设备不存 type(fota/sota)对应的升级任务。
	//  27 版本号格式错误(版本号只能包括:[a-zA-Z0-9_\\-.],长度为[1, 20])。
	//  32 存在升级任务,但是没有找到对应的差分包(在设备没有上报版本号,页面新建任务时  使用初始版本:“无版本号”时可能出现该情况)。
	//  5116 套餐不足(自动添加策略配备到升级任务)。
	// status == 402:
	//  1 未找到资源
	//  2 文件大小不一致
	//  3 无效 token
	//  4 获取文件失败
	//  5 请求参数错误
	//  6 NB 基站限制(只有 NB 设备下载会出现这个状态码)
	Reason int32 `protobuf:"varint,3,opt,name=reason,proto3" json:"reason,omitempty"`
	// 升级前版本，ascii码
	OldVer string `protobuf:"bytes,4,opt,name=old_ver,json=oldVer,proto3" json:"old_ver,omitempty"`
	// 升级后版本，ascii码
	NewVer string `protobuf:"bytes,5,opt,name=new_ver,json=newVer,proto3" json:"new_ver,omitempty"`
}

func (m *NBSlu_4F00) Reset()         { *m = NBSlu_4F00{} }
func (m *NBSlu_4F00) String() string { return proto.CompactTextString(m) }
func (*NBSlu_4F00) ProtoMessage()    {}
func (*NBSlu_4F00) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{22}
}
func (m *NBSlu_4F00) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NBSlu_4F00) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NBSlu_4F00.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NBSlu_4F00) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NBSlu_4F00.Merge(m, src)
}
func (m *NBSlu_4F00) XXX_Size() int {
	return m.Size()
}
func (m *NBSlu_4F00) XXX_DiscardUnknown() {
	xxx_messageInfo_NBSlu_4F00.DiscardUnknown(m)
}

var xxx_messageInfo_NBSlu_4F00 proto.InternalMessageInfo

func (m *NBSlu_4F00) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *NBSlu_4F00) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *NBSlu_4F00) GetReason() int32 {
	if m != nil {
		return m.Reason
	}
	return 0
}

func (m *NBSlu_4F00) GetOldVer() string {
	if m != nil {
		return m.OldVer
	}
	return ""
}

func (m *NBSlu_4F00) GetNewVer() string {
	if m != nil {
		return m.NewVer
	}
	return ""
}

func init() {
	proto.RegisterType((*MsgNBiot)(nil), "wlst.nbiot.MsgNBiot")
	proto.RegisterType((*MsgNBOpen)(nil), "wlst.nbiot.MsgNBOpen")
	proto.RegisterType((*SluitemConfig)(nil), "wlst.nbiot.SluitemConfig")
	proto.RegisterType((*SluitemConfig_DataMark)(nil), "wlst.nbiot.SluitemConfig.Data_mark")
	proto.RegisterType((*SluitemConfig_SetMark)(nil), "wlst.nbiot.SluitemConfig.Set_mark")
	proto.RegisterType((*SluitemConfig_SluitemPara)(nil), "wlst.nbiot.SluitemConfig.Sluitem_para")
	proto.RegisterType((*SluitemConfig_SluitemVer)(nil), "wlst.nbiot.SluitemConfig.Sluitem_ver")
	proto.RegisterType((*SluitemConfig_SluitemSunriseset)(nil), "wlst.nbiot.SluitemConfig.Sluitem_sunriseset")
	proto.RegisterType((*SluitemConfig_SluitemRuntime)(nil), "wlst.nbiot.SluitemConfig.Sluitem_runtime")
	proto.RegisterType((*SluitemReply)(nil), "wlst.nbiot.SluitemReply")
	proto.RegisterType((*SluitemData)(nil), "wlst.nbiot.SluitemData")
	proto.RegisterType((*SluitemData_ModelInfo)(nil), "wlst.nbiot.SluitemData.Model_info")
	proto.RegisterType((*SluitemData_LightData)(nil), "wlst.nbiot.SluitemData.Light_data")
	proto.RegisterType((*SluitemData_LightStatus)(nil), "wlst.nbiot.SluitemData.Light_status")
	proto.RegisterType((*SluitemData_SluitemStatus)(nil), "wlst.nbiot.SluitemData.Sluitem_status")
	proto.RegisterType((*SluitemData_TimeFault)(nil), "wlst.nbiot.SluitemData.Time_fault")
	proto.RegisterType((*SluitemData_SluitemPara)(nil), "wlst.nbiot.SluitemData.Sluitem_para")
	proto.RegisterType((*NBSlu_3100)(nil), "wlst.nbiot.NBSlu_3100")
	proto.RegisterType((*NBSlu_3700)(nil), "wlst.nbiot.NBSlu_3700")
	proto.RegisterType((*NBSlu_1400)(nil), "wlst.nbiot.NBSlu_1400")
	proto.RegisterType((*NBSlu_5100)(nil), "wlst.nbiot.NBSlu_5100")
	proto.RegisterType((*NBSlu_5200)(nil), "wlst.nbiot.NBSlu_5200")
	proto.RegisterType((*NBSlu_5400)(nil), "wlst.nbiot.NBSlu_5400")
	proto.RegisterType((*NBSlu_5500)(nil), "wlst.nbiot.NBSlu_5500")
	proto.RegisterType((*NBSlu_5600)(nil), "wlst.nbiot.NBSlu_5600")
	proto.RegisterType((*NBSlu_5600_SluitemRuntime)(nil), "wlst.nbiot.NBSlu_5600.Sluitem_runtime")
	proto.RegisterType((*NBSlu_FF05)(nil), "wlst.nbiot.NBSlu_FF05")
	proto.RegisterType((*NBSlu_FF07)(nil), "wlst.nbiot.NBSlu_FF07")
	proto.RegisterType((*NBSlu_FF01)(nil), "wlst.nbiot.NBSlu_FF01")
	proto.RegisterType((*NBSlu_5800)(nil), "wlst.nbiot.NBSlu_5800")
	proto.RegisterType((*NBSlu_6200)(nil), "wlst.nbiot.NBSlu_6200")
	proto.RegisterType((*NBSlu_6100)(nil), "wlst.nbiot.NBSlu_6100")
	proto.RegisterType((*NBSlu_6100_Data_Record)(nil), "wlst.nbiot.NBSlu_6100.Data_Record")
	proto.RegisterType((*NBSlu_6400)(nil), "wlst.nbiot.NBSlu_6400")
	proto.RegisterType((*NBSlu_6400_Event_Data)(nil), "wlst.nbiot.NBSlu_6400.Event_Data")
	proto.RegisterType((*NBSlu_4C00)(nil), "wlst.nbiot.NBSlu_4C00")
	proto.RegisterType((*NBSlu_4E00)(nil), "wlst.nbiot.NBSlu_4E00")
	proto.RegisterType((*NBSlu_4F00)(nil), "wlst.nbiot.NBSlu_4F00")
}

func init() { proto.RegisterFile("msg_nb.proto", fileDescriptor_7d0ba9a34991f86e) }

var fileDescriptor_7d0ba9a34991f86e = []byte{
	// 3348 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x5a, 0xcd, 0x6f, 0x1c, 0xc7,
	0xb1, 0xd7, 0x72, 0xbf, 0x7b, 0x77, 0x49, 0x6a, 0xf4, 0x35, 0x5a, 0x49, 0x14, 0xb5, 0x7a, 0x92,
	0xf9, 0x9e, 0x6d, 0x61, 0x49, 0x93, 0x4b, 0xc1, 0x86, 0x1f, 0x2c, 0x51, 0xa2, 0x9f, 0x00, 0x49,
	0x34, 0x86, 0x84, 0x2f, 0xc6, 0xc3, 0xbc, 0xe6, 0x4c, 0xef, 0x6a, 0xc0, 0xf9, 0x58, 0xcd, 0xcc,
	0x2e, 0xc5, 0x07, 0xe4, 0x16, 0xc0, 0xb9, 0x04, 0xc8, 0x21, 0xb9, 0x25, 0x7f, 0x44, 0x72, 0xcd,
	0x3f, 0x90, 0x43, 0x0e, 0x3e, 0x1a, 0xc8, 0x25, 0x90, 0x81, 0x00, 0x49, 0x0e, 0x49, 0x90, 0x7b,
	0x10, 0x54, 0x55, 0xf7, 0x7c, 0xec, 0x07, 0x57, 0x71, 0x6e, 0xd3, 0xf5, 0xd1, 0x5d, 0xdd, 0x5d,
	0xf5, 0xeb, 0xaa, 0xda, 0x65, 0x4d, 0x2f, 0x1a, 0x98, 0xfe, 0xf1, 0x83, 0x61, 0x18, 0xc4, 0x81,
	0xc6, 0x4e, 0xdd, 0x28, 0x7e, 0xe0, 0x1f, 0x3b, 0x41, 0xdc, 0xf9, 0x51, 0x81, 0xd5, 0x5e, 0x44,
	0x83, 0x97, 0x8f, 0x9d, 0x20, 0xd6, 0xae, 0xb1, 0xaa, 0xe5, 0xd9, 0xa6, 0x63, 0xbf, 0xd1, 0x0b,
	0xeb, 0x85, 0x8d, 0xa2, 0x51, 0xb1, 0x3c, 0xfb, 0x99, 0xfd, 0x46, 0xbb, 0xce, 0x6a, 0xc0, 0xf0,
	0xb9, 0x27, 0xf4, 0xa5, 0xf5, 0xc2, 0x46, 0xdd, 0x00, 0xc1, 0x97, 0xdc, 0x13, 0x8a, 0xd5, 0x77,
	0xf9, 0x40, 0x2f, 0xae, 0x17, 0x36, 0xca, 0xc8, 0xda, 0x77, 0xf9, 0x40, 0xd3, 0x58, 0xc9, 0xf1,
	0x84, 0xa3, 0x97, 0xd6, 0x8b, 0x1b, 0x45, 0x03, 0xbf, 0x41, 0x3c, 0xe4, 0xa7, 0xa6, 0xcd, 0x63,
	0xae, 0x97, 0xd7, 0x8b, 0x20, 0x1e, 0xf2, 0xd3, 0x27, 0x3c, 0xe6, 0x9d, 0xaf, 0x1b, 0xac, 0x8e,
	0xa6, 0x1c, 0x0c, 0x85, 0x9f, 0x28, 0x93, 0x21, 0xa4, 0x7c, 0x8b, 0x31, 0x3b, 0x36, 0x43, 0x61,
	0x09, 0x67, 0x4c, 0x86, 0x14, 0x8d, 0xba, 0x1d, 0x1b, 0x44, 0xd0, 0x6e, 0xb0, 0x3a, 0xcc, 0x6b,
	0xc6, 0x67, 0x43, 0x21, 0x6d, 0xa9, 0x01, 0xe1, 0xe8, 0x6c, 0x88, 0x76, 0x22, 0xd3, 0xf2, 0x6c,
	0xbd, 0x4e, 0x5b, 0x80, 0xf1, 0x9e, 0x67, 0x6b, 0x1f, 0xb3, 0x66, 0xe4, 0x8e, 0x9c, 0x58, 0x78,
	0x64, 0x17, 0x5b, 0x2f, 0x6c, 0x34, 0xb6, 0xae, 0x3d, 0x48, 0x8f, 0xe9, 0xc1, 0x21, 0xf1, 0xc1,
	0x4e, 0xa3, 0x11, 0xa5, 0x03, 0xed, 0x53, 0xd6, 0x52, 0xba, 0xa1, 0x18, 0xba, 0x67, 0x7a, 0x03,
	0x95, 0xf5, 0x19, 0xca, 0x06, 0xf0, 0x0d, 0xb5, 0x14, 0x8e, 0xb4, 0xcf, 0xd8, 0xb2, 0x52, 0xb7,
	0x02, 0xbf, 0xef, 0x0c, 0xf4, 0x26, 0xea, 0x5f, 0x9f, 0xa1, 0xbf, 0x87, 0x02, 0x86, 0x5a, 0x8f,
	0x86, 0x5a, 0x8f, 0x35, 0xfc, 0x63, 0x33, 0x72, 0x47, 0xe6, 0x47, 0x9b, 0xdd, 0xae, 0xde, 0x42,
	0xf5, 0xab, 0x59, 0xf5, 0x97, 0x8f, 0x0f, 0x25, 0xd7, 0xa8, 0xfb, 0xc7, 0x87, 0xee, 0x08, 0x3e,
	0xb3, 0x7a, 0xbb, 0xdd, 0xae, 0xbe, 0x3c, 0x57, 0x6f, 0x37, 0xd5, 0xdb, 0xcd, 0xe9, 0x6d, 0x6e,
	0x77, 0xbb, 0xfa, 0xca, 0x3c, 0x3d, 0xe0, 0x4a, 0x3d, 0xf8, 0xcc, 0xe8, 0xed, 0x80, 0x9d, 0xab,
	0xf3, 0xf4, 0x76, 0x52, 0x3b, 0x77, 0xa4, 0x9d, 0x2f, 0xa5, 0xde, 0x56, 0xb7, 0xab, 0x5f, 0x9c,
	0xab, 0xb7, 0x05, 0x7a, 0x2f, 0x51, 0x6f, 0x2b, 0xaf, 0x07, 0x76, 0x6a, 0x73, 0xf5, 0xb6, 0x53,
	0xbd, 0xed, 0xbc, 0xde, 0x4e, 0xb7, 0xab, 0x5f, 0x9a, 0xab, 0xb7, 0x93, 0xea, 0xed, 0xe4, 0xf5,
	0x7a, 0xdd, 0xae, 0x7e, 0x79, 0xae, 0x5e, 0x2f, 0xd5, 0xeb, 0x75, 0xbb, 0xe8, 0xb4, 0x62, 0xec,
	0x58, 0xc2, 0x74, 0x6c, 0xfd, 0x0a, 0x3a, 0x66, 0x8d, 0x08, 0xcf, 0x6c, 0x6d, 0x95, 0x15, 0x23,
	0xf1, 0x5a, 0x2f, 0xa1, 0x2f, 0xc3, 0xa7, 0x76, 0x95, 0x55, 0xa2, 0x98, 0xc7, 0xa3, 0x48, 0x2f,
	0x23, 0x51, 0x8e, 0x32, 0xcb, 0xf7, 0xfb, 0xdd, 0x1d, 0xfd, 0xea, 0xbc, 0xe5, 0xf7, 0xf7, 0xbb,
	0x3b, 0x72, 0xf9, 0xfd, 0x7e, 0x77, 0x27, 0xaf, 0xb7, 0xab, 0x5f, 0x3b, 0x47, 0x6f, 0x37, 0xd5,
	0xdb, 0xcd, 0xeb, 0x6d, 0xea, 0xfa, 0x39, 0x7a, 0x9b, 0xa9, 0xde, 0x66, 0x12, 0xa3, 0x88, 0x17,
	0xd7, 0xd3, 0x18, 0x45, 0xc0, 0xc8, 0x9c, 0xe1, 0xc3, 0x6e, 0x57, 0x6f, 0xcf, 0x3d, 0xc3, 0x87,
	0xe9, 0x19, 0x3e, 0xcc, 0x9d, 0x7d, 0x0f, 0x7c, 0xeb, 0xc6, 0x3c, 0xbd, 0xde, 0x66, 0xa2, 0xd7,
	0xcb, 0xfb, 0x56, 0x0f, 0x7c, 0xeb, 0xe6, 0x5c, 0xbd, 0xd4, 0xb7, 0x7a, 0x79, 0xdf, 0xea, 0x81,
	0x6f, 0xdd, 0x9a, 0xab, 0x97, 0xfa, 0x56, 0x2f, 0xef, 0x5b, 0xdb, 0x56, 0xb7, 0xab, 0xaf, 0xcd,
	0xd3, 0xdb, 0xde, 0x4b, 0xf4, 0x40, 0x30, 0xab, 0x27, 0xba, 0x5d, 0xfd, 0xf6, 0x5c, 0xbd, 0xa7,
	0xa9, 0x9e, 0xc8, 0xeb, 0xf5, 0xbb, 0x5d, 0x7d, 0x7d, 0xae, 0xde, 0x7e, 0xaa, 0xd7, 0xef, 0x76,
	0x3b, 0x7f, 0x5d, 0x61, 0xad, 0x1c, 0xe8, 0x4c, 0xbe, 0x0c, 0xe5, 0xe4, 0x65, 0xb8, 0xcd, 0x14,
	0x1c, 0x22, 0x93, 0x30, 0x99, 0x49, 0x12, 0x08, 0x7c, 0x26, 0x2f, 0xdc, 0xe3, 0xe1, 0x09, 0x3a,
	0x72, 0x63, 0xeb, 0xee, 0x5c, 0x70, 0x7b, 0xf0, 0x44, 0x89, 0x92, 0x57, 0xbc, 0xe0, 0xe1, 0x09,
	0xa0, 0xbe, 0x1b, 0x04, 0x43, 0xd3, 0x0a, 0x46, 0x7e, 0x2c, 0xdd, 0xbe, 0x0e, 0x94, 0x3d, 0x20,
	0x68, 0x77, 0x52, 0xf4, 0x8e, 0x1d, 0x4f, 0xe8, 0x55, 0x34, 0x41, 0x59, 0x75, 0xe4, 0x78, 0x42,
	0x7b, 0x96, 0x8a, 0x0c, 0x79, 0xc8, 0xf5, 0x1a, 0x9a, 0x71, 0x7f, 0xbe, 0x19, 0x87, 0x19, 0xe9,
	0x64, 0xaa, 0x2f, 0x78, 0xc8, 0xb5, 0xfd, 0x74, 0xbf, 0x63, 0x11, 0xca, 0xa7, 0xe2, 0xde, 0xe2,
	0x99, 0xc6, 0x22, 0x4c, 0x8e, 0xe5, 0x4b, 0x11, 0x6a, 0x5f, 0x31, 0x4d, 0xcd, 0x13, 0x8d, 0xfc,
	0xd0, 0x89, 0x44, 0x24, 0x62, 0xf9, 0x78, 0x7c, 0xb0, 0x78, 0xba, 0x54, 0xc7, 0xb8, 0x28, 0xe7,
	0x39, 0x4c, 0x48, 0x9a, 0xc1, 0x56, 0x92, 0x47, 0x69, 0xe4, 0xe3, 0xa9, 0x34, 0xd7, 0x8b, 0x1b,
	0x8d, 0xad, 0xff, 0x5c, 0x3c, 0xb3, 0x54, 0x30, 0xd4, 0xbb, 0x64, 0xd0, 0x38, 0x03, 0x3c, 0xcb,
	0x39, 0xe0, 0xf9, 0x94, 0xd5, 0x22, 0x11, 0xd3, 0xf5, 0xd2, 0x63, 0xd0, 0x39, 0x67, 0x11, 0x29,
	0x69, 0x54, 0x23, 0x11, 0xc3, 0xe5, 0xb6, 0x7f, 0x55, 0x60, 0xf5, 0xe4, 0xd2, 0xe1, 0xaa, 0x43,
	0xc1, 0x6d, 0xbc, 0xc8, 0x10, 0x9d, 0xa9, 0x6c, 0xd4, 0x81, 0x02, 0xd7, 0x18, 0x02, 0x78, 0x20,
	0x9b, 0x87, 0x83, 0x48, 0x3d, 0xf0, 0x40, 0x78, 0x14, 0x0e, 0x22, 0xcc, 0x2c, 0x80, 0x09, 0xd7,
	0x42, 0x4e, 0x52, 0x85, 0x31, 0x1c, 0xf6, 0x7b, 0x6c, 0x05, 0x59, 0x99, 0x93, 0xae, 0xa0, 0xc4,
	0x32, 0x90, 0x33, 0x07, 0x77, 0x8f, 0x2d, 0x27, 0xeb, 0xc7, 0xfc, 0xd8, 0x25, 0x6f, 0x2a, 0x1b,
	0x2d, 0x65, 0x03, 0x12, 0xdb, 0x3f, 0x2c, 0xb0, 0x9a, 0xda, 0x0a, 0x18, 0x05, 0x07, 0x40, 0x26,
	0x53, 0x70, 0xc0, 0x89, 0x90, 0xc5, 0xd7, 0xe9, 0x74, 0xd0, 0x60, 0xda, 0x0e, 0xec, 0x1c, 0xed,
	0x95, 0x7a, 0x21, 0x9a, 0x53, 0x4a, 0xf4, 0x0c, 0x34, 0xe4, 0x2e, 0x6b, 0xa9, 0x49, 0xc9, 0x0e,
	0xda, 0x51, 0x53, 0x4e, 0x4c, 0x66, 0xfc, 0x63, 0x89, 0x35, 0xb3, 0x9e, 0x0a, 0xe6, 0x27, 0x4e,
	0x45, 0x77, 0x45, 0x6b, 0xaa, 0x94, 0xe1, 0x90, 0xae, 0xac, 0xcb, 0x2e, 0x2b, 0x31, 0xe1, 0xc3,
	0x4c, 0x26, 0x77, 0x79, 0xe8, 0xc9, 0x13, 0x55, 0x7e, 0xf9, 0x14, 0x59, 0x8f, 0x80, 0xa3, 0x6d,
	0xa7, 0x1a, 0xc3, 0xe0, 0x54, 0x84, 0x66, 0x3c, 0x0a, 0xfd, 0xc0, 0xc7, 0xcc, 0xae, 0xfc, 0x78,
	0x69, 0xb5, 0x90, 0x68, 0x7d, 0x01, 0xec, 0x23, 0xe4, 0x6a, 0x37, 0x59, 0xdd, 0x0d, 0xfc, 0x81,
	0x13, 0x8f, 0x6c, 0x81, 0x07, 0x5e, 0x30, 0x52, 0x82, 0xd6, 0x66, 0x35, 0x97, 0xc7, 0xc4, 0xac,
	0x22, 0x33, 0x19, 0x6b, 0x77, 0x59, 0x23, 0xe4, 0xb1, 0xb0, 0x69, 0x35, 0xbd, 0x96, 0x2c, 0xc3,
	0x90, 0x8c, 0x8b, 0x40, 0xe0, 0x8f, 0x86, 0xae, 0xe3, 0x9f, 0xc8, 0xb3, 0xaf, 0xa3, 0xf9, 0x0d,
	0xa2, 0xd1, 0xf1, 0xa7, 0x22, 0x94, 0x9c, 0xb1, 0xac, 0x08, 0x65, 0x60, 0x1f, 0xb3, 0x6b, 0x69,
	0x02, 0x37, 0x16, 0x61, 0x24, 0x4c, 0xdb, 0xf1, 0x3c, 0xc7, 0x1f, 0x60, 0xcc, 0xd0, 0xb2, 0x57,
	0x92, 0xa4, 0x0d, 0x25, 0x9e, 0x90, 0x40, 0xfb, 0xa7, 0x4b, 0xac, 0x91, 0x09, 0xf0, 0x2c, 0x14,
	0x01, 0x3e, 0x49, 0x6f, 0x50, 0x80, 0xf1, 0x3c, 0x08, 0x86, 0x70, 0xb1, 0xc2, 0x17, 0xe1, 0xe0,
	0xcc, 0x8c, 0xf8, 0x18, 0x16, 0xa1, 0x1b, 0x6a, 0x12, 0xf1, 0x10, 0x69, 0x5a, 0x8f, 0x5d, 0x13,
	0xae, 0xb0, 0xe2, 0xd0, 0xb1, 0x4c, 0x57, 0xf0, 0x13, 0x3e, 0x10, 0xa6, 0x17, 0xd8, 0x23, 0x57,
	0xa5, 0xb5, 0x57, 0x14, 0xfb, 0x39, 0x71, 0x5f, 0x20, 0x53, 0xfb, 0x90, 0x69, 0xb1, 0xf0, 0x86,
	0x22, 0xe4, 0xf1, 0x28, 0x4c, 0x54, 0xc8, 0xb7, 0x2e, 0x66, 0x38, 0x52, 0xfc, 0x0e, 0x6b, 0xe2,
	0xc9, 0x29, 0x41, 0xf2, 0xb1, 0x06, 0xd2, 0x52, 0x91, 0x04, 0x5c, 0x21, 0xab, 0xae, 0x60, 0x82,
	0x92, 0x80, 0x2b, 0x24, 0xd6, 0xab, 0xac, 0x08, 0x21, 0x57, 0x45, 0x0e, 0x7c, 0xb6, 0xf7, 0x99,
	0x36, 0x8d, 0x53, 0x9a, 0xce, 0xaa, 0x72, 0x24, 0xcf, 0x45, 0x0d, 0x11, 0x5a, 0x46, 0x3e, 0x84,
	0xc1, 0x92, 0x84, 0x16, 0x1c, 0xb5, 0xff, 0xb8, 0xc4, 0x56, 0x26, 0x60, 0x29, 0x9f, 0xe3, 0x17,
	0x26, 0x72, 0xfc, 0xdb, 0xac, 0x11, 0x8c, 0xe2, 0xe1, 0x28, 0x26, 0x36, 0xcd, 0xc6, 0x88, 0x84,
	0x02, 0x77, 0x58, 0x33, 0xc0, 0x43, 0x10, 0xd9, 0x22, 0xa1, 0x21, 0x69, 0x28, 0x72, 0x97, 0x35,
	0x6c, 0xe0, 0x53, 0x64, 0x64, 0x3c, 0x9c, 0x01, 0x99, 0x82, 0x22, 0x37, 0x0f, 0xa0, 0x6b, 0x39,
	0x3f, 0x0f, 0x18, 0x7a, 0x8f, 0x2d, 0x2b, 0x91, 0xa0, 0xdf, 0x4f, 0x21, 0xa7, 0x25, 0xa9, 0x07,
	0x48, 0xd4, 0xde, 0x63, 0xad, 0x50, 0xb8, 0xfc, 0xcc, 0x94, 0x64, 0xbd, 0x9a, 0x2c, 0xd8, 0x44,
	0xc6, 0x01, 0xd1, 0xb5, 0x5b, 0xac, 0x36, 0x3c, 0x95, 0x7e, 0x95, 0xc6, 0x43, 0x75, 0x78, 0x4a,
	0x7e, 0x75, 0x83, 0xd5, 0x81, 0x4d, 0xf1, 0x42, 0x91, 0x00, 0xf2, 0x49, 0xa4, 0x00, 0xf3, 0x98,
	0x8f, 0x6c, 0x5c, 0x43, 0x86, 0xc1, 0xf0, 0xd4, 0x7b, 0x2c, 0x49, 0x9d, 0xfb, 0x09, 0x94, 0x50,
	0x58, 0xa4, 0x70, 0x5f, 0xc8, 0xc2, 0x7d, 0xe7, 0xdb, 0x95, 0xc4, 0xe5, 0xb1, 0xfe, 0x99, 0x9b,
	0x18, 0x3c, 0x62, 0xcc, 0x0b, 0x6c, 0xe1, 0x9a, 0x8e, 0xdf, 0x0f, 0xf0, 0x2a, 0x66, 0xbf, 0x0c,
	0x30, 0xcb, 0x83, 0x17, 0x89, 0xa4, 0x51, 0x47, 0xad, 0x67, 0x7e, 0x3f, 0x80, 0x29, 0x5c, 0x67,
	0xf0, 0x2a, 0xa6, 0xaa, 0xac, 0x88, 0x2f, 0xd8, 0xdc, 0x29, 0x9e, 0x27, 0x92, 0x46, 0x1d, 0xb5,
	0xd0, 0xbc, 0xf7, 0xd8, 0x8a, 0x0a, 0x20, 0x6b, 0x14, 0x86, 0xc2, 0x27, 0xa8, 0x2d, 0x18, 0xcb,
	0x92, 0xbc, 0x47, 0x54, 0xed, 0xc5, 0x14, 0x74, 0x96, 0xe7, 0x26, 0x09, 0xb8, 0xde, 0x61, 0x4e,
	0x7a, 0x12, 0x62, 0x1f, 0x31, 0x06, 0x8e, 0x61, 0xf6, 0xf9, 0xc8, 0xa5, 0x9b, 0x3f, 0xc7, 0xf4,
	0xa3, 0x44, 0xd2, 0xa8, 0x83, 0xd6, 0x3e, 0x7c, 0x82, 0x33, 0xe3, 0xdb, 0x20, 0xf3, 0x1e, 0x7a,
	0x88, 0x18, 0x92, 0x28, 0xf1, 0xa1, 0x50, 0x90, 0x1e, 0x58, 0xc3, 0xac, 0x07, 0x42, 0x81, 0xdc,
	0xef, 0xf3, 0x89, 0x94, 0xa7, 0x8e, 0x26, 0xfc, 0xc7, 0xa2, 0xdd, 0x4c, 0x27, 0x3c, 0x1a, 0x2b,
	0x85, 0x51, 0x38, 0x44, 0x9f, 0x29, 0x1a, 0xf8, 0x4d, 0xb4, 0xc8, 0xc1, 0x74, 0x05, 0x69, 0x91,
	0x83, 0xa5, 0x8a, 0x1f, 0x62, 0xf9, 0x5a, 0x34, 0xe0, 0x13, 0x28, 0x43, 0xcb, 0xc1, 0x8a, 0xb4,
	0x68, 0xc0, 0xa7, 0x9c, 0xeb, 0x35, 0x66, 0x10, 0x34, 0xd7, 0x6b, 0x80, 0x85, 0xf8, 0x0d, 0xb9,
	0xed, 0x0a, 0x92, 0xd5, 0x10, 0x5c, 0x50, 0xf0, 0xb0, 0x6f, 0xf9, 0x58, 0x2c, 0x16, 0x0d, 0x39,
	0x82, 0x79, 0x85, 0xe5, 0x62, 0x25, 0x58, 0x36, 0xe0, 0x13, 0x28, 0x56, 0xf4, 0x1a, 0x6b, 0xbc,
	0xb2, 0x01, 0x9f, 0xda, 0x65, 0x56, 0x0e, 0x45, 0x14, 0xf8, 0x58, 0xbf, 0x95, 0x0d, 0x1a, 0x10,
	0x35, 0x0e, 0xcf, 0xb0, 0x3a, 0x43, 0x6a, 0x1c, 0x9e, 0x65, 0x81, 0xe9, 0xca, 0x3c, 0x60, 0xba,
	0x9a, 0x03, 0xa6, 0x1f, 0x2f, 0x31, 0x96, 0xba, 0xec, 0xbb, 0xc0, 0x3e, 0x44, 0x20, 0x3e, 0x9c,
	0x39, 0xd4, 0x6f, 0x20, 0x4d, 0x82, 0xfe, 0x6d, 0xd6, 0x78, 0xc5, 0x23, 0x85, 0xf7, 0x12, 0x9a,
	0xd8, 0x2b, 0x1e, 0x49, 0x8c, 0x07, 0x5f, 0x06, 0x81, 0x0c, 0x8e, 0x4b, 0x68, 0x5f, 0x7e, 0xc5,
	0xa3, 0xa3, 0x94, 0x0a, 0x8e, 0x81, 0x82, 0xf8, 0x2a, 0x12, 0x34, 0xd5, 0x40, 0x04, 0x9f, 0xc4,
	0xcb, 0xac, 0x8c, 0x11, 0x26, 0xe1, 0x88, 0x06, 0x53, 0x38, 0x5f, 0x9d, 0xc6, 0xf9, 0xeb, 0xac,
	0x36, 0x8a, 0x84, 0x02, 0x20, 0x3c, 0xa7, 0x51, 0x24, 0x60, 0x77, 0xed, 0x5f, 0x16, 0x19, 0x4b,
	0xe3, 0x0f, 0x0e, 0x74, 0x1c, 0xb8, 0x31, 0xec, 0xa2, 0x80, 0xc1, 0xa6, 0x86, 0xc0, 0x51, 0x61,
	0xb8, 0x44, 0x1c, 0x39, 0x04, 0x03, 0xb8, 0x15, 0x3b, 0x63, 0x21, 0x21, 0xac, 0x88, 0xec, 0x06,
	0xd1, 0x08, 0xc5, 0x28, 0x39, 0xcb, 0x0a, 0x51, 0x28, 0xb7, 0x14, 0x35, 0x11, 0xe3, 0xc3, 0x21,
	0x87, 0x59, 0xa5, 0x58, 0x99, 0xc4, 0x14, 0x95, 0xc4, 0xd6, 0x59, 0x43, 0x3d, 0xa2, 0x4e, 0x7c,
	0x26, 0xd3, 0x93, 0x2c, 0x09, 0x2e, 0x44, 0xae, 0x96, 0xd4, 0x15, 0x05, 0x83, 0x11, 0x49, 0xc5,
	0x18, 0xe1, 0x93, 0x44, 0x8c, 0xda, 0xf9, 0x31, 0xf6, 0x3c, 0x23, 0x6b, 0x34, 0x50, 0x53, 0xa2,
	0xc5, 0x6d, 0x46, 0x9e, 0x60, 0xba, 0x62, 0x2c, 0x5c, 0x09, 0xdf, 0x0c, 0x49, 0xcf, 0x81, 0x92,
	0xcd, 0xd8, 0x72, 0xf9, 0x17, 0xcb, 0x65, 0x6c, 0xd9, 0xdc, 0xeb, 0x76, 0x3e, 0x83, 0x6a, 0x48,
	0xf4, 0x48, 0xb2, 0xa7, 0xf6, 0xff, 0xb2, 0x66, 0xd6, 0x20, 0xb8, 0x1a, 0xe5, 0x7a, 0xf2, 0x79,
	0x96, 0x43, 0xf0, 0x18, 0x82, 0x31, 0x72, 0x5a, 0x1a, 0x40, 0xaa, 0x7e, 0x1a, 0x84, 0x27, 0x8e,
	0x3f, 0x30, 0x03, 0x5f, 0x7a, 0x6b, 0x5d, 0x52, 0x0e, 0xfc, 0xf6, 0x11, 0x5b, 0xce, 0x23, 0x24,
	0x58, 0xd4, 0x77, 0x79, 0xf4, 0x4a, 0x62, 0x22, 0x2d, 0xc2, 0x90, 0x44, 0x80, 0x77, 0x87, 0x35,
	0x73, 0xe9, 0xa8, 0x8c, 0x11, 0x91, 0xe6, 0xa1, 0xed, 0x1f, 0x30, 0x96, 0x82, 0x25, 0xcc, 0x68,
	0xb9, 0x81, 0x75, 0x92, 0x9f, 0x11, 0x49, 0x34, 0xe3, 0x7d, 0xb6, 0x42, 0x02, 0xc1, 0x28, 0x36,
	0xb3, 0x7b, 0x68, 0x21, 0xf9, 0x60, 0x14, 0xcf, 0x90, 0xcb, 0xe6, 0xc2, 0x89, 0x1c, 0x2d, 0xff,
	0xbb, 0xc2, 0x44, 0xc2, 0x9d, 0xcb, 0x70, 0x0b, 0xe7, 0x65, 0xb8, 0x4b, 0x13, 0x19, 0xee, 0x06,
	0x5b, 0x85, 0x18, 0x9d, 0x91, 0x7f, 0x43, 0x34, 0x67, 0x73, 0xef, 0x5b, 0x8c, 0x39, 0x11, 0xe4,
	0x3f, 0x3e, 0x00, 0x07, 0x45, 0x7c, 0xdd, 0x89, 0x0c, 0x22, 0xa0, 0xbb, 0x83, 0x9c, 0xe9, 0xf8,
	0xb1, 0x08, 0xc7, 0xdc, 0x95, 0x11, 0xdf, 0x42, 0xea, 0x33, 0x49, 0x9c, 0xca, 0x84, 0x2b, 0x53,
	0x99, 0x70, 0xe7, 0x4f, 0x45, 0xc6, 0xd2, 0x5e, 0xe1, 0xfc, 0x97, 0x7d, 0x95, 0x15, 0xf9, 0xd0,
	0x97, 0x7d, 0x60, 0xf8, 0x04, 0xc0, 0x19, 0x45, 0x22, 0xa4, 0xfe, 0x70, 0x91, 0x7a, 0x58, 0x40,
	0xc0, 0x06, 0x71, 0x9b, 0xd5, 0x86, 0x3c, 0x8a, 0x4e, 0x83, 0xd0, 0x46, 0xeb, 0xeb, 0x46, 0x32,
	0x06, 0x9e, 0xcc, 0x7b, 0x12, 0xa0, 0x52, 0x63, 0xed, 0x0e, 0x63, 0xce, 0xd0, 0xe4, 0xb6, 0x1d,
	0x8a, 0x28, 0xd2, 0x2b, 0x49, 0xca, 0x53, 0x77, 0x86, 0x8f, 0x88, 0x08, 0xea, 0xb1, 0x70, 0xc5,
	0x30, 0x08, 0xd5, 0xfb, 0x98, 0x8c, 0xe9, 0x6a, 0x2c, 0xee, 0x22, 0xb3, 0xa6, 0x9a, 0x06, 0x92,
	0x00, 0x87, 0x3a, 0x4e, 0x4a, 0x07, 0x19, 0x70, 0xf5, 0xb1, 0x2a, 0x1c, 0xb4, 0x2d, 0x76, 0x65,
	0x10, 0x06, 0xa3, 0xa1, 0xc9, 0x2d, 0x4b, 0x44, 0x51, 0x7a, 0xb6, 0x14, 0x70, 0x97, 0x90, 0xf9,
	0x08, 0x79, 0xc9, 0x09, 0x7f, 0xc0, 0x34, 0xd2, 0x91, 0xed, 0x3c, 0x7a, 0xb6, 0x29, 0xf0, 0x56,
	0x91, 0xf3, 0x04, 0x19, 0xf4, 0x78, 0x6f, 0xb0, 0x55, 0x8f, 0xbf, 0xc9, 0xcb, 0x36, 0xe9, 0xfe,
	0x3d, 0xfe, 0x26, 0x2b, 0xa9, 0x1a, 0xe1, 0x2d, 0x3c, 0x3b, 0x6a, 0x84, 0x23, 0x2d, 0x72, 0xf0,
	0x21, 0x45, 0x5a, 0xe4, 0x40, 0x98, 0x3a, 0x96, 0xe5, 0xd8, 0xf8, 0x8c, 0xd6, 0x0d, 0x1a, 0x64,
	0xf2, 0xb8, 0xd5, 0x5c, 0x1e, 0xf7, 0x8b, 0x42, 0x72, 0xd9, 0xbb, 0xe7, 0x5d, 0xb6, 0x5a, 0x7d,
	0x69, 0xc6, 0xea, 0xc5, 0x59, 0xab, 0x97, 0xb2, 0xab, 0x6b, 0xac, 0x74, 0xcc, 0x7d, 0x5b, 0xde,
	0x2d, 0x7e, 0x27, 0x09, 0x45, 0x25, 0x93, 0x50, 0xc8, 0xe4, 0xa1, 0x9a, 0x24, 0x0f, 0x9d, 0x58,
	0x99, 0x87, 0xcd, 0xe3, 0xb9, 0xe6, 0x4d, 0x36, 0x7f, 0x96, 0xa6, 0x9b, 0x3f, 0x1a, 0x2b, 0x9d,
	0x0a, 0x71, 0x22, 0xa3, 0x0b, 0xbf, 0x33, 0xa7, 0x52, 0xca, 0x9d, 0xca, 0x81, 0x5a, 0x75, 0x67,
	0x51, 0x04, 0x8c, 0x65, 0x7f, 0x82, 0x4a, 0x9e, 0xcc, 0x84, 0xc5, 0xdc, 0x84, 0x7f, 0x4e, 0x62,
	0x0a, 0x9b, 0xd2, 0x73, 0x67, 0xcc, 0x01, 0xc9, 0xd2, 0x79, 0x40, 0x52, 0x9c, 0x00, 0x92, 0xe9,
	0x9a, 0xbf, 0x34, 0xab, 0xe6, 0x9f, 0x57, 0xc1, 0x97, 0xcf, 0xad, 0xe0, 0xe7, 0x75, 0x0a, 0x2a,
	0x73, 0x3b, 0x05, 0x13, 0x95, 0x7b, 0xf5, 0x9d, 0x2a, 0xf7, 0xda, 0xe2, 0xca, 0xbd, 0x3e, 0x5d,
	0xb9, 0x67, 0x13, 0x12, 0x96, 0x4b, 0x48, 0x32, 0xd7, 0xd1, 0xc8, 0x35, 0xab, 0xfe, 0x8d, 0x62,
	0x1f, 0x2c, 0x0a, 0x85, 0x15, 0x84, 0xaa, 0x3b, 0xd5, 0x22, 0x8b, 0x88, 0x86, 0x46, 0x77, 0xfe,
	0x90, 0x04, 0xd5, 0xce, 0xb9, 0x5e, 0xbb, 0xb0, 0x4e, 0x9d, 0xaa, 0x0a, 0x8b, 0xef, 0x50, 0x15,
	0x96, 0x16, 0x54, 0x85, 0xe5, 0x05, 0x55, 0x61, 0x65, 0xaa, 0x2a, 0xcc, 0x9c, 0x63, 0x35, 0xe7,
	0xd6, 0x7f, 0x4f, 0x37, 0xba, 0xb3, 0x20, 0x50, 0x3c, 0x6b, 0x24, 0x37, 0x08, 0x9f, 0xe0, 0xae,
	0x8e, 0xef, 0xc4, 0x0e, 0x77, 0x9d, 0xff, 0x17, 0x26, 0x30, 0xe5, 0x4b, 0x9b, 0x52, 0x5f, 0x4c,
	0x89, 0x85, 0xdc, 0x53, 0x5e, 0x9d, 0x52, 0x0d, 0xee, 0x69, 0xef, 0xb3, 0x8b, 0x19, 0x31, 0x21,
	0x86, 0x61, 0xe0, 0xc9, 0x7d, 0xae, 0xa6, 0x8c, 0xa7, 0x48, 0x87, 0xfc, 0x39, 0x2b, 0xec, 0x0a,
	0x4b, 0x75, 0x01, 0x33, 0xa2, 0xae, 0xb0, 0xe6, 0xee, 0xfa, 0x6d, 0x29, 0xd9, 0x75, 0xef, 0xbc,
	0x5d, 0xff, 0x17, 0xbb, 0x68, 0xb9, 0x82, 0x87, 0x66, 0xe0, 0xda, 0x49, 0x03, 0x96, 0xce, 0x60,
	0x05, 0x19, 0x07, 0xae, 0xad, 0xda, 0xaa, 0x77, 0x59, 0x8b, 0x7e, 0x96, 0x0c, 0xfc, 0xd8, 0xf1,
	0x47, 0x2a, 0xef, 0x6f, 0xe2, 0x6f, 0x93, 0x92, 0x06, 0xcf, 0xd1, 0x44, 0x3f, 0x57, 0xbe, 0x18,
	0x74, 0x28, 0x97, 0xf2, 0xad, 0x5a, 0x7a, 0x36, 0x0e, 0xa6, 0x7b, 0xc0, 0x65, 0xac, 0xa0, 0xef,
	0xcf, 0xfe, 0x4d, 0xea, 0x5f, 0x68, 0x00, 0x57, 0xb2, 0xa7, 0xd2, 0xfe, 0xed, 0x8c, 0x2e, 0xcd,
	0x84, 0x83, 0x17, 0x16, 0x36, 0x62, 0x96, 0x16, 0x36, 0x62, 0x8a, 0xef, 0xd4, 0x88, 0x29, 0xbd,
	0x4b, 0x23, 0xa6, 0xfc, 0x4e, 0x8d, 0x98, 0xca, 0x3b, 0x84, 0x5c, 0x75, 0x41, 0xc8, 0xd5, 0x16,
	0x84, 0x5c, 0x7d, 0xba, 0x11, 0xb3, 0xa6, 0x7c, 0x6c, 0x7f, 0xbf, 0xbb, 0xa3, 0x5e, 0x9a, 0x42,
	0xf2, 0xd2, 0x74, 0xfe, 0x2f, 0xc3, 0xdf, 0x85, 0xcd, 0x81, 0xa7, 0x0c, 0xb9, 0x75, 0x62, 0xc6,
	0x41, 0xcc, 0x5d, 0x79, 0xd6, 0x2d, 0x45, 0x3d, 0x02, 0xa2, 0xf6, 0x3e, 0x5b, 0x49, 0xc4, 0x92,
	0xce, 0xb0, 0x32, 0x3d, 0x99, 0x81, 0x9e, 0x8a, 0xce, 0x7f, 0x67, 0x56, 0xd8, 0x04, 0x2f, 0x07,
	0x37, 0x4e, 0xad, 0xa8, 0x04, 0x2e, 0x36, 0xd5, 0xaf, 0xb1, 0xaa, 0x2f, 0x4e, 0xcd, 0xf4, 0x21,
	0xac, 0xf8, 0xe2, 0xf4, 0x4b, 0x11, 0x76, 0xfe, 0x96, 0x82, 0xc3, 0xc3, 0xf3, 0xc2, 0x24, 0x75,
	0xa8, 0xa5, 0x1c, 0x48, 0x43, 0xdd, 0x85, 0x19, 0xad, 0x0d, 0xc7, 0xae, 0x0a, 0x61, 0x24, 0x3d,
	0x01, 0x4a, 0x2a, 0xe0, 0x3a, 0x9e, 0xa3, 0x82, 0x80, 0x04, 0x9e, 0x03, 0x05, 0xee, 0x20, 0x18,
	0xc6, 0x52, 0x3f, 0xc9, 0x2b, 0x63, 0xd2, 0x96, 0x4c, 0xd2, 0xad, 0x24, 0x4c, 0xd2, 0xbc, 0xce,
	0x6a, 0x96, 0x25, 0x1f, 0xb9, 0xaa, 0xfc, 0x37, 0x83, 0x45, 0x2f, 0xdb, 0x0d, 0x56, 0xb7, 0x2c,
	0xd3, 0x0f, 0x42, 0x8f, 0xbb, 0xea, 0x62, 0x2d, 0xeb, 0x25, 0x8e, 0x3b, 0x3f, 0x4b, 0xf6, 0xdc,
	0xdb, 0xfa, 0x3e, 0x7b, 0xfe, 0x90, 0xad, 0x8a, 0xb1, 0xf0, 0xe3, 0xc8, 0xe4, 0x63, 0xee, 0xb8,
	0x13, 0x1e, 0xbf, 0x42, 0xbc, 0x47, 0x8a, 0x05, 0xce, 0x2a, 0xc5, 0x43, 0xca, 0x7e, 0x53, 0xec,
	0x6f, 0x12, 0xc3, 0x40, 0x7a, 0xe7, 0xd7, 0x09, 0x64, 0xf5, 0x26, 0x32, 0x9a, 0x95, 0x9c, 0x5d,
	0xd7, 0x59, 0xcd, 0xc6, 0x52, 0x30, 0x8c, 0xe5, 0x3f, 0x2e, 0xaa, 0x36, 0x54, 0xa7, 0x61, 0xac,
	0x5d, 0x61, 0x15, 0x3b, 0x36, 0x85, 0x6f, 0xcb, 0xe4, 0xaa, 0x6c, 0xc7, 0x4f, 0x7d, 0x5b, 0xdb,
	0xc3, 0xf0, 0xe4, 0x26, 0xbd, 0x7f, 0xb3, 0xba, 0x73, 0xe9, 0xba, 0xf4, 0xb3, 0x9e, 0x81, 0x92,
	0x18, 0xbe, 0x9c, 0xbe, 0xdb, 0x3f, 0x2f, 0xb2, 0x46, 0x86, 0x87, 0x2d, 0xad, 0x58, 0x4d, 0x59,
	0x90, 0x2d, 0xad, 0x58, 0x32, 0x6f, 0xa6, 0x6d, 0x05, 0x70, 0xde, 0x02, 0xc5, 0x9d, 0x6a, 0x2d,
	0xdc, 0x4c, 0x5b, 0x0b, 0xc5, 0x94, 0xab, 0xda, 0x0b, 0xf7, 0x26, 0xda, 0x0b, 0xa5, 0x44, 0x64,
	0xa2, 0xc5, 0x20, 0xdb, 0x34, 0x7d, 0x6e, 0xc5, 0x41, 0x88, 0x88, 0x29, 0xc5, 0x90, 0xbe, 0x8f,
	0xe4, 0x59, 0x5d, 0xc5, 0xca, 0xcc, 0xae, 0xe2, 0x2a, 0x2b, 0xba, 0xa3, 0x37, 0xb2, 0x75, 0x00,
	0x9f, 0xaa, 0x55, 0x55, 0x4b, 0x5b, 0x55, 0x32, 0xf7, 0xad, 0xa7, 0x8d, 0xb3, 0x59, 0x2d, 0xb7,
	0xab, 0xac, 0x62, 0x09, 0xd7, 0x75, 0x6c, 0xd9, 0x74, 0x93, 0x23, 0xd5, 0x64, 0x6b, 0xa6, 0x4d,
	0xb6, 0xb4, 0x6d, 0xd6, 0xca, 0xb5, 0xcd, 0x36, 0xd9, 0x65, 0x72, 0x36, 0xd3, 0x0a, 0x3c, 0x6f,
	0xe4, 0x3b, 0x16, 0x8f, 0x9d, 0xc0, 0x97, 0x3f, 0xe7, 0x5d, 0x22, 0xde, 0x5e, 0x96, 0xd5, 0xf9,
	0x4b, 0xea, 0xd5, 0x8b, 0xb2, 0x70, 0xe9, 0x8e, 0xf4, 0x2c, 0xa9, 0xca, 0x1d, 0x69, 0xf4, 0x1c,
	0x7d, 0xc6, 0x18, 0x0e, 0xb3, 0xbd, 0xdc, 0x3b, 0xb3, 0x7f, 0x31, 0x7f, 0xf0, 0x14, 0x05, 0xf1,
	0xbf, 0x36, 0x75, 0x54, 0x82, 0xcf, 0xb6, 0xc5, 0x58, 0xca, 0x00, 0x87, 0xa5, 0xf9, 0x1c, 0x5b,
	0xf5, 0x2b, 0x70, 0xfc, 0xcc, 0x86, 0xda, 0x8e, 0x58, 0x99, 0x8a, 0x80, 0xe6, 0x39, 0x92, 0xbf,
	0x20, 0x10, 0xdb, 0x8b, 0x06, 0xaa, 0x58, 0x45, 0xc2, 0x8b, 0x68, 0xd0, 0xf9, 0x44, 0x6d, 0x78,
	0x7b, 0xef, 0xbc, 0x0d, 0x5f, 0x66, 0xe5, 0x08, 0x37, 0x42, 0xc8, 0x47, 0x83, 0xce, 0x57, 0x89,
	0xf2, 0xd3, 0xf3, 0x94, 0x01, 0x48, 0xe2, 0xd0, 0xcd, 0x3e, 0x7c, 0x35, 0x20, 0xe0, 0xab, 0x97,
	0x41, 0xd5, 0x62, 0x0e, 0x55, 0xbf, 0x4e, 0xee, 0x62, 0x7b, 0xff, 0xfb, 0x20, 0xcc, 0x55, 0x56,
	0x09, 0x05, 0x8f, 0x92, 0x5e, 0x8d, 0x1c, 0x65, 0xf1, 0xbd, 0x34, 0x0f, 0xdf, 0xcb, 0x59, 0x4b,
	0xb6, 0x3e, 0x67, 0xb5, 0x97, 0x8f, 0x9f, 0x05, 0x47, 0x7b, 0xb1, 0xab, 0x7d, 0xc2, 0xea, 0xf8,
	0xfd, 0xd4, 0x7a, 0x15, 0x68, 0x57, 0xb2, 0xf7, 0x99, 0xfc, 0x93, 0xab, 0x3d, 0x9b, 0xdc, 0xb9,
	0xf0, 0xb8, 0xfd, 0x9b, 0xb7, 0x6b, 0x85, 0x6f, 0xde, 0xae, 0x15, 0x7e, 0xff, 0x76, 0xad, 0xf0,
	0x93, 0xef, 0xd6, 0x2e, 0x7c, 0xf3, 0xdd, 0xda, 0x85, 0x6f, 0xbf, 0x5b, 0xbb, 0xf0, 0x3f, 0x85,
	0xe3, 0x0a, 0xfe, 0x55, 0xed, 0xa3, 0x7f, 0x06, 0x00, 0x00, 0xff, 0xff, 0xf9, 0xc1, 0x61, 0xae,
	0xba, 0x26, 0x00, 0x00,
}

func (m *MsgNBiot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgNBiot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgNBiot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RawData) > 0 {
		dAtA2 := make([]byte, len(m.RawData)*10)
		var j1 int
		for _, num1 := range m.RawData {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintMsgNb(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Imei) > 0 {
		dAtA4 := make([]byte, len(m.Imei)*10)
		var j3 int
		for _, num1 := range m.Imei {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintMsgNb(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x22
	}
	if m.CmdFlag != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.CmdFlag))
		i--
		dAtA[i] = 0x18
	}
	if len(m.CmdName) > 0 {
		i -= len(m.CmdName)
		copy(dAtA[i:], m.CmdName)
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.CmdName)))
		i--
		dAtA[i] = 0x12
	}
	if m.CmdIdx != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgNBOpen) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgNBOpen) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgNBOpen) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NbSlu_4F00 != nil {
		{
			size, err := m.NbSlu_4F00.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	if m.NbSlu_4E00 != nil {
		{
			size, err := m.NbSlu_4E00.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	if m.NbSlu_4C00 != nil {
		{
			size, err := m.NbSlu_4C00.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if m.NbSlu_6400 != nil {
		{
			size, err := m.NbSlu_6400.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	if m.NbSlu_6200 != nil {
		{
			size, err := m.NbSlu_6200.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if m.NbSlu_6100 != nil {
		{
			size, err := m.NbSlu_6100.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if m.NbSlu_5800 != nil {
		{
			size, err := m.NbSlu_5800.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if m.DataFlag != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.DataFlag))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.NbSluFf01 != nil {
		{
			size, err := m.NbSluFf01.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.NbSluFf07 != nil {
		{
			size, err := m.NbSluFf07.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.NbSluFf05 != nil {
		{
			size, err := m.NbSluFf05.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if len(m.DeviceId) > 0 {
		i -= len(m.DeviceId)
		copy(dAtA[i:], m.DeviceId)
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.DeviceId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.NbSlu_5600 != nil {
		{
			size, err := m.NbSlu_5600.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.NbSlu_5500 != nil {
		{
			size, err := m.NbSlu_5500.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.NbSlu_5400 != nil {
		{
			size, err := m.NbSlu_5400.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.NbSlu_5200 != nil {
		{
			size, err := m.NbSlu_5200.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.NbSlu_5100 != nil {
		{
			size, err := m.NbSlu_5100.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.NbSlu_1400 != nil {
		{
			size, err := m.NbSlu_1400.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.NbSlu_3700 != nil {
		{
			size, err := m.NbSlu_3700.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.NbSlu_3100 != nil {
		{
			size, err := m.NbSlu_3100.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.SluitemConfig != nil {
		{
			size, err := m.SluitemConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.SluitemReply != nil {
		{
			size, err := m.SluitemReply.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.SluitemData != nil {
		{
			size, err := m.SluitemData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.DataCmd) > 0 {
		i -= len(m.DataCmd)
		copy(dAtA[i:], m.DataCmd)
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.DataCmd)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Status != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x28
	}
	if m.Seq != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x20
	}
	if m.DataType != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.DataType))
		i--
		dAtA[i] = 0x18
	}
	if m.DtReceive != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.DtReceive))
		i--
		dAtA[i] = 0x10
	}
	if m.Imei != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Imei))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SluitemConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SluitemConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SluitemConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SetMark != nil {
		{
			size, err := m.SetMark.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.Status != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x70
	}
	if len(m.SluitemRuntime) > 0 {
		for iNdEx := len(m.SluitemRuntime) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SluitemRuntime[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsgNb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if m.SluitemSunriseset != nil {
		{
			size, err := m.SluitemSunriseset.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.SluitemVer != nil {
		{
			size, err := m.SluitemVer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.SluitemPara != nil {
		{
			size, err := m.SluitemPara.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.SluitemTime != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.SluitemTime))
		i--
		dAtA[i] = 0x38
	}
	if m.LoopCount != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.LoopCount))
		i--
		dAtA[i] = 0x28
	}
	if m.DataMark != nil {
		{
			size, err := m.DataMark.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.SluitemIdx != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.SluitemIdx))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SluitemConfig_DataMark) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SluitemConfig_DataMark) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SluitemConfig_DataMark) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReadTimetable != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.ReadTimetable))
		i--
		dAtA[i] = 0x38
	}
	if m.ReadSunriseset != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.ReadSunriseset))
		i--
		dAtA[i] = 0x30
	}
	if m.ReadVer != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.ReadVer))
		i--
		dAtA[i] = 0x28
	}
	if m.ReadArgs != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.ReadArgs))
		i--
		dAtA[i] = 0x18
	}
	if m.ReadTimer != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.ReadTimer))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *SluitemConfig_SetMark) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SluitemConfig_SetMark) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SluitemConfig_SetMark) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SetTimetable != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.SetTimetable))
		i--
		dAtA[i] = 0x28
	}
	if m.SetReset != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.SetReset))
		i--
		dAtA[i] = 0x20
	}
	if m.SetArgs != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.SetArgs))
		i--
		dAtA[i] = 0x10
	}
	if m.SetTimer != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.SetTimer))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SluitemConfig_SluitemPara) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SluitemConfig_SluitemPara) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SluitemConfig_SluitemPara) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SluitemReverseDimming) > 0 {
		dAtA32 := make([]byte, len(m.SluitemReverseDimming)*10)
		var j31 int
		for _, num1 := range m.SluitemReverseDimming {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA32[j31] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j31++
			}
			dAtA32[j31] = uint8(num)
			j31++
		}
		i -= j31
		copy(dAtA[i:], dAtA32[:j31])
		i = encodeVarintMsgNb(dAtA, i, uint64(j31))
		i--
		dAtA[i] = 0x62
	}
	if m.UplinkReply != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.UplinkReply))
		i--
		dAtA[i] = 0x50
	}
	if m.UplinkTimer != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.UplinkTimer))
		i--
		dAtA[i] = 0x48
	}
	if len(m.RatedPower) > 0 {
		dAtA34 := make([]byte, len(m.RatedPower)*10)
		var j33 int
		for _, num1 := range m.RatedPower {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA34[j33] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j33++
			}
			dAtA34[j33] = uint8(num)
			j33++
		}
		i -= j33
		copy(dAtA[i:], dAtA34[:j33])
		i = encodeVarintMsgNb(dAtA, i, uint64(j33))
		i--
		dAtA[i] = 0x42
	}
	if m.Latitude != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Latitude))))
		i--
		dAtA[i] = 0x39
	}
	if m.Longitude != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Longitude))))
		i--
		dAtA[i] = 0x31
	}
	if len(m.SluitemPowerTurnon) > 0 {
		dAtA36 := make([]byte, len(m.SluitemPowerTurnon)*10)
		var j35 int
		for _, num1 := range m.SluitemPowerTurnon {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA36[j35] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j35++
			}
			dAtA36[j35] = uint8(num)
			j35++
		}
		i -= j35
		copy(dAtA[i:], dAtA36[:j35])
		i = encodeVarintMsgNb(dAtA, i, uint64(j35))
		i--
		dAtA[i] = 0x22
	}
	if m.SluitemEnableAlarm != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.SluitemEnableAlarm))
		i--
		dAtA[i] = 0x18
	}
	if m.SluitemStatus != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.SluitemStatus))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *SluitemConfig_SluitemVer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SluitemConfig_SluitemVer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SluitemConfig_SluitemVer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ver) > 0 {
		i -= len(m.Ver)
		copy(dAtA[i:], m.Ver)
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.Ver)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.SluitemType) > 0 {
		i -= len(m.SluitemType)
		copy(dAtA[i:], m.SluitemType)
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.SluitemType)))
		i--
		dAtA[i] = 0x32
	}
	if m.TimerModule != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.TimerModule))
		i--
		dAtA[i] = 0x28
	}
	if m.TemperatureModule != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.TemperatureModule))
		i--
		dAtA[i] = 0x20
	}
	if m.ElectricLeakageModule != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.ElectricLeakageModule))
		i--
		dAtA[i] = 0x18
	}
	if m.EnergySaving != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.EnergySaving))
		i--
		dAtA[i] = 0x10
	}
	if m.SluitemLoop != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.SluitemLoop))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SluitemConfig_SluitemSunriseset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SluitemConfig_SluitemSunriseset) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SluitemConfig_SluitemSunriseset) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sunset != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Sunset))
		i--
		dAtA[i] = 0x10
	}
	if m.Sunrise != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Sunrise))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SluitemConfig_SluitemRuntime) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SluitemConfig_SluitemRuntime) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SluitemConfig_SluitemRuntime) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PwmBaudrate != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.PwmBaudrate))
		i--
		dAtA[i] = 0x50
	}
	if m.PwmPower != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.PwmPower))
		i--
		dAtA[i] = 0x48
	}
	if len(m.PwmLoop) > 0 {
		dAtA38 := make([]byte, len(m.PwmLoop)*10)
		var j37 int
		for _, num1 := range m.PwmLoop {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA38[j37] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j37++
			}
			dAtA38[j37] = uint8(num)
			j37++
		}
		i -= j37
		copy(dAtA[i:], dAtA38[:j37])
		i = encodeVarintMsgNb(dAtA, i, uint64(j37))
		i--
		dAtA[i] = 0x42
	}
	if len(m.RelayOperate) > 0 {
		dAtA40 := make([]byte, len(m.RelayOperate)*10)
		var j39 int
		for _, num1 := range m.RelayOperate {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA40[j39] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j39++
			}
			dAtA40[j39] = uint8(num)
			j39++
		}
		i -= j39
		copy(dAtA[i:], dAtA40[:j39])
		i = encodeVarintMsgNb(dAtA, i, uint64(j39))
		i--
		dAtA[i] = 0x3a
	}
	if m.OperateOffset != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.OperateOffset))
		i--
		dAtA[i] = 0x30
	}
	if m.OperateTime != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.OperateTime))
		i--
		dAtA[i] = 0x28
	}
	if len(m.DateEnable) > 0 {
		dAtA42 := make([]byte, len(m.DateEnable)*10)
		var j41 int
		for _, num1 := range m.DateEnable {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA42[j41] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j41++
			}
			dAtA42[j41] = uint8(num)
			j41++
		}
		i -= j41
		copy(dAtA[i:], dAtA42[:j41])
		i = encodeVarintMsgNb(dAtA, i, uint64(j41))
		i--
		dAtA[i] = 0x22
	}
	if m.OperateType != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.OperateType))
		i--
		dAtA[i] = 0x18
	}
	if m.OutputType != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.OutputType))
		i--
		dAtA[i] = 0x10
	}
	if m.DataType != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.DataType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SluitemReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SluitemReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SluitemReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SluitemData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SluitemData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SluitemData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sunset != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Sunset))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.Sunrise != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Sunrise))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.Retry != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Retry))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.Reson != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Reson))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.Csq != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Csq))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.Ecl != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Ecl))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.Earfcn != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Earfcn))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.Txpower != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Txpower))
		i--
		dAtA[i] = 0x78
	}
	if m.Rsrq != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Rsrq))
		i--
		dAtA[i] = 0x70
	}
	if m.Pci != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Pci))
		i--
		dAtA[i] = 0x68
	}
	if m.Snr != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Snr))
		i--
		dAtA[i] = 0x60
	}
	if m.Rssi != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Rssi))
		i--
		dAtA[i] = 0x58
	}
	if m.Rsrp != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Rsrp))
		i--
		dAtA[i] = 0x50
	}
	if m.SluitemPara != nil {
		{
			size, err := m.SluitemPara.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.DateTime != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.DateTime))
		i--
		dAtA[i] = 0x40
	}
	if m.ResetCount != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.ResetCount))
		i--
		dAtA[i] = 0x38
	}
	if m.TimeFault != nil {
		{
			size, err := m.TimeFault.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.SluitemStatus != nil {
		{
			size, err := m.SluitemStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.LeakageCurrent != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.LeakageCurrent))))
		i--
		dAtA[i] = 0x21
	}
	if len(m.LightData) > 0 {
		for iNdEx := len(m.LightData) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LightData[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsgNb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.ModelInfo != nil {
		{
			size, err := m.ModelInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.CmdIdx != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SluitemData_ModelInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SluitemData_ModelInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SluitemData_ModelInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UseLoop != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.UseLoop))
		i--
		dAtA[i] = 0x40
	}
	if len(m.SluitemType) > 0 {
		i -= len(m.SluitemType)
		copy(dAtA[i:], m.SluitemType)
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.SluitemType)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Model != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Model))
		i--
		dAtA[i] = 0x30
	}
	if m.HasTimer != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.HasTimer))
		i--
		dAtA[i] = 0x28
	}
	if m.HasTemperature != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.HasTemperature))
		i--
		dAtA[i] = 0x20
	}
	if m.HasLeakage != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.HasLeakage))
		i--
		dAtA[i] = 0x18
	}
	if m.PowerSaving != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.PowerSaving))
		i--
		dAtA[i] = 0x10
	}
	if m.SluitemLoop != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.SluitemLoop))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SluitemData_LightData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SluitemData_LightData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SluitemData_LightData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RatedPower != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.RatedPower))
		i--
		dAtA[i] = 0x58
	}
	if m.SluitemPowerTurnon != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.SluitemPowerTurnon))
		i--
		dAtA[i] = 0x50
	}
	if m.PowerLevel != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.PowerLevel))
		i--
		dAtA[i] = 0x48
	}
	if m.LightStatus != nil {
		{
			size, err := m.LightStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.ActiveTime != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ActiveTime))))
		i--
		dAtA[i] = 0x39
	}
	if m.Electricity != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Electricity))))
		i--
		dAtA[i] = 0x31
	}
	if m.ApparentPower != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ApparentPower))))
		i--
		dAtA[i] = 0x29
	}
	if m.ReactivePower != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ReactivePower))))
		i--
		dAtA[i] = 0x21
	}
	if m.ActivePower != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ActivePower))))
		i--
		dAtA[i] = 0x19
	}
	if m.Current != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Current))))
		i--
		dAtA[i] = 0x11
	}
	if m.Voltage != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Voltage))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *SluitemData_LightStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SluitemData_LightStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SluitemData_LightStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WorkingOn != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.WorkingOn))
		i--
		dAtA[i] = 0x18
	}
	if m.Fault != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Fault))
		i--
		dAtA[i] = 0x10
	}
	if m.Leakage != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Leakage))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SluitemData_SluitemStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SluitemData_SluitemStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SluitemData_SluitemStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EnableAlarm != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.EnableAlarm))
		i--
		dAtA[i] = 0x10
	}
	if m.FlashFault != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.FlashFault))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SluitemData_TimeFault) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SluitemData_TimeFault) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SluitemData_TimeFault) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ClockOutAlarm != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.ClockOutAlarm))
		i--
		dAtA[i] = 0x18
	}
	if m.ClockOutFault != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.ClockOutFault))
		i--
		dAtA[i] = 0x10
	}
	if m.ClockFault != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.ClockFault))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SluitemData_SluitemPara) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SluitemData_SluitemPara) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SluitemData_SluitemPara) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UplinkReply != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.UplinkReply))
		i--
		dAtA[i] = 0x30
	}
	if m.AlarmInterval != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.AlarmInterval))
		i--
		dAtA[i] = 0x28
	}
	if m.IsRunning != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.IsRunning))
		i--
		dAtA[i] = 0x20
	}
	if m.HasEnableAlarm != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.HasEnableAlarm))
		i--
		dAtA[i] = 0x18
	}
	if m.Latitude != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Latitude))))
		i--
		dAtA[i] = 0x11
	}
	if m.Longitude != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Longitude))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *NBSlu_3100) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NBSlu_3100) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NBSlu_3100) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if len(m.Iccid) > 0 {
		i -= len(m.Iccid)
		copy(dAtA[i:], m.Iccid)
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.Iccid)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.Imsi) > 0 {
		i -= len(m.Imsi)
		copy(dAtA[i:], m.Imsi)
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.Imsi)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.Imei) > 0 {
		i -= len(m.Imei)
		copy(dAtA[i:], m.Imei)
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.Imei)))
		i--
		dAtA[i] = 0x6a
	}
	if m.MaxDeviceCount != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.MaxDeviceCount))
		i--
		dAtA[i] = 0x60
	}
	if m.GroupDeviceCount != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.GroupDeviceCount))
		i--
		dAtA[i] = 0x58
	}
	if m.GroupAccessInterval != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.GroupAccessInterval))
		i--
		dAtA[i] = 0x50
	}
	if m.VlinkTime != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.VlinkTime))
		i--
		dAtA[i] = 0x48
	}
	if m.Localport != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Localport))
		i--
		dAtA[i] = 0x40
	}
	if m.Teleport != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Teleport))
		i--
		dAtA[i] = 0x38
	}
	if len(m.IpAddress) > 0 {
		dAtA49 := make([]byte, len(m.IpAddress)*10)
		var j48 int
		for _, num1 := range m.IpAddress {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA49[j48] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j48++
			}
			dAtA49[j48] = uint8(num)
			j48++
		}
		i -= j48
		copy(dAtA[i:], dAtA49[:j48])
		i = encodeVarintMsgNb(dAtA, i, uint64(j48))
		i--
		dAtA[i] = 0x32
	}
	if m.Operater != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Operater))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Password) > 0 {
		i -= len(m.Password)
		copy(dAtA[i:], m.Password)
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.Password)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.UserName) > 0 {
		i -= len(m.UserName)
		copy(dAtA[i:], m.UserName)
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.UserName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Apn) > 0 {
		i -= len(m.Apn)
		copy(dAtA[i:], m.Apn)
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.Apn)))
		i--
		dAtA[i] = 0x12
	}
	if m.CmdIdx != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NBSlu_3700) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NBSlu_3700) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NBSlu_3700) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Snr != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Snr))
		i--
		dAtA[i] = 0x38
	}
	if m.Rsrp != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Rsrp))
		i--
		dAtA[i] = 0x30
	}
	if m.Band != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Band))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Iccid) > 0 {
		i -= len(m.Iccid)
		copy(dAtA[i:], m.Iccid)
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.Iccid)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Imsi) > 0 {
		i -= len(m.Imsi)
		copy(dAtA[i:], m.Imsi)
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.Imsi)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Imei) > 0 {
		i -= len(m.Imei)
		copy(dAtA[i:], m.Imei)
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.Imei)))
		i--
		dAtA[i] = 0x12
	}
	if m.CmdIdx != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NBSlu_1400) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NBSlu_1400) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NBSlu_1400) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x20
	}
	if m.Week != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Week))
		i--
		dAtA[i] = 0x18
	}
	if m.SluitemTime != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.SluitemTime))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NBSlu_5100) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NBSlu_5100) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NBSlu_5100) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Ver) > 0 {
		i -= len(m.Ver)
		copy(dAtA[i:], m.Ver)
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.Ver)))
		i--
		dAtA[i] = 0x12
	}
	if m.CmdIdx != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NBSlu_5200) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NBSlu_5200) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NBSlu_5200) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RecordTimer != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.RecordTimer))
		i--
		dAtA[i] = 0x68
	}
	if len(m.SluitemReverseDimming) > 0 {
		dAtA51 := make([]byte, len(m.SluitemReverseDimming)*10)
		var j50 int
		for _, num1 := range m.SluitemReverseDimming {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA51[j50] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j50++
			}
			dAtA51[j50] = uint8(num)
			j50++
		}
		i -= j50
		copy(dAtA[i:], dAtA51[:j50])
		i = encodeVarintMsgNb(dAtA, i, uint64(j50))
		i--
		dAtA[i] = 0x62
	}
	if m.Status != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x58
	}
	if m.UseLoop != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.UseLoop))
		i--
		dAtA[i] = 0x50
	}
	if m.UplinkReply != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.UplinkReply))
		i--
		dAtA[i] = 0x48
	}
	if m.UplinkTimer != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.UplinkTimer))
		i--
		dAtA[i] = 0x40
	}
	if len(m.RatedPower) > 0 {
		dAtA53 := make([]byte, len(m.RatedPower)*10)
		var j52 int
		for _, num1 := range m.RatedPower {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA53[j52] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j52++
			}
			dAtA53[j52] = uint8(num)
			j52++
		}
		i -= j52
		copy(dAtA[i:], dAtA53[:j52])
		i = encodeVarintMsgNb(dAtA, i, uint64(j52))
		i--
		dAtA[i] = 0x3a
	}
	if m.SluitemEnableAlarm != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.SluitemEnableAlarm))
		i--
		dAtA[i] = 0x30
	}
	if len(m.SluitemPowerTurnon) > 0 {
		dAtA55 := make([]byte, len(m.SluitemPowerTurnon)*10)
		var j54 int
		for _, num1 := range m.SluitemPowerTurnon {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA55[j54] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j54++
			}
			dAtA55[j54] = uint8(num)
			j54++
		}
		i -= j54
		copy(dAtA[i:], dAtA55[:j54])
		i = encodeVarintMsgNb(dAtA, i, uint64(j54))
		i--
		dAtA[i] = 0x2a
	}
	if m.SluitemStatus != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.SluitemStatus))
		i--
		dAtA[i] = 0x20
	}
	if m.Latitude != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Latitude))))
		i--
		dAtA[i] = 0x19
	}
	if m.Longitude != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Longitude))))
		i--
		dAtA[i] = 0x11
	}
	if m.CmdIdx != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NBSlu_5400) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NBSlu_5400) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NBSlu_5400) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x38
	}
	if m.PwmBaudrate != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.PwmBaudrate))
		i--
		dAtA[i] = 0x30
	}
	if m.PwmPower != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.PwmPower))
		i--
		dAtA[i] = 0x28
	}
	if len(m.PwmLoop) > 0 {
		dAtA57 := make([]byte, len(m.PwmLoop)*10)
		var j56 int
		for _, num1 := range m.PwmLoop {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA57[j56] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j56++
			}
			dAtA57[j56] = uint8(num)
			j56++
		}
		i -= j56
		copy(dAtA[i:], dAtA57[:j56])
		i = encodeVarintMsgNb(dAtA, i, uint64(j56))
		i--
		dAtA[i] = 0x22
	}
	if len(m.RelayOperate) > 0 {
		dAtA59 := make([]byte, len(m.RelayOperate)*10)
		var j58 int
		for _, num1 := range m.RelayOperate {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA59[j58] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j58++
			}
			dAtA59[j58] = uint8(num)
			j58++
		}
		i -= j58
		copy(dAtA[i:], dAtA59[:j58])
		i = encodeVarintMsgNb(dAtA, i, uint64(j58))
		i--
		dAtA[i] = 0x1a
	}
	if m.OutputType != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.OutputType))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NBSlu_5500) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NBSlu_5500) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NBSlu_5500) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x38
	}
	if m.InitializeElec != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.InitializeElec))
		i--
		dAtA[i] = 0x30
	}
	if m.InitializeEeprom != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.InitializeEeprom))
		i--
		dAtA[i] = 0x28
	}
	if m.InitializeRam != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.InitializeRam))
		i--
		dAtA[i] = 0x20
	}
	if m.InitializeMcu != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.InitializeMcu))
		i--
		dAtA[i] = 0x18
	}
	if m.Mcu != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Mcu))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NBSlu_5600) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NBSlu_5600) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NBSlu_5600) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x30
	}
	if len(m.SluitemRuntime) > 0 {
		for iNdEx := len(m.SluitemRuntime) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SluitemRuntime[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsgNb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.SluitemRuntimeCount != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.SluitemRuntimeCount))
		i--
		dAtA[i] = 0x20
	}
	if m.DataContinue != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.DataContinue))
		i--
		dAtA[i] = 0x18
	}
	if m.ClearOldRuntime != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.ClearOldRuntime))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NBSlu_5600_SluitemRuntime) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NBSlu_5600_SluitemRuntime) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NBSlu_5600_SluitemRuntime) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PwmBaudrate != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.PwmBaudrate))
		i--
		dAtA[i] = 0x48
	}
	if m.PwmPower != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.PwmPower))
		i--
		dAtA[i] = 0x40
	}
	if len(m.PwmLoop) > 0 {
		dAtA61 := make([]byte, len(m.PwmLoop)*10)
		var j60 int
		for _, num1 := range m.PwmLoop {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA61[j60] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j60++
			}
			dAtA61[j60] = uint8(num)
			j60++
		}
		i -= j60
		copy(dAtA[i:], dAtA61[:j60])
		i = encodeVarintMsgNb(dAtA, i, uint64(j60))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.RelayOperate) > 0 {
		dAtA63 := make([]byte, len(m.RelayOperate)*10)
		var j62 int
		for _, num1 := range m.RelayOperate {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA63[j62] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j62++
			}
			dAtA63[j62] = uint8(num)
			j62++
		}
		i -= j62
		copy(dAtA[i:], dAtA63[:j62])
		i = encodeVarintMsgNb(dAtA, i, uint64(j62))
		i--
		dAtA[i] = 0x32
	}
	if m.OperateOffset != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.OperateOffset))
		i--
		dAtA[i] = 0x28
	}
	if m.OperateTime != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.OperateTime))
		i--
		dAtA[i] = 0x20
	}
	if len(m.DateEnable) > 0 {
		dAtA65 := make([]byte, len(m.DateEnable)*10)
		var j64 int
		for _, num1 := range m.DateEnable {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA65[j64] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j64++
			}
			dAtA65[j64] = uint8(num)
			j64++
		}
		i -= j64
		copy(dAtA[i:], dAtA65[:j64])
		i = encodeVarintMsgNb(dAtA, i, uint64(j64))
		i--
		dAtA[i] = 0x1a
	}
	if m.OperateType != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.OperateType))
		i--
		dAtA[i] = 0x10
	}
	if m.OutputType != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.OutputType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NBSlu_FF05) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NBSlu_FF05) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NBSlu_FF05) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ver) > 0 {
		i -= len(m.Ver)
		copy(dAtA[i:], m.Ver)
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.Ver)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NBSlu_FF07) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NBSlu_FF07) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NBSlu_FF07) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DatapackStatus) > 0 {
		dAtA67 := make([]byte, len(m.DatapackStatus)*10)
		var j66 int
		for _, num1 := range m.DatapackStatus {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA67[j66] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j66++
			}
			dAtA67[j66] = uint8(num)
			j66++
		}
		i -= j66
		copy(dAtA[i:], dAtA67[:j66])
		i = encodeVarintMsgNb(dAtA, i, uint64(j66))
		i--
		dAtA[i] = 0x12
	}
	if m.DatapackTotal != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.DatapackTotal))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NBSlu_FF01) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NBSlu_FF01) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NBSlu_FF01) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewVer) > 0 {
		i -= len(m.NewVer)
		copy(dAtA[i:], m.NewVer)
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.NewVer)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.OldVer) > 0 {
		i -= len(m.OldVer)
		copy(dAtA[i:], m.OldVer)
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.OldVer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NBSlu_5800) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NBSlu_5800) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NBSlu_5800) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CcNormal != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.CcNormal))
		i--
		dAtA[i] = 0x40
	}
	if m.CcAlarm != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.CcAlarm))
		i--
		dAtA[i] = 0x38
	}
	if m.OptLimit != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.OptLimit))
		i--
		dAtA[i] = 0x30
	}
	if m.OptDelay != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.OptDelay))
		i--
		dAtA[i] = 0x28
	}
	if m.AlarmLimit != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.AlarmLimit))
		i--
		dAtA[i] = 0x20
	}
	if m.AlarmDelay != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.AlarmDelay))
		i--
		dAtA[i] = 0x18
	}
	if m.Status != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NBSlu_6200) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NBSlu_6200) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NBSlu_6200) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EventsReport) > 0 {
		dAtA69 := make([]byte, len(m.EventsReport)*10)
		var j68 int
		for _, num1 := range m.EventsReport {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA69[j68] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j68++
			}
			dAtA69[j68] = uint8(num)
			j68++
		}
		i -= j68
		copy(dAtA[i:], dAtA69[:j68])
		i = encodeVarintMsgNb(dAtA, i, uint64(j68))
		i--
		dAtA[i] = 0x22
	}
	if len(m.EventsAvailable) > 0 {
		dAtA71 := make([]byte, len(m.EventsAvailable)*10)
		var j70 int
		for _, num1 := range m.EventsAvailable {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA71[j70] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j70++
			}
			dAtA71[j70] = uint8(num)
			j70++
		}
		i -= j70
		copy(dAtA[i:], dAtA71[:j70])
		i = encodeVarintMsgNb(dAtA, i, uint64(j70))
		i--
		dAtA[i] = 0x1a
	}
	if m.Status != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NBSlu_6100) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NBSlu_6100) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NBSlu_6100) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CmdIdx != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x78
	}
	if len(m.DataRecord) > 0 {
		for iNdEx := len(m.DataRecord) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DataRecord[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsgNb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.DtEnd != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.DtEnd))
		i--
		dAtA[i] = 0x10
	}
	if m.DtStart != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.DtStart))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NBSlu_6100_Data_Record) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NBSlu_6100_Data_Record) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NBSlu_6100_Data_Record) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StatusCommunication != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.StatusCommunication))
		i--
		dAtA[i] = 0x70
	}
	if m.Earfcn != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Earfcn))
		i--
		dAtA[i] = 0x68
	}
	if m.Pci != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Pci))
		i--
		dAtA[i] = 0x60
	}
	if m.Cellid != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Cellid))
		i--
		dAtA[i] = 0x58
	}
	if m.Rsrp != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Rsrp))
		i--
		dAtA[i] = 0x50
	}
	if m.Snr != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Snr))
		i--
		dAtA[i] = 0x48
	}
	if m.Csq != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Csq))
		i--
		dAtA[i] = 0x40
	}
	if m.Lux != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Lux))))
		i--
		dAtA[i] = 0x39
	}
	if m.LeakageCurrent != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.LeakageCurrent))))
		i--
		dAtA[i] = 0x31
	}
	if len(m.PowerFactor) > 0 {
		for iNdEx := len(m.PowerFactor) - 1; iNdEx >= 0; iNdEx-- {
			f72 := math.Float64bits(float64(m.PowerFactor[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f72))
		}
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.PowerFactor)*8))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ActivePower) > 0 {
		for iNdEx := len(m.ActivePower) - 1; iNdEx >= 0; iNdEx-- {
			f73 := math.Float64bits(float64(m.ActivePower[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f73))
		}
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.ActivePower)*8))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Current) > 0 {
		for iNdEx := len(m.Current) - 1; iNdEx >= 0; iNdEx-- {
			f74 := math.Float64bits(float64(m.Current[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f74))
		}
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.Current)*8))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Voltage) > 0 {
		for iNdEx := len(m.Voltage) - 1; iNdEx >= 0; iNdEx-- {
			f75 := math.Float64bits(float64(m.Voltage[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f75))
		}
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.Voltage)*8))
		i--
		dAtA[i] = 0x12
	}
	if m.DtRecord != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.DtRecord))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NBSlu_6400) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NBSlu_6400) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NBSlu_6400) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EventData) > 0 {
		for iNdEx := len(m.EventData) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EventData[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsgNb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.EventsCount != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.EventsCount))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NBSlu_6400_Event_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NBSlu_6400_Event_Data) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NBSlu_6400_Event_Data) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EventMsg) > 0 {
		i -= len(m.EventMsg)
		copy(dAtA[i:], m.EventMsg)
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.EventMsg)))
		i--
		dAtA[i] = 0x1a
	}
	if m.EventTime != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.EventTime))
		i--
		dAtA[i] = 0x10
	}
	if m.EventId != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.EventId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NBSlu_4C00) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NBSlu_4C00) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NBSlu_4C00) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sdata) > 0 {
		i -= len(m.Sdata)
		copy(dAtA[i:], m.Sdata)
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.Sdata)))
		i--
		dAtA[i] = 0x12
	}
	if m.CmdIdx != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NBSlu_4E00) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NBSlu_4E00) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NBSlu_4E00) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewVer) > 0 {
		i -= len(m.NewVer)
		copy(dAtA[i:], m.NewVer)
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.NewVer)))
		i--
		dAtA[i] = 0x1a
	}
	if m.CtrlType != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.CtrlType))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NBSlu_4F00) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NBSlu_4F00) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NBSlu_4F00) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewVer) > 0 {
		i -= len(m.NewVer)
		copy(dAtA[i:], m.NewVer)
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.NewVer)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.OldVer) > 0 {
		i -= len(m.OldVer)
		copy(dAtA[i:], m.OldVer)
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.OldVer)))
		i--
		dAtA[i] = 0x22
	}
	if m.Reason != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Reason))
		i--
		dAtA[i] = 0x18
	}
	if m.Status != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintMsgNb(dAtA []byte, offset int, v uint64) int {
	offset -= sovMsgNb(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgNBiot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovMsgNb(uint64(m.CmdIdx))
	}
	l = len(m.CmdName)
	if l > 0 {
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.CmdFlag != 0 {
		n += 1 + sovMsgNb(uint64(m.CmdFlag))
	}
	if len(m.Imei) > 0 {
		l = 0
		for _, e := range m.Imei {
			l += sovMsgNb(uint64(e))
		}
		n += 1 + sovMsgNb(uint64(l)) + l
	}
	if len(m.RawData) > 0 {
		l = 0
		for _, e := range m.RawData {
			l += sovMsgNb(uint64(e))
		}
		n += 1 + sovMsgNb(uint64(l)) + l
	}
	return n
}

func (m *MsgNBOpen) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Imei != 0 {
		n += 1 + sovMsgNb(uint64(m.Imei))
	}
	if m.DtReceive != 0 {
		n += 1 + sovMsgNb(uint64(m.DtReceive))
	}
	if m.DataType != 0 {
		n += 1 + sovMsgNb(uint64(m.DataType))
	}
	if m.Seq != 0 {
		n += 1 + sovMsgNb(uint64(m.Seq))
	}
	if m.Status != 0 {
		n += 1 + sovMsgNb(uint64(m.Status))
	}
	l = len(m.DataCmd)
	if l > 0 {
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.SluitemData != nil {
		l = m.SluitemData.Size()
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.SluitemReply != nil {
		l = m.SluitemReply.Size()
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.SluitemConfig != nil {
		l = m.SluitemConfig.Size()
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.NbSlu_3100 != nil {
		l = m.NbSlu_3100.Size()
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.NbSlu_3700 != nil {
		l = m.NbSlu_3700.Size()
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.NbSlu_1400 != nil {
		l = m.NbSlu_1400.Size()
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.NbSlu_5100 != nil {
		l = m.NbSlu_5100.Size()
		n += 2 + l + sovMsgNb(uint64(l))
	}
	if m.NbSlu_5200 != nil {
		l = m.NbSlu_5200.Size()
		n += 2 + l + sovMsgNb(uint64(l))
	}
	if m.NbSlu_5400 != nil {
		l = m.NbSlu_5400.Size()
		n += 2 + l + sovMsgNb(uint64(l))
	}
	if m.NbSlu_5500 != nil {
		l = m.NbSlu_5500.Size()
		n += 2 + l + sovMsgNb(uint64(l))
	}
	if m.NbSlu_5600 != nil {
		l = m.NbSlu_5600.Size()
		n += 2 + l + sovMsgNb(uint64(l))
	}
	l = len(m.DeviceId)
	if l > 0 {
		n += 2 + l + sovMsgNb(uint64(l))
	}
	if m.NbSluFf05 != nil {
		l = m.NbSluFf05.Size()
		n += 2 + l + sovMsgNb(uint64(l))
	}
	if m.NbSluFf07 != nil {
		l = m.NbSluFf07.Size()
		n += 2 + l + sovMsgNb(uint64(l))
	}
	if m.NbSluFf01 != nil {
		l = m.NbSluFf01.Size()
		n += 2 + l + sovMsgNb(uint64(l))
	}
	if m.DataFlag != 0 {
		n += 2 + sovMsgNb(uint64(m.DataFlag))
	}
	if m.NbSlu_5800 != nil {
		l = m.NbSlu_5800.Size()
		n += 2 + l + sovMsgNb(uint64(l))
	}
	if m.NbSlu_6100 != nil {
		l = m.NbSlu_6100.Size()
		n += 2 + l + sovMsgNb(uint64(l))
	}
	if m.NbSlu_6200 != nil {
		l = m.NbSlu_6200.Size()
		n += 2 + l + sovMsgNb(uint64(l))
	}
	if m.NbSlu_6400 != nil {
		l = m.NbSlu_6400.Size()
		n += 2 + l + sovMsgNb(uint64(l))
	}
	if m.NbSlu_4C00 != nil {
		l = m.NbSlu_4C00.Size()
		n += 2 + l + sovMsgNb(uint64(l))
	}
	if m.NbSlu_4E00 != nil {
		l = m.NbSlu_4E00.Size()
		n += 2 + l + sovMsgNb(uint64(l))
	}
	if m.NbSlu_4F00 != nil {
		l = m.NbSlu_4F00.Size()
		n += 2 + l + sovMsgNb(uint64(l))
	}
	return n
}

func (m *SluitemConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovMsgNb(uint64(m.CmdIdx))
	}
	if m.SluitemIdx != 0 {
		n += 1 + sovMsgNb(uint64(m.SluitemIdx))
	}
	if m.DataMark != nil {
		l = m.DataMark.Size()
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.LoopCount != 0 {
		n += 1 + sovMsgNb(uint64(m.LoopCount))
	}
	if m.SluitemTime != 0 {
		n += 1 + sovMsgNb(uint64(m.SluitemTime))
	}
	if m.SluitemPara != nil {
		l = m.SluitemPara.Size()
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.SluitemVer != nil {
		l = m.SluitemVer.Size()
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.SluitemSunriseset != nil {
		l = m.SluitemSunriseset.Size()
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if len(m.SluitemRuntime) > 0 {
		for _, e := range m.SluitemRuntime {
			l = e.Size()
			n += 1 + l + sovMsgNb(uint64(l))
		}
	}
	if m.Status != 0 {
		n += 1 + sovMsgNb(uint64(m.Status))
	}
	if m.SetMark != nil {
		l = m.SetMark.Size()
		n += 1 + l + sovMsgNb(uint64(l))
	}
	return n
}

func (m *SluitemConfig_DataMark) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReadTimer != 0 {
		n += 1 + sovMsgNb(uint64(m.ReadTimer))
	}
	if m.ReadArgs != 0 {
		n += 1 + sovMsgNb(uint64(m.ReadArgs))
	}
	if m.ReadVer != 0 {
		n += 1 + sovMsgNb(uint64(m.ReadVer))
	}
	if m.ReadSunriseset != 0 {
		n += 1 + sovMsgNb(uint64(m.ReadSunriseset))
	}
	if m.ReadTimetable != 0 {
		n += 1 + sovMsgNb(uint64(m.ReadTimetable))
	}
	return n
}

func (m *SluitemConfig_SetMark) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SetTimer != 0 {
		n += 1 + sovMsgNb(uint64(m.SetTimer))
	}
	if m.SetArgs != 0 {
		n += 1 + sovMsgNb(uint64(m.SetArgs))
	}
	if m.SetReset != 0 {
		n += 1 + sovMsgNb(uint64(m.SetReset))
	}
	if m.SetTimetable != 0 {
		n += 1 + sovMsgNb(uint64(m.SetTimetable))
	}
	return n
}

func (m *SluitemConfig_SluitemPara) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SluitemStatus != 0 {
		n += 1 + sovMsgNb(uint64(m.SluitemStatus))
	}
	if m.SluitemEnableAlarm != 0 {
		n += 1 + sovMsgNb(uint64(m.SluitemEnableAlarm))
	}
	if len(m.SluitemPowerTurnon) > 0 {
		l = 0
		for _, e := range m.SluitemPowerTurnon {
			l += sovMsgNb(uint64(e))
		}
		n += 1 + sovMsgNb(uint64(l)) + l
	}
	if m.Longitude != 0 {
		n += 9
	}
	if m.Latitude != 0 {
		n += 9
	}
	if len(m.RatedPower) > 0 {
		l = 0
		for _, e := range m.RatedPower {
			l += sovMsgNb(uint64(e))
		}
		n += 1 + sovMsgNb(uint64(l)) + l
	}
	if m.UplinkTimer != 0 {
		n += 1 + sovMsgNb(uint64(m.UplinkTimer))
	}
	if m.UplinkReply != 0 {
		n += 1 + sovMsgNb(uint64(m.UplinkReply))
	}
	if len(m.SluitemReverseDimming) > 0 {
		l = 0
		for _, e := range m.SluitemReverseDimming {
			l += sovMsgNb(uint64(e))
		}
		n += 1 + sovMsgNb(uint64(l)) + l
	}
	return n
}

func (m *SluitemConfig_SluitemVer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SluitemLoop != 0 {
		n += 1 + sovMsgNb(uint64(m.SluitemLoop))
	}
	if m.EnergySaving != 0 {
		n += 1 + sovMsgNb(uint64(m.EnergySaving))
	}
	if m.ElectricLeakageModule != 0 {
		n += 1 + sovMsgNb(uint64(m.ElectricLeakageModule))
	}
	if m.TemperatureModule != 0 {
		n += 1 + sovMsgNb(uint64(m.TemperatureModule))
	}
	if m.TimerModule != 0 {
		n += 1 + sovMsgNb(uint64(m.TimerModule))
	}
	l = len(m.SluitemType)
	if l > 0 {
		n += 1 + l + sovMsgNb(uint64(l))
	}
	l = len(m.Ver)
	if l > 0 {
		n += 1 + l + sovMsgNb(uint64(l))
	}
	return n
}

func (m *SluitemConfig_SluitemSunriseset) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sunrise != 0 {
		n += 1 + sovMsgNb(uint64(m.Sunrise))
	}
	if m.Sunset != 0 {
		n += 1 + sovMsgNb(uint64(m.Sunset))
	}
	return n
}

func (m *SluitemConfig_SluitemRuntime) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DataType != 0 {
		n += 1 + sovMsgNb(uint64(m.DataType))
	}
	if m.OutputType != 0 {
		n += 1 + sovMsgNb(uint64(m.OutputType))
	}
	if m.OperateType != 0 {
		n += 1 + sovMsgNb(uint64(m.OperateType))
	}
	if len(m.DateEnable) > 0 {
		l = 0
		for _, e := range m.DateEnable {
			l += sovMsgNb(uint64(e))
		}
		n += 1 + sovMsgNb(uint64(l)) + l
	}
	if m.OperateTime != 0 {
		n += 1 + sovMsgNb(uint64(m.OperateTime))
	}
	if m.OperateOffset != 0 {
		n += 1 + sovMsgNb(uint64(m.OperateOffset))
	}
	if len(m.RelayOperate) > 0 {
		l = 0
		for _, e := range m.RelayOperate {
			l += sovMsgNb(uint64(e))
		}
		n += 1 + sovMsgNb(uint64(l)) + l
	}
	if len(m.PwmLoop) > 0 {
		l = 0
		for _, e := range m.PwmLoop {
			l += sovMsgNb(uint64(e))
		}
		n += 1 + sovMsgNb(uint64(l)) + l
	}
	if m.PwmPower != 0 {
		n += 1 + sovMsgNb(uint64(m.PwmPower))
	}
	if m.PwmBaudrate != 0 {
		n += 1 + sovMsgNb(uint64(m.PwmBaudrate))
	}
	return n
}

func (m *SluitemReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovMsgNb(uint64(m.Status))
	}
	return n
}

func (m *SluitemData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovMsgNb(uint64(m.CmdIdx))
	}
	if m.ModelInfo != nil {
		l = m.ModelInfo.Size()
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if len(m.LightData) > 0 {
		for _, e := range m.LightData {
			l = e.Size()
			n += 1 + l + sovMsgNb(uint64(l))
		}
	}
	if m.LeakageCurrent != 0 {
		n += 9
	}
	if m.SluitemStatus != nil {
		l = m.SluitemStatus.Size()
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.TimeFault != nil {
		l = m.TimeFault.Size()
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.ResetCount != 0 {
		n += 1 + sovMsgNb(uint64(m.ResetCount))
	}
	if m.DateTime != 0 {
		n += 1 + sovMsgNb(uint64(m.DateTime))
	}
	if m.SluitemPara != nil {
		l = m.SluitemPara.Size()
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.Rsrp != 0 {
		n += 1 + sovMsgNb(uint64(m.Rsrp))
	}
	if m.Rssi != 0 {
		n += 1 + sovMsgNb(uint64(m.Rssi))
	}
	if m.Snr != 0 {
		n += 1 + sovMsgNb(uint64(m.Snr))
	}
	if m.Pci != 0 {
		n += 1 + sovMsgNb(uint64(m.Pci))
	}
	if m.Rsrq != 0 {
		n += 1 + sovMsgNb(uint64(m.Rsrq))
	}
	if m.Txpower != 0 {
		n += 1 + sovMsgNb(uint64(m.Txpower))
	}
	if m.Earfcn != 0 {
		n += 2 + sovMsgNb(uint64(m.Earfcn))
	}
	if m.Ecl != 0 {
		n += 2 + sovMsgNb(uint64(m.Ecl))
	}
	if m.Csq != 0 {
		n += 2 + sovMsgNb(uint64(m.Csq))
	}
	if m.Reson != 0 {
		n += 2 + sovMsgNb(uint64(m.Reson))
	}
	if m.Retry != 0 {
		n += 2 + sovMsgNb(uint64(m.Retry))
	}
	if m.Sunrise != 0 {
		n += 2 + sovMsgNb(uint64(m.Sunrise))
	}
	if m.Sunset != 0 {
		n += 2 + sovMsgNb(uint64(m.Sunset))
	}
	return n
}

func (m *SluitemData_ModelInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SluitemLoop != 0 {
		n += 1 + sovMsgNb(uint64(m.SluitemLoop))
	}
	if m.PowerSaving != 0 {
		n += 1 + sovMsgNb(uint64(m.PowerSaving))
	}
	if m.HasLeakage != 0 {
		n += 1 + sovMsgNb(uint64(m.HasLeakage))
	}
	if m.HasTemperature != 0 {
		n += 1 + sovMsgNb(uint64(m.HasTemperature))
	}
	if m.HasTimer != 0 {
		n += 1 + sovMsgNb(uint64(m.HasTimer))
	}
	if m.Model != 0 {
		n += 1 + sovMsgNb(uint64(m.Model))
	}
	l = len(m.SluitemType)
	if l > 0 {
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.UseLoop != 0 {
		n += 1 + sovMsgNb(uint64(m.UseLoop))
	}
	return n
}

func (m *SluitemData_LightData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Voltage != 0 {
		n += 9
	}
	if m.Current != 0 {
		n += 9
	}
	if m.ActivePower != 0 {
		n += 9
	}
	if m.ReactivePower != 0 {
		n += 9
	}
	if m.ApparentPower != 0 {
		n += 9
	}
	if m.Electricity != 0 {
		n += 9
	}
	if m.ActiveTime != 0 {
		n += 9
	}
	if m.LightStatus != nil {
		l = m.LightStatus.Size()
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.PowerLevel != 0 {
		n += 1 + sovMsgNb(uint64(m.PowerLevel))
	}
	if m.SluitemPowerTurnon != 0 {
		n += 1 + sovMsgNb(uint64(m.SluitemPowerTurnon))
	}
	if m.RatedPower != 0 {
		n += 1 + sovMsgNb(uint64(m.RatedPower))
	}
	return n
}

func (m *SluitemData_LightStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Leakage != 0 {
		n += 1 + sovMsgNb(uint64(m.Leakage))
	}
	if m.Fault != 0 {
		n += 1 + sovMsgNb(uint64(m.Fault))
	}
	if m.WorkingOn != 0 {
		n += 1 + sovMsgNb(uint64(m.WorkingOn))
	}
	return n
}

func (m *SluitemData_SluitemStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FlashFault != 0 {
		n += 1 + sovMsgNb(uint64(m.FlashFault))
	}
	if m.EnableAlarm != 0 {
		n += 1 + sovMsgNb(uint64(m.EnableAlarm))
	}
	return n
}

func (m *SluitemData_TimeFault) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClockFault != 0 {
		n += 1 + sovMsgNb(uint64(m.ClockFault))
	}
	if m.ClockOutFault != 0 {
		n += 1 + sovMsgNb(uint64(m.ClockOutFault))
	}
	if m.ClockOutAlarm != 0 {
		n += 1 + sovMsgNb(uint64(m.ClockOutAlarm))
	}
	return n
}

func (m *SluitemData_SluitemPara) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Longitude != 0 {
		n += 9
	}
	if m.Latitude != 0 {
		n += 9
	}
	if m.HasEnableAlarm != 0 {
		n += 1 + sovMsgNb(uint64(m.HasEnableAlarm))
	}
	if m.IsRunning != 0 {
		n += 1 + sovMsgNb(uint64(m.IsRunning))
	}
	if m.AlarmInterval != 0 {
		n += 1 + sovMsgNb(uint64(m.AlarmInterval))
	}
	if m.UplinkReply != 0 {
		n += 1 + sovMsgNb(uint64(m.UplinkReply))
	}
	return n
}

func (m *NBSlu_3100) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovMsgNb(uint64(m.CmdIdx))
	}
	l = len(m.Apn)
	if l > 0 {
		n += 1 + l + sovMsgNb(uint64(l))
	}
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovMsgNb(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.Operater != 0 {
		n += 1 + sovMsgNb(uint64(m.Operater))
	}
	if len(m.IpAddress) > 0 {
		l = 0
		for _, e := range m.IpAddress {
			l += sovMsgNb(uint64(e))
		}
		n += 1 + sovMsgNb(uint64(l)) + l
	}
	if m.Teleport != 0 {
		n += 1 + sovMsgNb(uint64(m.Teleport))
	}
	if m.Localport != 0 {
		n += 1 + sovMsgNb(uint64(m.Localport))
	}
	if m.VlinkTime != 0 {
		n += 1 + sovMsgNb(uint64(m.VlinkTime))
	}
	if m.GroupAccessInterval != 0 {
		n += 1 + sovMsgNb(uint64(m.GroupAccessInterval))
	}
	if m.GroupDeviceCount != 0 {
		n += 1 + sovMsgNb(uint64(m.GroupDeviceCount))
	}
	if m.MaxDeviceCount != 0 {
		n += 1 + sovMsgNb(uint64(m.MaxDeviceCount))
	}
	l = len(m.Imei)
	if l > 0 {
		n += 1 + l + sovMsgNb(uint64(l))
	}
	l = len(m.Imsi)
	if l > 0 {
		n += 1 + l + sovMsgNb(uint64(l))
	}
	l = len(m.Iccid)
	if l > 0 {
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.Status != 0 {
		n += 2 + sovMsgNb(uint64(m.Status))
	}
	return n
}

func (m *NBSlu_3700) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovMsgNb(uint64(m.CmdIdx))
	}
	l = len(m.Imei)
	if l > 0 {
		n += 1 + l + sovMsgNb(uint64(l))
	}
	l = len(m.Imsi)
	if l > 0 {
		n += 1 + l + sovMsgNb(uint64(l))
	}
	l = len(m.Iccid)
	if l > 0 {
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.Band != 0 {
		n += 1 + sovMsgNb(uint64(m.Band))
	}
	if m.Rsrp != 0 {
		n += 1 + sovMsgNb(uint64(m.Rsrp))
	}
	if m.Snr != 0 {
		n += 1 + sovMsgNb(uint64(m.Snr))
	}
	return n
}

func (m *NBSlu_1400) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovMsgNb(uint64(m.CmdIdx))
	}
	if m.SluitemTime != 0 {
		n += 1 + sovMsgNb(uint64(m.SluitemTime))
	}
	if m.Week != 0 {
		n += 1 + sovMsgNb(uint64(m.Week))
	}
	if m.Status != 0 {
		n += 1 + sovMsgNb(uint64(m.Status))
	}
	return n
}

func (m *NBSlu_5100) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovMsgNb(uint64(m.CmdIdx))
	}
	l = len(m.Ver)
	if l > 0 {
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovMsgNb(uint64(m.Status))
	}
	return n
}

func (m *NBSlu_5200) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovMsgNb(uint64(m.CmdIdx))
	}
	if m.Longitude != 0 {
		n += 9
	}
	if m.Latitude != 0 {
		n += 9
	}
	if m.SluitemStatus != 0 {
		n += 1 + sovMsgNb(uint64(m.SluitemStatus))
	}
	if len(m.SluitemPowerTurnon) > 0 {
		l = 0
		for _, e := range m.SluitemPowerTurnon {
			l += sovMsgNb(uint64(e))
		}
		n += 1 + sovMsgNb(uint64(l)) + l
	}
	if m.SluitemEnableAlarm != 0 {
		n += 1 + sovMsgNb(uint64(m.SluitemEnableAlarm))
	}
	if len(m.RatedPower) > 0 {
		l = 0
		for _, e := range m.RatedPower {
			l += sovMsgNb(uint64(e))
		}
		n += 1 + sovMsgNb(uint64(l)) + l
	}
	if m.UplinkTimer != 0 {
		n += 1 + sovMsgNb(uint64(m.UplinkTimer))
	}
	if m.UplinkReply != 0 {
		n += 1 + sovMsgNb(uint64(m.UplinkReply))
	}
	if m.UseLoop != 0 {
		n += 1 + sovMsgNb(uint64(m.UseLoop))
	}
	if m.Status != 0 {
		n += 1 + sovMsgNb(uint64(m.Status))
	}
	if len(m.SluitemReverseDimming) > 0 {
		l = 0
		for _, e := range m.SluitemReverseDimming {
			l += sovMsgNb(uint64(e))
		}
		n += 1 + sovMsgNb(uint64(l)) + l
	}
	if m.RecordTimer != 0 {
		n += 1 + sovMsgNb(uint64(m.RecordTimer))
	}
	return n
}

func (m *NBSlu_5400) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovMsgNb(uint64(m.CmdIdx))
	}
	if m.OutputType != 0 {
		n += 1 + sovMsgNb(uint64(m.OutputType))
	}
	if len(m.RelayOperate) > 0 {
		l = 0
		for _, e := range m.RelayOperate {
			l += sovMsgNb(uint64(e))
		}
		n += 1 + sovMsgNb(uint64(l)) + l
	}
	if len(m.PwmLoop) > 0 {
		l = 0
		for _, e := range m.PwmLoop {
			l += sovMsgNb(uint64(e))
		}
		n += 1 + sovMsgNb(uint64(l)) + l
	}
	if m.PwmPower != 0 {
		n += 1 + sovMsgNb(uint64(m.PwmPower))
	}
	if m.PwmBaudrate != 0 {
		n += 1 + sovMsgNb(uint64(m.PwmBaudrate))
	}
	if m.Status != 0 {
		n += 1 + sovMsgNb(uint64(m.Status))
	}
	return n
}

func (m *NBSlu_5500) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovMsgNb(uint64(m.CmdIdx))
	}
	if m.Mcu != 0 {
		n += 1 + sovMsgNb(uint64(m.Mcu))
	}
	if m.InitializeMcu != 0 {
		n += 1 + sovMsgNb(uint64(m.InitializeMcu))
	}
	if m.InitializeRam != 0 {
		n += 1 + sovMsgNb(uint64(m.InitializeRam))
	}
	if m.InitializeEeprom != 0 {
		n += 1 + sovMsgNb(uint64(m.InitializeEeprom))
	}
	if m.InitializeElec != 0 {
		n += 1 + sovMsgNb(uint64(m.InitializeElec))
	}
	if m.Status != 0 {
		n += 1 + sovMsgNb(uint64(m.Status))
	}
	return n
}

func (m *NBSlu_5600) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovMsgNb(uint64(m.CmdIdx))
	}
	if m.ClearOldRuntime != 0 {
		n += 1 + sovMsgNb(uint64(m.ClearOldRuntime))
	}
	if m.DataContinue != 0 {
		n += 1 + sovMsgNb(uint64(m.DataContinue))
	}
	if m.SluitemRuntimeCount != 0 {
		n += 1 + sovMsgNb(uint64(m.SluitemRuntimeCount))
	}
	if len(m.SluitemRuntime) > 0 {
		for _, e := range m.SluitemRuntime {
			l = e.Size()
			n += 1 + l + sovMsgNb(uint64(l))
		}
	}
	if m.Status != 0 {
		n += 1 + sovMsgNb(uint64(m.Status))
	}
	return n
}

func (m *NBSlu_5600_SluitemRuntime) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OutputType != 0 {
		n += 1 + sovMsgNb(uint64(m.OutputType))
	}
	if m.OperateType != 0 {
		n += 1 + sovMsgNb(uint64(m.OperateType))
	}
	if len(m.DateEnable) > 0 {
		l = 0
		for _, e := range m.DateEnable {
			l += sovMsgNb(uint64(e))
		}
		n += 1 + sovMsgNb(uint64(l)) + l
	}
	if m.OperateTime != 0 {
		n += 1 + sovMsgNb(uint64(m.OperateTime))
	}
	if m.OperateOffset != 0 {
		n += 1 + sovMsgNb(uint64(m.OperateOffset))
	}
	if len(m.RelayOperate) > 0 {
		l = 0
		for _, e := range m.RelayOperate {
			l += sovMsgNb(uint64(e))
		}
		n += 1 + sovMsgNb(uint64(l)) + l
	}
	if len(m.PwmLoop) > 0 {
		l = 0
		for _, e := range m.PwmLoop {
			l += sovMsgNb(uint64(e))
		}
		n += 1 + sovMsgNb(uint64(l)) + l
	}
	if m.PwmPower != 0 {
		n += 1 + sovMsgNb(uint64(m.PwmPower))
	}
	if m.PwmBaudrate != 0 {
		n += 1 + sovMsgNb(uint64(m.PwmBaudrate))
	}
	return n
}

func (m *NBSlu_FF05) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Ver)
	if l > 0 {
		n += 1 + l + sovMsgNb(uint64(l))
	}
	return n
}

func (m *NBSlu_FF07) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatapackTotal != 0 {
		n += 1 + sovMsgNb(uint64(m.DatapackTotal))
	}
	if len(m.DatapackStatus) > 0 {
		l = 0
		for _, e := range m.DatapackStatus {
			l += sovMsgNb(uint64(e))
		}
		n += 1 + sovMsgNb(uint64(l)) + l
	}
	return n
}

func (m *NBSlu_FF01) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OldVer)
	if l > 0 {
		n += 1 + l + sovMsgNb(uint64(l))
	}
	l = len(m.NewVer)
	if l > 0 {
		n += 1 + l + sovMsgNb(uint64(l))
	}
	return n
}

func (m *NBSlu_5800) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovMsgNb(uint64(m.CmdIdx))
	}
	if m.Status != 0 {
		n += 1 + sovMsgNb(uint64(m.Status))
	}
	if m.AlarmDelay != 0 {
		n += 1 + sovMsgNb(uint64(m.AlarmDelay))
	}
	if m.AlarmLimit != 0 {
		n += 1 + sovMsgNb(uint64(m.AlarmLimit))
	}
	if m.OptDelay != 0 {
		n += 1 + sovMsgNb(uint64(m.OptDelay))
	}
	if m.OptLimit != 0 {
		n += 1 + sovMsgNb(uint64(m.OptLimit))
	}
	if m.CcAlarm != 0 {
		n += 1 + sovMsgNb(uint64(m.CcAlarm))
	}
	if m.CcNormal != 0 {
		n += 1 + sovMsgNb(uint64(m.CcNormal))
	}
	return n
}

func (m *NBSlu_6200) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovMsgNb(uint64(m.CmdIdx))
	}
	if m.Status != 0 {
		n += 1 + sovMsgNb(uint64(m.Status))
	}
	if len(m.EventsAvailable) > 0 {
		l = 0
		for _, e := range m.EventsAvailable {
			l += sovMsgNb(uint64(e))
		}
		n += 1 + sovMsgNb(uint64(l)) + l
	}
	if len(m.EventsReport) > 0 {
		l = 0
		for _, e := range m.EventsReport {
			l += sovMsgNb(uint64(e))
		}
		n += 1 + sovMsgNb(uint64(l)) + l
	}
	return n
}

func (m *NBSlu_6100) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DtStart != 0 {
		n += 1 + sovMsgNb(uint64(m.DtStart))
	}
	if m.DtEnd != 0 {
		n += 1 + sovMsgNb(uint64(m.DtEnd))
	}
	if len(m.DataRecord) > 0 {
		for _, e := range m.DataRecord {
			l = e.Size()
			n += 1 + l + sovMsgNb(uint64(l))
		}
	}
	if m.CmdIdx != 0 {
		n += 1 + sovMsgNb(uint64(m.CmdIdx))
	}
	return n
}

func (m *NBSlu_6100_Data_Record) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DtRecord != 0 {
		n += 1 + sovMsgNb(uint64(m.DtRecord))
	}
	if len(m.Voltage) > 0 {
		n += 1 + sovMsgNb(uint64(len(m.Voltage)*8)) + len(m.Voltage)*8
	}
	if len(m.Current) > 0 {
		n += 1 + sovMsgNb(uint64(len(m.Current)*8)) + len(m.Current)*8
	}
	if len(m.ActivePower) > 0 {
		n += 1 + sovMsgNb(uint64(len(m.ActivePower)*8)) + len(m.ActivePower)*8
	}
	if len(m.PowerFactor) > 0 {
		n += 1 + sovMsgNb(uint64(len(m.PowerFactor)*8)) + len(m.PowerFactor)*8
	}
	if m.LeakageCurrent != 0 {
		n += 9
	}
	if m.Lux != 0 {
		n += 9
	}
	if m.Csq != 0 {
		n += 1 + sovMsgNb(uint64(m.Csq))
	}
	if m.Snr != 0 {
		n += 1 + sovMsgNb(uint64(m.Snr))
	}
	if m.Rsrp != 0 {
		n += 1 + sovMsgNb(uint64(m.Rsrp))
	}
	if m.Cellid != 0 {
		n += 1 + sovMsgNb(uint64(m.Cellid))
	}
	if m.Pci != 0 {
		n += 1 + sovMsgNb(uint64(m.Pci))
	}
	if m.Earfcn != 0 {
		n += 1 + sovMsgNb(uint64(m.Earfcn))
	}
	if m.StatusCommunication != 0 {
		n += 1 + sovMsgNb(uint64(m.StatusCommunication))
	}
	return n
}

func (m *NBSlu_6400) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovMsgNb(uint64(m.CmdIdx))
	}
	if m.EventsCount != 0 {
		n += 1 + sovMsgNb(uint64(m.EventsCount))
	}
	if len(m.EventData) > 0 {
		for _, e := range m.EventData {
			l = e.Size()
			n += 1 + l + sovMsgNb(uint64(l))
		}
	}
	return n
}

func (m *NBSlu_6400_Event_Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EventId != 0 {
		n += 1 + sovMsgNb(uint64(m.EventId))
	}
	if m.EventTime != 0 {
		n += 1 + sovMsgNb(uint64(m.EventTime))
	}
	l = len(m.EventMsg)
	if l > 0 {
		n += 1 + l + sovMsgNb(uint64(l))
	}
	return n
}

func (m *NBSlu_4C00) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovMsgNb(uint64(m.CmdIdx))
	}
	l = len(m.Sdata)
	if l > 0 {
		n += 1 + l + sovMsgNb(uint64(l))
	}
	return n
}

func (m *NBSlu_4E00) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovMsgNb(uint64(m.CmdIdx))
	}
	if m.CtrlType != 0 {
		n += 1 + sovMsgNb(uint64(m.CtrlType))
	}
	l = len(m.NewVer)
	if l > 0 {
		n += 1 + l + sovMsgNb(uint64(l))
	}
	return n
}

func (m *NBSlu_4F00) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovMsgNb(uint64(m.CmdIdx))
	}
	if m.Status != 0 {
		n += 1 + sovMsgNb(uint64(m.Status))
	}
	if m.Reason != 0 {
		n += 1 + sovMsgNb(uint64(m.Reason))
	}
	l = len(m.OldVer)
	if l > 0 {
		n += 1 + l + sovMsgNb(uint64(l))
	}
	l = len(m.NewVer)
	if l > 0 {
		n += 1 + l + sovMsgNb(uint64(l))
	}
	return n
}

func sovMsgNb(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMsgNb(x uint64) (n int) {
	return sovMsgNb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgNBiot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgNBiot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgNBiot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CmdName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdFlag", wireType)
			}
			m.CmdFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdFlag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Imei = append(m.Imei, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsgNb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsgNb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Imei) == 0 {
					m.Imei = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsgNb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Imei = append(m.Imei, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Imei", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RawData = append(m.RawData, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsgNb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsgNb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RawData) == 0 {
					m.RawData = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsgNb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RawData = append(m.RawData, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RawData", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgNBOpen) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgNBOpen: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgNBOpen: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Imei", wireType)
			}
			m.Imei = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Imei |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DtReceive", wireType)
			}
			m.DtReceive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DtReceive |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataType", wireType)
			}
			m.DataType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataCmd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataCmd = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SluitemData == nil {
				m.SluitemData = &SluitemData{}
			}
			if err := m.SluitemData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemReply", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SluitemReply == nil {
				m.SluitemReply = &SluitemReply{}
			}
			if err := m.SluitemReply.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SluitemConfig == nil {
				m.SluitemConfig = &SluitemConfig{}
			}
			if err := m.SluitemConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NbSlu_3100", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NbSlu_3100 == nil {
				m.NbSlu_3100 = &NBSlu_3100{}
			}
			if err := m.NbSlu_3100.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NbSlu_3700", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NbSlu_3700 == nil {
				m.NbSlu_3700 = &NBSlu_3700{}
			}
			if err := m.NbSlu_3700.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NbSlu_1400", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NbSlu_1400 == nil {
				m.NbSlu_1400 = &NBSlu_1400{}
			}
			if err := m.NbSlu_1400.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NbSlu_5100", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NbSlu_5100 == nil {
				m.NbSlu_5100 = &NBSlu_5100{}
			}
			if err := m.NbSlu_5100.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NbSlu_5200", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NbSlu_5200 == nil {
				m.NbSlu_5200 = &NBSlu_5200{}
			}
			if err := m.NbSlu_5200.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NbSlu_5400", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NbSlu_5400 == nil {
				m.NbSlu_5400 = &NBSlu_5400{}
			}
			if err := m.NbSlu_5400.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NbSlu_5500", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NbSlu_5500 == nil {
				m.NbSlu_5500 = &NBSlu_5500{}
			}
			if err := m.NbSlu_5500.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NbSlu_5600", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NbSlu_5600 == nil {
				m.NbSlu_5600 = &NBSlu_5600{}
			}
			if err := m.NbSlu_5600.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NbSluFf05", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NbSluFf05 == nil {
				m.NbSluFf05 = &NBSlu_FF05{}
			}
			if err := m.NbSluFf05.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NbSluFf07", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NbSluFf07 == nil {
				m.NbSluFf07 = &NBSlu_FF07{}
			}
			if err := m.NbSluFf07.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NbSluFf01", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NbSluFf01 == nil {
				m.NbSluFf01 = &NBSlu_FF01{}
			}
			if err := m.NbSluFf01.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataFlag", wireType)
			}
			m.DataFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataFlag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NbSlu_5800", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NbSlu_5800 == nil {
				m.NbSlu_5800 = &NBSlu_5800{}
			}
			if err := m.NbSlu_5800.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NbSlu_6100", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NbSlu_6100 == nil {
				m.NbSlu_6100 = &NBSlu_6100{}
			}
			if err := m.NbSlu_6100.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NbSlu_6200", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NbSlu_6200 == nil {
				m.NbSlu_6200 = &NBSlu_6200{}
			}
			if err := m.NbSlu_6200.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NbSlu_6400", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NbSlu_6400 == nil {
				m.NbSlu_6400 = &NBSlu_6400{}
			}
			if err := m.NbSlu_6400.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NbSlu_4C00", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NbSlu_4C00 == nil {
				m.NbSlu_4C00 = &NBSlu_4C00{}
			}
			if err := m.NbSlu_4C00.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NbSlu_4E00", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NbSlu_4E00 == nil {
				m.NbSlu_4E00 = &NBSlu_4E00{}
			}
			if err := m.NbSlu_4E00.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NbSlu_4F00", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NbSlu_4F00 == nil {
				m.NbSlu_4F00 = &NBSlu_4F00{}
			}
			if err := m.NbSlu_4F00.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SluitemConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SluitemConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SluitemConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemIdx", wireType)
			}
			m.SluitemIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemIdx |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataMark", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DataMark == nil {
				m.DataMark = &SluitemConfig_DataMark{}
			}
			if err := m.DataMark.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoopCount", wireType)
			}
			m.LoopCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoopCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemTime", wireType)
			}
			m.SluitemTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemPara", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SluitemPara == nil {
				m.SluitemPara = &SluitemConfig_SluitemPara{}
			}
			if err := m.SluitemPara.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemVer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SluitemVer == nil {
				m.SluitemVer = &SluitemConfig_SluitemVer{}
			}
			if err := m.SluitemVer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemSunriseset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SluitemSunriseset == nil {
				m.SluitemSunriseset = &SluitemConfig_SluitemSunriseset{}
			}
			if err := m.SluitemSunriseset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemRuntime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SluitemRuntime = append(m.SluitemRuntime, &SluitemConfig_SluitemRuntime{})
			if err := m.SluitemRuntime[len(m.SluitemRuntime)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetMark", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SetMark == nil {
				m.SetMark = &SluitemConfig_SetMark{}
			}
			if err := m.SetMark.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SluitemConfig_DataMark) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Data_mark: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Data_mark: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadTimer", wireType)
			}
			m.ReadTimer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadTimer |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadArgs", wireType)
			}
			m.ReadArgs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadArgs |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadVer", wireType)
			}
			m.ReadVer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadVer |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadSunriseset", wireType)
			}
			m.ReadSunriseset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadSunriseset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadTimetable", wireType)
			}
			m.ReadTimetable = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadTimetable |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SluitemConfig_SetMark) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Set_mark: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Set_mark: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetTimer", wireType)
			}
			m.SetTimer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SetTimer |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetArgs", wireType)
			}
			m.SetArgs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SetArgs |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetReset", wireType)
			}
			m.SetReset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SetReset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetTimetable", wireType)
			}
			m.SetTimetable = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SetTimetable |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SluitemConfig_SluitemPara) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sluitem_para: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sluitem_para: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemStatus", wireType)
			}
			m.SluitemStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemStatus |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemEnableAlarm", wireType)
			}
			m.SluitemEnableAlarm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemEnableAlarm |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SluitemPowerTurnon = append(m.SluitemPowerTurnon, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsgNb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsgNb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SluitemPowerTurnon) == 0 {
					m.SluitemPowerTurnon = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsgNb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SluitemPowerTurnon = append(m.SluitemPowerTurnon, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemPowerTurnon", wireType)
			}
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longitude", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Longitude = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latitude", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Latitude = float64(math.Float64frombits(v))
		case 8:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RatedPower = append(m.RatedPower, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsgNb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsgNb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RatedPower) == 0 {
					m.RatedPower = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsgNb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RatedPower = append(m.RatedPower, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RatedPower", wireType)
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UplinkTimer", wireType)
			}
			m.UplinkTimer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UplinkTimer |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UplinkReply", wireType)
			}
			m.UplinkReply = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UplinkReply |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SluitemReverseDimming = append(m.SluitemReverseDimming, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsgNb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsgNb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SluitemReverseDimming) == 0 {
					m.SluitemReverseDimming = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsgNb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SluitemReverseDimming = append(m.SluitemReverseDimming, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemReverseDimming", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SluitemConfig_SluitemVer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sluitem_ver: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sluitem_ver: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemLoop", wireType)
			}
			m.SluitemLoop = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemLoop |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnergySaving", wireType)
			}
			m.EnergySaving = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EnergySaving |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElectricLeakageModule", wireType)
			}
			m.ElectricLeakageModule = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ElectricLeakageModule |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemperatureModule", wireType)
			}
			m.TemperatureModule = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TemperatureModule |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimerModule", wireType)
			}
			m.TimerModule = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimerModule |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SluitemType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SluitemConfig_SluitemSunriseset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sluitem_sunriseset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sluitem_sunriseset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sunrise", wireType)
			}
			m.Sunrise = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sunrise |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sunset", wireType)
			}
			m.Sunset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sunset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SluitemConfig_SluitemRuntime) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sluitem_runtime: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sluitem_runtime: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataType", wireType)
			}
			m.DataType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputType", wireType)
			}
			m.OutputType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperateType", wireType)
			}
			m.OperateType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperateType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DateEnable = append(m.DateEnable, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsgNb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsgNb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DateEnable) == 0 {
					m.DateEnable = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsgNb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DateEnable = append(m.DateEnable, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DateEnable", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperateTime", wireType)
			}
			m.OperateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperateTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperateOffset", wireType)
			}
			m.OperateOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperateOffset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RelayOperate = append(m.RelayOperate, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsgNb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsgNb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RelayOperate) == 0 {
					m.RelayOperate = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsgNb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RelayOperate = append(m.RelayOperate, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayOperate", wireType)
			}
		case 8:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PwmLoop = append(m.PwmLoop, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsgNb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsgNb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PwmLoop) == 0 {
					m.PwmLoop = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsgNb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PwmLoop = append(m.PwmLoop, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PwmLoop", wireType)
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PwmPower", wireType)
			}
			m.PwmPower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PwmPower |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PwmBaudrate", wireType)
			}
			m.PwmBaudrate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PwmBaudrate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SluitemReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SluitemReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SluitemReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SluitemData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SluitemData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SluitemData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ModelInfo == nil {
				m.ModelInfo = &SluitemData_ModelInfo{}
			}
			if err := m.ModelInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LightData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LightData = append(m.LightData, &SluitemData_LightData{})
			if err := m.LightData[len(m.LightData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeakageCurrent", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.LeakageCurrent = float64(math.Float64frombits(v))
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SluitemStatus == nil {
				m.SluitemStatus = &SluitemData_SluitemStatus{}
			}
			if err := m.SluitemStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeFault", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TimeFault == nil {
				m.TimeFault = &SluitemData_TimeFault{}
			}
			if err := m.TimeFault.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResetCount", wireType)
			}
			m.ResetCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResetCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateTime", wireType)
			}
			m.DateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DateTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemPara", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SluitemPara == nil {
				m.SluitemPara = &SluitemData_SluitemPara{}
			}
			if err := m.SluitemPara.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rsrp", wireType)
			}
			m.Rsrp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rsrp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rssi", wireType)
			}
			m.Rssi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rssi |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snr", wireType)
			}
			m.Snr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Snr |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pci", wireType)
			}
			m.Pci = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pci |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rsrq", wireType)
			}
			m.Rsrq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rsrq |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txpower", wireType)
			}
			m.Txpower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Txpower |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Earfcn", wireType)
			}
			m.Earfcn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Earfcn |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecl", wireType)
			}
			m.Ecl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ecl |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Csq", wireType)
			}
			m.Csq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Csq |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reson", wireType)
			}
			m.Reson = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reson |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Retry", wireType)
			}
			m.Retry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Retry |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sunrise", wireType)
			}
			m.Sunrise = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sunrise |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sunset", wireType)
			}
			m.Sunset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sunset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SluitemData_ModelInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Model_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Model_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemLoop", wireType)
			}
			m.SluitemLoop = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemLoop |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PowerSaving", wireType)
			}
			m.PowerSaving = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PowerSaving |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasLeakage", wireType)
			}
			m.HasLeakage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HasLeakage |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasTemperature", wireType)
			}
			m.HasTemperature = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HasTemperature |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasTimer", wireType)
			}
			m.HasTimer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HasTimer |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			m.Model = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Model |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SluitemType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseLoop", wireType)
			}
			m.UseLoop = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UseLoop |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SluitemData_LightData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Light_data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Light_data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voltage", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Voltage = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Current", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Current = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivePower", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ActivePower = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReactivePower", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ReactivePower = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApparentPower", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ApparentPower = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Electricity", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Electricity = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveTime", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ActiveTime = float64(math.Float64frombits(v))
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LightStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LightStatus == nil {
				m.LightStatus = &SluitemData_LightStatus{}
			}
			if err := m.LightStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PowerLevel", wireType)
			}
			m.PowerLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PowerLevel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemPowerTurnon", wireType)
			}
			m.SluitemPowerTurnon = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemPowerTurnon |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RatedPower", wireType)
			}
			m.RatedPower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RatedPower |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SluitemData_LightStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Light_status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Light_status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leakage", wireType)
			}
			m.Leakage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Leakage |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fault", wireType)
			}
			m.Fault = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fault |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkingOn", wireType)
			}
			m.WorkingOn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkingOn |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SluitemData_SluitemStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sluitem_status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sluitem_status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlashFault", wireType)
			}
			m.FlashFault = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FlashFault |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableAlarm", wireType)
			}
			m.EnableAlarm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EnableAlarm |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SluitemData_TimeFault) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Time_fault: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Time_fault: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClockFault", wireType)
			}
			m.ClockFault = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClockFault |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClockOutFault", wireType)
			}
			m.ClockOutFault = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClockOutFault |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClockOutAlarm", wireType)
			}
			m.ClockOutAlarm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClockOutAlarm |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SluitemData_SluitemPara) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sluitem_para: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sluitem_para: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longitude", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Longitude = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latitude", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Latitude = float64(math.Float64frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasEnableAlarm", wireType)
			}
			m.HasEnableAlarm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HasEnableAlarm |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRunning", wireType)
			}
			m.IsRunning = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsRunning |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlarmInterval", wireType)
			}
			m.AlarmInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlarmInterval |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UplinkReply", wireType)
			}
			m.UplinkReply = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UplinkReply |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NBSlu_3100) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NBSlu_3100: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NBSlu_3100: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Apn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Apn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operater", wireType)
			}
			m.Operater = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Operater |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IpAddress = append(m.IpAddress, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsgNb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsgNb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.IpAddress) == 0 {
					m.IpAddress = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsgNb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IpAddress = append(m.IpAddress, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddress", wireType)
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Teleport", wireType)
			}
			m.Teleport = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Teleport |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Localport", wireType)
			}
			m.Localport = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Localport |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VlinkTime", wireType)
			}
			m.VlinkTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VlinkTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupAccessInterval", wireType)
			}
			m.GroupAccessInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupAccessInterval |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupDeviceCount", wireType)
			}
			m.GroupDeviceCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupDeviceCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDeviceCount", wireType)
			}
			m.MaxDeviceCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxDeviceCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Imei", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Imei = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Imsi", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Imsi = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iccid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Iccid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NBSlu_3700) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NBSlu_3700: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NBSlu_3700: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Imei", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Imei = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Imsi", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Imsi = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iccid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Iccid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Band", wireType)
			}
			m.Band = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Band |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rsrp", wireType)
			}
			m.Rsrp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rsrp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snr", wireType)
			}
			m.Snr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Snr |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NBSlu_1400) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NBSlu_1400: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NBSlu_1400: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemTime", wireType)
			}
			m.SluitemTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Week", wireType)
			}
			m.Week = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Week |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NBSlu_5100) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NBSlu_5100: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NBSlu_5100: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NBSlu_5200) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NBSlu_5200: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NBSlu_5200: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longitude", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Longitude = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latitude", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Latitude = float64(math.Float64frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemStatus", wireType)
			}
			m.SluitemStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemStatus |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SluitemPowerTurnon = append(m.SluitemPowerTurnon, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsgNb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsgNb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SluitemPowerTurnon) == 0 {
					m.SluitemPowerTurnon = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsgNb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SluitemPowerTurnon = append(m.SluitemPowerTurnon, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemPowerTurnon", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemEnableAlarm", wireType)
			}
			m.SluitemEnableAlarm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemEnableAlarm |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RatedPower = append(m.RatedPower, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsgNb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsgNb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RatedPower) == 0 {
					m.RatedPower = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsgNb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RatedPower = append(m.RatedPower, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RatedPower", wireType)
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UplinkTimer", wireType)
			}
			m.UplinkTimer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UplinkTimer |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UplinkReply", wireType)
			}
			m.UplinkReply = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UplinkReply |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseLoop", wireType)
			}
			m.UseLoop = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UseLoop |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SluitemReverseDimming = append(m.SluitemReverseDimming, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsgNb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsgNb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SluitemReverseDimming) == 0 {
					m.SluitemReverseDimming = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsgNb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SluitemReverseDimming = append(m.SluitemReverseDimming, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemReverseDimming", wireType)
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordTimer", wireType)
			}
			m.RecordTimer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecordTimer |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NBSlu_5400) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NBSlu_5400: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NBSlu_5400: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputType", wireType)
			}
			m.OutputType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RelayOperate = append(m.RelayOperate, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsgNb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsgNb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RelayOperate) == 0 {
					m.RelayOperate = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsgNb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RelayOperate = append(m.RelayOperate, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayOperate", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PwmLoop = append(m.PwmLoop, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsgNb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsgNb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PwmLoop) == 0 {
					m.PwmLoop = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsgNb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PwmLoop = append(m.PwmLoop, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PwmLoop", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PwmPower", wireType)
			}
			m.PwmPower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PwmPower |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PwmBaudrate", wireType)
			}
			m.PwmBaudrate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PwmBaudrate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NBSlu_5500) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NBSlu_5500: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NBSlu_5500: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mcu", wireType)
			}
			m.Mcu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mcu |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitializeMcu", wireType)
			}
			m.InitializeMcu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitializeMcu |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitializeRam", wireType)
			}
			m.InitializeRam = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitializeRam |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitializeEeprom", wireType)
			}
			m.InitializeEeprom = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitializeEeprom |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitializeElec", wireType)
			}
			m.InitializeElec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitializeElec |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NBSlu_5600) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NBSlu_5600: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NBSlu_5600: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClearOldRuntime", wireType)
			}
			m.ClearOldRuntime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClearOldRuntime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataContinue", wireType)
			}
			m.DataContinue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataContinue |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemRuntimeCount", wireType)
			}
			m.SluitemRuntimeCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemRuntimeCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemRuntime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SluitemRuntime = append(m.SluitemRuntime, &NBSlu_5600_SluitemRuntime{})
			if err := m.SluitemRuntime[len(m.SluitemRuntime)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NBSlu_5600_SluitemRuntime) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sluitem_runtime: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sluitem_runtime: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputType", wireType)
			}
			m.OutputType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperateType", wireType)
			}
			m.OperateType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperateType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DateEnable = append(m.DateEnable, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsgNb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsgNb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DateEnable) == 0 {
					m.DateEnable = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsgNb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DateEnable = append(m.DateEnable, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DateEnable", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperateTime", wireType)
			}
			m.OperateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperateTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperateOffset", wireType)
			}
			m.OperateOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperateOffset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RelayOperate = append(m.RelayOperate, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsgNb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsgNb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RelayOperate) == 0 {
					m.RelayOperate = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsgNb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RelayOperate = append(m.RelayOperate, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayOperate", wireType)
			}
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PwmLoop = append(m.PwmLoop, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsgNb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsgNb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PwmLoop) == 0 {
					m.PwmLoop = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsgNb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PwmLoop = append(m.PwmLoop, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PwmLoop", wireType)
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PwmPower", wireType)
			}
			m.PwmPower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PwmPower |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PwmBaudrate", wireType)
			}
			m.PwmBaudrate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PwmBaudrate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NBSlu_FF05) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NBSlu_FF05: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NBSlu_FF05: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NBSlu_FF07) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NBSlu_FF07: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NBSlu_FF07: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatapackTotal", wireType)
			}
			m.DatapackTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DatapackTotal |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DatapackStatus = append(m.DatapackStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsgNb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsgNb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DatapackStatus) == 0 {
					m.DatapackStatus = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsgNb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DatapackStatus = append(m.DatapackStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DatapackStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NBSlu_FF01) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NBSlu_FF01: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NBSlu_FF01: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldVer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OldVer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewVer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewVer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NBSlu_5800) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NBSlu_5800: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NBSlu_5800: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlarmDelay", wireType)
			}
			m.AlarmDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlarmDelay |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlarmLimit", wireType)
			}
			m.AlarmLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlarmLimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptDelay", wireType)
			}
			m.OptDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptDelay |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptLimit", wireType)
			}
			m.OptLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptLimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CcAlarm", wireType)
			}
			m.CcAlarm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CcAlarm |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CcNormal", wireType)
			}
			m.CcNormal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CcNormal |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NBSlu_6200) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NBSlu_6200: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NBSlu_6200: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.EventsAvailable = append(m.EventsAvailable, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsgNb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsgNb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.EventsAvailable) == 0 {
					m.EventsAvailable = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsgNb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.EventsAvailable = append(m.EventsAvailable, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field EventsAvailable", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.EventsReport = append(m.EventsReport, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsgNb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsgNb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.EventsReport) == 0 {
					m.EventsReport = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsgNb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.EventsReport = append(m.EventsReport, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field EventsReport", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NBSlu_6100) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NBSlu_6100: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NBSlu_6100: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DtStart", wireType)
			}
			m.DtStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DtStart |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DtEnd", wireType)
			}
			m.DtEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DtEnd |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataRecord", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataRecord = append(m.DataRecord, &NBSlu_6100_Data_Record{})
			if err := m.DataRecord[len(m.DataRecord)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NBSlu_6100_Data_Record) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Data_Record: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Data_Record: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DtRecord", wireType)
			}
			m.DtRecord = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DtRecord |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.Voltage = append(m.Voltage, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsgNb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsgNb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.Voltage) == 0 {
					m.Voltage = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.Voltage = append(m.Voltage, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Voltage", wireType)
			}
		case 3:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.Current = append(m.Current, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsgNb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsgNb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.Current) == 0 {
					m.Current = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.Current = append(m.Current, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Current", wireType)
			}
		case 4:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.ActivePower = append(m.ActivePower, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsgNb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsgNb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.ActivePower) == 0 {
					m.ActivePower = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.ActivePower = append(m.ActivePower, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivePower", wireType)
			}
		case 5:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.PowerFactor = append(m.PowerFactor, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsgNb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsgNb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.PowerFactor) == 0 {
					m.PowerFactor = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.PowerFactor = append(m.PowerFactor, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PowerFactor", wireType)
			}
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeakageCurrent", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.LeakageCurrent = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lux", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Lux = float64(math.Float64frombits(v))
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Csq", wireType)
			}
			m.Csq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Csq |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snr", wireType)
			}
			m.Snr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Snr |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rsrp", wireType)
			}
			m.Rsrp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rsrp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cellid", wireType)
			}
			m.Cellid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cellid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pci", wireType)
			}
			m.Pci = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pci |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Earfcn", wireType)
			}
			m.Earfcn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Earfcn |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusCommunication", wireType)
			}
			m.StatusCommunication = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusCommunication |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NBSlu_6400) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NBSlu_6400: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NBSlu_6400: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventsCount", wireType)
			}
			m.EventsCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventsCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EventData = append(m.EventData, &NBSlu_6400_Event_Data{})
			if err := m.EventData[len(m.EventData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NBSlu_6400_Event_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Event_Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Event_Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventId", wireType)
			}
			m.EventId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventTime", wireType)
			}
			m.EventTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EventMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NBSlu_4C00) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NBSlu_4C00: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NBSlu_4C00: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sdata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sdata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NBSlu_4E00) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NBSlu_4E00: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NBSlu_4E00: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CtrlType", wireType)
			}
			m.CtrlType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CtrlType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewVer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewVer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NBSlu_4F00) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NBSlu_4F00: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NBSlu_4F00: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			m.Reason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reason |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldVer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OldVer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewVer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewVer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMsgNb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMsgNb
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMsgNb
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMsgNb
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMsgNb        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMsgNb          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMsgNb = fmt.Errorf("proto: unexpected end of group")
)
