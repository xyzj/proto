// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: msg_nb.proto

package wlst_nbiot

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type MsgNBiot struct {
	CmdIdx int64 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// GoWork or GoWorkTask
	CmdName string `protobuf:"bytes,2,opt,name=cmd_name,json=cmdName,proto3" json:"cmd_name,omitempty"`
	// 0xdad9 or 0xdad0
	CmdFlag int32   `protobuf:"varint,3,opt,name=cmd_flag,json=cmdFlag,proto3" json:"cmd_flag,omitempty"`
	Imei    []int64 `protobuf:"varint,4,rep,packed,name=imei,proto3" json:"imei,omitempty"`
	// hex string
	RawData []int32 `protobuf:"varint,5,rep,packed,name=raw_data,json=rawData,proto3" json:"raw_data,omitempty"`
}

func (m *MsgNBiot) Reset()         { *m = MsgNBiot{} }
func (m *MsgNBiot) String() string { return proto.CompactTextString(m) }
func (*MsgNBiot) ProtoMessage()    {}
func (*MsgNBiot) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{0}
}
func (m *MsgNBiot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgNBiot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgNBiot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgNBiot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgNBiot.Merge(m, src)
}
func (m *MsgNBiot) XXX_Size() int {
	return m.Size()
}
func (m *MsgNBiot) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgNBiot.DiscardUnknown(m)
}

var xxx_messageInfo_MsgNBiot proto.InternalMessageInfo

func (m *MsgNBiot) GetCmdIdx() int64 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *MsgNBiot) GetCmdName() string {
	if m != nil {
		return m.CmdName
	}
	return ""
}

func (m *MsgNBiot) GetCmdFlag() int32 {
	if m != nil {
		return m.CmdFlag
	}
	return 0
}

func (m *MsgNBiot) GetImei() []int64 {
	if m != nil {
		return m.Imei
	}
	return nil
}

func (m *MsgNBiot) GetRawData() []int32 {
	if m != nil {
		return m.RawData
	}
	return nil
}

//数据服务和通讯服务传输格式
type MsgNBOpen struct {
	// 设备imei（云平台不填充，只填充device_id）
	Imei int64 `protobuf:"varint,1,opt,name=imei,proto3" json:"imei,omitempty"`
	// 数据接收时间
	DtReceive int64 `protobuf:"varint,2,opt,name=dt_receive,json=dtReceive,proto3" json:"dt_receive,omitempty"`
	// 数据类型，1-设备最新数据，2-控制应答，3-参数设置/读取应答,4-登录主报，5-时间应答，6-即时控制应答，7-复位应答，8-本地控制方案应答,9-版本读取，10-运行参数，11-网络参数
	DataType int32 `protobuf:"varint,3,opt,name=data_type,json=dataType,proto3" json:"data_type,omitempty"`
	// 内部命令名称: 选测 wlst.vslu.b900,
	DataCmd string `protobuf:"bytes,9,opt,name=data_cmd,json=dataCmd,proto3" json:"data_cmd,omitempty"`
	// 设备最新数据
	SluitemData *SluitemData `protobuf:"bytes,10,opt,name=sluitem_data,json=sluitemData,proto3" json:"sluitem_data,omitempty"`
	// 控制应答
	SluitemReply *SluitemReply `protobuf:"bytes,11,opt,name=sluitem_reply,json=sluitemReply,proto3" json:"sluitem_reply,omitempty"`
	// 参数设置/读取
	SluitemConfig *SluitemConfig `protobuf:"bytes,12,opt,name=sluitem_config,json=sluitemConfig,proto3" json:"sluitem_config,omitempty"`
	// 网络参数设置/读取
	NbSlu_3100 *NBSlu_3100 `protobuf:"bytes,13,opt,name=nb_slu_3100,json=nbSlu3100,proto3" json:"nb_slu_3100,omitempty"`
	// 登录信息数据主报
	NbSlu_3700 *NBSlu_3700 `protobuf:"bytes,14,opt,name=nb_slu_3700,json=nbSlu3700,proto3" json:"nb_slu_3700,omitempty"`
	// 时间设置/读取
	NbSlu_1400 *NBSlu_1400 `protobuf:"bytes,15,opt,name=nb_slu_1400,json=nbSlu1400,proto3" json:"nb_slu_1400,omitempty"`
	// 版本读取
	NbSlu_5100 *NBSlu_5100 `protobuf:"bytes,16,opt,name=nb_slu_5100,json=nbSlu5100,proto3" json:"nb_slu_5100,omitempty"`
	// 运行参数设置/读取
	NbSlu_5200 *NBSlu_5200 `protobuf:"bytes,17,opt,name=Nb_slu_5200,json=NbSlu5200,proto3" json:"Nb_slu_5200,omitempty"`
	// 即时控制
	NbSlu_5400 *NBSlu_5400 `protobuf:"bytes,18,opt,name=Nb_slu_5400,json=NbSlu5400,proto3" json:"Nb_slu_5400,omitempty"`
	// 复位
	NbSlu_5500 *NBSlu_5500 `protobuf:"bytes,19,opt,name=Nb_slu_5500,json=NbSlu5500,proto3" json:"Nb_slu_5500,omitempty"`
	// 本地控制方案设置/读取
	NbSlu_5600 *NBSlu_5600 `protobuf:"bytes,20,opt,name=Nb_slu_5600,json=NbSlu5600,proto3" json:"Nb_slu_5600,omitempty"`
	// deviceid，与imei对应
	DeviceId string `protobuf:"bytes,21,opt,name=device_id,json=deviceId,proto3" json:"device_id,omitempty"`
	// 升级
	// 序号（升级协议用）
	Seq int32 `protobuf:"varint,4,opt,name=seq,proto3" json:"seq,omitempty"`
	// 执行状态（升级协议用），0-成功
	Status int32 `protobuf:"varint,5,opt,name=status,proto3" json:"status,omitempty"`
	// 查询版本
	NbSluFf05 *NBSlu_FF05 `protobuf:"bytes,22,opt,name=Nb_slu_ff05,json=NbSluFf05,proto3" json:"Nb_slu_ff05,omitempty"`
	// 升级状态
	NbSluFf07 *NBSlu_FF07 `protobuf:"bytes,23,opt,name=Nb_slu_ff07,json=NbSluFf07,proto3" json:"Nb_slu_ff07,omitempty"`
	// 升级完成
	NbSluFf01 *NBSlu_FF01 `protobuf:"bytes,24,opt,name=Nb_slu_ff01,json=NbSluFf01,proto3" json:"Nb_slu_ff01,omitempty"`
}

func (m *MsgNBOpen) Reset()         { *m = MsgNBOpen{} }
func (m *MsgNBOpen) String() string { return proto.CompactTextString(m) }
func (*MsgNBOpen) ProtoMessage()    {}
func (*MsgNBOpen) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{1}
}
func (m *MsgNBOpen) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgNBOpen) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgNBOpen.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgNBOpen) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgNBOpen.Merge(m, src)
}
func (m *MsgNBOpen) XXX_Size() int {
	return m.Size()
}
func (m *MsgNBOpen) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgNBOpen.DiscardUnknown(m)
}

var xxx_messageInfo_MsgNBOpen proto.InternalMessageInfo

func (m *MsgNBOpen) GetImei() int64 {
	if m != nil {
		return m.Imei
	}
	return 0
}

func (m *MsgNBOpen) GetDtReceive() int64 {
	if m != nil {
		return m.DtReceive
	}
	return 0
}

func (m *MsgNBOpen) GetDataType() int32 {
	if m != nil {
		return m.DataType
	}
	return 0
}

func (m *MsgNBOpen) GetDataCmd() string {
	if m != nil {
		return m.DataCmd
	}
	return ""
}

func (m *MsgNBOpen) GetSluitemData() *SluitemData {
	if m != nil {
		return m.SluitemData
	}
	return nil
}

func (m *MsgNBOpen) GetSluitemReply() *SluitemReply {
	if m != nil {
		return m.SluitemReply
	}
	return nil
}

func (m *MsgNBOpen) GetSluitemConfig() *SluitemConfig {
	if m != nil {
		return m.SluitemConfig
	}
	return nil
}

func (m *MsgNBOpen) GetNbSlu_3100() *NBSlu_3100 {
	if m != nil {
		return m.NbSlu_3100
	}
	return nil
}

func (m *MsgNBOpen) GetNbSlu_3700() *NBSlu_3700 {
	if m != nil {
		return m.NbSlu_3700
	}
	return nil
}

func (m *MsgNBOpen) GetNbSlu_1400() *NBSlu_1400 {
	if m != nil {
		return m.NbSlu_1400
	}
	return nil
}

func (m *MsgNBOpen) GetNbSlu_5100() *NBSlu_5100 {
	if m != nil {
		return m.NbSlu_5100
	}
	return nil
}

func (m *MsgNBOpen) GetNbSlu_5200() *NBSlu_5200 {
	if m != nil {
		return m.NbSlu_5200
	}
	return nil
}

func (m *MsgNBOpen) GetNbSlu_5400() *NBSlu_5400 {
	if m != nil {
		return m.NbSlu_5400
	}
	return nil
}

func (m *MsgNBOpen) GetNbSlu_5500() *NBSlu_5500 {
	if m != nil {
		return m.NbSlu_5500
	}
	return nil
}

func (m *MsgNBOpen) GetNbSlu_5600() *NBSlu_5600 {
	if m != nil {
		return m.NbSlu_5600
	}
	return nil
}

func (m *MsgNBOpen) GetDeviceId() string {
	if m != nil {
		return m.DeviceId
	}
	return ""
}

func (m *MsgNBOpen) GetSeq() int32 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *MsgNBOpen) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *MsgNBOpen) GetNbSluFf05() *NBSlu_FF05 {
	if m != nil {
		return m.NbSluFf05
	}
	return nil
}

func (m *MsgNBOpen) GetNbSluFf07() *NBSlu_FF07 {
	if m != nil {
		return m.NbSluFf07
	}
	return nil
}

func (m *MsgNBOpen) GetNbSluFf01() *NBSlu_FF01 {
	if m != nil {
		return m.NbSluFf01
	}
	return nil
}

type SluitemConfig struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 控制器条码（4字节）
	SluitemIdx int64 `protobuf:"varint,2,opt,name=sluitem_idx,json=sluitemIdx,proto3" json:"sluitem_idx,omitempty"`
	// 参数读取标识
	DataMark *SluitemConfig_DataMark `protobuf:"bytes,4,opt,name=data_mark,json=dataMark,proto3" json:"data_mark,omitempty"`
	// 控制器回路数量
	LoopCount int32 `protobuf:"varint,5,opt,name=loop_count,json=loopCount,proto3" json:"loop_count,omitempty"`
	// 控制器时钟(read_timer)
	SluitemTime int64 `protobuf:"varint,7,opt,name=sluitem_time,json=sluitemTime,proto3" json:"sluitem_time,omitempty"`
	// 控制器运行参数(read_args)
	SluitemPara *SluitemConfig_SluitemPara `protobuf:"bytes,8,opt,name=sluitem_para,json=sluitemPara,proto3" json:"sluitem_para,omitempty"`
	// 控制器版本(read_ver)
	SluitemVer *SluitemConfig_SluitemVer `protobuf:"bytes,10,opt,name=sluitem_ver,json=sluitemVer,proto3" json:"sluitem_ver,omitempty"`
	// 控制器当日日出日落(read_sunriseset)
	SluitemSunriseset *SluitemConfig_SluitemSunriseset `protobuf:"bytes,11,opt,name=sluitem_sunriseset,json=sluitemSunriseset,proto3" json:"sluitem_sunriseset,omitempty"`
	// 控制器定时控制参数(read_timetable)
	SluitemRuntime []*SluitemConfig_SluitemRuntime `protobuf:"bytes,12,rep,name=sluitem_runtime,json=sluitemRuntime,proto3" json:"sluitem_runtime,omitempty"`
	// 设置状态0-失败，1-成功
	Status int32 `protobuf:"varint,14,opt,name=status,proto3" json:"status,omitempty"`
	// 参数设置标识
	SetMark *SluitemConfig_SetMark `protobuf:"bytes,15,opt,name=set_mark,json=setMark,proto3" json:"set_mark,omitempty"`
}

func (m *SluitemConfig) Reset()         { *m = SluitemConfig{} }
func (m *SluitemConfig) String() string { return proto.CompactTextString(m) }
func (*SluitemConfig) ProtoMessage()    {}
func (*SluitemConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{2}
}
func (m *SluitemConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SluitemConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SluitemConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SluitemConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SluitemConfig.Merge(m, src)
}
func (m *SluitemConfig) XXX_Size() int {
	return m.Size()
}
func (m *SluitemConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_SluitemConfig.DiscardUnknown(m)
}

var xxx_messageInfo_SluitemConfig proto.InternalMessageInfo

func (m *SluitemConfig) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *SluitemConfig) GetSluitemIdx() int64 {
	if m != nil {
		return m.SluitemIdx
	}
	return 0
}

func (m *SluitemConfig) GetDataMark() *SluitemConfig_DataMark {
	if m != nil {
		return m.DataMark
	}
	return nil
}

func (m *SluitemConfig) GetLoopCount() int32 {
	if m != nil {
		return m.LoopCount
	}
	return 0
}

func (m *SluitemConfig) GetSluitemTime() int64 {
	if m != nil {
		return m.SluitemTime
	}
	return 0
}

func (m *SluitemConfig) GetSluitemPara() *SluitemConfig_SluitemPara {
	if m != nil {
		return m.SluitemPara
	}
	return nil
}

func (m *SluitemConfig) GetSluitemVer() *SluitemConfig_SluitemVer {
	if m != nil {
		return m.SluitemVer
	}
	return nil
}

func (m *SluitemConfig) GetSluitemSunriseset() *SluitemConfig_SluitemSunriseset {
	if m != nil {
		return m.SluitemSunriseset
	}
	return nil
}

func (m *SluitemConfig) GetSluitemRuntime() []*SluitemConfig_SluitemRuntime {
	if m != nil {
		return m.SluitemRuntime
	}
	return nil
}

func (m *SluitemConfig) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *SluitemConfig) GetSetMark() *SluitemConfig_SetMark {
	if m != nil {
		return m.SetMark
	}
	return nil
}

type SluitemConfig_DataMark struct {
	// 读取时钟
	ReadTimer int32 `protobuf:"varint,2,opt,name=read_timer,json=readTimer,proto3" json:"read_timer,omitempty"`
	// 读取运行参数
	ReadArgs int32 `protobuf:"varint,3,opt,name=read_args,json=readArgs,proto3" json:"read_args,omitempty"`
	// 读取版本
	ReadVer int32 `protobuf:"varint,5,opt,name=read_ver,json=readVer,proto3" json:"read_ver,omitempty"`
	// 读取当天日出日落
	ReadSunriseset int32 `protobuf:"varint,6,opt,name=read_sunriseset,json=readSunriseset,proto3" json:"read_sunriseset,omitempty"`
	// 读取定时控制参数
	ReadTimetable int32 `protobuf:"varint,7,opt,name=read_timetable,json=readTimetable,proto3" json:"read_timetable,omitempty"`
}

func (m *SluitemConfig_DataMark) Reset()         { *m = SluitemConfig_DataMark{} }
func (m *SluitemConfig_DataMark) String() string { return proto.CompactTextString(m) }
func (*SluitemConfig_DataMark) ProtoMessage()    {}
func (*SluitemConfig_DataMark) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{2, 0}
}
func (m *SluitemConfig_DataMark) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SluitemConfig_DataMark) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SluitemConfig_DataMark.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SluitemConfig_DataMark) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SluitemConfig_DataMark.Merge(m, src)
}
func (m *SluitemConfig_DataMark) XXX_Size() int {
	return m.Size()
}
func (m *SluitemConfig_DataMark) XXX_DiscardUnknown() {
	xxx_messageInfo_SluitemConfig_DataMark.DiscardUnknown(m)
}

var xxx_messageInfo_SluitemConfig_DataMark proto.InternalMessageInfo

func (m *SluitemConfig_DataMark) GetReadTimer() int32 {
	if m != nil {
		return m.ReadTimer
	}
	return 0
}

func (m *SluitemConfig_DataMark) GetReadArgs() int32 {
	if m != nil {
		return m.ReadArgs
	}
	return 0
}

func (m *SluitemConfig_DataMark) GetReadVer() int32 {
	if m != nil {
		return m.ReadVer
	}
	return 0
}

func (m *SluitemConfig_DataMark) GetReadSunriseset() int32 {
	if m != nil {
		return m.ReadSunriseset
	}
	return 0
}

func (m *SluitemConfig_DataMark) GetReadTimetable() int32 {
	if m != nil {
		return m.ReadTimetable
	}
	return 0
}

type SluitemConfig_SetMark struct {
	// 设置时钟
	SetTimer int32 `protobuf:"varint,1,opt,name=set_timer,json=setTimer,proto3" json:"set_timer,omitempty"`
	// 设置运行参数
	SetArgs int32 `protobuf:"varint,2,opt,name=set_args,json=setArgs,proto3" json:"set_args,omitempty"`
	// 复位设备
	SetReset int32 `protobuf:"varint,4,opt,name=set_reset,json=setReset,proto3" json:"set_reset,omitempty"`
	// 设置定时控制参数
	SetTimetable int32 `protobuf:"varint,5,opt,name=set_timetable,json=setTimetable,proto3" json:"set_timetable,omitempty"`
}

func (m *SluitemConfig_SetMark) Reset()         { *m = SluitemConfig_SetMark{} }
func (m *SluitemConfig_SetMark) String() string { return proto.CompactTextString(m) }
func (*SluitemConfig_SetMark) ProtoMessage()    {}
func (*SluitemConfig_SetMark) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{2, 1}
}
func (m *SluitemConfig_SetMark) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SluitemConfig_SetMark) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SluitemConfig_SetMark.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SluitemConfig_SetMark) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SluitemConfig_SetMark.Merge(m, src)
}
func (m *SluitemConfig_SetMark) XXX_Size() int {
	return m.Size()
}
func (m *SluitemConfig_SetMark) XXX_DiscardUnknown() {
	xxx_messageInfo_SluitemConfig_SetMark.DiscardUnknown(m)
}

var xxx_messageInfo_SluitemConfig_SetMark proto.InternalMessageInfo

func (m *SluitemConfig_SetMark) GetSetTimer() int32 {
	if m != nil {
		return m.SetTimer
	}
	return 0
}

func (m *SluitemConfig_SetMark) GetSetArgs() int32 {
	if m != nil {
		return m.SetArgs
	}
	return 0
}

func (m *SluitemConfig_SetMark) GetSetReset() int32 {
	if m != nil {
		return m.SetReset
	}
	return 0
}

func (m *SluitemConfig_SetMark) GetSetTimetable() int32 {
	if m != nil {
		return m.SetTimetable
	}
	return 0
}

type SluitemConfig_SluitemPara struct {
	// 控制器状态 0-停运，1-投运
	SluitemStatus int32 `protobuf:"varint,2,opt,name=sluitem_status,json=sluitemStatus,proto3" json:"sluitem_status,omitempty"`
	// 控制器主报 0-禁止主报，1-允许主报
	SluitemEnableAlarm int32 `protobuf:"varint,3,opt,name=sluitem_enable_alarm,json=sluitemEnableAlarm,proto3" json:"sluitem_enable_alarm,omitempty"`
	// 控制器上电开灯 1-开灯，0-关灯
	SluitemPowerTurnon []int32 `protobuf:"varint,4,rep,packed,name=sluitem_power_turnon,json=sluitemPowerTurnon,proto3" json:"sluitem_power_turnon,omitempty"`
	// 经度
	Longitude float64 `protobuf:"fixed64,6,opt,name=longitude,proto3" json:"longitude,omitempty"`
	// 纬度
	Latitude float64 `protobuf:"fixed64,7,opt,name=latitude,proto3" json:"latitude,omitempty"`
	// 1-4回路额定功率
	RatedPower []int32 `protobuf:"varint,8,rep,packed,name=rated_power,json=ratedPower,proto3" json:"rated_power,omitempty"`
	// nb主报间隔，(0～127)*5
	UplinkTimer int32 `protobuf:"varint,9,opt,name=uplink_timer,json=uplinkTimer,proto3" json:"uplink_timer,omitempty"`
	// nb主报需要主站应答，0-不需要，1-需要
	UplinkReply int32 `protobuf:"varint,10,opt,name=uplink_reply,json=uplinkReply,proto3" json:"uplink_reply,omitempty"`
}

func (m *SluitemConfig_SluitemPara) Reset()         { *m = SluitemConfig_SluitemPara{} }
func (m *SluitemConfig_SluitemPara) String() string { return proto.CompactTextString(m) }
func (*SluitemConfig_SluitemPara) ProtoMessage()    {}
func (*SluitemConfig_SluitemPara) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{2, 2}
}
func (m *SluitemConfig_SluitemPara) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SluitemConfig_SluitemPara) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SluitemConfig_SluitemPara.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SluitemConfig_SluitemPara) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SluitemConfig_SluitemPara.Merge(m, src)
}
func (m *SluitemConfig_SluitemPara) XXX_Size() int {
	return m.Size()
}
func (m *SluitemConfig_SluitemPara) XXX_DiscardUnknown() {
	xxx_messageInfo_SluitemConfig_SluitemPara.DiscardUnknown(m)
}

var xxx_messageInfo_SluitemConfig_SluitemPara proto.InternalMessageInfo

func (m *SluitemConfig_SluitemPara) GetSluitemStatus() int32 {
	if m != nil {
		return m.SluitemStatus
	}
	return 0
}

func (m *SluitemConfig_SluitemPara) GetSluitemEnableAlarm() int32 {
	if m != nil {
		return m.SluitemEnableAlarm
	}
	return 0
}

func (m *SluitemConfig_SluitemPara) GetSluitemPowerTurnon() []int32 {
	if m != nil {
		return m.SluitemPowerTurnon
	}
	return nil
}

func (m *SluitemConfig_SluitemPara) GetLongitude() float64 {
	if m != nil {
		return m.Longitude
	}
	return 0
}

func (m *SluitemConfig_SluitemPara) GetLatitude() float64 {
	if m != nil {
		return m.Latitude
	}
	return 0
}

func (m *SluitemConfig_SluitemPara) GetRatedPower() []int32 {
	if m != nil {
		return m.RatedPower
	}
	return nil
}

func (m *SluitemConfig_SluitemPara) GetUplinkTimer() int32 {
	if m != nil {
		return m.UplinkTimer
	}
	return 0
}

func (m *SluitemConfig_SluitemPara) GetUplinkReply() int32 {
	if m != nil {
		return m.UplinkReply
	}
	return 0
}

type SluitemConfig_SluitemVer struct {
	// 控制器回路
	SluitemLoop int32 `protobuf:"varint,1,opt,name=sluitem_loop,json=sluitemLoop,proto3" json:"sluitem_loop,omitempty"`
	// 节能方式
	EnergySaving int32 `protobuf:"varint,2,opt,name=energy_saving,json=energySaving,proto3" json:"energy_saving,omitempty"`
	// 有漏电模块
	ElectricLeakageModule int32 `protobuf:"varint,3,opt,name=electric_leakage_module,json=electricLeakageModule,proto3" json:"electric_leakage_module,omitempty"`
	// 有温度检测模块
	TemperatureModule int32 `protobuf:"varint,4,opt,name=temperature_module,json=temperatureModule,proto3" json:"temperature_module,omitempty"`
	// 有时钟
	TimerModule int32 `protobuf:"varint,5,opt,name=timer_module,json=timerModule,proto3" json:"timer_module,omitempty"`
	// 型号 0-unknow,1-wj2090j
	SluitemType string `protobuf:"bytes,6,opt,name=sluitem_type,json=sluitemType,proto3" json:"sluitem_type,omitempty"`
	// 软件版本
	Ver string `protobuf:"bytes,7,opt,name=ver,proto3" json:"ver,omitempty"`
}

func (m *SluitemConfig_SluitemVer) Reset()         { *m = SluitemConfig_SluitemVer{} }
func (m *SluitemConfig_SluitemVer) String() string { return proto.CompactTextString(m) }
func (*SluitemConfig_SluitemVer) ProtoMessage()    {}
func (*SluitemConfig_SluitemVer) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{2, 3}
}
func (m *SluitemConfig_SluitemVer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SluitemConfig_SluitemVer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SluitemConfig_SluitemVer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SluitemConfig_SluitemVer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SluitemConfig_SluitemVer.Merge(m, src)
}
func (m *SluitemConfig_SluitemVer) XXX_Size() int {
	return m.Size()
}
func (m *SluitemConfig_SluitemVer) XXX_DiscardUnknown() {
	xxx_messageInfo_SluitemConfig_SluitemVer.DiscardUnknown(m)
}

var xxx_messageInfo_SluitemConfig_SluitemVer proto.InternalMessageInfo

func (m *SluitemConfig_SluitemVer) GetSluitemLoop() int32 {
	if m != nil {
		return m.SluitemLoop
	}
	return 0
}

func (m *SluitemConfig_SluitemVer) GetEnergySaving() int32 {
	if m != nil {
		return m.EnergySaving
	}
	return 0
}

func (m *SluitemConfig_SluitemVer) GetElectricLeakageModule() int32 {
	if m != nil {
		return m.ElectricLeakageModule
	}
	return 0
}

func (m *SluitemConfig_SluitemVer) GetTemperatureModule() int32 {
	if m != nil {
		return m.TemperatureModule
	}
	return 0
}

func (m *SluitemConfig_SluitemVer) GetTimerModule() int32 {
	if m != nil {
		return m.TimerModule
	}
	return 0
}

func (m *SluitemConfig_SluitemVer) GetSluitemType() string {
	if m != nil {
		return m.SluitemType
	}
	return ""
}

func (m *SluitemConfig_SluitemVer) GetVer() string {
	if m != nil {
		return m.Ver
	}
	return ""
}

type SluitemConfig_SluitemSunriseset struct {
	// 当日日出日落时间 hhmm->int32
	Sunrise int32 `protobuf:"varint,1,opt,name=sunrise,proto3" json:"sunrise,omitempty"`
	Sunset  int32 `protobuf:"varint,2,opt,name=sunset,proto3" json:"sunset,omitempty"`
}

func (m *SluitemConfig_SluitemSunriseset) Reset()         { *m = SluitemConfig_SluitemSunriseset{} }
func (m *SluitemConfig_SluitemSunriseset) String() string { return proto.CompactTextString(m) }
func (*SluitemConfig_SluitemSunriseset) ProtoMessage()    {}
func (*SluitemConfig_SluitemSunriseset) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{2, 4}
}
func (m *SluitemConfig_SluitemSunriseset) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SluitemConfig_SluitemSunriseset) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SluitemConfig_SluitemSunriseset.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SluitemConfig_SluitemSunriseset) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SluitemConfig_SluitemSunriseset.Merge(m, src)
}
func (m *SluitemConfig_SluitemSunriseset) XXX_Size() int {
	return m.Size()
}
func (m *SluitemConfig_SluitemSunriseset) XXX_DiscardUnknown() {
	xxx_messageInfo_SluitemConfig_SluitemSunriseset.DiscardUnknown(m)
}

var xxx_messageInfo_SluitemConfig_SluitemSunriseset proto.InternalMessageInfo

func (m *SluitemConfig_SluitemSunriseset) GetSunrise() int32 {
	if m != nil {
		return m.Sunrise
	}
	return 0
}

func (m *SluitemConfig_SluitemSunriseset) GetSunset() int32 {
	if m != nil {
		return m.Sunset
	}
	return 0
}

type SluitemConfig_SluitemRuntime struct {
	// 本地控制数据类型0-基本类型（6字节），1-扩展类型（6+20字节）
	DataType int32 `protobuf:"varint,1,opt,name=data_type,json=dataType,proto3" json:"data_type,omitempty"`
	// 输出类型0-继电器，1-pwm输出，2-485
	OutputType int32 `protobuf:"varint,2,opt,name=output_type,json=outputType,proto3" json:"output_type,omitempty"`
	// 操作类型1-定时操作，2-经纬度操作，3-即时操作
	OperateType int32 `protobuf:"varint,3,opt,name=operate_type,json=operateType,proto3" json:"operate_type,omitempty"`
	// 有效日期，0-6～周日-周6
	DateEnable []int32 `protobuf:"varint,4,rep,packed,name=date_enable,json=dateEnable,proto3" json:"date_enable,omitempty"`
	// 开关灯操作时间 hhmm->int32
	OperateTime int32 `protobuf:"varint,5,opt,name=operate_time,json=operateTime,proto3" json:"operate_time,omitempty"`
	// 操作偏移 -720~+720
	OperateOffset int32 `protobuf:"varint,6,opt,name=operate_offset,json=operateOffset,proto3" json:"operate_offset,omitempty"`
	// 继电器操作回路1-4, 0x0-不操作，0x3-开灯，0xc-关灯
	RelayOperate []int32 `protobuf:"varint,7,rep,packed,name=relay_operate,json=relayOperate,proto3" json:"relay_operate,omitempty"`
	// PWM操作回路
	PwmLoop []int32 `protobuf:"varint,8,rep,packed,name=pwm_loop,json=pwmLoop,proto3" json:"pwm_loop,omitempty"`
	// PWM操作占空比
	PwmPower int32 `protobuf:"varint,9,opt,name=pwm_power,json=pwmPower,proto3" json:"pwm_power,omitempty"`
	// PWM频率 (1~255) * 100
	PwmBaudrate int32 `protobuf:"varint,10,opt,name=pwm_baudrate,json=pwmBaudrate,proto3" json:"pwm_baudrate,omitempty"`
}

func (m *SluitemConfig_SluitemRuntime) Reset()         { *m = SluitemConfig_SluitemRuntime{} }
func (m *SluitemConfig_SluitemRuntime) String() string { return proto.CompactTextString(m) }
func (*SluitemConfig_SluitemRuntime) ProtoMessage()    {}
func (*SluitemConfig_SluitemRuntime) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{2, 5}
}
func (m *SluitemConfig_SluitemRuntime) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SluitemConfig_SluitemRuntime) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SluitemConfig_SluitemRuntime.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SluitemConfig_SluitemRuntime) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SluitemConfig_SluitemRuntime.Merge(m, src)
}
func (m *SluitemConfig_SluitemRuntime) XXX_Size() int {
	return m.Size()
}
func (m *SluitemConfig_SluitemRuntime) XXX_DiscardUnknown() {
	xxx_messageInfo_SluitemConfig_SluitemRuntime.DiscardUnknown(m)
}

var xxx_messageInfo_SluitemConfig_SluitemRuntime proto.InternalMessageInfo

func (m *SluitemConfig_SluitemRuntime) GetDataType() int32 {
	if m != nil {
		return m.DataType
	}
	return 0
}

func (m *SluitemConfig_SluitemRuntime) GetOutputType() int32 {
	if m != nil {
		return m.OutputType
	}
	return 0
}

func (m *SluitemConfig_SluitemRuntime) GetOperateType() int32 {
	if m != nil {
		return m.OperateType
	}
	return 0
}

func (m *SluitemConfig_SluitemRuntime) GetDateEnable() []int32 {
	if m != nil {
		return m.DateEnable
	}
	return nil
}

func (m *SluitemConfig_SluitemRuntime) GetOperateTime() int32 {
	if m != nil {
		return m.OperateTime
	}
	return 0
}

func (m *SluitemConfig_SluitemRuntime) GetOperateOffset() int32 {
	if m != nil {
		return m.OperateOffset
	}
	return 0
}

func (m *SluitemConfig_SluitemRuntime) GetRelayOperate() []int32 {
	if m != nil {
		return m.RelayOperate
	}
	return nil
}

func (m *SluitemConfig_SluitemRuntime) GetPwmLoop() []int32 {
	if m != nil {
		return m.PwmLoop
	}
	return nil
}

func (m *SluitemConfig_SluitemRuntime) GetPwmPower() int32 {
	if m != nil {
		return m.PwmPower
	}
	return 0
}

func (m *SluitemConfig_SluitemRuntime) GetPwmBaudrate() int32 {
	if m != nil {
		return m.PwmBaudrate
	}
	return 0
}

type SluitemReply struct {
	// 开关灯调光操作结果，0-失败，1-成功
	Status int32 `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *SluitemReply) Reset()         { *m = SluitemReply{} }
func (m *SluitemReply) String() string { return proto.CompactTextString(m) }
func (*SluitemReply) ProtoMessage()    {}
func (*SluitemReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{3}
}
func (m *SluitemReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SluitemReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SluitemReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SluitemReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SluitemReply.Merge(m, src)
}
func (m *SluitemReply) XXX_Size() int {
	return m.Size()
}
func (m *SluitemReply) XXX_DiscardUnknown() {
	xxx_messageInfo_SluitemReply.DiscardUnknown(m)
}

var xxx_messageInfo_SluitemReply proto.InternalMessageInfo

func (m *SluitemReply) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

type SluitemData struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 型号
	ModelInfo *SluitemData_ModelInfo `protobuf:"bytes,2,opt,name=model_info,json=modelInfo,proto3" json:"model_info,omitempty"`
	// 回路数据(最大4个)
	LightData []*SluitemData_LightData `protobuf:"bytes,3,rep,name=light_data,json=lightData,proto3" json:"light_data,omitempty"`
	// 漏电流
	LeakageCurrent float64 `protobuf:"fixed64,4,opt,name=leakage_current,json=leakageCurrent,proto3" json:"leakage_current,omitempty"`
	// 控制器状态
	SluitemStatus *SluitemData_SluitemStatus `protobuf:"bytes,5,opt,name=sluitem_status,json=sluitemStatus,proto3" json:"sluitem_status,omitempty"`
	// 时钟故障
	TimeFault *SluitemData_TimeFault `protobuf:"bytes,6,opt,name=time_fault,json=timeFault,proto3" json:"time_fault,omitempty"`
	// 自复位次数
	ResetCount int32 `protobuf:"varint,7,opt,name=reset_count,json=resetCount,proto3" json:"reset_count,omitempty"`
	// 时间
	DateTime int64 `protobuf:"varint,8,opt,name=date_time,json=dateTime,proto3" json:"date_time,omitempty"`
	// 控制器运行参数
	SluitemPara *SluitemData_SluitemPara `protobuf:"bytes,9,opt,name=sluitem_para,json=sluitemPara,proto3" json:"sluitem_para,omitempty"`
	// 参考信号接收功率
	Rsrp int64 `protobuf:"varint,10,opt,name=rsrp,proto3" json:"rsrp,omitempty"`
	// 接收信号强度等级
	Rssi int64 `protobuf:"varint,11,opt,name=rssi,proto3" json:"rssi,omitempty"`
	// 信噪比
	Snr int64 `protobuf:"varint,12,opt,name=snr,proto3" json:"snr,omitempty"`
	// 物理小区标识
	Pci int64 `protobuf:"varint,13,opt,name=pci,proto3" json:"pci,omitempty"`
	// 参考信号接收质量
	Rsrq int64 `protobuf:"varint,14,opt,name=rsrq,proto3" json:"rsrq,omitempty"`
	// 终端发射功率
	Txpower int64 `protobuf:"varint,15,opt,name=txpower,proto3" json:"txpower,omitempty"`
	// 频点号
	Earfcn int64 `protobuf:"varint,16,opt,name=earfcn,proto3" json:"earfcn,omitempty"`
	// 信号覆盖等级
	Ecl int32 `protobuf:"varint,17,opt,name=ecl,proto3" json:"ecl,omitempty"`
	// 信号强度值
	Csq int32 `protobuf:"varint,18,opt,name=csq,proto3" json:"csq,omitempty"`
	// 主动上报原因，0-非主动上报，1-登录，2-开关灯状态变化，3-故障发生/消除，4-定时主动上报
	Reson int32 `protobuf:"varint,19,opt,name=reson,proto3" json:"reson,omitempty"`
	// 重连次数
	Retry int32 `protobuf:"varint,20,opt,name=retry,proto3" json:"retry,omitempty"`
	// 日出时间
	Sunrise int32 `protobuf:"varint,21,opt,name=sunrise,proto3" json:"sunrise,omitempty"`
	// 日落时间
	Sunset int32 `protobuf:"varint,22,opt,name=sunset,proto3" json:"sunset,omitempty"`
}

func (m *SluitemData) Reset()         { *m = SluitemData{} }
func (m *SluitemData) String() string { return proto.CompactTextString(m) }
func (*SluitemData) ProtoMessage()    {}
func (*SluitemData) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{4}
}
func (m *SluitemData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SluitemData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SluitemData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SluitemData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SluitemData.Merge(m, src)
}
func (m *SluitemData) XXX_Size() int {
	return m.Size()
}
func (m *SluitemData) XXX_DiscardUnknown() {
	xxx_messageInfo_SluitemData.DiscardUnknown(m)
}

var xxx_messageInfo_SluitemData proto.InternalMessageInfo

func (m *SluitemData) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *SluitemData) GetModelInfo() *SluitemData_ModelInfo {
	if m != nil {
		return m.ModelInfo
	}
	return nil
}

func (m *SluitemData) GetLightData() []*SluitemData_LightData {
	if m != nil {
		return m.LightData
	}
	return nil
}

func (m *SluitemData) GetLeakageCurrent() float64 {
	if m != nil {
		return m.LeakageCurrent
	}
	return 0
}

func (m *SluitemData) GetSluitemStatus() *SluitemData_SluitemStatus {
	if m != nil {
		return m.SluitemStatus
	}
	return nil
}

func (m *SluitemData) GetTimeFault() *SluitemData_TimeFault {
	if m != nil {
		return m.TimeFault
	}
	return nil
}

func (m *SluitemData) GetResetCount() int32 {
	if m != nil {
		return m.ResetCount
	}
	return 0
}

func (m *SluitemData) GetDateTime() int64 {
	if m != nil {
		return m.DateTime
	}
	return 0
}

func (m *SluitemData) GetSluitemPara() *SluitemData_SluitemPara {
	if m != nil {
		return m.SluitemPara
	}
	return nil
}

func (m *SluitemData) GetRsrp() int64 {
	if m != nil {
		return m.Rsrp
	}
	return 0
}

func (m *SluitemData) GetRssi() int64 {
	if m != nil {
		return m.Rssi
	}
	return 0
}

func (m *SluitemData) GetSnr() int64 {
	if m != nil {
		return m.Snr
	}
	return 0
}

func (m *SluitemData) GetPci() int64 {
	if m != nil {
		return m.Pci
	}
	return 0
}

func (m *SluitemData) GetRsrq() int64 {
	if m != nil {
		return m.Rsrq
	}
	return 0
}

func (m *SluitemData) GetTxpower() int64 {
	if m != nil {
		return m.Txpower
	}
	return 0
}

func (m *SluitemData) GetEarfcn() int64 {
	if m != nil {
		return m.Earfcn
	}
	return 0
}

func (m *SluitemData) GetEcl() int32 {
	if m != nil {
		return m.Ecl
	}
	return 0
}

func (m *SluitemData) GetCsq() int32 {
	if m != nil {
		return m.Csq
	}
	return 0
}

func (m *SluitemData) GetReson() int32 {
	if m != nil {
		return m.Reson
	}
	return 0
}

func (m *SluitemData) GetRetry() int32 {
	if m != nil {
		return m.Retry
	}
	return 0
}

func (m *SluitemData) GetSunrise() int32 {
	if m != nil {
		return m.Sunrise
	}
	return 0
}

func (m *SluitemData) GetSunset() int32 {
	if m != nil {
		return m.Sunset
	}
	return 0
}

type SluitemData_ModelInfo struct {
	// 控制器回路数量
	SluitemLoop int32 `protobuf:"varint,1,opt,name=sluitem_loop,json=sluitemLoop,proto3" json:"sluitem_loop,omitempty"`
	// 节能方式 0-无控制，1-只有开关灯，4-RS485，5-PWM，6-0~10V
	PowerSaving int32 `protobuf:"varint,2,opt,name=power_saving,json=powerSaving,proto3" json:"power_saving,omitempty"`
	// 漏电流测量 0-无，1-有
	HasLeakage int32 `protobuf:"varint,3,opt,name=has_leakage,json=hasLeakage,proto3" json:"has_leakage,omitempty"`
	// 温度采集 0-无，1-有
	HasTemperature int32 `protobuf:"varint,4,opt,name=has_temperature,json=hasTemperature,proto3" json:"has_temperature,omitempty"`
	// 时钟 0-无，1-有
	HasTimer int32 `protobuf:"varint,5,opt,name=has_timer,json=hasTimer,proto3" json:"has_timer,omitempty"`
	// 型号 0-unknow（V0.2改为协议版本）
	Model int32 `protobuf:"varint,6,opt,name=model,proto3" json:"model,omitempty"`
	// 字符串型号（V0.2改为协议版本）
	SluitemType string `protobuf:"bytes,7,opt,name=sluitem_type,json=sluitemType,proto3" json:"sluitem_type,omitempty"`
	// 实际使用回路数（V0.2增加）
	UseLoop int32 `protobuf:"varint,8,opt,name=use_loop,json=useLoop,proto3" json:"use_loop,omitempty"`
}

func (m *SluitemData_ModelInfo) Reset()         { *m = SluitemData_ModelInfo{} }
func (m *SluitemData_ModelInfo) String() string { return proto.CompactTextString(m) }
func (*SluitemData_ModelInfo) ProtoMessage()    {}
func (*SluitemData_ModelInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{4, 0}
}
func (m *SluitemData_ModelInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SluitemData_ModelInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SluitemData_ModelInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SluitemData_ModelInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SluitemData_ModelInfo.Merge(m, src)
}
func (m *SluitemData_ModelInfo) XXX_Size() int {
	return m.Size()
}
func (m *SluitemData_ModelInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SluitemData_ModelInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SluitemData_ModelInfo proto.InternalMessageInfo

func (m *SluitemData_ModelInfo) GetSluitemLoop() int32 {
	if m != nil {
		return m.SluitemLoop
	}
	return 0
}

func (m *SluitemData_ModelInfo) GetPowerSaving() int32 {
	if m != nil {
		return m.PowerSaving
	}
	return 0
}

func (m *SluitemData_ModelInfo) GetHasLeakage() int32 {
	if m != nil {
		return m.HasLeakage
	}
	return 0
}

func (m *SluitemData_ModelInfo) GetHasTemperature() int32 {
	if m != nil {
		return m.HasTemperature
	}
	return 0
}

func (m *SluitemData_ModelInfo) GetHasTimer() int32 {
	if m != nil {
		return m.HasTimer
	}
	return 0
}

func (m *SluitemData_ModelInfo) GetModel() int32 {
	if m != nil {
		return m.Model
	}
	return 0
}

func (m *SluitemData_ModelInfo) GetSluitemType() string {
	if m != nil {
		return m.SluitemType
	}
	return ""
}

func (m *SluitemData_ModelInfo) GetUseLoop() int32 {
	if m != nil {
		return m.UseLoop
	}
	return 0
}

type SluitemData_LightData struct {
	// 电压
	Voltage float64 `protobuf:"fixed64,1,opt,name=voltage,proto3" json:"voltage,omitempty"`
	// 电流
	Current float64 `protobuf:"fixed64,2,opt,name=current,proto3" json:"current,omitempty"`
	// 有功功率
	ActivePower float64 `protobuf:"fixed64,3,opt,name=active_power,json=activePower,proto3" json:"active_power,omitempty"`
	// 无功功率
	ReactivePower float64 `protobuf:"fixed64,4,opt,name=reactive_power,json=reactivePower,proto3" json:"reactive_power,omitempty"`
	// 视在功率
	ApparentPower float64 `protobuf:"fixed64,5,opt,name=apparent_power,json=apparentPower,proto3" json:"apparent_power,omitempty"`
	// 电量
	Electricity float64 `protobuf:"fixed64,6,opt,name=electricity,proto3" json:"electricity,omitempty"`
	// 运行时间
	ActiveTime float64 `protobuf:"fixed64,7,opt,name=active_time,json=activeTime,proto3" json:"active_time,omitempty"`
	// 灯状态
	LightStatus *SluitemData_LightStatus `protobuf:"bytes,8,opt,name=light_status,json=lightStatus,proto3" json:"light_status,omitempty"`
	// 节能档位
	PowerLevel int32 `protobuf:"varint,9,opt,name=power_level,json=powerLevel,proto3" json:"power_level,omitempty"`
	// 控制器上电开灯 1-开灯，0-关灯
	SluitemPowerTurnon int32 `protobuf:"varint,10,opt,name=sluitem_power_turnon,json=sluitemPowerTurnon,proto3" json:"sluitem_power_turnon,omitempty"`
	// 1-4回路额定功率
	RatedPower int32 `protobuf:"varint,11,opt,name=rated_power,json=ratedPower,proto3" json:"rated_power,omitempty"`
}

func (m *SluitemData_LightData) Reset()         { *m = SluitemData_LightData{} }
func (m *SluitemData_LightData) String() string { return proto.CompactTextString(m) }
func (*SluitemData_LightData) ProtoMessage()    {}
func (*SluitemData_LightData) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{4, 1}
}
func (m *SluitemData_LightData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SluitemData_LightData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SluitemData_LightData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SluitemData_LightData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SluitemData_LightData.Merge(m, src)
}
func (m *SluitemData_LightData) XXX_Size() int {
	return m.Size()
}
func (m *SluitemData_LightData) XXX_DiscardUnknown() {
	xxx_messageInfo_SluitemData_LightData.DiscardUnknown(m)
}

var xxx_messageInfo_SluitemData_LightData proto.InternalMessageInfo

func (m *SluitemData_LightData) GetVoltage() float64 {
	if m != nil {
		return m.Voltage
	}
	return 0
}

func (m *SluitemData_LightData) GetCurrent() float64 {
	if m != nil {
		return m.Current
	}
	return 0
}

func (m *SluitemData_LightData) GetActivePower() float64 {
	if m != nil {
		return m.ActivePower
	}
	return 0
}

func (m *SluitemData_LightData) GetReactivePower() float64 {
	if m != nil {
		return m.ReactivePower
	}
	return 0
}

func (m *SluitemData_LightData) GetApparentPower() float64 {
	if m != nil {
		return m.ApparentPower
	}
	return 0
}

func (m *SluitemData_LightData) GetElectricity() float64 {
	if m != nil {
		return m.Electricity
	}
	return 0
}

func (m *SluitemData_LightData) GetActiveTime() float64 {
	if m != nil {
		return m.ActiveTime
	}
	return 0
}

func (m *SluitemData_LightData) GetLightStatus() *SluitemData_LightStatus {
	if m != nil {
		return m.LightStatus
	}
	return nil
}

func (m *SluitemData_LightData) GetPowerLevel() int32 {
	if m != nil {
		return m.PowerLevel
	}
	return 0
}

func (m *SluitemData_LightData) GetSluitemPowerTurnon() int32 {
	if m != nil {
		return m.SluitemPowerTurnon
	}
	return 0
}

func (m *SluitemData_LightData) GetRatedPower() int32 {
	if m != nil {
		return m.RatedPower
	}
	return 0
}

type SluitemData_LightStatus struct {
	// 灯具漏电 0-正常，1-漏电
	Leakage int32 `protobuf:"varint,1,opt,name=leakage,proto3" json:"leakage,omitempty"`
	// 故障 0-正常，1-光源故障，2-补偿电容故障，3-意外灭灯，4-意外亮灯，5-自熄灯
	Fault int32 `protobuf:"varint,2,opt,name=fault,proto3" json:"fault,omitempty"`
	// 工作状态 0-正常亮灯，1-保留，2-调光节能，3-关灯
	WorkingOn int32 `protobuf:"varint,3,opt,name=working_on,json=workingOn,proto3" json:"working_on,omitempty"`
}

func (m *SluitemData_LightStatus) Reset()         { *m = SluitemData_LightStatus{} }
func (m *SluitemData_LightStatus) String() string { return proto.CompactTextString(m) }
func (*SluitemData_LightStatus) ProtoMessage()    {}
func (*SluitemData_LightStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{4, 2}
}
func (m *SluitemData_LightStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SluitemData_LightStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SluitemData_LightStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SluitemData_LightStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SluitemData_LightStatus.Merge(m, src)
}
func (m *SluitemData_LightStatus) XXX_Size() int {
	return m.Size()
}
func (m *SluitemData_LightStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_SluitemData_LightStatus.DiscardUnknown(m)
}

var xxx_messageInfo_SluitemData_LightStatus proto.InternalMessageInfo

func (m *SluitemData_LightStatus) GetLeakage() int32 {
	if m != nil {
		return m.Leakage
	}
	return 0
}

func (m *SluitemData_LightStatus) GetFault() int32 {
	if m != nil {
		return m.Fault
	}
	return 0
}

func (m *SluitemData_LightStatus) GetWorkingOn() int32 {
	if m != nil {
		return m.WorkingOn
	}
	return 0
}

type SluitemData_SluitemStatus struct {
	// flash故障 0-正常 1-故障
	FlashFault int32 `protobuf:"varint,1,opt,name=flash_fault,json=flashFault,proto3" json:"flash_fault,omitempty"`
	// 主动报警禁止 0-正常 1-禁止
	EnableAlarm int32 `protobuf:"varint,2,opt,name=enable_alarm,json=enableAlarm,proto3" json:"enable_alarm,omitempty"`
}

func (m *SluitemData_SluitemStatus) Reset()         { *m = SluitemData_SluitemStatus{} }
func (m *SluitemData_SluitemStatus) String() string { return proto.CompactTextString(m) }
func (*SluitemData_SluitemStatus) ProtoMessage()    {}
func (*SluitemData_SluitemStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{4, 3}
}
func (m *SluitemData_SluitemStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SluitemData_SluitemStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SluitemData_SluitemStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SluitemData_SluitemStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SluitemData_SluitemStatus.Merge(m, src)
}
func (m *SluitemData_SluitemStatus) XXX_Size() int {
	return m.Size()
}
func (m *SluitemData_SluitemStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_SluitemData_SluitemStatus.DiscardUnknown(m)
}

var xxx_messageInfo_SluitemData_SluitemStatus proto.InternalMessageInfo

func (m *SluitemData_SluitemStatus) GetFlashFault() int32 {
	if m != nil {
		return m.FlashFault
	}
	return 0
}

func (m *SluitemData_SluitemStatus) GetEnableAlarm() int32 {
	if m != nil {
		return m.EnableAlarm
	}
	return 0
}

type SluitemData_TimeFault struct {
	// 本地时钟故障 0-正常 1-故障
	ClockFault int32 `protobuf:"varint,1,opt,name=clock_fault,json=clockFault,proto3" json:"clock_fault,omitempty"`
	// 本地时钟超差故障 0-正常 1-故障
	ClockOutFault int32 `protobuf:"varint,2,opt,name=clock_out_fault,json=clockOutFault,proto3" json:"clock_out_fault,omitempty"`
	// 校时超差故障 0-正常 1-故障
	ClockOutAlarm int32 `protobuf:"varint,3,opt,name=clock_out_alarm,json=clockOutAlarm,proto3" json:"clock_out_alarm,omitempty"`
}

func (m *SluitemData_TimeFault) Reset()         { *m = SluitemData_TimeFault{} }
func (m *SluitemData_TimeFault) String() string { return proto.CompactTextString(m) }
func (*SluitemData_TimeFault) ProtoMessage()    {}
func (*SluitemData_TimeFault) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{4, 4}
}
func (m *SluitemData_TimeFault) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SluitemData_TimeFault) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SluitemData_TimeFault.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SluitemData_TimeFault) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SluitemData_TimeFault.Merge(m, src)
}
func (m *SluitemData_TimeFault) XXX_Size() int {
	return m.Size()
}
func (m *SluitemData_TimeFault) XXX_DiscardUnknown() {
	xxx_messageInfo_SluitemData_TimeFault.DiscardUnknown(m)
}

var xxx_messageInfo_SluitemData_TimeFault proto.InternalMessageInfo

func (m *SluitemData_TimeFault) GetClockFault() int32 {
	if m != nil {
		return m.ClockFault
	}
	return 0
}

func (m *SluitemData_TimeFault) GetClockOutFault() int32 {
	if m != nil {
		return m.ClockOutFault
	}
	return 0
}

func (m *SluitemData_TimeFault) GetClockOutAlarm() int32 {
	if m != nil {
		return m.ClockOutAlarm
	}
	return 0
}

type SluitemData_SluitemPara struct {
	// 经度
	Longitude float64 `protobuf:"fixed64,1,opt,name=longitude,proto3" json:"longitude,omitempty"`
	// 纬度
	Latitude float64 `protobuf:"fixed64,2,opt,name=latitude,proto3" json:"latitude,omitempty"`
	// 是否允许主报 1-允许 0-不允许
	HasEnableAlarm int32 `protobuf:"varint,3,opt,name=has_enable_alarm,json=hasEnableAlarm,proto3" json:"has_enable_alarm,omitempty"`
	// 是否投运 1-投运 0-停运
	IsRunning int32 `protobuf:"varint,4,opt,name=is_running,json=isRunning,proto3" json:"is_running,omitempty"`
	// 主动报警间隔 单位分钟 0表示30分钟
	AlarmInterval int32 `protobuf:"varint,5,opt,name=alarm_interval,json=alarmInterval,proto3" json:"alarm_interval,omitempty"`
	// nb主报需要主站应答，0-不需要，1-需要
	UplinkReply int32 `protobuf:"varint,6,opt,name=uplink_reply,json=uplinkReply,proto3" json:"uplink_reply,omitempty"`
}

func (m *SluitemData_SluitemPara) Reset()         { *m = SluitemData_SluitemPara{} }
func (m *SluitemData_SluitemPara) String() string { return proto.CompactTextString(m) }
func (*SluitemData_SluitemPara) ProtoMessage()    {}
func (*SluitemData_SluitemPara) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{4, 5}
}
func (m *SluitemData_SluitemPara) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SluitemData_SluitemPara) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SluitemData_SluitemPara.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SluitemData_SluitemPara) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SluitemData_SluitemPara.Merge(m, src)
}
func (m *SluitemData_SluitemPara) XXX_Size() int {
	return m.Size()
}
func (m *SluitemData_SluitemPara) XXX_DiscardUnknown() {
	xxx_messageInfo_SluitemData_SluitemPara.DiscardUnknown(m)
}

var xxx_messageInfo_SluitemData_SluitemPara proto.InternalMessageInfo

func (m *SluitemData_SluitemPara) GetLongitude() float64 {
	if m != nil {
		return m.Longitude
	}
	return 0
}

func (m *SluitemData_SluitemPara) GetLatitude() float64 {
	if m != nil {
		return m.Latitude
	}
	return 0
}

func (m *SluitemData_SluitemPara) GetHasEnableAlarm() int32 {
	if m != nil {
		return m.HasEnableAlarm
	}
	return 0
}

func (m *SluitemData_SluitemPara) GetIsRunning() int32 {
	if m != nil {
		return m.IsRunning
	}
	return 0
}

func (m *SluitemData_SluitemPara) GetAlarmInterval() int32 {
	if m != nil {
		return m.AlarmInterval
	}
	return 0
}

func (m *SluitemData_SluitemPara) GetUplinkReply() int32 {
	if m != nil {
		return m.UplinkReply
	}
	return 0
}

// 网络参数 (不进行设置的参数的值下发时置零)
type NBSlu_3100 struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// APN
	Apn string `protobuf:"bytes,2,opt,name=apn,proto3" json:"apn,omitempty"`
	// 用户名
	UserName string `protobuf:"bytes,3,opt,name=user_name,json=userName,proto3" json:"user_name,omitempty"`
	// 密码
	Password string `protobuf:"bytes,4,opt,name=password,proto3" json:"password,omitempty"`
	// 接入运营商
	Operater int32 `protobuf:"varint,5,opt,name=operater,proto3" json:"operater,omitempty"`
	// ip (每1字节分别代表地址中1个数字)
	IpAddress []int32 `protobuf:"varint,6,rep,packed,name=ip_address,json=ipAddress,proto3" json:"ip_address,omitempty"`
	// 远程端口
	Teleport int32 `protobuf:"varint,7,opt,name=teleport,proto3" json:"teleport,omitempty"`
	// 本地端口
	Localport int32 `protobuf:"varint,8,opt,name=localport,proto3" json:"localport,omitempty"`
	// 虚连接时间 (单位为分)
	VlinkTime int32 `protobuf:"varint,9,opt,name=vlink_time,json=vlinkTime,proto3" json:"vlink_time,omitempty"`
	// 组入网间隔 (单位为秒)
	GroupAccessInterval int32 `protobuf:"varint,10,opt,name=group_access_interval,json=groupAccessInterval,proto3" json:"group_access_interval,omitempty"`
	// 组内设备个数
	GroupDeviceCount int32 `protobuf:"varint,11,opt,name=group_device_count,json=groupDeviceCount,proto3" json:"group_device_count,omitempty"`
	// 扇区最大允许接入设备总数
	MaxDeviceCount int32 `protobuf:"varint,12,opt,name=max_device_count,json=maxDeviceCount,proto3" json:"max_device_count,omitempty"`
	// IMEI
	Imei string `protobuf:"bytes,13,opt,name=imei,proto3" json:"imei,omitempty"`
	// IMSI
	Imsi string `protobuf:"bytes,14,opt,name=imsi,proto3" json:"imsi,omitempty"`
	// ICCID
	Iccid string `protobuf:"bytes,15,opt,name=iccid,proto3" json:"iccid,omitempty"`
	// 应答状态 (0x35为成功，其它失败)
	Status int32 `protobuf:"varint,16,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *NBSlu_3100) Reset()         { *m = NBSlu_3100{} }
func (m *NBSlu_3100) String() string { return proto.CompactTextString(m) }
func (*NBSlu_3100) ProtoMessage()    {}
func (*NBSlu_3100) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{5}
}
func (m *NBSlu_3100) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NBSlu_3100) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NBSlu_3100.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NBSlu_3100) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NBSlu_3100.Merge(m, src)
}
func (m *NBSlu_3100) XXX_Size() int {
	return m.Size()
}
func (m *NBSlu_3100) XXX_DiscardUnknown() {
	xxx_messageInfo_NBSlu_3100.DiscardUnknown(m)
}

var xxx_messageInfo_NBSlu_3100 proto.InternalMessageInfo

func (m *NBSlu_3100) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *NBSlu_3100) GetApn() string {
	if m != nil {
		return m.Apn
	}
	return ""
}

func (m *NBSlu_3100) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

func (m *NBSlu_3100) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *NBSlu_3100) GetOperater() int32 {
	if m != nil {
		return m.Operater
	}
	return 0
}

func (m *NBSlu_3100) GetIpAddress() []int32 {
	if m != nil {
		return m.IpAddress
	}
	return nil
}

func (m *NBSlu_3100) GetTeleport() int32 {
	if m != nil {
		return m.Teleport
	}
	return 0
}

func (m *NBSlu_3100) GetLocalport() int32 {
	if m != nil {
		return m.Localport
	}
	return 0
}

func (m *NBSlu_3100) GetVlinkTime() int32 {
	if m != nil {
		return m.VlinkTime
	}
	return 0
}

func (m *NBSlu_3100) GetGroupAccessInterval() int32 {
	if m != nil {
		return m.GroupAccessInterval
	}
	return 0
}

func (m *NBSlu_3100) GetGroupDeviceCount() int32 {
	if m != nil {
		return m.GroupDeviceCount
	}
	return 0
}

func (m *NBSlu_3100) GetMaxDeviceCount() int32 {
	if m != nil {
		return m.MaxDeviceCount
	}
	return 0
}

func (m *NBSlu_3100) GetImei() string {
	if m != nil {
		return m.Imei
	}
	return ""
}

func (m *NBSlu_3100) GetImsi() string {
	if m != nil {
		return m.Imsi
	}
	return ""
}

func (m *NBSlu_3100) GetIccid() string {
	if m != nil {
		return m.Iccid
	}
	return ""
}

func (m *NBSlu_3100) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

// 登录信息数据主报
type NBSlu_3700 struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// IMEI
	Imei string `protobuf:"bytes,2,opt,name=imei,proto3" json:"imei,omitempty"`
	// IMSI
	Imsi string `protobuf:"bytes,3,opt,name=imsi,proto3" json:"imsi,omitempty"`
	// ICCID 集成电路卡识别码
	Iccid string `protobuf:"bytes,4,opt,name=iccid,proto3" json:"iccid,omitempty"`
	// 频段
	Band int32 `protobuf:"varint,5,opt,name=band,proto3" json:"band,omitempty"`
	// 参考信号接收功率
	Rsrp int64 `protobuf:"varint,6,opt,name=rsrp,proto3" json:"rsrp,omitempty"`
	// 信噪比
	Snr int64 `protobuf:"varint,7,opt,name=snr,proto3" json:"snr,omitempty"`
}

func (m *NBSlu_3700) Reset()         { *m = NBSlu_3700{} }
func (m *NBSlu_3700) String() string { return proto.CompactTextString(m) }
func (*NBSlu_3700) ProtoMessage()    {}
func (*NBSlu_3700) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{6}
}
func (m *NBSlu_3700) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NBSlu_3700) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NBSlu_3700.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NBSlu_3700) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NBSlu_3700.Merge(m, src)
}
func (m *NBSlu_3700) XXX_Size() int {
	return m.Size()
}
func (m *NBSlu_3700) XXX_DiscardUnknown() {
	xxx_messageInfo_NBSlu_3700.DiscardUnknown(m)
}

var xxx_messageInfo_NBSlu_3700 proto.InternalMessageInfo

func (m *NBSlu_3700) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *NBSlu_3700) GetImei() string {
	if m != nil {
		return m.Imei
	}
	return ""
}

func (m *NBSlu_3700) GetImsi() string {
	if m != nil {
		return m.Imsi
	}
	return ""
}

func (m *NBSlu_3700) GetIccid() string {
	if m != nil {
		return m.Iccid
	}
	return ""
}

func (m *NBSlu_3700) GetBand() int32 {
	if m != nil {
		return m.Band
	}
	return 0
}

func (m *NBSlu_3700) GetRsrp() int64 {
	if m != nil {
		return m.Rsrp
	}
	return 0
}

func (m *NBSlu_3700) GetSnr() int64 {
	if m != nil {
		return m.Snr
	}
	return 0
}

// 时间
type NBSlu_1400 struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 时间
	SluitemTime int64 `protobuf:"varint,2,opt,name=sluitem_time,json=sluitemTime,proto3" json:"sluitem_time,omitempty"`
	// 星期
	Week int32 `protobuf:"varint,3,opt,name=week,proto3" json:"week,omitempty"`
	// 应答状态 (0x35为成功，其它失败)
	Status int32 `protobuf:"varint,4,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *NBSlu_1400) Reset()         { *m = NBSlu_1400{} }
func (m *NBSlu_1400) String() string { return proto.CompactTextString(m) }
func (*NBSlu_1400) ProtoMessage()    {}
func (*NBSlu_1400) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{7}
}
func (m *NBSlu_1400) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NBSlu_1400) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NBSlu_1400.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NBSlu_1400) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NBSlu_1400.Merge(m, src)
}
func (m *NBSlu_1400) XXX_Size() int {
	return m.Size()
}
func (m *NBSlu_1400) XXX_DiscardUnknown() {
	xxx_messageInfo_NBSlu_1400.DiscardUnknown(m)
}

var xxx_messageInfo_NBSlu_1400 proto.InternalMessageInfo

func (m *NBSlu_1400) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *NBSlu_1400) GetSluitemTime() int64 {
	if m != nil {
		return m.SluitemTime
	}
	return 0
}

func (m *NBSlu_1400) GetWeek() int32 {
	if m != nil {
		return m.Week
	}
	return 0
}

func (m *NBSlu_1400) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

// 版本
type NBSlu_5100 struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 版本
	Ver string `protobuf:"bytes,2,opt,name=ver,proto3" json:"ver,omitempty"`
	// 应答状态 (0x35为成功，其它失败)
	Status int32 `protobuf:"varint,3,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *NBSlu_5100) Reset()         { *m = NBSlu_5100{} }
func (m *NBSlu_5100) String() string { return proto.CompactTextString(m) }
func (*NBSlu_5100) ProtoMessage()    {}
func (*NBSlu_5100) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{8}
}
func (m *NBSlu_5100) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NBSlu_5100) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NBSlu_5100.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NBSlu_5100) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NBSlu_5100.Merge(m, src)
}
func (m *NBSlu_5100) XXX_Size() int {
	return m.Size()
}
func (m *NBSlu_5100) XXX_DiscardUnknown() {
	xxx_messageInfo_NBSlu_5100.DiscardUnknown(m)
}

var xxx_messageInfo_NBSlu_5100 proto.InternalMessageInfo

func (m *NBSlu_5100) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *NBSlu_5100) GetVer() string {
	if m != nil {
		return m.Ver
	}
	return ""
}

func (m *NBSlu_5100) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

// 运行参数
type NBSlu_5200 struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 经度
	Longitude float64 `protobuf:"fixed64,2,opt,name=longitude,proto3" json:"longitude,omitempty"`
	// 纬度
	Latitude float64 `protobuf:"fixed64,3,opt,name=latitude,proto3" json:"latitude,omitempty"`
	// 控制器状态 0-停运，1-投运
	SluitemStatus int32 `protobuf:"varint,4,opt,name=sluitem_status,json=sluitemStatus,proto3" json:"sluitem_status,omitempty"`
	// 控制器上电开灯 1-开灯，0-关灯
	SluitemPowerTurnon []int32 `protobuf:"varint,5,rep,packed,name=sluitem_power_turnon,json=sluitemPowerTurnon,proto3" json:"sluitem_power_turnon,omitempty"`
	// 控制器主报 0-禁止主报，1-允许主报
	SluitemEnableAlarm int32 `protobuf:"varint,6,opt,name=sluitem_enable_alarm,json=sluitemEnableAlarm,proto3" json:"sluitem_enable_alarm,omitempty"`
	// 1-4回路额定功率
	RatedPower []int32 `protobuf:"varint,7,rep,packed,name=rated_power,json=ratedPower,proto3" json:"rated_power,omitempty"`
	// nb主报间隔，(0～127)*5
	UplinkTimer int32 `protobuf:"varint,8,opt,name=uplink_timer,json=uplinkTimer,proto3" json:"uplink_timer,omitempty"`
	// nb主报需要主站应答，0-不需要，1-需要
	UplinkReply int32 `protobuf:"varint,9,opt,name=uplink_reply,json=uplinkReply,proto3" json:"uplink_reply,omitempty"`
	// 实际使用回路数
	UseLoop int32 `protobuf:"varint,10,opt,name=use_loop,json=useLoop,proto3" json:"use_loop,omitempty"`
	// 应答状态 (0x35为成功，其它失败)
	Status int32 `protobuf:"varint,11,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *NBSlu_5200) Reset()         { *m = NBSlu_5200{} }
func (m *NBSlu_5200) String() string { return proto.CompactTextString(m) }
func (*NBSlu_5200) ProtoMessage()    {}
func (*NBSlu_5200) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{9}
}
func (m *NBSlu_5200) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NBSlu_5200) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NBSlu_5200.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NBSlu_5200) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NBSlu_5200.Merge(m, src)
}
func (m *NBSlu_5200) XXX_Size() int {
	return m.Size()
}
func (m *NBSlu_5200) XXX_DiscardUnknown() {
	xxx_messageInfo_NBSlu_5200.DiscardUnknown(m)
}

var xxx_messageInfo_NBSlu_5200 proto.InternalMessageInfo

func (m *NBSlu_5200) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *NBSlu_5200) GetLongitude() float64 {
	if m != nil {
		return m.Longitude
	}
	return 0
}

func (m *NBSlu_5200) GetLatitude() float64 {
	if m != nil {
		return m.Latitude
	}
	return 0
}

func (m *NBSlu_5200) GetSluitemStatus() int32 {
	if m != nil {
		return m.SluitemStatus
	}
	return 0
}

func (m *NBSlu_5200) GetSluitemPowerTurnon() []int32 {
	if m != nil {
		return m.SluitemPowerTurnon
	}
	return nil
}

func (m *NBSlu_5200) GetSluitemEnableAlarm() int32 {
	if m != nil {
		return m.SluitemEnableAlarm
	}
	return 0
}

func (m *NBSlu_5200) GetRatedPower() []int32 {
	if m != nil {
		return m.RatedPower
	}
	return nil
}

func (m *NBSlu_5200) GetUplinkTimer() int32 {
	if m != nil {
		return m.UplinkTimer
	}
	return 0
}

func (m *NBSlu_5200) GetUplinkReply() int32 {
	if m != nil {
		return m.UplinkReply
	}
	return 0
}

func (m *NBSlu_5200) GetUseLoop() int32 {
	if m != nil {
		return m.UseLoop
	}
	return 0
}

func (m *NBSlu_5200) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

// 即时控制
type NBSlu_5400 struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 输出类型0-继电器，1-pwm输出
	OutputType int32 `protobuf:"varint,2,opt,name=output_type,json=outputType,proto3" json:"output_type,omitempty"`
	// 继电器操作回路1-4, 0x0-不操作，0x3-开灯，0xc-关灯
	RelayOperate []int32 `protobuf:"varint,3,rep,packed,name=relay_operate,json=relayOperate,proto3" json:"relay_operate,omitempty"`
	// PWM操作回路
	PwmLoop []int32 `protobuf:"varint,4,rep,packed,name=pwm_loop,json=pwmLoop,proto3" json:"pwm_loop,omitempty"`
	// PWM操作占空比
	PwmPower int32 `protobuf:"varint,5,opt,name=pwm_power,json=pwmPower,proto3" json:"pwm_power,omitempty"`
	// PWM频率 (1~15) * 100 默认为4
	PwmBaudrate int32 `protobuf:"varint,6,opt,name=pwm_baudrate,json=pwmBaudrate,proto3" json:"pwm_baudrate,omitempty"`
	// 应答状态 (0x35为成功，其它失败)
	Status int32 `protobuf:"varint,7,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *NBSlu_5400) Reset()         { *m = NBSlu_5400{} }
func (m *NBSlu_5400) String() string { return proto.CompactTextString(m) }
func (*NBSlu_5400) ProtoMessage()    {}
func (*NBSlu_5400) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{10}
}
func (m *NBSlu_5400) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NBSlu_5400) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NBSlu_5400.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NBSlu_5400) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NBSlu_5400.Merge(m, src)
}
func (m *NBSlu_5400) XXX_Size() int {
	return m.Size()
}
func (m *NBSlu_5400) XXX_DiscardUnknown() {
	xxx_messageInfo_NBSlu_5400.DiscardUnknown(m)
}

var xxx_messageInfo_NBSlu_5400 proto.InternalMessageInfo

func (m *NBSlu_5400) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *NBSlu_5400) GetOutputType() int32 {
	if m != nil {
		return m.OutputType
	}
	return 0
}

func (m *NBSlu_5400) GetRelayOperate() []int32 {
	if m != nil {
		return m.RelayOperate
	}
	return nil
}

func (m *NBSlu_5400) GetPwmLoop() []int32 {
	if m != nil {
		return m.PwmLoop
	}
	return nil
}

func (m *NBSlu_5400) GetPwmPower() int32 {
	if m != nil {
		return m.PwmPower
	}
	return 0
}

func (m *NBSlu_5400) GetPwmBaudrate() int32 {
	if m != nil {
		return m.PwmBaudrate
	}
	return 0
}

func (m *NBSlu_5400) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

// 复位
type NBSlu_5500 struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// MCU复位 0-不勾选 1-勾选
	Mcu int32 `protobuf:"varint,2,opt,name=mcu,proto3" json:"mcu,omitempty"`
	// 初始化MCU硬件配置 0-不勾选 1-勾选 (暂不使用)
	InitializeMcu int32 `protobuf:"varint,3,opt,name=initialize_mcu,json=initializeMcu,proto3" json:"initialize_mcu,omitempty"`
	// 初始化RAM区所有变量 0-不勾选 1-勾选 (暂不使用)
	InitializeRam int32 `protobuf:"varint,4,opt,name=initialize_ram,json=initializeRam,proto3" json:"initialize_ram,omitempty"`
	// EEPROM全部清零 0-不勾选 1-勾选 (暂不使用)
	InitializeEeprom int32 `protobuf:"varint,5,opt,name=initialize_eeprom,json=initializeEeprom,proto3" json:"initialize_eeprom,omitempty"`
	// 电能计量值清零 0-不勾选 1-勾选
	InitializeElec int32 `protobuf:"varint,6,opt,name=initialize_elec,json=initializeElec,proto3" json:"initialize_elec,omitempty"`
	// 应答状态 (0x35为成功，其它失败)
	Status int32 `protobuf:"varint,7,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *NBSlu_5500) Reset()         { *m = NBSlu_5500{} }
func (m *NBSlu_5500) String() string { return proto.CompactTextString(m) }
func (*NBSlu_5500) ProtoMessage()    {}
func (*NBSlu_5500) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{11}
}
func (m *NBSlu_5500) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NBSlu_5500) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NBSlu_5500.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NBSlu_5500) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NBSlu_5500.Merge(m, src)
}
func (m *NBSlu_5500) XXX_Size() int {
	return m.Size()
}
func (m *NBSlu_5500) XXX_DiscardUnknown() {
	xxx_messageInfo_NBSlu_5500.DiscardUnknown(m)
}

var xxx_messageInfo_NBSlu_5500 proto.InternalMessageInfo

func (m *NBSlu_5500) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *NBSlu_5500) GetMcu() int32 {
	if m != nil {
		return m.Mcu
	}
	return 0
}

func (m *NBSlu_5500) GetInitializeMcu() int32 {
	if m != nil {
		return m.InitializeMcu
	}
	return 0
}

func (m *NBSlu_5500) GetInitializeRam() int32 {
	if m != nil {
		return m.InitializeRam
	}
	return 0
}

func (m *NBSlu_5500) GetInitializeEeprom() int32 {
	if m != nil {
		return m.InitializeEeprom
	}
	return 0
}

func (m *NBSlu_5500) GetInitializeElec() int32 {
	if m != nil {
		return m.InitializeElec
	}
	return 0
}

func (m *NBSlu_5500) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

// 本地控制方案
type NBSlu_5600 struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 是否清除原方案 0-保留 1-清除
	ClearOldRuntime int32 `protobuf:"varint,2,opt,name=clear_old_runtime,json=clearOldRuntime,proto3" json:"clear_old_runtime,omitempty"`
	// 是否含有后续数据
	DataContinue int32 `protobuf:"varint,3,opt,name=data_continue,json=dataContinue,proto3" json:"data_continue,omitempty"`
	// 后续方案个数
	SluitemRuntimeCount int32 `protobuf:"varint,4,opt,name=sluitem_runtime_count,json=sluitemRuntimeCount,proto3" json:"sluitem_runtime_count,omitempty"`
	// 方案
	SluitemRuntime []*NBSlu_5600_SluitemRuntime `protobuf:"bytes,5,rep,name=sluitem_runtime,json=sluitemRuntime,proto3" json:"sluitem_runtime,omitempty"`
	// 应答状态 (0x35为成功，其它失败)
	Status int32 `protobuf:"varint,6,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *NBSlu_5600) Reset()         { *m = NBSlu_5600{} }
func (m *NBSlu_5600) String() string { return proto.CompactTextString(m) }
func (*NBSlu_5600) ProtoMessage()    {}
func (*NBSlu_5600) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{12}
}
func (m *NBSlu_5600) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NBSlu_5600) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NBSlu_5600.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NBSlu_5600) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NBSlu_5600.Merge(m, src)
}
func (m *NBSlu_5600) XXX_Size() int {
	return m.Size()
}
func (m *NBSlu_5600) XXX_DiscardUnknown() {
	xxx_messageInfo_NBSlu_5600.DiscardUnknown(m)
}

var xxx_messageInfo_NBSlu_5600 proto.InternalMessageInfo

func (m *NBSlu_5600) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *NBSlu_5600) GetClearOldRuntime() int32 {
	if m != nil {
		return m.ClearOldRuntime
	}
	return 0
}

func (m *NBSlu_5600) GetDataContinue() int32 {
	if m != nil {
		return m.DataContinue
	}
	return 0
}

func (m *NBSlu_5600) GetSluitemRuntimeCount() int32 {
	if m != nil {
		return m.SluitemRuntimeCount
	}
	return 0
}

func (m *NBSlu_5600) GetSluitemRuntime() []*NBSlu_5600_SluitemRuntime {
	if m != nil {
		return m.SluitemRuntime
	}
	return nil
}

func (m *NBSlu_5600) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

type NBSlu_5600_SluitemRuntime struct {
	// 输出类型0-继电器，1-pwm输出
	OutputType int32 `protobuf:"varint,1,opt,name=output_type,json=outputType,proto3" json:"output_type,omitempty"`
	// 操作类型1-定时操作，2-经纬度操作
	OperateType int32 `protobuf:"varint,2,opt,name=operate_type,json=operateType,proto3" json:"operate_type,omitempty"`
	// 有效日期，0-6～周日-周6
	DateEnable []int32 `protobuf:"varint,3,rep,packed,name=date_enable,json=dateEnable,proto3" json:"date_enable,omitempty"`
	// 开关灯操作时间 hhmm->int32
	OperateTime int32 `protobuf:"varint,4,opt,name=operate_time,json=operateTime,proto3" json:"operate_time,omitempty"`
	// 操作偏移 -720~+720
	OperateOffset int32 `protobuf:"varint,5,opt,name=operate_offset,json=operateOffset,proto3" json:"operate_offset,omitempty"`
	// 继电器操作回路1-4, 0x0-不操作，0x3-开灯，0xc-关灯
	RelayOperate []int32 `protobuf:"varint,6,rep,packed,name=relay_operate,json=relayOperate,proto3" json:"relay_operate,omitempty"`
	// PWM操作回路
	PwmLoop []int32 `protobuf:"varint,7,rep,packed,name=pwm_loop,json=pwmLoop,proto3" json:"pwm_loop,omitempty"`
	// PWM操作占空比
	PwmPower int32 `protobuf:"varint,8,opt,name=pwm_power,json=pwmPower,proto3" json:"pwm_power,omitempty"`
	// PWM频率 (1~15) * 100 默认为4
	PwmBaudrate int32 `protobuf:"varint,9,opt,name=pwm_baudrate,json=pwmBaudrate,proto3" json:"pwm_baudrate,omitempty"`
}

func (m *NBSlu_5600_SluitemRuntime) Reset()         { *m = NBSlu_5600_SluitemRuntime{} }
func (m *NBSlu_5600_SluitemRuntime) String() string { return proto.CompactTextString(m) }
func (*NBSlu_5600_SluitemRuntime) ProtoMessage()    {}
func (*NBSlu_5600_SluitemRuntime) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{12, 0}
}
func (m *NBSlu_5600_SluitemRuntime) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NBSlu_5600_SluitemRuntime) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NBSlu_5600_SluitemRuntime.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NBSlu_5600_SluitemRuntime) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NBSlu_5600_SluitemRuntime.Merge(m, src)
}
func (m *NBSlu_5600_SluitemRuntime) XXX_Size() int {
	return m.Size()
}
func (m *NBSlu_5600_SluitemRuntime) XXX_DiscardUnknown() {
	xxx_messageInfo_NBSlu_5600_SluitemRuntime.DiscardUnknown(m)
}

var xxx_messageInfo_NBSlu_5600_SluitemRuntime proto.InternalMessageInfo

func (m *NBSlu_5600_SluitemRuntime) GetOutputType() int32 {
	if m != nil {
		return m.OutputType
	}
	return 0
}

func (m *NBSlu_5600_SluitemRuntime) GetOperateType() int32 {
	if m != nil {
		return m.OperateType
	}
	return 0
}

func (m *NBSlu_5600_SluitemRuntime) GetDateEnable() []int32 {
	if m != nil {
		return m.DateEnable
	}
	return nil
}

func (m *NBSlu_5600_SluitemRuntime) GetOperateTime() int32 {
	if m != nil {
		return m.OperateTime
	}
	return 0
}

func (m *NBSlu_5600_SluitemRuntime) GetOperateOffset() int32 {
	if m != nil {
		return m.OperateOffset
	}
	return 0
}

func (m *NBSlu_5600_SluitemRuntime) GetRelayOperate() []int32 {
	if m != nil {
		return m.RelayOperate
	}
	return nil
}

func (m *NBSlu_5600_SluitemRuntime) GetPwmLoop() []int32 {
	if m != nil {
		return m.PwmLoop
	}
	return nil
}

func (m *NBSlu_5600_SluitemRuntime) GetPwmPower() int32 {
	if m != nil {
		return m.PwmPower
	}
	return 0
}

func (m *NBSlu_5600_SluitemRuntime) GetPwmBaudrate() int32 {
	if m != nil {
		return m.PwmBaudrate
	}
	return 0
}

// 远程升级相关
// 查询版本
type NBSlu_FF05 struct {
	// 版本号
	Ver string `protobuf:"bytes,1,opt,name=ver,proto3" json:"ver,omitempty"`
}

func (m *NBSlu_FF05) Reset()         { *m = NBSlu_FF05{} }
func (m *NBSlu_FF05) String() string { return proto.CompactTextString(m) }
func (*NBSlu_FF05) ProtoMessage()    {}
func (*NBSlu_FF05) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{13}
}
func (m *NBSlu_FF05) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NBSlu_FF05) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NBSlu_FF05.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NBSlu_FF05) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NBSlu_FF05.Merge(m, src)
}
func (m *NBSlu_FF05) XXX_Size() int {
	return m.Size()
}
func (m *NBSlu_FF05) XXX_DiscardUnknown() {
	xxx_messageInfo_NBSlu_FF05.DiscardUnknown(m)
}

var xxx_messageInfo_NBSlu_FF05 proto.InternalMessageInfo

func (m *NBSlu_FF05) GetVer() string {
	if m != nil {
		return m.Ver
	}
	return ""
}

// 查询升级状态
type NBSlu_FF07 struct {
	// 数据包总数
	DatapackTotal int32 `protobuf:"varint,1,opt,name=datapack_total,json=datapackTotal,proto3" json:"datapack_total,omitempty"`
	// 数据包状态
	DatapackStatus []int32 `protobuf:"varint,2,rep,packed,name=datapack_status,json=datapackStatus,proto3" json:"datapack_status,omitempty"`
}

func (m *NBSlu_FF07) Reset()         { *m = NBSlu_FF07{} }
func (m *NBSlu_FF07) String() string { return proto.CompactTextString(m) }
func (*NBSlu_FF07) ProtoMessage()    {}
func (*NBSlu_FF07) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{14}
}
func (m *NBSlu_FF07) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NBSlu_FF07) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NBSlu_FF07.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NBSlu_FF07) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NBSlu_FF07.Merge(m, src)
}
func (m *NBSlu_FF07) XXX_Size() int {
	return m.Size()
}
func (m *NBSlu_FF07) XXX_DiscardUnknown() {
	xxx_messageInfo_NBSlu_FF07.DiscardUnknown(m)
}

var xxx_messageInfo_NBSlu_FF07 proto.InternalMessageInfo

func (m *NBSlu_FF07) GetDatapackTotal() int32 {
	if m != nil {
		return m.DatapackTotal
	}
	return 0
}

func (m *NBSlu_FF07) GetDatapackStatus() []int32 {
	if m != nil {
		return m.DatapackStatus
	}
	return nil
}

// 升级完成通知
type NBSlu_FF01 struct {
	// 旧版本
	OldVer string `protobuf:"bytes,1,opt,name=old_ver,json=oldVer,proto3" json:"old_ver,omitempty"`
	// 新版本
	NewVer string `protobuf:"bytes,2,opt,name=new_ver,json=newVer,proto3" json:"new_ver,omitempty"`
}

func (m *NBSlu_FF01) Reset()         { *m = NBSlu_FF01{} }
func (m *NBSlu_FF01) String() string { return proto.CompactTextString(m) }
func (*NBSlu_FF01) ProtoMessage()    {}
func (*NBSlu_FF01) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{15}
}
func (m *NBSlu_FF01) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NBSlu_FF01) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NBSlu_FF01.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NBSlu_FF01) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NBSlu_FF01.Merge(m, src)
}
func (m *NBSlu_FF01) XXX_Size() int {
	return m.Size()
}
func (m *NBSlu_FF01) XXX_DiscardUnknown() {
	xxx_messageInfo_NBSlu_FF01.DiscardUnknown(m)
}

var xxx_messageInfo_NBSlu_FF01 proto.InternalMessageInfo

func (m *NBSlu_FF01) GetOldVer() string {
	if m != nil {
		return m.OldVer
	}
	return ""
}

func (m *NBSlu_FF01) GetNewVer() string {
	if m != nil {
		return m.NewVer
	}
	return ""
}

func init() {
	proto.RegisterType((*MsgNBiot)(nil), "wlst.nbiot.MsgNBiot")
	proto.RegisterType((*MsgNBOpen)(nil), "wlst.nbiot.MsgNBOpen")
	proto.RegisterType((*SluitemConfig)(nil), "wlst.nbiot.SluitemConfig")
	proto.RegisterType((*SluitemConfig_DataMark)(nil), "wlst.nbiot.SluitemConfig.Data_mark")
	proto.RegisterType((*SluitemConfig_SetMark)(nil), "wlst.nbiot.SluitemConfig.Set_mark")
	proto.RegisterType((*SluitemConfig_SluitemPara)(nil), "wlst.nbiot.SluitemConfig.Sluitem_para")
	proto.RegisterType((*SluitemConfig_SluitemVer)(nil), "wlst.nbiot.SluitemConfig.Sluitem_ver")
	proto.RegisterType((*SluitemConfig_SluitemSunriseset)(nil), "wlst.nbiot.SluitemConfig.Sluitem_sunriseset")
	proto.RegisterType((*SluitemConfig_SluitemRuntime)(nil), "wlst.nbiot.SluitemConfig.Sluitem_runtime")
	proto.RegisterType((*SluitemReply)(nil), "wlst.nbiot.SluitemReply")
	proto.RegisterType((*SluitemData)(nil), "wlst.nbiot.SluitemData")
	proto.RegisterType((*SluitemData_ModelInfo)(nil), "wlst.nbiot.SluitemData.Model_info")
	proto.RegisterType((*SluitemData_LightData)(nil), "wlst.nbiot.SluitemData.Light_data")
	proto.RegisterType((*SluitemData_LightStatus)(nil), "wlst.nbiot.SluitemData.Light_status")
	proto.RegisterType((*SluitemData_SluitemStatus)(nil), "wlst.nbiot.SluitemData.Sluitem_status")
	proto.RegisterType((*SluitemData_TimeFault)(nil), "wlst.nbiot.SluitemData.Time_fault")
	proto.RegisterType((*SluitemData_SluitemPara)(nil), "wlst.nbiot.SluitemData.Sluitem_para")
	proto.RegisterType((*NBSlu_3100)(nil), "wlst.nbiot.NBSlu_3100")
	proto.RegisterType((*NBSlu_3700)(nil), "wlst.nbiot.NBSlu_3700")
	proto.RegisterType((*NBSlu_1400)(nil), "wlst.nbiot.NBSlu_1400")
	proto.RegisterType((*NBSlu_5100)(nil), "wlst.nbiot.NBSlu_5100")
	proto.RegisterType((*NBSlu_5200)(nil), "wlst.nbiot.NBSlu_5200")
	proto.RegisterType((*NBSlu_5400)(nil), "wlst.nbiot.NBSlu_5400")
	proto.RegisterType((*NBSlu_5500)(nil), "wlst.nbiot.NBSlu_5500")
	proto.RegisterType((*NBSlu_5600)(nil), "wlst.nbiot.NBSlu_5600")
	proto.RegisterType((*NBSlu_5600_SluitemRuntime)(nil), "wlst.nbiot.NBSlu_5600.Sluitem_runtime")
	proto.RegisterType((*NBSlu_FF05)(nil), "wlst.nbiot.NBSlu_FF05")
	proto.RegisterType((*NBSlu_FF07)(nil), "wlst.nbiot.NBSlu_FF07")
	proto.RegisterType((*NBSlu_FF01)(nil), "wlst.nbiot.NBSlu_FF01")
}

func init() { proto.RegisterFile("msg_nb.proto", fileDescriptor_7d0ba9a34991f86e) }

var fileDescriptor_7d0ba9a34991f86e = []byte{
	// 2713 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x59, 0x4b, 0x6f, 0x1c, 0xc7,
	0xf1, 0xd7, 0x72, 0xdf, 0xb5, 0xbb, 0x24, 0x35, 0xd6, 0x63, 0xb4, 0xfe, 0x9b, 0xa2, 0xa8, 0xbf,
	0x65, 0x26, 0x76, 0x84, 0x15, 0xad, 0x15, 0x81, 0x04, 0x0e, 0x2c, 0xc9, 0xa6, 0x23, 0x40, 0x12,
	0x8d, 0x21, 0xe1, 0x4b, 0x10, 0x4c, 0x9a, 0x33, 0xcd, 0xd5, 0x80, 0xb3, 0x33, 0xa3, 0x79, 0x90,
	0x62, 0x80, 0xdc, 0x72, 0xc8, 0x21, 0x01, 0x72, 0xc8, 0x35, 0x1f, 0x22, 0x41, 0x3e, 0x41, 0x4e,
	0x39, 0xe4, 0xe0, 0xa3, 0x81, 0x5c, 0x02, 0x09, 0x08, 0x90, 0x5c, 0xf3, 0x05, 0x82, 0xaa, 0xea,
	0x9e, 0x07, 0x97, 0xcb, 0x65, 0x6e, 0xd3, 0xbf, 0xaa, 0xea, 0xae, 0xee, 0xae, 0xfa, 0x75, 0x75,
	0x0f, 0xf4, 0xa7, 0xc9, 0xc4, 0x0e, 0x0e, 0xee, 0x47, 0x71, 0x98, 0x86, 0x06, 0x9c, 0xf8, 0x49,
	0x7a, 0x3f, 0x38, 0xf0, 0xc2, 0x74, 0xe3, 0xd7, 0x35, 0xe8, 0xbc, 0x48, 0x26, 0x2f, 0x9f, 0x78,
	0x61, 0x6a, 0xdc, 0x84, 0xb6, 0x33, 0x75, 0x6d, 0xcf, 0x7d, 0x63, 0xd6, 0xd6, 0x6b, 0x9b, 0x75,
	0xab, 0xe5, 0x4c, 0xdd, 0x67, 0xee, 0x1b, 0xe3, 0x16, 0x74, 0x50, 0x10, 0x88, 0xa9, 0x34, 0x97,
	0xd6, 0x6b, 0x9b, 0x5d, 0x0b, 0x15, 0x5f, 0x8a, 0xa9, 0xd4, 0xa2, 0x43, 0x5f, 0x4c, 0xcc, 0xfa,
	0x7a, 0x6d, 0xb3, 0x49, 0xa2, 0x1d, 0x5f, 0x4c, 0x0c, 0x03, 0x1a, 0xde, 0x54, 0x7a, 0x66, 0x63,
	0xbd, 0xbe, 0x59, 0xb7, 0xe8, 0x1b, 0xd5, 0x63, 0x71, 0x62, 0xbb, 0x22, 0x15, 0x66, 0x73, 0xbd,
	0x8e, 0xea, 0xb1, 0x38, 0xf9, 0x42, 0xa4, 0x62, 0xe3, 0x6d, 0x1b, 0xba, 0xe4, 0xca, 0x6e, 0x24,
	0x83, 0xdc, 0x98, 0x1d, 0x61, 0xe3, 0x0f, 0x00, 0xdc, 0xd4, 0x8e, 0xa5, 0x23, 0xbd, 0x63, 0x76,
	0xa4, 0x6e, 0x75, 0xdd, 0xd4, 0x62, 0xc0, 0x78, 0x1f, 0xba, 0xd8, 0xaf, 0x9d, 0x9e, 0x46, 0x52,
	0xf9, 0xd2, 0x41, 0x60, 0xff, 0x34, 0x22, 0x3f, 0x49, 0xe8, 0x4c, 0x5d, 0xb3, 0xcb, 0x53, 0xc0,
	0xf6, 0xd3, 0xa9, 0x6b, 0xfc, 0x10, 0xfa, 0x89, 0x9f, 0x79, 0xa9, 0x9c, 0xb2, 0x5f, 0xb0, 0x5e,
	0xdb, 0xec, 0x6d, 0xdd, 0xbc, 0x5f, 0x2c, 0xd3, 0xfd, 0x3d, 0x96, 0xa3, 0x9f, 0x56, 0x2f, 0x29,
	0x1a, 0xc6, 0x67, 0x30, 0xd0, 0xb6, 0xb1, 0x8c, 0xfc, 0x53, 0xb3, 0x47, 0xc6, 0xe6, 0x39, 0xc6,
	0x16, 0xca, 0x2d, 0x3d, 0x14, 0xb5, 0x8c, 0xcf, 0x61, 0x59, 0x9b, 0x3b, 0x61, 0x70, 0xe8, 0x4d,
	0xcc, 0x3e, 0xd9, 0xdf, 0x3a, 0xc7, 0xfe, 0x29, 0x29, 0x58, 0x7a, 0x3c, 0x6e, 0x1a, 0x8f, 0xa0,
	0x17, 0x1c, 0xd8, 0x89, 0x9f, 0xd9, 0x9f, 0x3e, 0x18, 0x8d, 0xcc, 0x01, 0x99, 0xdf, 0x28, 0x9b,
	0xbf, 0x7c, 0xb2, 0xa7, 0xa4, 0x56, 0x37, 0x38, 0xd8, 0xf3, 0x33, 0xfc, 0x2c, 0xdb, 0x6d, 0x8f,
	0x46, 0xe6, 0xf2, 0x5c, 0xbb, 0xed, 0xc2, 0x6e, 0xbb, 0x62, 0xf7, 0xe0, 0xe1, 0x68, 0x64, 0xae,
	0xcc, 0xb3, 0x43, 0xa9, 0xb2, 0xc3, 0xcf, 0x92, 0xdd, 0x18, 0xfd, 0x5c, 0x9d, 0x67, 0x37, 0x2e,
	0xfc, 0x1c, 0x2b, 0x3f, 0x5f, 0x2a, 0xbb, 0xad, 0xd1, 0xc8, 0xbc, 0x3a, 0xd7, 0x6e, 0x0b, 0xed,
	0x5e, 0x92, 0xdd, 0x56, 0xd5, 0x0e, 0xfd, 0x34, 0xe6, 0xda, 0x3d, 0x2c, 0xec, 0x1e, 0x56, 0xed,
	0xc6, 0xa3, 0x91, 0xf9, 0xde, 0x5c, 0xbb, 0x71, 0x61, 0x37, 0xae, 0xda, 0x3d, 0x1a, 0x8d, 0xcc,
	0x6b, 0x73, 0xed, 0x1e, 0x15, 0x76, 0x8f, 0x46, 0x23, 0x0a, 0x5a, 0x79, 0xec, 0x39, 0xd2, 0xf6,
	0x5c, 0xf3, 0x3a, 0x05, 0x66, 0x87, 0x81, 0x67, 0xae, 0xb1, 0x0a, 0xf5, 0x44, 0xbe, 0x36, 0x1b,
	0x14, 0xcb, 0xf8, 0x69, 0xdc, 0x80, 0x56, 0x92, 0x8a, 0x34, 0x4b, 0xcc, 0x26, 0x81, 0xaa, 0x55,
	0x1a, 0xfe, 0xf0, 0x70, 0x34, 0x36, 0x6f, 0xcc, 0x1b, 0x7e, 0x67, 0x67, 0x34, 0x56, 0xc3, 0xef,
	0x1c, 0x8e, 0xc6, 0x55, 0xbb, 0x6d, 0xf3, 0xe6, 0x05, 0x76, 0xdb, 0x85, 0xdd, 0x76, 0xd5, 0xee,
	0x81, 0x69, 0x5e, 0x60, 0xf7, 0xa0, 0xb0, 0x7b, 0xb0, 0xf1, 0xe7, 0x15, 0x18, 0x54, 0xe2, 0xf9,
	0x2c, 0xe9, 0x34, 0x73, 0xd2, 0xb9, 0x0d, 0x3a, 0xd3, 0x48, 0xc8, 0xe9, 0x0e, 0x0a, 0x42, 0x85,
	0xcf, 0x55, 0xbe, 0x4f, 0x45, 0x7c, 0x44, 0x6b, 0xd4, 0xdb, 0xba, 0x3b, 0x37, 0x6f, 0xee, 0x7f,
	0xa1, 0x55, 0x99, 0x14, 0x5e, 0x88, 0xf8, 0x08, 0x09, 0xc5, 0x0f, 0xc3, 0xc8, 0x76, 0xc2, 0x2c,
	0x48, 0xd5, 0x8a, 0x76, 0x11, 0x79, 0x8a, 0x80, 0x71, 0xa7, 0x20, 0x86, 0xd4, 0x9b, 0x4a, 0xb3,
	0x4d, 0x2e, 0x68, 0xaf, 0xf6, 0xbd, 0xa9, 0x34, 0x9e, 0x15, 0x2a, 0x91, 0x88, 0x85, 0xd9, 0x21,
	0x37, 0xee, 0xcd, 0x77, 0x63, 0xaf, 0xa4, 0x9d, 0x77, 0xf5, 0xb5, 0x88, 0x85, 0xb1, 0x53, 0xcc,
	0xf7, 0x58, 0xc6, 0x8a, 0x85, 0x3e, 0x5c, 0xdc, 0xd3, 0xb1, 0x8c, 0xf3, 0x65, 0xf9, 0x46, 0xc6,
	0xc6, 0x4f, 0xc1, 0xd0, 0xfd, 0x24, 0x59, 0x10, 0x7b, 0x89, 0x4c, 0x64, 0xaa, 0x78, 0xe9, 0x93,
	0xc5, 0xdd, 0x15, 0x36, 0xd6, 0x55, 0xd5, 0xcf, 0x5e, 0x0e, 0x19, 0x16, 0xac, 0xe4, 0x7c, 0x97,
	0x05, 0xb4, 0x2a, 0xfd, 0xf5, 0xfa, 0x66, 0x6f, 0xeb, 0x7b, 0x8b, 0x7b, 0x56, 0x06, 0x96, 0xa6,
	0x3c, 0x8b, 0xdb, 0xa5, 0x98, 0x5e, 0xae, 0xc4, 0xf4, 0x67, 0xd0, 0x49, 0x64, 0xca, 0xdb, 0xcb,
	0x3c, 0xb3, 0x71, 0xc1, 0x20, 0x4a, 0xd3, 0x6a, 0x27, 0x32, 0xc5, 0xcd, 0x1d, 0xfe, 0xa9, 0x06,
	0xdd, 0x7c, 0xd3, 0x71, 0xab, 0x63, 0x29, 0x5c, 0xda, 0xc8, 0x98, 0x82, 0xa9, 0x69, 0x75, 0x11,
	0xc1, 0x6d, 0x8c, 0x31, 0x0d, 0x49, 0x2c, 0xe2, 0x49, 0xa2, 0xcf, 0x0e, 0x04, 0x1e, 0xc7, 0x93,
	0x84, 0x0e, 0x2d, 0x14, 0xe2, 0xb6, 0x70, 0x90, 0xb4, 0xb1, 0x8d, 0x8b, 0xfd, 0x11, 0xac, 0x90,
	0xa8, 0xb4, 0xd2, 0x2d, 0xd2, 0x58, 0x46, 0xb8, 0xb4, 0x70, 0x1f, 0xc2, 0x72, 0x3e, 0x7e, 0x2a,
	0x0e, 0x7c, 0x8e, 0xa6, 0xa6, 0x35, 0xd0, 0x3e, 0x10, 0x38, 0xfc, 0x55, 0x0d, 0x3a, 0x7a, 0x2a,
	0xe8, 0x14, 0x2e, 0x00, 0xbb, 0xcc, 0xc9, 0x81, 0x2b, 0xc2, 0x1e, 0xdf, 0xe2, 0xd5, 0x21, 0x87,
	0x79, 0x3a, 0x38, 0x73, 0xf2, 0x57, 0xd9, 0xc5, 0xe4, 0x4e, 0x23, 0xb7, 0xb3, 0xc8, 0x91, 0xbb,
	0x30, 0xd0, 0x9d, 0xb2, 0x1f, 0x3c, 0xa3, 0xbe, 0xea, 0x98, 0xdd, 0xf8, 0xcb, 0x12, 0xf4, 0xcb,
	0x91, 0x8a, 0xee, 0xe7, 0x41, 0xc5, 0x7b, 0xc5, 0x63, 0xea, 0xd3, 0x68, 0x8f, 0xb7, 0x6c, 0x04,
	0xd7, 0xb4, 0x9a, 0x0c, 0xb0, 0x27, 0x5b, 0xf8, 0x22, 0x9e, 0xaa, 0x15, 0xd5, 0x71, 0xf9, 0x25,
	0x89, 0x1e, 0xa3, 0xc4, 0x78, 0x58, 0x58, 0x44, 0xe1, 0x89, 0x8c, 0xed, 0x34, 0x8b, 0x83, 0x30,
	0xa0, 0xa2, 0xa1, 0xf9, 0x64, 0x69, 0xb5, 0x96, 0x5b, 0x7d, 0x8d, 0xe2, 0x7d, 0x92, 0x1a, 0xff,
	0x07, 0x5d, 0x3f, 0x0c, 0x26, 0x5e, 0x9a, 0xb9, 0x92, 0x16, 0xbc, 0x66, 0x15, 0x80, 0x31, 0x84,
	0x8e, 0x2f, 0x52, 0x16, 0xb6, 0x49, 0x98, 0xb7, 0x8d, 0xbb, 0xd0, 0x8b, 0x45, 0x2a, 0x5d, 0x1e,
	0xcd, 0xec, 0xe4, 0xc3, 0x00, 0xc1, 0x34, 0x08, 0x26, 0x7e, 0x16, 0xf9, 0x5e, 0x70, 0xa4, 0xd6,
	0xbe, 0x4b, 0xee, 0xf7, 0x18, 0xe3, 0xe5, 0x2f, 0x54, 0xf8, 0xdc, 0x87, 0xb2, 0x0a, 0x1d, 0xee,
	0xc3, 0xdf, 0x2f, 0x41, 0xaf, 0x94, 0xa4, 0x65, 0x3a, 0x41, 0x8e, 0x51, 0x3b, 0xaa, 0x93, 0xfe,
	0x79, 0x18, 0x46, 0xb8, 0x39, 0x32, 0x90, 0xf1, 0xe4, 0xd4, 0x4e, 0xc4, 0xb1, 0x17, 0x4c, 0xd4,
	0x2a, 0xf7, 0x19, 0xdc, 0x23, 0xcc, 0x78, 0x04, 0x37, 0xa5, 0x2f, 0x9d, 0x34, 0xf6, 0x1c, 0xdb,
	0x97, 0xe2, 0x48, 0x4c, 0xa4, 0x3d, 0x0d, 0xdd, 0xcc, 0xd7, 0x55, 0xcf, 0x75, 0x2d, 0x7e, 0xce,
	0xd2, 0x17, 0x24, 0x34, 0x7e, 0x00, 0x46, 0x2a, 0xa7, 0x91, 0x8c, 0x45, 0x9a, 0xc5, 0xb9, 0x09,
	0xc7, 0xc7, 0xd5, 0x92, 0x44, 0xa9, 0xdf, 0x81, 0x3e, 0xcd, 0x5e, 0x2b, 0x72, 0x9c, 0xf4, 0x08,
	0x2b, 0x54, 0x72, 0x82, 0xc4, 0xa2, 0xab, 0x45, 0xe7, 0x57, 0x4e, 0x90, 0x58, 0x77, 0xad, 0x42,
	0x1d, 0xd3, 0xa6, 0x4d, 0x12, 0xfc, 0x1c, 0xee, 0x80, 0x31, 0xcb, 0x35, 0x86, 0x09, 0x6d, 0xd5,
	0x52, 0xeb, 0xa2, 0x9b, 0x44, 0x0f, 0x59, 0x80, 0xa1, 0xbc, 0xa4, 0xe8, 0x81, 0x5a, 0xc3, 0x7f,
	0x2d, 0xc1, 0xca, 0x19, 0x6a, 0xa9, 0x96, 0x80, 0xb5, 0x33, 0x25, 0xe0, 0x6d, 0xe8, 0x85, 0x59,
	0x1a, 0x65, 0x29, 0x8b, 0xb9, 0x37, 0x60, 0x88, 0x14, 0xee, 0x40, 0x3f, 0xa4, 0x45, 0x90, 0xe5,
	0x1a, 0xb2, 0xa7, 0x30, 0x52, 0xb9, 0x0b, 0x3d, 0x17, 0xe5, 0x1c, 0xdd, 0xa5, 0x28, 0x05, 0x84,
	0x39, 0xb0, 0x2b, 0xfd, 0x20, 0x43, 0x36, 0xab, 0xfd, 0xa0, 0xa3, 0x1f, 0xc2, 0xb2, 0x56, 0x09,
	0x0f, 0x0f, 0x0b, 0xda, 0x18, 0x28, 0x74, 0x97, 0x40, 0xe3, 0x23, 0x18, 0xc4, 0xd2, 0x17, 0xa7,
	0xb6, 0x82, 0xcd, 0x76, 0x3e, 0x60, 0x9f, 0x04, 0xbb, 0x8c, 0x1b, 0x1f, 0x40, 0x27, 0x3a, 0x51,
	0x71, 0x55, 0xc4, 0x74, 0x3b, 0x3a, 0xe1, 0xb8, 0x7a, 0x1f, 0xba, 0x28, 0xe6, 0x98, 0xe7, 0x68,
	0x46, 0xfd, 0x3c, 0xda, 0x51, 0x78, 0x20, 0x32, 0x97, 0xc6, 0x50, 0xa1, 0x1c, 0x9d, 0x4c, 0x9f,
	0x28, 0x68, 0xe3, 0x5e, 0x4e, 0x07, 0x5c, 0xb7, 0x16, 0x94, 0x5d, 0x2b, 0x53, 0xf6, 0xc6, 0x77,
	0x2b, 0x79, 0xc8, 0x53, 0x79, 0x3c, 0xf7, 0x70, 0x7f, 0x0c, 0x30, 0x0d, 0x5d, 0xe9, 0xdb, 0x5e,
	0x70, 0x18, 0xd2, 0x56, 0x9c, 0xcf, 0xee, 0xd8, 0xcb, 0xfd, 0x17, 0xb9, 0xa6, 0xd5, 0x25, 0xab,
	0x67, 0xc1, 0x61, 0x88, 0x5d, 0xf8, 0xde, 0xe4, 0x55, 0xca, 0x45, 0x7b, 0x9d, 0x4e, 0xa1, 0xb9,
	0x5d, 0x3c, 0xcf, 0x35, 0xad, 0x2e, 0x59, 0x91, 0x7b, 0x1f, 0xc1, 0x8a, 0x4e, 0x20, 0x27, 0x8b,
	0x63, 0x19, 0x30, 0x5d, 0xd6, 0xac, 0x65, 0x05, 0x3f, 0x65, 0xd4, 0x78, 0x31, 0x43, 0x7f, 0xcd,
	0xb9, 0x07, 0x3d, 0x8d, 0xb7, 0x57, 0xd1, 0x3e, 0x4b, 0x93, 0x8f, 0x01, 0x30, 0x30, 0xec, 0x43,
	0x91, 0xf9, 0xbc, 0xf3, 0x17, 0xb8, 0xbe, 0x9f, 0x6b, 0x5a, 0x5d, 0xb4, 0xda, 0xc1, 0x4f, 0x0c,
	0x66, 0xe2, 0x77, 0x55, 0xbb, 0xf0, 0x61, 0x02, 0x04, 0x71, 0xf1, 0xc2, 0xa9, 0xa0, 0x22, 0xb0,
	0x43, 0x95, 0x0b, 0xa6, 0x02, 0x87, 0xdf, 0x57, 0x67, 0xca, 0x96, 0x2e, 0xb9, 0xf0, 0xff, 0x8b,
	0x66, 0x33, 0x5b, 0xb4, 0x18, 0xd0, 0x88, 0x93, 0x38, 0xa2, 0x98, 0xa9, 0x5b, 0xf4, 0xcd, 0x58,
	0xe2, 0x51, 0xc9, 0x41, 0x58, 0xe2, 0x51, 0x25, 0x1b, 0xc4, 0x74, 0xbb, 0xa9, 0x5b, 0xf8, 0x89,
	0x48, 0xe4, 0x78, 0x74, 0x61, 0xa9, 0x5b, 0xf8, 0xa9, 0xfa, 0x7a, 0x4d, 0x55, 0x00, 0xf7, 0xf5,
	0x1a, 0x69, 0x21, 0x7d, 0xc3, 0x61, 0xbb, 0x42, 0xb0, 0x6e, 0x62, 0x08, 0x4a, 0x11, 0x1f, 0x3a,
	0x01, 0xdd, 0x25, 0xea, 0x96, 0x6a, 0x61, 0xbf, 0xd2, 0xf1, 0xe9, 0xa2, 0xd0, 0xb4, 0xf0, 0x13,
	0x11, 0x27, 0x79, 0x4d, 0x57, 0x80, 0xa6, 0x85, 0x9f, 0xc6, 0x35, 0x68, 0xc6, 0x32, 0x09, 0x03,
	0x2a, 0xef, 0x9b, 0x16, 0x37, 0x18, 0x4d, 0xe3, 0x53, 0x2a, 0xde, 0x09, 0x4d, 0xe3, 0xd3, 0x32,
	0x31, 0x5d, 0x9f, 0x47, 0x4c, 0x37, 0x2a, 0xc4, 0xf4, 0xdb, 0x25, 0x80, 0x22, 0x64, 0x2f, 0x43,
	0xfb, 0x98, 0x81, 0x74, 0xf8, 0x55, 0x58, 0xbf, 0x47, 0x98, 0x22, 0xfd, 0xdb, 0xd0, 0x7b, 0x25,
	0x12, 0xcd, 0xf7, 0x8a, 0x9a, 0xe0, 0x95, 0x48, 0x14, 0xc7, 0x63, 0x2c, 0xa3, 0x42, 0x89, 0xc7,
	0x15, 0xb5, 0x2f, 0xbf, 0x12, 0xc9, 0x7e, 0x81, 0x62, 0x60, 0x90, 0x22, 0x9d, 0x6c, 0x4c, 0x4d,
	0x1d, 0x54, 0xa1, 0x63, 0xed, 0x1a, 0x34, 0x29, 0xc3, 0x14, 0x1d, 0x71, 0x63, 0x86, 0xe7, 0xdb,
	0xb3, 0x3c, 0x7f, 0x0b, 0x3a, 0x59, 0x22, 0x35, 0x01, 0xd1, 0x3a, 0x65, 0x89, 0xc4, 0xd9, 0x0d,
	0xff, 0x58, 0x07, 0x28, 0xf2, 0x0f, 0x17, 0xf4, 0x38, 0xf4, 0x53, 0x9c, 0x45, 0x8d, 0x92, 0x4d,
	0x37, 0x51, 0xa2, 0xd3, 0x70, 0x89, 0x25, 0xaa, 0x89, 0x0e, 0x08, 0x27, 0xf5, 0x8e, 0xa5, 0xa2,
	0xb0, 0x3a, 0x89, 0x7b, 0x8c, 0x31, 0x8b, 0x71, 0x81, 0x55, 0x56, 0xe2, 0x54, 0x1e, 0x68, 0x34,
	0x57, 0x13, 0x51, 0x24, 0xb0, 0x57, 0xa5, 0xd6, 0x64, 0x35, 0x8d, 0xb2, 0xda, 0x3a, 0xf4, 0xf4,
	0x21, 0xea, 0xa5, 0xa7, 0xaa, 0xc4, 0x28, 0x43, 0xb8, 0x21, 0x6a, 0xb4, 0xfc, 0x6e, 0x50, 0xb3,
	0x80, 0x21, 0x9d, 0x63, 0xcc, 0x4f, 0x8a, 0x31, 0x3a, 0x17, 0xe7, 0xd8, 0xf3, 0x92, 0xae, 0xd5,
	0x23, 0x4b, 0xc5, 0x16, 0xb7, 0x81, 0x23, 0xc1, 0xf6, 0xe5, 0xb1, 0xf4, 0x15, 0x7d, 0x03, 0x41,
	0xcf, 0x11, 0x29, 0x57, 0x5d, 0x95, 0x1a, 0x0a, 0x2a, 0x55, 0x57, 0xb9, 0x7e, 0xba, 0x5d, 0xad,
	0x82, 0x7a, 0x8a, 0x3d, 0xf2, 0x0a, 0x68, 0xf8, 0x33, 0xe8, 0x97, 0x1d, 0xc2, 0xad, 0xd1, 0xa1,
	0xa7, 0x8e, 0x67, 0xd5, 0xc4, 0x88, 0x61, 0x1a, 0xe3, 0xa0, 0xe5, 0x06, 0x96, 0xdb, 0x27, 0x61,
	0x7c, 0xe4, 0x05, 0x13, 0x3b, 0x0c, 0x54, 0xb4, 0x76, 0x15, 0xb2, 0x1b, 0x0c, 0xf7, 0x61, 0xb9,
	0xca, 0x90, 0xe8, 0xd1, 0xa1, 0x2f, 0x92, 0x57, 0x8a, 0x13, 0x79, 0x10, 0x20, 0x88, 0x09, 0xef,
	0x0e, 0xf4, 0x2b, 0x25, 0xa5, 0xca, 0x11, 0x59, 0xd4, 0x92, 0xc3, 0x5f, 0x02, 0x14, 0x64, 0x89,
	0x3d, 0x3a, 0x7e, 0xe8, 0x1c, 0x55, 0x7b, 0x24, 0x88, 0x7b, 0xbc, 0x07, 0x2b, 0xac, 0x10, 0x66,
	0xa9, 0x5d, 0x9e, 0xc3, 0x80, 0xe0, 0xdd, 0x2c, 0x3d, 0x47, 0xaf, 0x5c, 0xcf, 0xe6, 0x7a, 0x3c,
	0xfc, 0xdf, 0x6b, 0x67, 0x8a, 0xe6, 0x4a, 0x95, 0x5a, 0xbb, 0xa8, 0x4a, 0x5d, 0x3a, 0x53, 0xa5,
	0x6e, 0xc2, 0x2a, 0xe6, 0xe8, 0x39, 0x35, 0x34, 0x66, 0x73, 0xb9, 0x7e, 0xfe, 0x00, 0xc0, 0x4b,
	0xb0, 0xfe, 0x09, 0x90, 0x38, 0x38, 0xe3, 0xbb, 0x5e, 0x62, 0x31, 0x40, 0xe1, 0x8e, 0x7a, 0xb6,
	0x17, 0xa4, 0x32, 0x3e, 0x16, 0xbe, 0xca, 0xf8, 0x01, 0xa1, 0xcf, 0x14, 0x38, 0x53, 0xcd, 0xb6,
	0x66, 0xaa, 0xd9, 0x8d, 0x7f, 0xd7, 0x01, 0x8a, 0xa7, 0xa4, 0xf9, 0x27, 0xfb, 0x2a, 0xd4, 0x45,
	0x14, 0xa8, 0x67, 0x42, 0xfc, 0x44, 0xc2, 0xc9, 0x12, 0x19, 0xf3, 0xf3, 0x61, 0x9d, 0x9f, 0x38,
	0x10, 0xa0, 0xf7, 0xc3, 0x21, 0x74, 0x22, 0x91, 0x24, 0x27, 0x61, 0xec, 0x92, 0xf7, 0x5d, 0x2b,
	0x6f, 0xa3, 0x4c, 0xd5, 0x3d, 0x39, 0x51, 0xe9, 0xb6, 0x71, 0x07, 0xc0, 0x8b, 0x6c, 0xe1, 0xba,
	0xb1, 0x4c, 0x12, 0xb3, 0x95, 0x97, 0x3c, 0x5d, 0x2f, 0x7a, 0xcc, 0x20, 0x9a, 0xa7, 0xd2, 0x97,
	0x51, 0x18, 0xeb, 0xf3, 0x31, 0x6f, 0xf3, 0xd6, 0x38, 0xc2, 0x27, 0x61, 0x47, 0x5f, 0xfc, 0x15,
	0x80, 0x8b, 0x7a, 0x9c, 0x97, 0xff, 0x2a, 0xe1, 0xba, 0xc7, 0xba, 0xf8, 0x37, 0xb6, 0xe0, 0xfa,
	0x24, 0x0e, 0xb3, 0xc8, 0x16, 0x8e, 0x23, 0x93, 0xa4, 0x58, 0x5b, 0x4e, 0xb8, 0xf7, 0x48, 0xf8,
	0x98, 0x64, 0xf9, 0x0a, 0x7f, 0x02, 0x06, 0xdb, 0xa8, 0xd7, 0x1e, 0x3e, 0xb6, 0x39, 0xf1, 0x56,
	0x49, 0xf2, 0x05, 0x09, 0xf8, 0xf0, 0xde, 0x84, 0xd5, 0xa9, 0x78, 0x53, 0xd5, 0xed, 0xf3, 0xfe,
	0x4f, 0xc5, 0x9b, 0xb2, 0xa6, 0x7e, 0x27, 0x1d, 0xd0, 0xda, 0xf1, 0x3b, 0x29, 0x61, 0x89, 0x47,
	0x07, 0x29, 0x61, 0x89, 0x87, 0x69, 0xea, 0x39, 0x8e, 0xe7, 0xd2, 0x31, 0xda, 0xb5, 0xb8, 0x51,
	0xaa, 0xe3, 0x56, 0x2b, 0x75, 0xdc, 0x1f, 0x6a, 0xf9, 0x66, 0x6f, 0x5f, 0xb4, 0xd9, 0x7a, 0xf4,
	0xa5, 0x73, 0x46, 0xaf, 0x9f, 0x37, 0x7a, 0xa3, 0x3c, 0xba, 0x01, 0x8d, 0x03, 0x11, 0xb8, 0x6a,
	0x6f, 0xe9, 0x3b, 0x2f, 0x28, 0x5a, 0xa5, 0x82, 0x42, 0x15, 0x0f, 0xed, 0xbc, 0x78, 0xd8, 0x48,
	0xb5, 0x7b, 0xf4, 0xb6, 0x38, 0xd7, 0xbd, 0xb3, 0x0f, 0x38, 0x4b, 0xb3, 0x0f, 0x38, 0x06, 0x34,
	0x4e, 0xa4, 0x3c, 0x52, 0xd9, 0x45, 0xdf, 0xa5, 0x55, 0x69, 0x54, 0x56, 0x65, 0x57, 0x8f, 0x3a,
	0x5e, 0x94, 0x01, 0xc7, 0xea, 0x8d, 0x81, 0xaf, 0x3c, 0xa5, 0x0e, 0xeb, 0x95, 0x0e, 0x7f, 0x93,
	0xe7, 0x14, 0xbd, 0x59, 0xce, 0xed, 0xb1, 0x42, 0x24, 0x4b, 0x17, 0x11, 0x49, 0xfd, 0x0c, 0x91,
	0xcc, 0xde, 0xdb, 0x1b, 0xe7, 0xdd, 0xdb, 0xe7, 0xdd, 0xc2, 0x9b, 0x17, 0xde, 0xc2, 0xe7, 0xdd,
	0xf6, 0x5b, 0x73, 0x6f, 0xfb, 0x67, 0x6e, 0xdf, 0xed, 0x4b, 0xdd, 0xbe, 0x3b, 0x8b, 0x6f, 0xdf,
	0xdd, 0x19, 0xbe, 0xaa, 0x14, 0x24, 0x50, 0x29, 0x48, 0x4a, 0xdb, 0xd1, 0xab, 0x6c, 0xc7, 0x3f,
	0xf3, 0xa8, 0x1f, 0x5f, 0x18, 0x56, 0x0b, 0x2f, 0x92, 0x33, 0xd7, 0xb6, 0xfa, 0x25, 0xae, 0x6d,
	0x8d, 0x05, 0xd7, 0xb6, 0xe6, 0x82, 0x6b, 0x5b, 0x6b, 0xe6, 0xda, 0x56, 0x9a, 0x68, 0xbb, 0x32,
	0xd1, 0xff, 0x14, 0x13, 0x1d, 0x2f, 0x88, 0xe4, 0xa9, 0x93, 0xa9, 0x09, 0xe2, 0x27, 0xc6, 0x93,
	0x17, 0x78, 0xa9, 0x27, 0x7c, 0xef, 0x17, 0xd2, 0x46, 0xa1, 0x3a, 0x0a, 0x0b, 0xf4, 0xc5, 0x8c,
	0x5a, 0x2c, 0xa6, 0x3a, 0xec, 0x0a, 0xd4, 0x12, 0x53, 0xe3, 0x63, 0xb8, 0x5a, 0x52, 0x93, 0x32,
	0x8a, 0xc3, 0xa9, 0x9a, 0xe7, 0x6a, 0x21, 0xf8, 0x92, 0x70, 0x2c, 0x70, 0xcb, 0xca, 0xbe, 0x74,
	0xf4, 0x53, 0x5b, 0x49, 0xd5, 0x97, 0xce, 0xdc, 0x59, 0xbf, 0x6d, 0xe4, 0xb3, 0x7e, 0x74, 0xd1,
	0xac, 0xbf, 0x0f, 0x57, 0x1d, 0x5f, 0x8a, 0xd8, 0x0e, 0x7d, 0x37, 0x7f, 0xe5, 0xe4, 0x35, 0x58,
	0x21, 0xc1, 0xae, 0xef, 0xea, 0xb7, 0xcb, 0xbb, 0x30, 0xe0, 0xdf, 0x4a, 0x61, 0x90, 0x7a, 0x41,
	0xa6, 0x0b, 0xf3, 0x3e, 0xfd, 0x5b, 0x52, 0x18, 0x9e, 0x17, 0x67, 0x1e, 0x4d, 0x15, 0xa5, 0xf3,
	0xa2, 0xbc, 0x57, 0x7d, 0x0f, 0x65, 0x5e, 0xdf, 0x9d, 0x7d, 0x68, 0x6d, 0xd2, 0x15, 0xf7, 0xde,
	0xf9, 0xff, 0x14, 0xfe, 0x87, 0x57, 0xd6, 0x56, 0x79, 0x55, 0x86, 0x7f, 0x3b, 0xe7, 0x19, 0xe5,
	0x4c, 0x80, 0xd7, 0x16, 0xbe, 0x94, 0x2c, 0x2d, 0x7c, 0x29, 0xa9, 0x5f, 0xea, 0xa5, 0xa4, 0x71,
	0x99, 0x97, 0x92, 0xe6, 0xa5, 0x5e, 0x4a, 0x5a, 0x97, 0x48, 0xb9, 0xf6, 0x82, 0x94, 0xeb, 0x2c,
	0x48, 0xb9, 0xee, 0xec, 0x4b, 0xc9, 0x9a, 0x8e, 0xb1, 0x9d, 0x9d, 0xd1, 0x58, 0x1f, 0x05, 0xb5,
	0xfc, 0x28, 0xd8, 0xf8, 0x79, 0x49, 0xbe, 0x8d, 0x93, 0xc3, 0x48, 0x89, 0x84, 0x73, 0x64, 0xa7,
	0x61, 0x2a, 0x7c, 0xb5, 0xd6, 0x03, 0x8d, 0xee, 0x23, 0x68, 0x7c, 0x0c, 0x2b, 0xb9, 0x5a, 0xfe,
	0xfc, 0xaa, 0x5d, 0xcf, 0x7b, 0x60, 0x2e, 0xdf, 0xf8, 0x71, 0x69, 0x84, 0x07, 0x18, 0xe5, 0x18,
	0xc6, 0x85, 0x17, 0xad, 0xd0, 0xa7, 0x97, 0xeb, 0x9b, 0xd0, 0x0e, 0xe4, 0x89, 0x5d, 0x9c, 0x54,
	0xad, 0x40, 0x9e, 0x7c, 0x23, 0xe3, 0xad, 0xaf, 0xa0, 0xf3, 0xf2, 0xc9, 0xb3, 0x70, 0xff, 0x69,
	0xea, 0x1b, 0x3f, 0x82, 0x2e, 0x7d, 0x7f, 0xe9, 0xbc, 0x0a, 0x8d, 0xeb, 0xe5, 0xc8, 0xcb, 0xff,
	0xd4, 0x0e, 0xcf, 0x87, 0x37, 0xae, 0x3c, 0x19, 0xfe, 0xf5, 0xed, 0x5a, 0xed, 0xdb, 0xb7, 0x6b,
	0xb5, 0x7f, 0xbc, 0x5d, 0xab, 0xfd, 0xee, 0xdd, 0xda, 0x95, 0x6f, 0xdf, 0xad, 0x5d, 0xf9, 0xee,
	0xdd, 0xda, 0x95, 0x9f, 0xd4, 0x0e, 0x5a, 0xf4, 0x2b, 0xfa, 0xd3, 0xff, 0x06, 0x00, 0x00, 0xff,
	0xff, 0xe7, 0x55, 0x63, 0xd0, 0x9a, 0x1e, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// NBIoTCtlClient is the client API for NBIoTCtl service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type NBIoTCtlClient interface {
	NBIoTEcho(ctx context.Context, in *MsgNBOpen, opts ...grpc.CallOption) (*MsgNBOpen, error)
}

type nBIoTCtlClient struct {
	cc *grpc.ClientConn
}

func NewNBIoTCtlClient(cc *grpc.ClientConn) NBIoTCtlClient {
	return &nBIoTCtlClient{cc}
}

func (c *nBIoTCtlClient) NBIoTEcho(ctx context.Context, in *MsgNBOpen, opts ...grpc.CallOption) (*MsgNBOpen, error) {
	out := new(MsgNBOpen)
	err := c.cc.Invoke(ctx, "/wlst.nbiot.NBIoTCtl/NBIoTEcho", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NBIoTCtlServer is the server API for NBIoTCtl service.
type NBIoTCtlServer interface {
	NBIoTEcho(context.Context, *MsgNBOpen) (*MsgNBOpen, error)
}

// UnimplementedNBIoTCtlServer can be embedded to have forward compatible implementations.
type UnimplementedNBIoTCtlServer struct {
}

func (*UnimplementedNBIoTCtlServer) NBIoTEcho(ctx context.Context, req *MsgNBOpen) (*MsgNBOpen, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NBIoTEcho not implemented")
}

func RegisterNBIoTCtlServer(s *grpc.Server, srv NBIoTCtlServer) {
	s.RegisterService(&_NBIoTCtl_serviceDesc, srv)
}

func _NBIoTCtl_NBIoTEcho_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgNBOpen)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NBIoTCtlServer).NBIoTEcho(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/wlst.nbiot.NBIoTCtl/NBIoTEcho",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NBIoTCtlServer).NBIoTEcho(ctx, req.(*MsgNBOpen))
	}
	return interceptor(ctx, in, info, handler)
}

var _NBIoTCtl_serviceDesc = grpc.ServiceDesc{
	ServiceName: "wlst.nbiot.NBIoTCtl",
	HandlerType: (*NBIoTCtlServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NBIoTEcho",
			Handler:    _NBIoTCtl_NBIoTEcho_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "msg_nb.proto",
}

func (m *MsgNBiot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgNBiot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgNBiot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RawData) > 0 {
		dAtA2 := make([]byte, len(m.RawData)*10)
		var j1 int
		for _, num1 := range m.RawData {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintMsgNb(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Imei) > 0 {
		dAtA4 := make([]byte, len(m.Imei)*10)
		var j3 int
		for _, num1 := range m.Imei {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintMsgNb(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x22
	}
	if m.CmdFlag != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.CmdFlag))
		i--
		dAtA[i] = 0x18
	}
	if len(m.CmdName) > 0 {
		i -= len(m.CmdName)
		copy(dAtA[i:], m.CmdName)
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.CmdName)))
		i--
		dAtA[i] = 0x12
	}
	if m.CmdIdx != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgNBOpen) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgNBOpen) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgNBOpen) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NbSluFf01 != nil {
		{
			size, err := m.NbSluFf01.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.NbSluFf07 != nil {
		{
			size, err := m.NbSluFf07.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.NbSluFf05 != nil {
		{
			size, err := m.NbSluFf05.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if len(m.DeviceId) > 0 {
		i -= len(m.DeviceId)
		copy(dAtA[i:], m.DeviceId)
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.DeviceId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.NbSlu_5600 != nil {
		{
			size, err := m.NbSlu_5600.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.NbSlu_5500 != nil {
		{
			size, err := m.NbSlu_5500.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.NbSlu_5400 != nil {
		{
			size, err := m.NbSlu_5400.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.NbSlu_5200 != nil {
		{
			size, err := m.NbSlu_5200.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.NbSlu_5100 != nil {
		{
			size, err := m.NbSlu_5100.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.NbSlu_1400 != nil {
		{
			size, err := m.NbSlu_1400.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.NbSlu_3700 != nil {
		{
			size, err := m.NbSlu_3700.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.NbSlu_3100 != nil {
		{
			size, err := m.NbSlu_3100.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.SluitemConfig != nil {
		{
			size, err := m.SluitemConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.SluitemReply != nil {
		{
			size, err := m.SluitemReply.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.SluitemData != nil {
		{
			size, err := m.SluitemData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.DataCmd) > 0 {
		i -= len(m.DataCmd)
		copy(dAtA[i:], m.DataCmd)
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.DataCmd)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Status != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x28
	}
	if m.Seq != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x20
	}
	if m.DataType != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.DataType))
		i--
		dAtA[i] = 0x18
	}
	if m.DtReceive != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.DtReceive))
		i--
		dAtA[i] = 0x10
	}
	if m.Imei != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Imei))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SluitemConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SluitemConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SluitemConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SetMark != nil {
		{
			size, err := m.SetMark.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.Status != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x70
	}
	if len(m.SluitemRuntime) > 0 {
		for iNdEx := len(m.SluitemRuntime) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SluitemRuntime[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsgNb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if m.SluitemSunriseset != nil {
		{
			size, err := m.SluitemSunriseset.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.SluitemVer != nil {
		{
			size, err := m.SluitemVer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.SluitemPara != nil {
		{
			size, err := m.SluitemPara.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.SluitemTime != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.SluitemTime))
		i--
		dAtA[i] = 0x38
	}
	if m.LoopCount != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.LoopCount))
		i--
		dAtA[i] = 0x28
	}
	if m.DataMark != nil {
		{
			size, err := m.DataMark.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.SluitemIdx != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.SluitemIdx))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SluitemConfig_DataMark) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SluitemConfig_DataMark) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SluitemConfig_DataMark) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReadTimetable != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.ReadTimetable))
		i--
		dAtA[i] = 0x38
	}
	if m.ReadSunriseset != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.ReadSunriseset))
		i--
		dAtA[i] = 0x30
	}
	if m.ReadVer != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.ReadVer))
		i--
		dAtA[i] = 0x28
	}
	if m.ReadArgs != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.ReadArgs))
		i--
		dAtA[i] = 0x18
	}
	if m.ReadTimer != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.ReadTimer))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *SluitemConfig_SetMark) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SluitemConfig_SetMark) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SluitemConfig_SetMark) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SetTimetable != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.SetTimetable))
		i--
		dAtA[i] = 0x28
	}
	if m.SetReset != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.SetReset))
		i--
		dAtA[i] = 0x20
	}
	if m.SetArgs != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.SetArgs))
		i--
		dAtA[i] = 0x10
	}
	if m.SetTimer != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.SetTimer))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SluitemConfig_SluitemPara) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SluitemConfig_SluitemPara) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SluitemConfig_SluitemPara) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UplinkReply != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.UplinkReply))
		i--
		dAtA[i] = 0x50
	}
	if m.UplinkTimer != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.UplinkTimer))
		i--
		dAtA[i] = 0x48
	}
	if len(m.RatedPower) > 0 {
		dAtA25 := make([]byte, len(m.RatedPower)*10)
		var j24 int
		for _, num1 := range m.RatedPower {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA25[j24] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j24++
			}
			dAtA25[j24] = uint8(num)
			j24++
		}
		i -= j24
		copy(dAtA[i:], dAtA25[:j24])
		i = encodeVarintMsgNb(dAtA, i, uint64(j24))
		i--
		dAtA[i] = 0x42
	}
	if m.Latitude != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Latitude))))
		i--
		dAtA[i] = 0x39
	}
	if m.Longitude != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Longitude))))
		i--
		dAtA[i] = 0x31
	}
	if len(m.SluitemPowerTurnon) > 0 {
		dAtA27 := make([]byte, len(m.SluitemPowerTurnon)*10)
		var j26 int
		for _, num1 := range m.SluitemPowerTurnon {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA27[j26] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j26++
			}
			dAtA27[j26] = uint8(num)
			j26++
		}
		i -= j26
		copy(dAtA[i:], dAtA27[:j26])
		i = encodeVarintMsgNb(dAtA, i, uint64(j26))
		i--
		dAtA[i] = 0x22
	}
	if m.SluitemEnableAlarm != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.SluitemEnableAlarm))
		i--
		dAtA[i] = 0x18
	}
	if m.SluitemStatus != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.SluitemStatus))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *SluitemConfig_SluitemVer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SluitemConfig_SluitemVer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SluitemConfig_SluitemVer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ver) > 0 {
		i -= len(m.Ver)
		copy(dAtA[i:], m.Ver)
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.Ver)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.SluitemType) > 0 {
		i -= len(m.SluitemType)
		copy(dAtA[i:], m.SluitemType)
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.SluitemType)))
		i--
		dAtA[i] = 0x32
	}
	if m.TimerModule != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.TimerModule))
		i--
		dAtA[i] = 0x28
	}
	if m.TemperatureModule != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.TemperatureModule))
		i--
		dAtA[i] = 0x20
	}
	if m.ElectricLeakageModule != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.ElectricLeakageModule))
		i--
		dAtA[i] = 0x18
	}
	if m.EnergySaving != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.EnergySaving))
		i--
		dAtA[i] = 0x10
	}
	if m.SluitemLoop != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.SluitemLoop))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SluitemConfig_SluitemSunriseset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SluitemConfig_SluitemSunriseset) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SluitemConfig_SluitemSunriseset) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sunset != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Sunset))
		i--
		dAtA[i] = 0x10
	}
	if m.Sunrise != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Sunrise))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SluitemConfig_SluitemRuntime) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SluitemConfig_SluitemRuntime) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SluitemConfig_SluitemRuntime) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PwmBaudrate != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.PwmBaudrate))
		i--
		dAtA[i] = 0x50
	}
	if m.PwmPower != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.PwmPower))
		i--
		dAtA[i] = 0x48
	}
	if len(m.PwmLoop) > 0 {
		dAtA29 := make([]byte, len(m.PwmLoop)*10)
		var j28 int
		for _, num1 := range m.PwmLoop {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA29[j28] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j28++
			}
			dAtA29[j28] = uint8(num)
			j28++
		}
		i -= j28
		copy(dAtA[i:], dAtA29[:j28])
		i = encodeVarintMsgNb(dAtA, i, uint64(j28))
		i--
		dAtA[i] = 0x42
	}
	if len(m.RelayOperate) > 0 {
		dAtA31 := make([]byte, len(m.RelayOperate)*10)
		var j30 int
		for _, num1 := range m.RelayOperate {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA31[j30] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j30++
			}
			dAtA31[j30] = uint8(num)
			j30++
		}
		i -= j30
		copy(dAtA[i:], dAtA31[:j30])
		i = encodeVarintMsgNb(dAtA, i, uint64(j30))
		i--
		dAtA[i] = 0x3a
	}
	if m.OperateOffset != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.OperateOffset))
		i--
		dAtA[i] = 0x30
	}
	if m.OperateTime != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.OperateTime))
		i--
		dAtA[i] = 0x28
	}
	if len(m.DateEnable) > 0 {
		dAtA33 := make([]byte, len(m.DateEnable)*10)
		var j32 int
		for _, num1 := range m.DateEnable {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA33[j32] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j32++
			}
			dAtA33[j32] = uint8(num)
			j32++
		}
		i -= j32
		copy(dAtA[i:], dAtA33[:j32])
		i = encodeVarintMsgNb(dAtA, i, uint64(j32))
		i--
		dAtA[i] = 0x22
	}
	if m.OperateType != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.OperateType))
		i--
		dAtA[i] = 0x18
	}
	if m.OutputType != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.OutputType))
		i--
		dAtA[i] = 0x10
	}
	if m.DataType != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.DataType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SluitemReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SluitemReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SluitemReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SluitemData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SluitemData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SluitemData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sunset != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Sunset))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.Sunrise != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Sunrise))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.Retry != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Retry))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.Reson != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Reson))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.Csq != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Csq))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.Ecl != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Ecl))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.Earfcn != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Earfcn))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.Txpower != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Txpower))
		i--
		dAtA[i] = 0x78
	}
	if m.Rsrq != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Rsrq))
		i--
		dAtA[i] = 0x70
	}
	if m.Pci != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Pci))
		i--
		dAtA[i] = 0x68
	}
	if m.Snr != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Snr))
		i--
		dAtA[i] = 0x60
	}
	if m.Rssi != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Rssi))
		i--
		dAtA[i] = 0x58
	}
	if m.Rsrp != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Rsrp))
		i--
		dAtA[i] = 0x50
	}
	if m.SluitemPara != nil {
		{
			size, err := m.SluitemPara.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.DateTime != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.DateTime))
		i--
		dAtA[i] = 0x40
	}
	if m.ResetCount != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.ResetCount))
		i--
		dAtA[i] = 0x38
	}
	if m.TimeFault != nil {
		{
			size, err := m.TimeFault.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.SluitemStatus != nil {
		{
			size, err := m.SluitemStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.LeakageCurrent != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.LeakageCurrent))))
		i--
		dAtA[i] = 0x21
	}
	if len(m.LightData) > 0 {
		for iNdEx := len(m.LightData) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LightData[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsgNb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.ModelInfo != nil {
		{
			size, err := m.ModelInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.CmdIdx != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SluitemData_ModelInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SluitemData_ModelInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SluitemData_ModelInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UseLoop != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.UseLoop))
		i--
		dAtA[i] = 0x40
	}
	if len(m.SluitemType) > 0 {
		i -= len(m.SluitemType)
		copy(dAtA[i:], m.SluitemType)
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.SluitemType)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Model != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Model))
		i--
		dAtA[i] = 0x30
	}
	if m.HasTimer != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.HasTimer))
		i--
		dAtA[i] = 0x28
	}
	if m.HasTemperature != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.HasTemperature))
		i--
		dAtA[i] = 0x20
	}
	if m.HasLeakage != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.HasLeakage))
		i--
		dAtA[i] = 0x18
	}
	if m.PowerSaving != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.PowerSaving))
		i--
		dAtA[i] = 0x10
	}
	if m.SluitemLoop != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.SluitemLoop))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SluitemData_LightData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SluitemData_LightData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SluitemData_LightData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RatedPower != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.RatedPower))
		i--
		dAtA[i] = 0x58
	}
	if m.SluitemPowerTurnon != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.SluitemPowerTurnon))
		i--
		dAtA[i] = 0x50
	}
	if m.PowerLevel != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.PowerLevel))
		i--
		dAtA[i] = 0x48
	}
	if m.LightStatus != nil {
		{
			size, err := m.LightStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.ActiveTime != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ActiveTime))))
		i--
		dAtA[i] = 0x39
	}
	if m.Electricity != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Electricity))))
		i--
		dAtA[i] = 0x31
	}
	if m.ApparentPower != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ApparentPower))))
		i--
		dAtA[i] = 0x29
	}
	if m.ReactivePower != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ReactivePower))))
		i--
		dAtA[i] = 0x21
	}
	if m.ActivePower != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ActivePower))))
		i--
		dAtA[i] = 0x19
	}
	if m.Current != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Current))))
		i--
		dAtA[i] = 0x11
	}
	if m.Voltage != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Voltage))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *SluitemData_LightStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SluitemData_LightStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SluitemData_LightStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WorkingOn != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.WorkingOn))
		i--
		dAtA[i] = 0x18
	}
	if m.Fault != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Fault))
		i--
		dAtA[i] = 0x10
	}
	if m.Leakage != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Leakage))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SluitemData_SluitemStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SluitemData_SluitemStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SluitemData_SluitemStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EnableAlarm != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.EnableAlarm))
		i--
		dAtA[i] = 0x10
	}
	if m.FlashFault != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.FlashFault))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SluitemData_TimeFault) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SluitemData_TimeFault) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SluitemData_TimeFault) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ClockOutAlarm != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.ClockOutAlarm))
		i--
		dAtA[i] = 0x18
	}
	if m.ClockOutFault != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.ClockOutFault))
		i--
		dAtA[i] = 0x10
	}
	if m.ClockFault != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.ClockFault))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SluitemData_SluitemPara) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SluitemData_SluitemPara) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SluitemData_SluitemPara) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UplinkReply != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.UplinkReply))
		i--
		dAtA[i] = 0x30
	}
	if m.AlarmInterval != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.AlarmInterval))
		i--
		dAtA[i] = 0x28
	}
	if m.IsRunning != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.IsRunning))
		i--
		dAtA[i] = 0x20
	}
	if m.HasEnableAlarm != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.HasEnableAlarm))
		i--
		dAtA[i] = 0x18
	}
	if m.Latitude != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Latitude))))
		i--
		dAtA[i] = 0x11
	}
	if m.Longitude != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Longitude))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *NBSlu_3100) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NBSlu_3100) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NBSlu_3100) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if len(m.Iccid) > 0 {
		i -= len(m.Iccid)
		copy(dAtA[i:], m.Iccid)
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.Iccid)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.Imsi) > 0 {
		i -= len(m.Imsi)
		copy(dAtA[i:], m.Imsi)
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.Imsi)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.Imei) > 0 {
		i -= len(m.Imei)
		copy(dAtA[i:], m.Imei)
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.Imei)))
		i--
		dAtA[i] = 0x6a
	}
	if m.MaxDeviceCount != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.MaxDeviceCount))
		i--
		dAtA[i] = 0x60
	}
	if m.GroupDeviceCount != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.GroupDeviceCount))
		i--
		dAtA[i] = 0x58
	}
	if m.GroupAccessInterval != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.GroupAccessInterval))
		i--
		dAtA[i] = 0x50
	}
	if m.VlinkTime != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.VlinkTime))
		i--
		dAtA[i] = 0x48
	}
	if m.Localport != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Localport))
		i--
		dAtA[i] = 0x40
	}
	if m.Teleport != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Teleport))
		i--
		dAtA[i] = 0x38
	}
	if len(m.IpAddress) > 0 {
		dAtA40 := make([]byte, len(m.IpAddress)*10)
		var j39 int
		for _, num1 := range m.IpAddress {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA40[j39] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j39++
			}
			dAtA40[j39] = uint8(num)
			j39++
		}
		i -= j39
		copy(dAtA[i:], dAtA40[:j39])
		i = encodeVarintMsgNb(dAtA, i, uint64(j39))
		i--
		dAtA[i] = 0x32
	}
	if m.Operater != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Operater))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Password) > 0 {
		i -= len(m.Password)
		copy(dAtA[i:], m.Password)
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.Password)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.UserName) > 0 {
		i -= len(m.UserName)
		copy(dAtA[i:], m.UserName)
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.UserName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Apn) > 0 {
		i -= len(m.Apn)
		copy(dAtA[i:], m.Apn)
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.Apn)))
		i--
		dAtA[i] = 0x12
	}
	if m.CmdIdx != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NBSlu_3700) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NBSlu_3700) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NBSlu_3700) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Snr != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Snr))
		i--
		dAtA[i] = 0x38
	}
	if m.Rsrp != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Rsrp))
		i--
		dAtA[i] = 0x30
	}
	if m.Band != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Band))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Iccid) > 0 {
		i -= len(m.Iccid)
		copy(dAtA[i:], m.Iccid)
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.Iccid)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Imsi) > 0 {
		i -= len(m.Imsi)
		copy(dAtA[i:], m.Imsi)
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.Imsi)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Imei) > 0 {
		i -= len(m.Imei)
		copy(dAtA[i:], m.Imei)
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.Imei)))
		i--
		dAtA[i] = 0x12
	}
	if m.CmdIdx != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NBSlu_1400) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NBSlu_1400) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NBSlu_1400) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x20
	}
	if m.Week != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Week))
		i--
		dAtA[i] = 0x18
	}
	if m.SluitemTime != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.SluitemTime))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NBSlu_5100) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NBSlu_5100) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NBSlu_5100) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Ver) > 0 {
		i -= len(m.Ver)
		copy(dAtA[i:], m.Ver)
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.Ver)))
		i--
		dAtA[i] = 0x12
	}
	if m.CmdIdx != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NBSlu_5200) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NBSlu_5200) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NBSlu_5200) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x58
	}
	if m.UseLoop != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.UseLoop))
		i--
		dAtA[i] = 0x50
	}
	if m.UplinkReply != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.UplinkReply))
		i--
		dAtA[i] = 0x48
	}
	if m.UplinkTimer != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.UplinkTimer))
		i--
		dAtA[i] = 0x40
	}
	if len(m.RatedPower) > 0 {
		dAtA42 := make([]byte, len(m.RatedPower)*10)
		var j41 int
		for _, num1 := range m.RatedPower {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA42[j41] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j41++
			}
			dAtA42[j41] = uint8(num)
			j41++
		}
		i -= j41
		copy(dAtA[i:], dAtA42[:j41])
		i = encodeVarintMsgNb(dAtA, i, uint64(j41))
		i--
		dAtA[i] = 0x3a
	}
	if m.SluitemEnableAlarm != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.SluitemEnableAlarm))
		i--
		dAtA[i] = 0x30
	}
	if len(m.SluitemPowerTurnon) > 0 {
		dAtA44 := make([]byte, len(m.SluitemPowerTurnon)*10)
		var j43 int
		for _, num1 := range m.SluitemPowerTurnon {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA44[j43] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j43++
			}
			dAtA44[j43] = uint8(num)
			j43++
		}
		i -= j43
		copy(dAtA[i:], dAtA44[:j43])
		i = encodeVarintMsgNb(dAtA, i, uint64(j43))
		i--
		dAtA[i] = 0x2a
	}
	if m.SluitemStatus != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.SluitemStatus))
		i--
		dAtA[i] = 0x20
	}
	if m.Latitude != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Latitude))))
		i--
		dAtA[i] = 0x19
	}
	if m.Longitude != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Longitude))))
		i--
		dAtA[i] = 0x11
	}
	if m.CmdIdx != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NBSlu_5400) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NBSlu_5400) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NBSlu_5400) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x38
	}
	if m.PwmBaudrate != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.PwmBaudrate))
		i--
		dAtA[i] = 0x30
	}
	if m.PwmPower != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.PwmPower))
		i--
		dAtA[i] = 0x28
	}
	if len(m.PwmLoop) > 0 {
		dAtA46 := make([]byte, len(m.PwmLoop)*10)
		var j45 int
		for _, num1 := range m.PwmLoop {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA46[j45] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j45++
			}
			dAtA46[j45] = uint8(num)
			j45++
		}
		i -= j45
		copy(dAtA[i:], dAtA46[:j45])
		i = encodeVarintMsgNb(dAtA, i, uint64(j45))
		i--
		dAtA[i] = 0x22
	}
	if len(m.RelayOperate) > 0 {
		dAtA48 := make([]byte, len(m.RelayOperate)*10)
		var j47 int
		for _, num1 := range m.RelayOperate {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA48[j47] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j47++
			}
			dAtA48[j47] = uint8(num)
			j47++
		}
		i -= j47
		copy(dAtA[i:], dAtA48[:j47])
		i = encodeVarintMsgNb(dAtA, i, uint64(j47))
		i--
		dAtA[i] = 0x1a
	}
	if m.OutputType != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.OutputType))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NBSlu_5500) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NBSlu_5500) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NBSlu_5500) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x38
	}
	if m.InitializeElec != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.InitializeElec))
		i--
		dAtA[i] = 0x30
	}
	if m.InitializeEeprom != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.InitializeEeprom))
		i--
		dAtA[i] = 0x28
	}
	if m.InitializeRam != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.InitializeRam))
		i--
		dAtA[i] = 0x20
	}
	if m.InitializeMcu != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.InitializeMcu))
		i--
		dAtA[i] = 0x18
	}
	if m.Mcu != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Mcu))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NBSlu_5600) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NBSlu_5600) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NBSlu_5600) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x30
	}
	if len(m.SluitemRuntime) > 0 {
		for iNdEx := len(m.SluitemRuntime) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SluitemRuntime[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsgNb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.SluitemRuntimeCount != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.SluitemRuntimeCount))
		i--
		dAtA[i] = 0x20
	}
	if m.DataContinue != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.DataContinue))
		i--
		dAtA[i] = 0x18
	}
	if m.ClearOldRuntime != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.ClearOldRuntime))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NBSlu_5600_SluitemRuntime) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NBSlu_5600_SluitemRuntime) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NBSlu_5600_SluitemRuntime) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PwmBaudrate != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.PwmBaudrate))
		i--
		dAtA[i] = 0x48
	}
	if m.PwmPower != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.PwmPower))
		i--
		dAtA[i] = 0x40
	}
	if len(m.PwmLoop) > 0 {
		dAtA50 := make([]byte, len(m.PwmLoop)*10)
		var j49 int
		for _, num1 := range m.PwmLoop {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA50[j49] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j49++
			}
			dAtA50[j49] = uint8(num)
			j49++
		}
		i -= j49
		copy(dAtA[i:], dAtA50[:j49])
		i = encodeVarintMsgNb(dAtA, i, uint64(j49))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.RelayOperate) > 0 {
		dAtA52 := make([]byte, len(m.RelayOperate)*10)
		var j51 int
		for _, num1 := range m.RelayOperate {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA52[j51] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j51++
			}
			dAtA52[j51] = uint8(num)
			j51++
		}
		i -= j51
		copy(dAtA[i:], dAtA52[:j51])
		i = encodeVarintMsgNb(dAtA, i, uint64(j51))
		i--
		dAtA[i] = 0x32
	}
	if m.OperateOffset != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.OperateOffset))
		i--
		dAtA[i] = 0x28
	}
	if m.OperateTime != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.OperateTime))
		i--
		dAtA[i] = 0x20
	}
	if len(m.DateEnable) > 0 {
		dAtA54 := make([]byte, len(m.DateEnable)*10)
		var j53 int
		for _, num1 := range m.DateEnable {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA54[j53] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j53++
			}
			dAtA54[j53] = uint8(num)
			j53++
		}
		i -= j53
		copy(dAtA[i:], dAtA54[:j53])
		i = encodeVarintMsgNb(dAtA, i, uint64(j53))
		i--
		dAtA[i] = 0x1a
	}
	if m.OperateType != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.OperateType))
		i--
		dAtA[i] = 0x10
	}
	if m.OutputType != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.OutputType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NBSlu_FF05) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NBSlu_FF05) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NBSlu_FF05) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ver) > 0 {
		i -= len(m.Ver)
		copy(dAtA[i:], m.Ver)
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.Ver)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NBSlu_FF07) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NBSlu_FF07) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NBSlu_FF07) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DatapackStatus) > 0 {
		dAtA56 := make([]byte, len(m.DatapackStatus)*10)
		var j55 int
		for _, num1 := range m.DatapackStatus {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA56[j55] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j55++
			}
			dAtA56[j55] = uint8(num)
			j55++
		}
		i -= j55
		copy(dAtA[i:], dAtA56[:j55])
		i = encodeVarintMsgNb(dAtA, i, uint64(j55))
		i--
		dAtA[i] = 0x12
	}
	if m.DatapackTotal != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.DatapackTotal))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NBSlu_FF01) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NBSlu_FF01) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NBSlu_FF01) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewVer) > 0 {
		i -= len(m.NewVer)
		copy(dAtA[i:], m.NewVer)
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.NewVer)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.OldVer) > 0 {
		i -= len(m.OldVer)
		copy(dAtA[i:], m.OldVer)
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.OldVer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintMsgNb(dAtA []byte, offset int, v uint64) int {
	offset -= sovMsgNb(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgNBiot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovMsgNb(uint64(m.CmdIdx))
	}
	l = len(m.CmdName)
	if l > 0 {
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.CmdFlag != 0 {
		n += 1 + sovMsgNb(uint64(m.CmdFlag))
	}
	if len(m.Imei) > 0 {
		l = 0
		for _, e := range m.Imei {
			l += sovMsgNb(uint64(e))
		}
		n += 1 + sovMsgNb(uint64(l)) + l
	}
	if len(m.RawData) > 0 {
		l = 0
		for _, e := range m.RawData {
			l += sovMsgNb(uint64(e))
		}
		n += 1 + sovMsgNb(uint64(l)) + l
	}
	return n
}

func (m *MsgNBOpen) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Imei != 0 {
		n += 1 + sovMsgNb(uint64(m.Imei))
	}
	if m.DtReceive != 0 {
		n += 1 + sovMsgNb(uint64(m.DtReceive))
	}
	if m.DataType != 0 {
		n += 1 + sovMsgNb(uint64(m.DataType))
	}
	if m.Seq != 0 {
		n += 1 + sovMsgNb(uint64(m.Seq))
	}
	if m.Status != 0 {
		n += 1 + sovMsgNb(uint64(m.Status))
	}
	l = len(m.DataCmd)
	if l > 0 {
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.SluitemData != nil {
		l = m.SluitemData.Size()
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.SluitemReply != nil {
		l = m.SluitemReply.Size()
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.SluitemConfig != nil {
		l = m.SluitemConfig.Size()
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.NbSlu_3100 != nil {
		l = m.NbSlu_3100.Size()
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.NbSlu_3700 != nil {
		l = m.NbSlu_3700.Size()
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.NbSlu_1400 != nil {
		l = m.NbSlu_1400.Size()
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.NbSlu_5100 != nil {
		l = m.NbSlu_5100.Size()
		n += 2 + l + sovMsgNb(uint64(l))
	}
	if m.NbSlu_5200 != nil {
		l = m.NbSlu_5200.Size()
		n += 2 + l + sovMsgNb(uint64(l))
	}
	if m.NbSlu_5400 != nil {
		l = m.NbSlu_5400.Size()
		n += 2 + l + sovMsgNb(uint64(l))
	}
	if m.NbSlu_5500 != nil {
		l = m.NbSlu_5500.Size()
		n += 2 + l + sovMsgNb(uint64(l))
	}
	if m.NbSlu_5600 != nil {
		l = m.NbSlu_5600.Size()
		n += 2 + l + sovMsgNb(uint64(l))
	}
	l = len(m.DeviceId)
	if l > 0 {
		n += 2 + l + sovMsgNb(uint64(l))
	}
	if m.NbSluFf05 != nil {
		l = m.NbSluFf05.Size()
		n += 2 + l + sovMsgNb(uint64(l))
	}
	if m.NbSluFf07 != nil {
		l = m.NbSluFf07.Size()
		n += 2 + l + sovMsgNb(uint64(l))
	}
	if m.NbSluFf01 != nil {
		l = m.NbSluFf01.Size()
		n += 2 + l + sovMsgNb(uint64(l))
	}
	return n
}

func (m *SluitemConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovMsgNb(uint64(m.CmdIdx))
	}
	if m.SluitemIdx != 0 {
		n += 1 + sovMsgNb(uint64(m.SluitemIdx))
	}
	if m.DataMark != nil {
		l = m.DataMark.Size()
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.LoopCount != 0 {
		n += 1 + sovMsgNb(uint64(m.LoopCount))
	}
	if m.SluitemTime != 0 {
		n += 1 + sovMsgNb(uint64(m.SluitemTime))
	}
	if m.SluitemPara != nil {
		l = m.SluitemPara.Size()
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.SluitemVer != nil {
		l = m.SluitemVer.Size()
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.SluitemSunriseset != nil {
		l = m.SluitemSunriseset.Size()
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if len(m.SluitemRuntime) > 0 {
		for _, e := range m.SluitemRuntime {
			l = e.Size()
			n += 1 + l + sovMsgNb(uint64(l))
		}
	}
	if m.Status != 0 {
		n += 1 + sovMsgNb(uint64(m.Status))
	}
	if m.SetMark != nil {
		l = m.SetMark.Size()
		n += 1 + l + sovMsgNb(uint64(l))
	}
	return n
}

func (m *SluitemConfig_DataMark) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReadTimer != 0 {
		n += 1 + sovMsgNb(uint64(m.ReadTimer))
	}
	if m.ReadArgs != 0 {
		n += 1 + sovMsgNb(uint64(m.ReadArgs))
	}
	if m.ReadVer != 0 {
		n += 1 + sovMsgNb(uint64(m.ReadVer))
	}
	if m.ReadSunriseset != 0 {
		n += 1 + sovMsgNb(uint64(m.ReadSunriseset))
	}
	if m.ReadTimetable != 0 {
		n += 1 + sovMsgNb(uint64(m.ReadTimetable))
	}
	return n
}

func (m *SluitemConfig_SetMark) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SetTimer != 0 {
		n += 1 + sovMsgNb(uint64(m.SetTimer))
	}
	if m.SetArgs != 0 {
		n += 1 + sovMsgNb(uint64(m.SetArgs))
	}
	if m.SetReset != 0 {
		n += 1 + sovMsgNb(uint64(m.SetReset))
	}
	if m.SetTimetable != 0 {
		n += 1 + sovMsgNb(uint64(m.SetTimetable))
	}
	return n
}

func (m *SluitemConfig_SluitemPara) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SluitemStatus != 0 {
		n += 1 + sovMsgNb(uint64(m.SluitemStatus))
	}
	if m.SluitemEnableAlarm != 0 {
		n += 1 + sovMsgNb(uint64(m.SluitemEnableAlarm))
	}
	if len(m.SluitemPowerTurnon) > 0 {
		l = 0
		for _, e := range m.SluitemPowerTurnon {
			l += sovMsgNb(uint64(e))
		}
		n += 1 + sovMsgNb(uint64(l)) + l
	}
	if m.Longitude != 0 {
		n += 9
	}
	if m.Latitude != 0 {
		n += 9
	}
	if len(m.RatedPower) > 0 {
		l = 0
		for _, e := range m.RatedPower {
			l += sovMsgNb(uint64(e))
		}
		n += 1 + sovMsgNb(uint64(l)) + l
	}
	if m.UplinkTimer != 0 {
		n += 1 + sovMsgNb(uint64(m.UplinkTimer))
	}
	if m.UplinkReply != 0 {
		n += 1 + sovMsgNb(uint64(m.UplinkReply))
	}
	return n
}

func (m *SluitemConfig_SluitemVer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SluitemLoop != 0 {
		n += 1 + sovMsgNb(uint64(m.SluitemLoop))
	}
	if m.EnergySaving != 0 {
		n += 1 + sovMsgNb(uint64(m.EnergySaving))
	}
	if m.ElectricLeakageModule != 0 {
		n += 1 + sovMsgNb(uint64(m.ElectricLeakageModule))
	}
	if m.TemperatureModule != 0 {
		n += 1 + sovMsgNb(uint64(m.TemperatureModule))
	}
	if m.TimerModule != 0 {
		n += 1 + sovMsgNb(uint64(m.TimerModule))
	}
	l = len(m.SluitemType)
	if l > 0 {
		n += 1 + l + sovMsgNb(uint64(l))
	}
	l = len(m.Ver)
	if l > 0 {
		n += 1 + l + sovMsgNb(uint64(l))
	}
	return n
}

func (m *SluitemConfig_SluitemSunriseset) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sunrise != 0 {
		n += 1 + sovMsgNb(uint64(m.Sunrise))
	}
	if m.Sunset != 0 {
		n += 1 + sovMsgNb(uint64(m.Sunset))
	}
	return n
}

func (m *SluitemConfig_SluitemRuntime) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DataType != 0 {
		n += 1 + sovMsgNb(uint64(m.DataType))
	}
	if m.OutputType != 0 {
		n += 1 + sovMsgNb(uint64(m.OutputType))
	}
	if m.OperateType != 0 {
		n += 1 + sovMsgNb(uint64(m.OperateType))
	}
	if len(m.DateEnable) > 0 {
		l = 0
		for _, e := range m.DateEnable {
			l += sovMsgNb(uint64(e))
		}
		n += 1 + sovMsgNb(uint64(l)) + l
	}
	if m.OperateTime != 0 {
		n += 1 + sovMsgNb(uint64(m.OperateTime))
	}
	if m.OperateOffset != 0 {
		n += 1 + sovMsgNb(uint64(m.OperateOffset))
	}
	if len(m.RelayOperate) > 0 {
		l = 0
		for _, e := range m.RelayOperate {
			l += sovMsgNb(uint64(e))
		}
		n += 1 + sovMsgNb(uint64(l)) + l
	}
	if len(m.PwmLoop) > 0 {
		l = 0
		for _, e := range m.PwmLoop {
			l += sovMsgNb(uint64(e))
		}
		n += 1 + sovMsgNb(uint64(l)) + l
	}
	if m.PwmPower != 0 {
		n += 1 + sovMsgNb(uint64(m.PwmPower))
	}
	if m.PwmBaudrate != 0 {
		n += 1 + sovMsgNb(uint64(m.PwmBaudrate))
	}
	return n
}

func (m *SluitemReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovMsgNb(uint64(m.Status))
	}
	return n
}

func (m *SluitemData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovMsgNb(uint64(m.CmdIdx))
	}
	if m.ModelInfo != nil {
		l = m.ModelInfo.Size()
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if len(m.LightData) > 0 {
		for _, e := range m.LightData {
			l = e.Size()
			n += 1 + l + sovMsgNb(uint64(l))
		}
	}
	if m.LeakageCurrent != 0 {
		n += 9
	}
	if m.SluitemStatus != nil {
		l = m.SluitemStatus.Size()
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.TimeFault != nil {
		l = m.TimeFault.Size()
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.ResetCount != 0 {
		n += 1 + sovMsgNb(uint64(m.ResetCount))
	}
	if m.DateTime != 0 {
		n += 1 + sovMsgNb(uint64(m.DateTime))
	}
	if m.SluitemPara != nil {
		l = m.SluitemPara.Size()
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.Rsrp != 0 {
		n += 1 + sovMsgNb(uint64(m.Rsrp))
	}
	if m.Rssi != 0 {
		n += 1 + sovMsgNb(uint64(m.Rssi))
	}
	if m.Snr != 0 {
		n += 1 + sovMsgNb(uint64(m.Snr))
	}
	if m.Pci != 0 {
		n += 1 + sovMsgNb(uint64(m.Pci))
	}
	if m.Rsrq != 0 {
		n += 1 + sovMsgNb(uint64(m.Rsrq))
	}
	if m.Txpower != 0 {
		n += 1 + sovMsgNb(uint64(m.Txpower))
	}
	if m.Earfcn != 0 {
		n += 2 + sovMsgNb(uint64(m.Earfcn))
	}
	if m.Ecl != 0 {
		n += 2 + sovMsgNb(uint64(m.Ecl))
	}
	if m.Csq != 0 {
		n += 2 + sovMsgNb(uint64(m.Csq))
	}
	if m.Reson != 0 {
		n += 2 + sovMsgNb(uint64(m.Reson))
	}
	if m.Retry != 0 {
		n += 2 + sovMsgNb(uint64(m.Retry))
	}
	if m.Sunrise != 0 {
		n += 2 + sovMsgNb(uint64(m.Sunrise))
	}
	if m.Sunset != 0 {
		n += 2 + sovMsgNb(uint64(m.Sunset))
	}
	return n
}

func (m *SluitemData_ModelInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SluitemLoop != 0 {
		n += 1 + sovMsgNb(uint64(m.SluitemLoop))
	}
	if m.PowerSaving != 0 {
		n += 1 + sovMsgNb(uint64(m.PowerSaving))
	}
	if m.HasLeakage != 0 {
		n += 1 + sovMsgNb(uint64(m.HasLeakage))
	}
	if m.HasTemperature != 0 {
		n += 1 + sovMsgNb(uint64(m.HasTemperature))
	}
	if m.HasTimer != 0 {
		n += 1 + sovMsgNb(uint64(m.HasTimer))
	}
	if m.Model != 0 {
		n += 1 + sovMsgNb(uint64(m.Model))
	}
	l = len(m.SluitemType)
	if l > 0 {
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.UseLoop != 0 {
		n += 1 + sovMsgNb(uint64(m.UseLoop))
	}
	return n
}

func (m *SluitemData_LightData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Voltage != 0 {
		n += 9
	}
	if m.Current != 0 {
		n += 9
	}
	if m.ActivePower != 0 {
		n += 9
	}
	if m.ReactivePower != 0 {
		n += 9
	}
	if m.ApparentPower != 0 {
		n += 9
	}
	if m.Electricity != 0 {
		n += 9
	}
	if m.ActiveTime != 0 {
		n += 9
	}
	if m.LightStatus != nil {
		l = m.LightStatus.Size()
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.PowerLevel != 0 {
		n += 1 + sovMsgNb(uint64(m.PowerLevel))
	}
	if m.SluitemPowerTurnon != 0 {
		n += 1 + sovMsgNb(uint64(m.SluitemPowerTurnon))
	}
	if m.RatedPower != 0 {
		n += 1 + sovMsgNb(uint64(m.RatedPower))
	}
	return n
}

func (m *SluitemData_LightStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Leakage != 0 {
		n += 1 + sovMsgNb(uint64(m.Leakage))
	}
	if m.Fault != 0 {
		n += 1 + sovMsgNb(uint64(m.Fault))
	}
	if m.WorkingOn != 0 {
		n += 1 + sovMsgNb(uint64(m.WorkingOn))
	}
	return n
}

func (m *SluitemData_SluitemStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FlashFault != 0 {
		n += 1 + sovMsgNb(uint64(m.FlashFault))
	}
	if m.EnableAlarm != 0 {
		n += 1 + sovMsgNb(uint64(m.EnableAlarm))
	}
	return n
}

func (m *SluitemData_TimeFault) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClockFault != 0 {
		n += 1 + sovMsgNb(uint64(m.ClockFault))
	}
	if m.ClockOutFault != 0 {
		n += 1 + sovMsgNb(uint64(m.ClockOutFault))
	}
	if m.ClockOutAlarm != 0 {
		n += 1 + sovMsgNb(uint64(m.ClockOutAlarm))
	}
	return n
}

func (m *SluitemData_SluitemPara) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Longitude != 0 {
		n += 9
	}
	if m.Latitude != 0 {
		n += 9
	}
	if m.HasEnableAlarm != 0 {
		n += 1 + sovMsgNb(uint64(m.HasEnableAlarm))
	}
	if m.IsRunning != 0 {
		n += 1 + sovMsgNb(uint64(m.IsRunning))
	}
	if m.AlarmInterval != 0 {
		n += 1 + sovMsgNb(uint64(m.AlarmInterval))
	}
	if m.UplinkReply != 0 {
		n += 1 + sovMsgNb(uint64(m.UplinkReply))
	}
	return n
}

func (m *NBSlu_3100) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovMsgNb(uint64(m.CmdIdx))
	}
	l = len(m.Apn)
	if l > 0 {
		n += 1 + l + sovMsgNb(uint64(l))
	}
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovMsgNb(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.Operater != 0 {
		n += 1 + sovMsgNb(uint64(m.Operater))
	}
	if len(m.IpAddress) > 0 {
		l = 0
		for _, e := range m.IpAddress {
			l += sovMsgNb(uint64(e))
		}
		n += 1 + sovMsgNb(uint64(l)) + l
	}
	if m.Teleport != 0 {
		n += 1 + sovMsgNb(uint64(m.Teleport))
	}
	if m.Localport != 0 {
		n += 1 + sovMsgNb(uint64(m.Localport))
	}
	if m.VlinkTime != 0 {
		n += 1 + sovMsgNb(uint64(m.VlinkTime))
	}
	if m.GroupAccessInterval != 0 {
		n += 1 + sovMsgNb(uint64(m.GroupAccessInterval))
	}
	if m.GroupDeviceCount != 0 {
		n += 1 + sovMsgNb(uint64(m.GroupDeviceCount))
	}
	if m.MaxDeviceCount != 0 {
		n += 1 + sovMsgNb(uint64(m.MaxDeviceCount))
	}
	l = len(m.Imei)
	if l > 0 {
		n += 1 + l + sovMsgNb(uint64(l))
	}
	l = len(m.Imsi)
	if l > 0 {
		n += 1 + l + sovMsgNb(uint64(l))
	}
	l = len(m.Iccid)
	if l > 0 {
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.Status != 0 {
		n += 2 + sovMsgNb(uint64(m.Status))
	}
	return n
}

func (m *NBSlu_3700) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovMsgNb(uint64(m.CmdIdx))
	}
	l = len(m.Imei)
	if l > 0 {
		n += 1 + l + sovMsgNb(uint64(l))
	}
	l = len(m.Imsi)
	if l > 0 {
		n += 1 + l + sovMsgNb(uint64(l))
	}
	l = len(m.Iccid)
	if l > 0 {
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.Band != 0 {
		n += 1 + sovMsgNb(uint64(m.Band))
	}
	if m.Rsrp != 0 {
		n += 1 + sovMsgNb(uint64(m.Rsrp))
	}
	if m.Snr != 0 {
		n += 1 + sovMsgNb(uint64(m.Snr))
	}
	return n
}

func (m *NBSlu_1400) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovMsgNb(uint64(m.CmdIdx))
	}
	if m.SluitemTime != 0 {
		n += 1 + sovMsgNb(uint64(m.SluitemTime))
	}
	if m.Week != 0 {
		n += 1 + sovMsgNb(uint64(m.Week))
	}
	if m.Status != 0 {
		n += 1 + sovMsgNb(uint64(m.Status))
	}
	return n
}

func (m *NBSlu_5100) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovMsgNb(uint64(m.CmdIdx))
	}
	l = len(m.Ver)
	if l > 0 {
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovMsgNb(uint64(m.Status))
	}
	return n
}

func (m *NBSlu_5200) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovMsgNb(uint64(m.CmdIdx))
	}
	if m.Longitude != 0 {
		n += 9
	}
	if m.Latitude != 0 {
		n += 9
	}
	if m.SluitemStatus != 0 {
		n += 1 + sovMsgNb(uint64(m.SluitemStatus))
	}
	if len(m.SluitemPowerTurnon) > 0 {
		l = 0
		for _, e := range m.SluitemPowerTurnon {
			l += sovMsgNb(uint64(e))
		}
		n += 1 + sovMsgNb(uint64(l)) + l
	}
	if m.SluitemEnableAlarm != 0 {
		n += 1 + sovMsgNb(uint64(m.SluitemEnableAlarm))
	}
	if len(m.RatedPower) > 0 {
		l = 0
		for _, e := range m.RatedPower {
			l += sovMsgNb(uint64(e))
		}
		n += 1 + sovMsgNb(uint64(l)) + l
	}
	if m.UplinkTimer != 0 {
		n += 1 + sovMsgNb(uint64(m.UplinkTimer))
	}
	if m.UplinkReply != 0 {
		n += 1 + sovMsgNb(uint64(m.UplinkReply))
	}
	if m.UseLoop != 0 {
		n += 1 + sovMsgNb(uint64(m.UseLoop))
	}
	if m.Status != 0 {
		n += 1 + sovMsgNb(uint64(m.Status))
	}
	return n
}

func (m *NBSlu_5400) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovMsgNb(uint64(m.CmdIdx))
	}
	if m.OutputType != 0 {
		n += 1 + sovMsgNb(uint64(m.OutputType))
	}
	if len(m.RelayOperate) > 0 {
		l = 0
		for _, e := range m.RelayOperate {
			l += sovMsgNb(uint64(e))
		}
		n += 1 + sovMsgNb(uint64(l)) + l
	}
	if len(m.PwmLoop) > 0 {
		l = 0
		for _, e := range m.PwmLoop {
			l += sovMsgNb(uint64(e))
		}
		n += 1 + sovMsgNb(uint64(l)) + l
	}
	if m.PwmPower != 0 {
		n += 1 + sovMsgNb(uint64(m.PwmPower))
	}
	if m.PwmBaudrate != 0 {
		n += 1 + sovMsgNb(uint64(m.PwmBaudrate))
	}
	if m.Status != 0 {
		n += 1 + sovMsgNb(uint64(m.Status))
	}
	return n
}

func (m *NBSlu_5500) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovMsgNb(uint64(m.CmdIdx))
	}
	if m.Mcu != 0 {
		n += 1 + sovMsgNb(uint64(m.Mcu))
	}
	if m.InitializeMcu != 0 {
		n += 1 + sovMsgNb(uint64(m.InitializeMcu))
	}
	if m.InitializeRam != 0 {
		n += 1 + sovMsgNb(uint64(m.InitializeRam))
	}
	if m.InitializeEeprom != 0 {
		n += 1 + sovMsgNb(uint64(m.InitializeEeprom))
	}
	if m.InitializeElec != 0 {
		n += 1 + sovMsgNb(uint64(m.InitializeElec))
	}
	if m.Status != 0 {
		n += 1 + sovMsgNb(uint64(m.Status))
	}
	return n
}

func (m *NBSlu_5600) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovMsgNb(uint64(m.CmdIdx))
	}
	if m.ClearOldRuntime != 0 {
		n += 1 + sovMsgNb(uint64(m.ClearOldRuntime))
	}
	if m.DataContinue != 0 {
		n += 1 + sovMsgNb(uint64(m.DataContinue))
	}
	if m.SluitemRuntimeCount != 0 {
		n += 1 + sovMsgNb(uint64(m.SluitemRuntimeCount))
	}
	if len(m.SluitemRuntime) > 0 {
		for _, e := range m.SluitemRuntime {
			l = e.Size()
			n += 1 + l + sovMsgNb(uint64(l))
		}
	}
	if m.Status != 0 {
		n += 1 + sovMsgNb(uint64(m.Status))
	}
	return n
}

func (m *NBSlu_5600_SluitemRuntime) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OutputType != 0 {
		n += 1 + sovMsgNb(uint64(m.OutputType))
	}
	if m.OperateType != 0 {
		n += 1 + sovMsgNb(uint64(m.OperateType))
	}
	if len(m.DateEnable) > 0 {
		l = 0
		for _, e := range m.DateEnable {
			l += sovMsgNb(uint64(e))
		}
		n += 1 + sovMsgNb(uint64(l)) + l
	}
	if m.OperateTime != 0 {
		n += 1 + sovMsgNb(uint64(m.OperateTime))
	}
	if m.OperateOffset != 0 {
		n += 1 + sovMsgNb(uint64(m.OperateOffset))
	}
	if len(m.RelayOperate) > 0 {
		l = 0
		for _, e := range m.RelayOperate {
			l += sovMsgNb(uint64(e))
		}
		n += 1 + sovMsgNb(uint64(l)) + l
	}
	if len(m.PwmLoop) > 0 {
		l = 0
		for _, e := range m.PwmLoop {
			l += sovMsgNb(uint64(e))
		}
		n += 1 + sovMsgNb(uint64(l)) + l
	}
	if m.PwmPower != 0 {
		n += 1 + sovMsgNb(uint64(m.PwmPower))
	}
	if m.PwmBaudrate != 0 {
		n += 1 + sovMsgNb(uint64(m.PwmBaudrate))
	}
	return n
}

func (m *NBSlu_FF05) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Ver)
	if l > 0 {
		n += 1 + l + sovMsgNb(uint64(l))
	}
	return n
}

func (m *NBSlu_FF07) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatapackTotal != 0 {
		n += 1 + sovMsgNb(uint64(m.DatapackTotal))
	}
	if len(m.DatapackStatus) > 0 {
		l = 0
		for _, e := range m.DatapackStatus {
			l += sovMsgNb(uint64(e))
		}
		n += 1 + sovMsgNb(uint64(l)) + l
	}
	return n
}

func (m *NBSlu_FF01) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OldVer)
	if l > 0 {
		n += 1 + l + sovMsgNb(uint64(l))
	}
	l = len(m.NewVer)
	if l > 0 {
		n += 1 + l + sovMsgNb(uint64(l))
	}
	return n
}

func sovMsgNb(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMsgNb(x uint64) (n int) {
	return sovMsgNb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgNBiot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgNBiot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgNBiot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CmdName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdFlag", wireType)
			}
			m.CmdFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdFlag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Imei = append(m.Imei, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsgNb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsgNb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Imei) == 0 {
					m.Imei = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsgNb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Imei = append(m.Imei, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Imei", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RawData = append(m.RawData, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsgNb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsgNb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RawData) == 0 {
					m.RawData = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsgNb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RawData = append(m.RawData, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RawData", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgNBOpen) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgNBOpen: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgNBOpen: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Imei", wireType)
			}
			m.Imei = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Imei |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DtReceive", wireType)
			}
			m.DtReceive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DtReceive |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataType", wireType)
			}
			m.DataType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataCmd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataCmd = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SluitemData == nil {
				m.SluitemData = &SluitemData{}
			}
			if err := m.SluitemData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemReply", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SluitemReply == nil {
				m.SluitemReply = &SluitemReply{}
			}
			if err := m.SluitemReply.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SluitemConfig == nil {
				m.SluitemConfig = &SluitemConfig{}
			}
			if err := m.SluitemConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NbSlu_3100", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NbSlu_3100 == nil {
				m.NbSlu_3100 = &NBSlu_3100{}
			}
			if err := m.NbSlu_3100.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NbSlu_3700", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NbSlu_3700 == nil {
				m.NbSlu_3700 = &NBSlu_3700{}
			}
			if err := m.NbSlu_3700.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NbSlu_1400", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NbSlu_1400 == nil {
				m.NbSlu_1400 = &NBSlu_1400{}
			}
			if err := m.NbSlu_1400.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NbSlu_5100", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NbSlu_5100 == nil {
				m.NbSlu_5100 = &NBSlu_5100{}
			}
			if err := m.NbSlu_5100.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NbSlu_5200", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NbSlu_5200 == nil {
				m.NbSlu_5200 = &NBSlu_5200{}
			}
			if err := m.NbSlu_5200.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NbSlu_5400", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NbSlu_5400 == nil {
				m.NbSlu_5400 = &NBSlu_5400{}
			}
			if err := m.NbSlu_5400.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NbSlu_5500", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NbSlu_5500 == nil {
				m.NbSlu_5500 = &NBSlu_5500{}
			}
			if err := m.NbSlu_5500.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NbSlu_5600", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NbSlu_5600 == nil {
				m.NbSlu_5600 = &NBSlu_5600{}
			}
			if err := m.NbSlu_5600.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NbSluFf05", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NbSluFf05 == nil {
				m.NbSluFf05 = &NBSlu_FF05{}
			}
			if err := m.NbSluFf05.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NbSluFf07", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NbSluFf07 == nil {
				m.NbSluFf07 = &NBSlu_FF07{}
			}
			if err := m.NbSluFf07.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NbSluFf01", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NbSluFf01 == nil {
				m.NbSluFf01 = &NBSlu_FF01{}
			}
			if err := m.NbSluFf01.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SluitemConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SluitemConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SluitemConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemIdx", wireType)
			}
			m.SluitemIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemIdx |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataMark", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DataMark == nil {
				m.DataMark = &SluitemConfig_DataMark{}
			}
			if err := m.DataMark.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoopCount", wireType)
			}
			m.LoopCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoopCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemTime", wireType)
			}
			m.SluitemTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemPara", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SluitemPara == nil {
				m.SluitemPara = &SluitemConfig_SluitemPara{}
			}
			if err := m.SluitemPara.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemVer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SluitemVer == nil {
				m.SluitemVer = &SluitemConfig_SluitemVer{}
			}
			if err := m.SluitemVer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemSunriseset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SluitemSunriseset == nil {
				m.SluitemSunriseset = &SluitemConfig_SluitemSunriseset{}
			}
			if err := m.SluitemSunriseset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemRuntime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SluitemRuntime = append(m.SluitemRuntime, &SluitemConfig_SluitemRuntime{})
			if err := m.SluitemRuntime[len(m.SluitemRuntime)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetMark", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SetMark == nil {
				m.SetMark = &SluitemConfig_SetMark{}
			}
			if err := m.SetMark.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SluitemConfig_DataMark) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Data_mark: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Data_mark: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadTimer", wireType)
			}
			m.ReadTimer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadTimer |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadArgs", wireType)
			}
			m.ReadArgs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadArgs |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadVer", wireType)
			}
			m.ReadVer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadVer |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadSunriseset", wireType)
			}
			m.ReadSunriseset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadSunriseset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadTimetable", wireType)
			}
			m.ReadTimetable = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadTimetable |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SluitemConfig_SetMark) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Set_mark: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Set_mark: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetTimer", wireType)
			}
			m.SetTimer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SetTimer |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetArgs", wireType)
			}
			m.SetArgs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SetArgs |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetReset", wireType)
			}
			m.SetReset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SetReset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetTimetable", wireType)
			}
			m.SetTimetable = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SetTimetable |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SluitemConfig_SluitemPara) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sluitem_para: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sluitem_para: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemStatus", wireType)
			}
			m.SluitemStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemStatus |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemEnableAlarm", wireType)
			}
			m.SluitemEnableAlarm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemEnableAlarm |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SluitemPowerTurnon = append(m.SluitemPowerTurnon, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsgNb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsgNb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SluitemPowerTurnon) == 0 {
					m.SluitemPowerTurnon = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsgNb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SluitemPowerTurnon = append(m.SluitemPowerTurnon, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemPowerTurnon", wireType)
			}
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longitude", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Longitude = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latitude", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Latitude = float64(math.Float64frombits(v))
		case 8:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RatedPower = append(m.RatedPower, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsgNb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsgNb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RatedPower) == 0 {
					m.RatedPower = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsgNb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RatedPower = append(m.RatedPower, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RatedPower", wireType)
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UplinkTimer", wireType)
			}
			m.UplinkTimer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UplinkTimer |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UplinkReply", wireType)
			}
			m.UplinkReply = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UplinkReply |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SluitemConfig_SluitemVer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sluitem_ver: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sluitem_ver: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemLoop", wireType)
			}
			m.SluitemLoop = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemLoop |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnergySaving", wireType)
			}
			m.EnergySaving = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EnergySaving |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElectricLeakageModule", wireType)
			}
			m.ElectricLeakageModule = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ElectricLeakageModule |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemperatureModule", wireType)
			}
			m.TemperatureModule = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TemperatureModule |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimerModule", wireType)
			}
			m.TimerModule = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimerModule |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SluitemType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SluitemConfig_SluitemSunriseset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sluitem_sunriseset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sluitem_sunriseset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sunrise", wireType)
			}
			m.Sunrise = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sunrise |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sunset", wireType)
			}
			m.Sunset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sunset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SluitemConfig_SluitemRuntime) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sluitem_runtime: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sluitem_runtime: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataType", wireType)
			}
			m.DataType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputType", wireType)
			}
			m.OutputType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperateType", wireType)
			}
			m.OperateType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperateType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DateEnable = append(m.DateEnable, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsgNb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsgNb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DateEnable) == 0 {
					m.DateEnable = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsgNb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DateEnable = append(m.DateEnable, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DateEnable", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperateTime", wireType)
			}
			m.OperateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperateTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperateOffset", wireType)
			}
			m.OperateOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperateOffset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RelayOperate = append(m.RelayOperate, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsgNb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsgNb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RelayOperate) == 0 {
					m.RelayOperate = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsgNb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RelayOperate = append(m.RelayOperate, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayOperate", wireType)
			}
		case 8:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PwmLoop = append(m.PwmLoop, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsgNb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsgNb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PwmLoop) == 0 {
					m.PwmLoop = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsgNb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PwmLoop = append(m.PwmLoop, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PwmLoop", wireType)
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PwmPower", wireType)
			}
			m.PwmPower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PwmPower |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PwmBaudrate", wireType)
			}
			m.PwmBaudrate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PwmBaudrate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SluitemReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SluitemReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SluitemReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SluitemData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SluitemData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SluitemData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ModelInfo == nil {
				m.ModelInfo = &SluitemData_ModelInfo{}
			}
			if err := m.ModelInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LightData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LightData = append(m.LightData, &SluitemData_LightData{})
			if err := m.LightData[len(m.LightData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeakageCurrent", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.LeakageCurrent = float64(math.Float64frombits(v))
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SluitemStatus == nil {
				m.SluitemStatus = &SluitemData_SluitemStatus{}
			}
			if err := m.SluitemStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeFault", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TimeFault == nil {
				m.TimeFault = &SluitemData_TimeFault{}
			}
			if err := m.TimeFault.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResetCount", wireType)
			}
			m.ResetCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResetCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateTime", wireType)
			}
			m.DateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DateTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemPara", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SluitemPara == nil {
				m.SluitemPara = &SluitemData_SluitemPara{}
			}
			if err := m.SluitemPara.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rsrp", wireType)
			}
			m.Rsrp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rsrp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rssi", wireType)
			}
			m.Rssi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rssi |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snr", wireType)
			}
			m.Snr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Snr |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pci", wireType)
			}
			m.Pci = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pci |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rsrq", wireType)
			}
			m.Rsrq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rsrq |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txpower", wireType)
			}
			m.Txpower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Txpower |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Earfcn", wireType)
			}
			m.Earfcn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Earfcn |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecl", wireType)
			}
			m.Ecl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ecl |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Csq", wireType)
			}
			m.Csq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Csq |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reson", wireType)
			}
			m.Reson = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reson |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Retry", wireType)
			}
			m.Retry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Retry |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sunrise", wireType)
			}
			m.Sunrise = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sunrise |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sunset", wireType)
			}
			m.Sunset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sunset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SluitemData_ModelInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Model_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Model_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemLoop", wireType)
			}
			m.SluitemLoop = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemLoop |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PowerSaving", wireType)
			}
			m.PowerSaving = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PowerSaving |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasLeakage", wireType)
			}
			m.HasLeakage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HasLeakage |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasTemperature", wireType)
			}
			m.HasTemperature = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HasTemperature |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasTimer", wireType)
			}
			m.HasTimer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HasTimer |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			m.Model = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Model |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SluitemType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseLoop", wireType)
			}
			m.UseLoop = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UseLoop |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SluitemData_LightData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Light_data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Light_data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voltage", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Voltage = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Current", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Current = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivePower", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ActivePower = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReactivePower", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ReactivePower = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApparentPower", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ApparentPower = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Electricity", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Electricity = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveTime", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ActiveTime = float64(math.Float64frombits(v))
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LightStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LightStatus == nil {
				m.LightStatus = &SluitemData_LightStatus{}
			}
			if err := m.LightStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PowerLevel", wireType)
			}
			m.PowerLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PowerLevel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemPowerTurnon", wireType)
			}
			m.SluitemPowerTurnon = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemPowerTurnon |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RatedPower", wireType)
			}
			m.RatedPower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RatedPower |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SluitemData_LightStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Light_status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Light_status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leakage", wireType)
			}
			m.Leakage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Leakage |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fault", wireType)
			}
			m.Fault = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fault |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkingOn", wireType)
			}
			m.WorkingOn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkingOn |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SluitemData_SluitemStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sluitem_status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sluitem_status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlashFault", wireType)
			}
			m.FlashFault = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FlashFault |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableAlarm", wireType)
			}
			m.EnableAlarm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EnableAlarm |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SluitemData_TimeFault) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Time_fault: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Time_fault: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClockFault", wireType)
			}
			m.ClockFault = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClockFault |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClockOutFault", wireType)
			}
			m.ClockOutFault = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClockOutFault |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClockOutAlarm", wireType)
			}
			m.ClockOutAlarm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClockOutAlarm |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SluitemData_SluitemPara) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sluitem_para: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sluitem_para: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longitude", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Longitude = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latitude", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Latitude = float64(math.Float64frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasEnableAlarm", wireType)
			}
			m.HasEnableAlarm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HasEnableAlarm |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRunning", wireType)
			}
			m.IsRunning = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsRunning |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlarmInterval", wireType)
			}
			m.AlarmInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlarmInterval |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UplinkReply", wireType)
			}
			m.UplinkReply = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UplinkReply |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NBSlu_3100) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NBSlu_3100: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NBSlu_3100: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Apn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Apn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operater", wireType)
			}
			m.Operater = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Operater |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IpAddress = append(m.IpAddress, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsgNb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsgNb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.IpAddress) == 0 {
					m.IpAddress = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsgNb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IpAddress = append(m.IpAddress, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddress", wireType)
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Teleport", wireType)
			}
			m.Teleport = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Teleport |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Localport", wireType)
			}
			m.Localport = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Localport |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VlinkTime", wireType)
			}
			m.VlinkTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VlinkTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupAccessInterval", wireType)
			}
			m.GroupAccessInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupAccessInterval |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupDeviceCount", wireType)
			}
			m.GroupDeviceCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupDeviceCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDeviceCount", wireType)
			}
			m.MaxDeviceCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxDeviceCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Imei", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Imei = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Imsi", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Imsi = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iccid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Iccid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NBSlu_3700) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NBSlu_3700: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NBSlu_3700: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Imei", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Imei = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Imsi", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Imsi = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iccid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Iccid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Band", wireType)
			}
			m.Band = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Band |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rsrp", wireType)
			}
			m.Rsrp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rsrp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snr", wireType)
			}
			m.Snr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Snr |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NBSlu_1400) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NBSlu_1400: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NBSlu_1400: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemTime", wireType)
			}
			m.SluitemTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Week", wireType)
			}
			m.Week = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Week |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NBSlu_5100) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NBSlu_5100: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NBSlu_5100: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NBSlu_5200) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NBSlu_5200: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NBSlu_5200: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longitude", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Longitude = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latitude", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Latitude = float64(math.Float64frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemStatus", wireType)
			}
			m.SluitemStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemStatus |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SluitemPowerTurnon = append(m.SluitemPowerTurnon, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsgNb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsgNb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SluitemPowerTurnon) == 0 {
					m.SluitemPowerTurnon = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsgNb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SluitemPowerTurnon = append(m.SluitemPowerTurnon, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemPowerTurnon", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemEnableAlarm", wireType)
			}
			m.SluitemEnableAlarm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemEnableAlarm |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RatedPower = append(m.RatedPower, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsgNb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsgNb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RatedPower) == 0 {
					m.RatedPower = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsgNb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RatedPower = append(m.RatedPower, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RatedPower", wireType)
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UplinkTimer", wireType)
			}
			m.UplinkTimer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UplinkTimer |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UplinkReply", wireType)
			}
			m.UplinkReply = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UplinkReply |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseLoop", wireType)
			}
			m.UseLoop = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UseLoop |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NBSlu_5400) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NBSlu_5400: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NBSlu_5400: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputType", wireType)
			}
			m.OutputType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RelayOperate = append(m.RelayOperate, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsgNb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsgNb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RelayOperate) == 0 {
					m.RelayOperate = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsgNb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RelayOperate = append(m.RelayOperate, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayOperate", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PwmLoop = append(m.PwmLoop, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsgNb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsgNb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PwmLoop) == 0 {
					m.PwmLoop = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsgNb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PwmLoop = append(m.PwmLoop, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PwmLoop", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PwmPower", wireType)
			}
			m.PwmPower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PwmPower |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PwmBaudrate", wireType)
			}
			m.PwmBaudrate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PwmBaudrate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NBSlu_5500) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NBSlu_5500: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NBSlu_5500: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mcu", wireType)
			}
			m.Mcu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mcu |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitializeMcu", wireType)
			}
			m.InitializeMcu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitializeMcu |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitializeRam", wireType)
			}
			m.InitializeRam = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitializeRam |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitializeEeprom", wireType)
			}
			m.InitializeEeprom = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitializeEeprom |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitializeElec", wireType)
			}
			m.InitializeElec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitializeElec |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NBSlu_5600) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NBSlu_5600: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NBSlu_5600: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClearOldRuntime", wireType)
			}
			m.ClearOldRuntime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClearOldRuntime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataContinue", wireType)
			}
			m.DataContinue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataContinue |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemRuntimeCount", wireType)
			}
			m.SluitemRuntimeCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemRuntimeCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemRuntime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SluitemRuntime = append(m.SluitemRuntime, &NBSlu_5600_SluitemRuntime{})
			if err := m.SluitemRuntime[len(m.SluitemRuntime)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NBSlu_5600_SluitemRuntime) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sluitem_runtime: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sluitem_runtime: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputType", wireType)
			}
			m.OutputType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperateType", wireType)
			}
			m.OperateType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperateType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DateEnable = append(m.DateEnable, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsgNb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsgNb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DateEnable) == 0 {
					m.DateEnable = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsgNb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DateEnable = append(m.DateEnable, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DateEnable", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperateTime", wireType)
			}
			m.OperateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperateTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperateOffset", wireType)
			}
			m.OperateOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperateOffset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RelayOperate = append(m.RelayOperate, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsgNb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsgNb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RelayOperate) == 0 {
					m.RelayOperate = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsgNb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RelayOperate = append(m.RelayOperate, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayOperate", wireType)
			}
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PwmLoop = append(m.PwmLoop, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsgNb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsgNb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PwmLoop) == 0 {
					m.PwmLoop = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsgNb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PwmLoop = append(m.PwmLoop, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PwmLoop", wireType)
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PwmPower", wireType)
			}
			m.PwmPower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PwmPower |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PwmBaudrate", wireType)
			}
			m.PwmBaudrate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PwmBaudrate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NBSlu_FF05) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NBSlu_FF05: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NBSlu_FF05: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NBSlu_FF07) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NBSlu_FF07: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NBSlu_FF07: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatapackTotal", wireType)
			}
			m.DatapackTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DatapackTotal |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DatapackStatus = append(m.DatapackStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsgNb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsgNb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DatapackStatus) == 0 {
					m.DatapackStatus = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsgNb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DatapackStatus = append(m.DatapackStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DatapackStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NBSlu_FF01) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NBSlu_FF01: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NBSlu_FF01: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldVer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OldVer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewVer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewVer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMsgNb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMsgNb
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMsgNb
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMsgNb
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMsgNb        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMsgNb          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMsgNb = fmt.Errorf("proto: unexpected end of group")
)
