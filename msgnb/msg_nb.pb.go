// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: msg_nb.proto

package wlst_nbiot

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type MsgNBiot struct {
	CmdIdx int64 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// GoWork or GoWorkTask
	CmdName string `protobuf:"bytes,2,opt,name=cmd_name,json=cmdName,proto3" json:"cmd_name,omitempty"`
	// 0xdad9 or 0xdad0
	CmdFlag int32   `protobuf:"varint,3,opt,name=cmd_flag,json=cmdFlag,proto3" json:"cmd_flag,omitempty"`
	Imei    []int64 `protobuf:"varint,4,rep,packed,name=imei,proto3" json:"imei,omitempty"`
	// hex string
	RawData []int32 `protobuf:"varint,5,rep,packed,name=raw_data,json=rawData,proto3" json:"raw_data,omitempty"`
}

func (m *MsgNBiot) Reset()      { *m = MsgNBiot{} }
func (*MsgNBiot) ProtoMessage() {}
func (*MsgNBiot) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{0}
}
func (m *MsgNBiot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgNBiot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgNBiot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgNBiot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgNBiot.Merge(m, src)
}
func (m *MsgNBiot) XXX_Size() int {
	return m.Size()
}
func (m *MsgNBiot) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgNBiot.DiscardUnknown(m)
}

var xxx_messageInfo_MsgNBiot proto.InternalMessageInfo

func (m *MsgNBiot) GetCmdIdx() int64 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *MsgNBiot) GetCmdName() string {
	if m != nil {
		return m.CmdName
	}
	return ""
}

func (m *MsgNBiot) GetCmdFlag() int32 {
	if m != nil {
		return m.CmdFlag
	}
	return 0
}

func (m *MsgNBiot) GetImei() []int64 {
	if m != nil {
		return m.Imei
	}
	return nil
}

func (m *MsgNBiot) GetRawData() []int32 {
	if m != nil {
		return m.RawData
	}
	return nil
}

//数据服务和通讯服务传输格式
type MsgNBOpen struct {
	// 设备imei
	Imei int64 `protobuf:"varint,1,opt,name=imei,proto3" json:"imei,omitempty"`
	// 数据接收时间
	DtReceive int64 `protobuf:"varint,2,opt,name=dt_receive,json=dtReceive,proto3" json:"dt_receive,omitempty"`
	// 数据类型，1-设备最新数据，2-控制应答，3-参数设置/读取应答
	DataType int32 `protobuf:"varint,3,opt,name=data_type,json=dataType,proto3" json:"data_type,omitempty"`
	// 内部命令名称
	DataCmd string `protobuf:"bytes,9,opt,name=data_cmd,json=dataCmd,proto3" json:"data_cmd,omitempty"`
	// 设备最新数据
	SluitemData *SluitemData `protobuf:"bytes,10,opt,name=sluitem_data,json=sluitemData,proto3" json:"sluitem_data,omitempty"`
	// 控制应答
	SluitemReply *SluitemReply `protobuf:"bytes,11,opt,name=sluitem_reply,json=sluitemReply,proto3" json:"sluitem_reply,omitempty"`
	// 参数设置/读取
	SluitemConfig *SluitemConfig `protobuf:"bytes,12,opt,name=sluitem_config,json=sluitemConfig,proto3" json:"sluitem_config,omitempty"`
}

func (m *MsgNBOpen) Reset()      { *m = MsgNBOpen{} }
func (*MsgNBOpen) ProtoMessage() {}
func (*MsgNBOpen) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{1}
}
func (m *MsgNBOpen) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgNBOpen) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgNBOpen.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgNBOpen) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgNBOpen.Merge(m, src)
}
func (m *MsgNBOpen) XXX_Size() int {
	return m.Size()
}
func (m *MsgNBOpen) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgNBOpen.DiscardUnknown(m)
}

var xxx_messageInfo_MsgNBOpen proto.InternalMessageInfo

func (m *MsgNBOpen) GetImei() int64 {
	if m != nil {
		return m.Imei
	}
	return 0
}

func (m *MsgNBOpen) GetDtReceive() int64 {
	if m != nil {
		return m.DtReceive
	}
	return 0
}

func (m *MsgNBOpen) GetDataType() int32 {
	if m != nil {
		return m.DataType
	}
	return 0
}

func (m *MsgNBOpen) GetDataCmd() string {
	if m != nil {
		return m.DataCmd
	}
	return ""
}

func (m *MsgNBOpen) GetSluitemData() *SluitemData {
	if m != nil {
		return m.SluitemData
	}
	return nil
}

func (m *MsgNBOpen) GetSluitemReply() *SluitemReply {
	if m != nil {
		return m.SluitemReply
	}
	return nil
}

func (m *MsgNBOpen) GetSluitemConfig() *SluitemConfig {
	if m != nil {
		return m.SluitemConfig
	}
	return nil
}

type SluitemConfig struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 控制器条码（4字节）
	SluitemIdx int64 `protobuf:"varint,2,opt,name=sluitem_idx,json=sluitemIdx,proto3" json:"sluitem_idx,omitempty"`
	// 参数读取标识
	DataMark *SluitemConfig_DataMark `protobuf:"bytes,4,opt,name=data_mark,json=dataMark,proto3" json:"data_mark,omitempty"`
	// 控制器回路数量
	LoopCount int32 `protobuf:"varint,5,opt,name=loop_count,json=loopCount,proto3" json:"loop_count,omitempty"`
	// 控制器时钟(read_timer)
	SluitemTime int64 `protobuf:"varint,7,opt,name=sluitem_time,json=sluitemTime,proto3" json:"sluitem_time,omitempty"`
	// 控制器运行参数(read_args)
	SluitemPara *SluitemConfig_SluitemPara `protobuf:"bytes,8,opt,name=sluitem_para,json=sluitemPara,proto3" json:"sluitem_para,omitempty"`
	// 控制器版本(read_ver)
	SluitemVer *SluitemConfig_SluitemVer `protobuf:"bytes,10,opt,name=sluitem_ver,json=sluitemVer,proto3" json:"sluitem_ver,omitempty"`
	// 控制器当日日出日落(read_sunriseset)
	SluitemSunriseset *SluitemConfig_SluitemSunriseset `protobuf:"bytes,11,opt,name=sluitem_sunriseset,json=sluitemSunriseset,proto3" json:"sluitem_sunriseset,omitempty"`
	// 控制器定时控制参数(read_timetable)
	SluitemRuntime []*SluitemConfig_SluitemRuntime `protobuf:"bytes,12,rep,name=sluitem_runtime,json=sluitemRuntime,proto3" json:"sluitem_runtime,omitempty"`
	// 设置状态0-失败，1-成功
	Status int32 `protobuf:"varint,14,opt,name=status,proto3" json:"status,omitempty"`
	// 参数设置标识
	SetMark *SluitemConfig_SetMark `protobuf:"bytes,15,opt,name=set_mark,json=setMark,proto3" json:"set_mark,omitempty"`
}

func (m *SluitemConfig) Reset()      { *m = SluitemConfig{} }
func (*SluitemConfig) ProtoMessage() {}
func (*SluitemConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{2}
}
func (m *SluitemConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SluitemConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SluitemConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SluitemConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SluitemConfig.Merge(m, src)
}
func (m *SluitemConfig) XXX_Size() int {
	return m.Size()
}
func (m *SluitemConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_SluitemConfig.DiscardUnknown(m)
}

var xxx_messageInfo_SluitemConfig proto.InternalMessageInfo

func (m *SluitemConfig) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *SluitemConfig) GetSluitemIdx() int64 {
	if m != nil {
		return m.SluitemIdx
	}
	return 0
}

func (m *SluitemConfig) GetDataMark() *SluitemConfig_DataMark {
	if m != nil {
		return m.DataMark
	}
	return nil
}

func (m *SluitemConfig) GetLoopCount() int32 {
	if m != nil {
		return m.LoopCount
	}
	return 0
}

func (m *SluitemConfig) GetSluitemTime() int64 {
	if m != nil {
		return m.SluitemTime
	}
	return 0
}

func (m *SluitemConfig) GetSluitemPara() *SluitemConfig_SluitemPara {
	if m != nil {
		return m.SluitemPara
	}
	return nil
}

func (m *SluitemConfig) GetSluitemVer() *SluitemConfig_SluitemVer {
	if m != nil {
		return m.SluitemVer
	}
	return nil
}

func (m *SluitemConfig) GetSluitemSunriseset() *SluitemConfig_SluitemSunriseset {
	if m != nil {
		return m.SluitemSunriseset
	}
	return nil
}

func (m *SluitemConfig) GetSluitemRuntime() []*SluitemConfig_SluitemRuntime {
	if m != nil {
		return m.SluitemRuntime
	}
	return nil
}

func (m *SluitemConfig) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *SluitemConfig) GetSetMark() *SluitemConfig_SetMark {
	if m != nil {
		return m.SetMark
	}
	return nil
}

type SluitemConfig_DataMark struct {
	// 读取时钟
	ReadTimer int32 `protobuf:"varint,2,opt,name=read_timer,json=readTimer,proto3" json:"read_timer,omitempty"`
	// 读取运行参数
	ReadArgs int32 `protobuf:"varint,3,opt,name=read_args,json=readArgs,proto3" json:"read_args,omitempty"`
	// 读取版本
	ReadVer int32 `protobuf:"varint,5,opt,name=read_ver,json=readVer,proto3" json:"read_ver,omitempty"`
	// 读取当天日出日落
	ReadSunriseset int32 `protobuf:"varint,6,opt,name=read_sunriseset,json=readSunriseset,proto3" json:"read_sunriseset,omitempty"`
	// 读取定时控制参数
	ReadTimetable int32 `protobuf:"varint,7,opt,name=read_timetable,json=readTimetable,proto3" json:"read_timetable,omitempty"`
}

func (m *SluitemConfig_DataMark) Reset()      { *m = SluitemConfig_DataMark{} }
func (*SluitemConfig_DataMark) ProtoMessage() {}
func (*SluitemConfig_DataMark) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{2, 0}
}
func (m *SluitemConfig_DataMark) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SluitemConfig_DataMark) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SluitemConfig_DataMark.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SluitemConfig_DataMark) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SluitemConfig_DataMark.Merge(m, src)
}
func (m *SluitemConfig_DataMark) XXX_Size() int {
	return m.Size()
}
func (m *SluitemConfig_DataMark) XXX_DiscardUnknown() {
	xxx_messageInfo_SluitemConfig_DataMark.DiscardUnknown(m)
}

var xxx_messageInfo_SluitemConfig_DataMark proto.InternalMessageInfo

func (m *SluitemConfig_DataMark) GetReadTimer() int32 {
	if m != nil {
		return m.ReadTimer
	}
	return 0
}

func (m *SluitemConfig_DataMark) GetReadArgs() int32 {
	if m != nil {
		return m.ReadArgs
	}
	return 0
}

func (m *SluitemConfig_DataMark) GetReadVer() int32 {
	if m != nil {
		return m.ReadVer
	}
	return 0
}

func (m *SluitemConfig_DataMark) GetReadSunriseset() int32 {
	if m != nil {
		return m.ReadSunriseset
	}
	return 0
}

func (m *SluitemConfig_DataMark) GetReadTimetable() int32 {
	if m != nil {
		return m.ReadTimetable
	}
	return 0
}

type SluitemConfig_SetMark struct {
	// 设置时钟
	SetTimer int32 `protobuf:"varint,1,opt,name=set_timer,json=setTimer,proto3" json:"set_timer,omitempty"`
	// 设置运行参数
	SetArgs int32 `protobuf:"varint,2,opt,name=set_args,json=setArgs,proto3" json:"set_args,omitempty"`
	// 复位设备
	SetReset int32 `protobuf:"varint,4,opt,name=set_reset,json=setReset,proto3" json:"set_reset,omitempty"`
	// 设置定时控制参数
	SetTimetable int32 `protobuf:"varint,5,opt,name=set_timetable,json=setTimetable,proto3" json:"set_timetable,omitempty"`
}

func (m *SluitemConfig_SetMark) Reset()      { *m = SluitemConfig_SetMark{} }
func (*SluitemConfig_SetMark) ProtoMessage() {}
func (*SluitemConfig_SetMark) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{2, 1}
}
func (m *SluitemConfig_SetMark) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SluitemConfig_SetMark) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SluitemConfig_SetMark.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SluitemConfig_SetMark) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SluitemConfig_SetMark.Merge(m, src)
}
func (m *SluitemConfig_SetMark) XXX_Size() int {
	return m.Size()
}
func (m *SluitemConfig_SetMark) XXX_DiscardUnknown() {
	xxx_messageInfo_SluitemConfig_SetMark.DiscardUnknown(m)
}

var xxx_messageInfo_SluitemConfig_SetMark proto.InternalMessageInfo

func (m *SluitemConfig_SetMark) GetSetTimer() int32 {
	if m != nil {
		return m.SetTimer
	}
	return 0
}

func (m *SluitemConfig_SetMark) GetSetArgs() int32 {
	if m != nil {
		return m.SetArgs
	}
	return 0
}

func (m *SluitemConfig_SetMark) GetSetReset() int32 {
	if m != nil {
		return m.SetReset
	}
	return 0
}

func (m *SluitemConfig_SetMark) GetSetTimetable() int32 {
	if m != nil {
		return m.SetTimetable
	}
	return 0
}

type SluitemConfig_SluitemPara struct {
	// 控制器状态 0-停运，1-投运
	SluitemStatus int32 `protobuf:"varint,2,opt,name=sluitem_status,json=sluitemStatus,proto3" json:"sluitem_status,omitempty"`
	// 控制器主报 0-禁止主报，1-允许主报
	SluitemEnableAlarm int32 `protobuf:"varint,3,opt,name=sluitem_enable_alarm,json=sluitemEnableAlarm,proto3" json:"sluitem_enable_alarm,omitempty"`
	// 控制器上电开灯 1-开灯，0-关灯
	SluitemPowerTurnon []int32 `protobuf:"varint,4,rep,packed,name=sluitem_power_turnon,json=sluitemPowerTurnon,proto3" json:"sluitem_power_turnon,omitempty"`
	// 经度
	Longitude float64 `protobuf:"fixed64,6,opt,name=longitude,proto3" json:"longitude,omitempty"`
	// 纬度
	Latitude float64 `protobuf:"fixed64,7,opt,name=latitude,proto3" json:"latitude,omitempty"`
	// 1-4回路额定功率
	RatedPower []int32 `protobuf:"varint,8,rep,packed,name=rated_power,json=ratedPower,proto3" json:"rated_power,omitempty"`
	// nb主报间隔，(0～127)*5
	UplinkTimer int32 `protobuf:"varint,9,opt,name=uplink_timer,json=uplinkTimer,proto3" json:"uplink_timer,omitempty"`
	// nb主报需要主站应答，0-不需要，1-需要
	UplinkReply int32 `protobuf:"varint,10,opt,name=uplink_reply,json=uplinkReply,proto3" json:"uplink_reply,omitempty"`
}

func (m *SluitemConfig_SluitemPara) Reset()      { *m = SluitemConfig_SluitemPara{} }
func (*SluitemConfig_SluitemPara) ProtoMessage() {}
func (*SluitemConfig_SluitemPara) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{2, 2}
}
func (m *SluitemConfig_SluitemPara) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SluitemConfig_SluitemPara) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SluitemConfig_SluitemPara.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SluitemConfig_SluitemPara) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SluitemConfig_SluitemPara.Merge(m, src)
}
func (m *SluitemConfig_SluitemPara) XXX_Size() int {
	return m.Size()
}
func (m *SluitemConfig_SluitemPara) XXX_DiscardUnknown() {
	xxx_messageInfo_SluitemConfig_SluitemPara.DiscardUnknown(m)
}

var xxx_messageInfo_SluitemConfig_SluitemPara proto.InternalMessageInfo

func (m *SluitemConfig_SluitemPara) GetSluitemStatus() int32 {
	if m != nil {
		return m.SluitemStatus
	}
	return 0
}

func (m *SluitemConfig_SluitemPara) GetSluitemEnableAlarm() int32 {
	if m != nil {
		return m.SluitemEnableAlarm
	}
	return 0
}

func (m *SluitemConfig_SluitemPara) GetSluitemPowerTurnon() []int32 {
	if m != nil {
		return m.SluitemPowerTurnon
	}
	return nil
}

func (m *SluitemConfig_SluitemPara) GetLongitude() float64 {
	if m != nil {
		return m.Longitude
	}
	return 0
}

func (m *SluitemConfig_SluitemPara) GetLatitude() float64 {
	if m != nil {
		return m.Latitude
	}
	return 0
}

func (m *SluitemConfig_SluitemPara) GetRatedPower() []int32 {
	if m != nil {
		return m.RatedPower
	}
	return nil
}

func (m *SluitemConfig_SluitemPara) GetUplinkTimer() int32 {
	if m != nil {
		return m.UplinkTimer
	}
	return 0
}

func (m *SluitemConfig_SluitemPara) GetUplinkReply() int32 {
	if m != nil {
		return m.UplinkReply
	}
	return 0
}

type SluitemConfig_SluitemVer struct {
	// 控制器回路
	SluitemLoop int32 `protobuf:"varint,1,opt,name=sluitem_loop,json=sluitemLoop,proto3" json:"sluitem_loop,omitempty"`
	// 节能方式
	EnergySaving int32 `protobuf:"varint,2,opt,name=energy_saving,json=energySaving,proto3" json:"energy_saving,omitempty"`
	// 有漏电模块
	ElectricLeakageModule int32 `protobuf:"varint,3,opt,name=electric_leakage_module,json=electricLeakageModule,proto3" json:"electric_leakage_module,omitempty"`
	// 有温度检测模块
	TemperatureModule int32 `protobuf:"varint,4,opt,name=temperature_module,json=temperatureModule,proto3" json:"temperature_module,omitempty"`
	// 有时钟
	TimerModule int32 `protobuf:"varint,5,opt,name=timer_module,json=timerModule,proto3" json:"timer_module,omitempty"`
	// 型号 0-unknow,1-wj2090j
	SluitemType string `protobuf:"bytes,6,opt,name=sluitem_type,json=sluitemType,proto3" json:"sluitem_type,omitempty"`
	// 软件版本
	Ver string `protobuf:"bytes,7,opt,name=ver,proto3" json:"ver,omitempty"`
}

func (m *SluitemConfig_SluitemVer) Reset()      { *m = SluitemConfig_SluitemVer{} }
func (*SluitemConfig_SluitemVer) ProtoMessage() {}
func (*SluitemConfig_SluitemVer) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{2, 3}
}
func (m *SluitemConfig_SluitemVer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SluitemConfig_SluitemVer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SluitemConfig_SluitemVer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SluitemConfig_SluitemVer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SluitemConfig_SluitemVer.Merge(m, src)
}
func (m *SluitemConfig_SluitemVer) XXX_Size() int {
	return m.Size()
}
func (m *SluitemConfig_SluitemVer) XXX_DiscardUnknown() {
	xxx_messageInfo_SluitemConfig_SluitemVer.DiscardUnknown(m)
}

var xxx_messageInfo_SluitemConfig_SluitemVer proto.InternalMessageInfo

func (m *SluitemConfig_SluitemVer) GetSluitemLoop() int32 {
	if m != nil {
		return m.SluitemLoop
	}
	return 0
}

func (m *SluitemConfig_SluitemVer) GetEnergySaving() int32 {
	if m != nil {
		return m.EnergySaving
	}
	return 0
}

func (m *SluitemConfig_SluitemVer) GetElectricLeakageModule() int32 {
	if m != nil {
		return m.ElectricLeakageModule
	}
	return 0
}

func (m *SluitemConfig_SluitemVer) GetTemperatureModule() int32 {
	if m != nil {
		return m.TemperatureModule
	}
	return 0
}

func (m *SluitemConfig_SluitemVer) GetTimerModule() int32 {
	if m != nil {
		return m.TimerModule
	}
	return 0
}

func (m *SluitemConfig_SluitemVer) GetSluitemType() string {
	if m != nil {
		return m.SluitemType
	}
	return ""
}

func (m *SluitemConfig_SluitemVer) GetVer() string {
	if m != nil {
		return m.Ver
	}
	return ""
}

type SluitemConfig_SluitemSunriseset struct {
	// 当日日出日落时间 hhmm->int32
	Sunrise int32 `protobuf:"varint,1,opt,name=sunrise,proto3" json:"sunrise,omitempty"`
	Sunset  int32 `protobuf:"varint,2,opt,name=sunset,proto3" json:"sunset,omitempty"`
}

func (m *SluitemConfig_SluitemSunriseset) Reset()      { *m = SluitemConfig_SluitemSunriseset{} }
func (*SluitemConfig_SluitemSunriseset) ProtoMessage() {}
func (*SluitemConfig_SluitemSunriseset) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{2, 4}
}
func (m *SluitemConfig_SluitemSunriseset) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SluitemConfig_SluitemSunriseset) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SluitemConfig_SluitemSunriseset.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SluitemConfig_SluitemSunriseset) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SluitemConfig_SluitemSunriseset.Merge(m, src)
}
func (m *SluitemConfig_SluitemSunriseset) XXX_Size() int {
	return m.Size()
}
func (m *SluitemConfig_SluitemSunriseset) XXX_DiscardUnknown() {
	xxx_messageInfo_SluitemConfig_SluitemSunriseset.DiscardUnknown(m)
}

var xxx_messageInfo_SluitemConfig_SluitemSunriseset proto.InternalMessageInfo

func (m *SluitemConfig_SluitemSunriseset) GetSunrise() int32 {
	if m != nil {
		return m.Sunrise
	}
	return 0
}

func (m *SluitemConfig_SluitemSunriseset) GetSunset() int32 {
	if m != nil {
		return m.Sunset
	}
	return 0
}

type SluitemConfig_SluitemRuntime struct {
	// 本地控制数据类型0-基本类型（6字节），1-扩展类型（6+20字节）
	DataType int32 `protobuf:"varint,1,opt,name=data_type,json=dataType,proto3" json:"data_type,omitempty"`
	// 输出类型0-继电器，1-pwm输出，2-485
	OutputType int32 `protobuf:"varint,2,opt,name=output_type,json=outputType,proto3" json:"output_type,omitempty"`
	// 操作类型1-定时操作，2-经纬度操作，3-即时操作
	OperateType int32 `protobuf:"varint,3,opt,name=operate_type,json=operateType,proto3" json:"operate_type,omitempty"`
	// 有效日期，0-6～周日-周6
	DateEnable []int32 `protobuf:"varint,4,rep,packed,name=date_enable,json=dateEnable,proto3" json:"date_enable,omitempty"`
	// 开关灯操作时间 hhmm->int32
	OperateTime int32 `protobuf:"varint,5,opt,name=operate_time,json=operateTime,proto3" json:"operate_time,omitempty"`
	// 操作偏移 -720~+720
	OperateOffset int32 `protobuf:"varint,6,opt,name=operate_offset,json=operateOffset,proto3" json:"operate_offset,omitempty"`
	// 继电器操作回路1-4, 0x0-不操作，0x3-开灯，0xc-关灯
	RelayOperate []int32 `protobuf:"varint,7,rep,packed,name=relay_operate,json=relayOperate,proto3" json:"relay_operate,omitempty"`
	// PWM操作回路
	PwmLoop []int32 `protobuf:"varint,8,rep,packed,name=pwm_loop,json=pwmLoop,proto3" json:"pwm_loop,omitempty"`
	// PWM操作占空比
	PwmPower int32 `protobuf:"varint,9,opt,name=pwm_power,json=pwmPower,proto3" json:"pwm_power,omitempty"`
	// PWM频率 (1~255) * 100
	PwmBaudrate int32 `protobuf:"varint,10,opt,name=pwm_baudrate,json=pwmBaudrate,proto3" json:"pwm_baudrate,omitempty"`
}

func (m *SluitemConfig_SluitemRuntime) Reset()      { *m = SluitemConfig_SluitemRuntime{} }
func (*SluitemConfig_SluitemRuntime) ProtoMessage() {}
func (*SluitemConfig_SluitemRuntime) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{2, 5}
}
func (m *SluitemConfig_SluitemRuntime) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SluitemConfig_SluitemRuntime) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SluitemConfig_SluitemRuntime.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SluitemConfig_SluitemRuntime) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SluitemConfig_SluitemRuntime.Merge(m, src)
}
func (m *SluitemConfig_SluitemRuntime) XXX_Size() int {
	return m.Size()
}
func (m *SluitemConfig_SluitemRuntime) XXX_DiscardUnknown() {
	xxx_messageInfo_SluitemConfig_SluitemRuntime.DiscardUnknown(m)
}

var xxx_messageInfo_SluitemConfig_SluitemRuntime proto.InternalMessageInfo

func (m *SluitemConfig_SluitemRuntime) GetDataType() int32 {
	if m != nil {
		return m.DataType
	}
	return 0
}

func (m *SluitemConfig_SluitemRuntime) GetOutputType() int32 {
	if m != nil {
		return m.OutputType
	}
	return 0
}

func (m *SluitemConfig_SluitemRuntime) GetOperateType() int32 {
	if m != nil {
		return m.OperateType
	}
	return 0
}

func (m *SluitemConfig_SluitemRuntime) GetDateEnable() []int32 {
	if m != nil {
		return m.DateEnable
	}
	return nil
}

func (m *SluitemConfig_SluitemRuntime) GetOperateTime() int32 {
	if m != nil {
		return m.OperateTime
	}
	return 0
}

func (m *SluitemConfig_SluitemRuntime) GetOperateOffset() int32 {
	if m != nil {
		return m.OperateOffset
	}
	return 0
}

func (m *SluitemConfig_SluitemRuntime) GetRelayOperate() []int32 {
	if m != nil {
		return m.RelayOperate
	}
	return nil
}

func (m *SluitemConfig_SluitemRuntime) GetPwmLoop() []int32 {
	if m != nil {
		return m.PwmLoop
	}
	return nil
}

func (m *SluitemConfig_SluitemRuntime) GetPwmPower() int32 {
	if m != nil {
		return m.PwmPower
	}
	return 0
}

func (m *SluitemConfig_SluitemRuntime) GetPwmBaudrate() int32 {
	if m != nil {
		return m.PwmBaudrate
	}
	return 0
}

type SluitemReply struct {
	// 开关灯调光操作结果，0-失败，1-成功
	Status int32 `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *SluitemReply) Reset()      { *m = SluitemReply{} }
func (*SluitemReply) ProtoMessage() {}
func (*SluitemReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{3}
}
func (m *SluitemReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SluitemReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SluitemReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SluitemReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SluitemReply.Merge(m, src)
}
func (m *SluitemReply) XXX_Size() int {
	return m.Size()
}
func (m *SluitemReply) XXX_DiscardUnknown() {
	xxx_messageInfo_SluitemReply.DiscardUnknown(m)
}

var xxx_messageInfo_SluitemReply proto.InternalMessageInfo

func (m *SluitemReply) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

type SluitemData struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 型号
	ModelInfo *SluitemData_ModelInfo `protobuf:"bytes,2,opt,name=model_info,json=modelInfo,proto3" json:"model_info,omitempty"`
	// 回路数据(最大4个)
	LightData []*SluitemData_LightData `protobuf:"bytes,3,rep,name=light_data,json=lightData,proto3" json:"light_data,omitempty"`
	// 漏电流
	LeakageCurrent float64 `protobuf:"fixed64,4,opt,name=leakage_current,json=leakageCurrent,proto3" json:"leakage_current,omitempty"`
	// 控制器状态
	SluitemStatus *SluitemData_SluitemStatus `protobuf:"bytes,5,opt,name=sluitem_status,json=sluitemStatus,proto3" json:"sluitem_status,omitempty"`
	// 时钟故障
	TimeFault *SluitemData_TimeFault `protobuf:"bytes,6,opt,name=time_fault,json=timeFault,proto3" json:"time_fault,omitempty"`
	// 自复位次数
	ResetCount int32 `protobuf:"varint,7,opt,name=reset_count,json=resetCount,proto3" json:"reset_count,omitempty"`
	// 时间
	DateTime int64 `protobuf:"varint,8,opt,name=date_time,json=dateTime,proto3" json:"date_time,omitempty"`
	// 控制器运行参数
	SluitemPara *SluitemData_SluitemPara `protobuf:"bytes,9,opt,name=sluitem_para,json=sluitemPara,proto3" json:"sluitem_para,omitempty"`
	// 参考信号接收功率
	Rsrp int64 `protobuf:"varint,10,opt,name=rsrp,proto3" json:"rsrp,omitempty"`
	// 接收信号强度等级
	Rssi int64 `protobuf:"varint,11,opt,name=rssi,proto3" json:"rssi,omitempty"`
	// 信噪比
	Snr int64 `protobuf:"varint,12,opt,name=snr,proto3" json:"snr,omitempty"`
	// 物理小区标识
	Pci int64 `protobuf:"varint,13,opt,name=pci,proto3" json:"pci,omitempty"`
	// 参考信号接收质量
	Rsrq int64 `protobuf:"varint,14,opt,name=rsrq,proto3" json:"rsrq,omitempty"`
	// 终端发射功率
	Txpower int64 `protobuf:"varint,15,opt,name=txpower,proto3" json:"txpower,omitempty"`
	// 频点号
	Earfcn int64 `protobuf:"varint,16,opt,name=earfcn,proto3" json:"earfcn,omitempty"`
	// 信号覆盖等级
	Ecl int32 `protobuf:"varint,17,opt,name=ecl,proto3" json:"ecl,omitempty"`
	// 信号强度值
	Csq int32 `protobuf:"varint,18,opt,name=csq,proto3" json:"csq,omitempty"`
	// 主动上报原因，0-非主动上报，1-登录，2-开关灯状态变化，3-故障发生/消除，4-定时主动上报
	Reson int32 `protobuf:"varint,19,opt,name=reson,proto3" json:"reson,omitempty"`
	// 重连次数
	Retry int32 `protobuf:"varint,20,opt,name=retry,proto3" json:"retry,omitempty"`
	// 日出时间
	Sunrise int32 `protobuf:"varint,21,opt,name=sunrise,proto3" json:"sunrise,omitempty"`
	// 日落时间
	Sunset int32 `protobuf:"varint,22,opt,name=sunset,proto3" json:"sunset,omitempty"`
}

func (m *SluitemData) Reset()      { *m = SluitemData{} }
func (*SluitemData) ProtoMessage() {}
func (*SluitemData) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{4}
}
func (m *SluitemData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SluitemData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SluitemData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SluitemData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SluitemData.Merge(m, src)
}
func (m *SluitemData) XXX_Size() int {
	return m.Size()
}
func (m *SluitemData) XXX_DiscardUnknown() {
	xxx_messageInfo_SluitemData.DiscardUnknown(m)
}

var xxx_messageInfo_SluitemData proto.InternalMessageInfo

func (m *SluitemData) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *SluitemData) GetModelInfo() *SluitemData_ModelInfo {
	if m != nil {
		return m.ModelInfo
	}
	return nil
}

func (m *SluitemData) GetLightData() []*SluitemData_LightData {
	if m != nil {
		return m.LightData
	}
	return nil
}

func (m *SluitemData) GetLeakageCurrent() float64 {
	if m != nil {
		return m.LeakageCurrent
	}
	return 0
}

func (m *SluitemData) GetSluitemStatus() *SluitemData_SluitemStatus {
	if m != nil {
		return m.SluitemStatus
	}
	return nil
}

func (m *SluitemData) GetTimeFault() *SluitemData_TimeFault {
	if m != nil {
		return m.TimeFault
	}
	return nil
}

func (m *SluitemData) GetResetCount() int32 {
	if m != nil {
		return m.ResetCount
	}
	return 0
}

func (m *SluitemData) GetDateTime() int64 {
	if m != nil {
		return m.DateTime
	}
	return 0
}

func (m *SluitemData) GetSluitemPara() *SluitemData_SluitemPara {
	if m != nil {
		return m.SluitemPara
	}
	return nil
}

func (m *SluitemData) GetRsrp() int64 {
	if m != nil {
		return m.Rsrp
	}
	return 0
}

func (m *SluitemData) GetRssi() int64 {
	if m != nil {
		return m.Rssi
	}
	return 0
}

func (m *SluitemData) GetSnr() int64 {
	if m != nil {
		return m.Snr
	}
	return 0
}

func (m *SluitemData) GetPci() int64 {
	if m != nil {
		return m.Pci
	}
	return 0
}

func (m *SluitemData) GetRsrq() int64 {
	if m != nil {
		return m.Rsrq
	}
	return 0
}

func (m *SluitemData) GetTxpower() int64 {
	if m != nil {
		return m.Txpower
	}
	return 0
}

func (m *SluitemData) GetEarfcn() int64 {
	if m != nil {
		return m.Earfcn
	}
	return 0
}

func (m *SluitemData) GetEcl() int32 {
	if m != nil {
		return m.Ecl
	}
	return 0
}

func (m *SluitemData) GetCsq() int32 {
	if m != nil {
		return m.Csq
	}
	return 0
}

func (m *SluitemData) GetReson() int32 {
	if m != nil {
		return m.Reson
	}
	return 0
}

func (m *SluitemData) GetRetry() int32 {
	if m != nil {
		return m.Retry
	}
	return 0
}

func (m *SluitemData) GetSunrise() int32 {
	if m != nil {
		return m.Sunrise
	}
	return 0
}

func (m *SluitemData) GetSunset() int32 {
	if m != nil {
		return m.Sunset
	}
	return 0
}

type SluitemData_ModelInfo struct {
	// 控制器回路数量
	SluitemLoop int32 `protobuf:"varint,1,opt,name=sluitem_loop,json=sluitemLoop,proto3" json:"sluitem_loop,omitempty"`
	// 节能方式 0-无控制，1-只有开关灯，4-RS485，5-PWM，6-0~10V
	PowerSaving int32 `protobuf:"varint,2,opt,name=power_saving,json=powerSaving,proto3" json:"power_saving,omitempty"`
	// 漏电流测量 0-无，1-有
	HasLeakage int32 `protobuf:"varint,3,opt,name=has_leakage,json=hasLeakage,proto3" json:"has_leakage,omitempty"`
	// 温度采集 0-无，1-有
	HasTemperature int32 `protobuf:"varint,4,opt,name=has_temperature,json=hasTemperature,proto3" json:"has_temperature,omitempty"`
	// 时钟 0-无，1-有
	HasTimer int32 `protobuf:"varint,5,opt,name=has_timer,json=hasTimer,proto3" json:"has_timer,omitempty"`
	// 型号 0-unknow
	Model int32 `protobuf:"varint,6,opt,name=model,proto3" json:"model,omitempty"`
	// 字符串型号
	SluitemType string `protobuf:"bytes,7,opt,name=sluitem_type,json=sluitemType,proto3" json:"sluitem_type,omitempty"`
}

func (m *SluitemData_ModelInfo) Reset()      { *m = SluitemData_ModelInfo{} }
func (*SluitemData_ModelInfo) ProtoMessage() {}
func (*SluitemData_ModelInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{4, 0}
}
func (m *SluitemData_ModelInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SluitemData_ModelInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SluitemData_ModelInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SluitemData_ModelInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SluitemData_ModelInfo.Merge(m, src)
}
func (m *SluitemData_ModelInfo) XXX_Size() int {
	return m.Size()
}
func (m *SluitemData_ModelInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SluitemData_ModelInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SluitemData_ModelInfo proto.InternalMessageInfo

func (m *SluitemData_ModelInfo) GetSluitemLoop() int32 {
	if m != nil {
		return m.SluitemLoop
	}
	return 0
}

func (m *SluitemData_ModelInfo) GetPowerSaving() int32 {
	if m != nil {
		return m.PowerSaving
	}
	return 0
}

func (m *SluitemData_ModelInfo) GetHasLeakage() int32 {
	if m != nil {
		return m.HasLeakage
	}
	return 0
}

func (m *SluitemData_ModelInfo) GetHasTemperature() int32 {
	if m != nil {
		return m.HasTemperature
	}
	return 0
}

func (m *SluitemData_ModelInfo) GetHasTimer() int32 {
	if m != nil {
		return m.HasTimer
	}
	return 0
}

func (m *SluitemData_ModelInfo) GetModel() int32 {
	if m != nil {
		return m.Model
	}
	return 0
}

func (m *SluitemData_ModelInfo) GetSluitemType() string {
	if m != nil {
		return m.SluitemType
	}
	return ""
}

type SluitemData_LightData struct {
	// 电压
	Voltage float64 `protobuf:"fixed64,1,opt,name=voltage,proto3" json:"voltage,omitempty"`
	// 电流
	Current float64 `protobuf:"fixed64,2,opt,name=current,proto3" json:"current,omitempty"`
	// 有功功率
	ActivePower float64 `protobuf:"fixed64,3,opt,name=active_power,json=activePower,proto3" json:"active_power,omitempty"`
	// 无功功率
	ReactivePower float64 `protobuf:"fixed64,4,opt,name=reactive_power,json=reactivePower,proto3" json:"reactive_power,omitempty"`
	// 视在功率
	ApparentPower float64 `protobuf:"fixed64,5,opt,name=apparent_power,json=apparentPower,proto3" json:"apparent_power,omitempty"`
	// 电量
	Electricity float64 `protobuf:"fixed64,6,opt,name=electricity,proto3" json:"electricity,omitempty"`
	// 运行时间
	ActiveTime float64 `protobuf:"fixed64,7,opt,name=active_time,json=activeTime,proto3" json:"active_time,omitempty"`
	// 灯状态
	LightStatus *SluitemData_LightStatus `protobuf:"bytes,8,opt,name=light_status,json=lightStatus,proto3" json:"light_status,omitempty"`
	// 节能档位
	PowerLevel int32 `protobuf:"varint,9,opt,name=power_level,json=powerLevel,proto3" json:"power_level,omitempty"`
	// 控制器上电开灯 1-开灯，0-关灯
	SluitemPowerTurnon int32 `protobuf:"varint,10,opt,name=sluitem_power_turnon,json=sluitemPowerTurnon,proto3" json:"sluitem_power_turnon,omitempty"`
	// 1-4回路额定功率
	RatedPower int32 `protobuf:"varint,11,opt,name=rated_power,json=ratedPower,proto3" json:"rated_power,omitempty"`
}

func (m *SluitemData_LightData) Reset()      { *m = SluitemData_LightData{} }
func (*SluitemData_LightData) ProtoMessage() {}
func (*SluitemData_LightData) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{4, 1}
}
func (m *SluitemData_LightData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SluitemData_LightData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SluitemData_LightData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SluitemData_LightData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SluitemData_LightData.Merge(m, src)
}
func (m *SluitemData_LightData) XXX_Size() int {
	return m.Size()
}
func (m *SluitemData_LightData) XXX_DiscardUnknown() {
	xxx_messageInfo_SluitemData_LightData.DiscardUnknown(m)
}

var xxx_messageInfo_SluitemData_LightData proto.InternalMessageInfo

func (m *SluitemData_LightData) GetVoltage() float64 {
	if m != nil {
		return m.Voltage
	}
	return 0
}

func (m *SluitemData_LightData) GetCurrent() float64 {
	if m != nil {
		return m.Current
	}
	return 0
}

func (m *SluitemData_LightData) GetActivePower() float64 {
	if m != nil {
		return m.ActivePower
	}
	return 0
}

func (m *SluitemData_LightData) GetReactivePower() float64 {
	if m != nil {
		return m.ReactivePower
	}
	return 0
}

func (m *SluitemData_LightData) GetApparentPower() float64 {
	if m != nil {
		return m.ApparentPower
	}
	return 0
}

func (m *SluitemData_LightData) GetElectricity() float64 {
	if m != nil {
		return m.Electricity
	}
	return 0
}

func (m *SluitemData_LightData) GetActiveTime() float64 {
	if m != nil {
		return m.ActiveTime
	}
	return 0
}

func (m *SluitemData_LightData) GetLightStatus() *SluitemData_LightStatus {
	if m != nil {
		return m.LightStatus
	}
	return nil
}

func (m *SluitemData_LightData) GetPowerLevel() int32 {
	if m != nil {
		return m.PowerLevel
	}
	return 0
}

func (m *SluitemData_LightData) GetSluitemPowerTurnon() int32 {
	if m != nil {
		return m.SluitemPowerTurnon
	}
	return 0
}

func (m *SluitemData_LightData) GetRatedPower() int32 {
	if m != nil {
		return m.RatedPower
	}
	return 0
}

type SluitemData_LightStatus struct {
	// 灯具漏电 0-正常，1-漏电
	Leakage int32 `protobuf:"varint,1,opt,name=leakage,proto3" json:"leakage,omitempty"`
	// 故障 0-正常，1-光源故障，2-补偿电容故障，3-意外灭灯，4-意外亮灯，5-自熄灯
	Fault int32 `protobuf:"varint,2,opt,name=fault,proto3" json:"fault,omitempty"`
	// 工作状态 0-正常亮灯，1-保留，2-调光节能，3-关灯
	WorkingOn int32 `protobuf:"varint,3,opt,name=working_on,json=workingOn,proto3" json:"working_on,omitempty"`
}

func (m *SluitemData_LightStatus) Reset()      { *m = SluitemData_LightStatus{} }
func (*SluitemData_LightStatus) ProtoMessage() {}
func (*SluitemData_LightStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{4, 2}
}
func (m *SluitemData_LightStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SluitemData_LightStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SluitemData_LightStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SluitemData_LightStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SluitemData_LightStatus.Merge(m, src)
}
func (m *SluitemData_LightStatus) XXX_Size() int {
	return m.Size()
}
func (m *SluitemData_LightStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_SluitemData_LightStatus.DiscardUnknown(m)
}

var xxx_messageInfo_SluitemData_LightStatus proto.InternalMessageInfo

func (m *SluitemData_LightStatus) GetLeakage() int32 {
	if m != nil {
		return m.Leakage
	}
	return 0
}

func (m *SluitemData_LightStatus) GetFault() int32 {
	if m != nil {
		return m.Fault
	}
	return 0
}

func (m *SluitemData_LightStatus) GetWorkingOn() int32 {
	if m != nil {
		return m.WorkingOn
	}
	return 0
}

type SluitemData_SluitemStatus struct {
	// flash故障 0-正常 1-故障
	FlashFault int32 `protobuf:"varint,1,opt,name=flash_fault,json=flashFault,proto3" json:"flash_fault,omitempty"`
	// 主动报警禁止 0-正常 1-禁止
	EnableAlarm int32 `protobuf:"varint,2,opt,name=enable_alarm,json=enableAlarm,proto3" json:"enable_alarm,omitempty"`
}

func (m *SluitemData_SluitemStatus) Reset()      { *m = SluitemData_SluitemStatus{} }
func (*SluitemData_SluitemStatus) ProtoMessage() {}
func (*SluitemData_SluitemStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{4, 3}
}
func (m *SluitemData_SluitemStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SluitemData_SluitemStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SluitemData_SluitemStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SluitemData_SluitemStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SluitemData_SluitemStatus.Merge(m, src)
}
func (m *SluitemData_SluitemStatus) XXX_Size() int {
	return m.Size()
}
func (m *SluitemData_SluitemStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_SluitemData_SluitemStatus.DiscardUnknown(m)
}

var xxx_messageInfo_SluitemData_SluitemStatus proto.InternalMessageInfo

func (m *SluitemData_SluitemStatus) GetFlashFault() int32 {
	if m != nil {
		return m.FlashFault
	}
	return 0
}

func (m *SluitemData_SluitemStatus) GetEnableAlarm() int32 {
	if m != nil {
		return m.EnableAlarm
	}
	return 0
}

type SluitemData_TimeFault struct {
	// 本地时钟故障 0-正常 1-故障
	ClockFault int32 `protobuf:"varint,1,opt,name=clock_fault,json=clockFault,proto3" json:"clock_fault,omitempty"`
	// 本地时钟超差故障 0-正常 1-故障
	ClockOutFault int32 `protobuf:"varint,2,opt,name=clock_out_fault,json=clockOutFault,proto3" json:"clock_out_fault,omitempty"`
	// 校时超差故障 0-正常 1-故障
	ClockOutAlarm int32 `protobuf:"varint,3,opt,name=clock_out_alarm,json=clockOutAlarm,proto3" json:"clock_out_alarm,omitempty"`
}

func (m *SluitemData_TimeFault) Reset()      { *m = SluitemData_TimeFault{} }
func (*SluitemData_TimeFault) ProtoMessage() {}
func (*SluitemData_TimeFault) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{4, 4}
}
func (m *SluitemData_TimeFault) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SluitemData_TimeFault) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SluitemData_TimeFault.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SluitemData_TimeFault) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SluitemData_TimeFault.Merge(m, src)
}
func (m *SluitemData_TimeFault) XXX_Size() int {
	return m.Size()
}
func (m *SluitemData_TimeFault) XXX_DiscardUnknown() {
	xxx_messageInfo_SluitemData_TimeFault.DiscardUnknown(m)
}

var xxx_messageInfo_SluitemData_TimeFault proto.InternalMessageInfo

func (m *SluitemData_TimeFault) GetClockFault() int32 {
	if m != nil {
		return m.ClockFault
	}
	return 0
}

func (m *SluitemData_TimeFault) GetClockOutFault() int32 {
	if m != nil {
		return m.ClockOutFault
	}
	return 0
}

func (m *SluitemData_TimeFault) GetClockOutAlarm() int32 {
	if m != nil {
		return m.ClockOutAlarm
	}
	return 0
}

type SluitemData_SluitemPara struct {
	// 经度
	Longitude float64 `protobuf:"fixed64,1,opt,name=longitude,proto3" json:"longitude,omitempty"`
	// 纬度
	Latitude float64 `protobuf:"fixed64,2,opt,name=latitude,proto3" json:"latitude,omitempty"`
	// 是否允许主报 1-允许 0-不允许
	HasEnableAlarm int32 `protobuf:"varint,3,opt,name=has_enable_alarm,json=hasEnableAlarm,proto3" json:"has_enable_alarm,omitempty"`
	// 是否投运 1-投运 0-停运
	IsRunning int32 `protobuf:"varint,4,opt,name=is_running,json=isRunning,proto3" json:"is_running,omitempty"`
	// 主动报警间隔 单位分钟 0表示30分钟
	AlarmInterval int32 `protobuf:"varint,5,opt,name=alarm_interval,json=alarmInterval,proto3" json:"alarm_interval,omitempty"`
	// nb主报需要主站应答，0-不需要，1-需要
	UplinkReply int32 `protobuf:"varint,6,opt,name=uplink_reply,json=uplinkReply,proto3" json:"uplink_reply,omitempty"`
}

func (m *SluitemData_SluitemPara) Reset()      { *m = SluitemData_SluitemPara{} }
func (*SluitemData_SluitemPara) ProtoMessage() {}
func (*SluitemData_SluitemPara) Descriptor() ([]byte, []int) {
	return fileDescriptor_7d0ba9a34991f86e, []int{4, 5}
}
func (m *SluitemData_SluitemPara) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SluitemData_SluitemPara) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SluitemData_SluitemPara.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SluitemData_SluitemPara) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SluitemData_SluitemPara.Merge(m, src)
}
func (m *SluitemData_SluitemPara) XXX_Size() int {
	return m.Size()
}
func (m *SluitemData_SluitemPara) XXX_DiscardUnknown() {
	xxx_messageInfo_SluitemData_SluitemPara.DiscardUnknown(m)
}

var xxx_messageInfo_SluitemData_SluitemPara proto.InternalMessageInfo

func (m *SluitemData_SluitemPara) GetLongitude() float64 {
	if m != nil {
		return m.Longitude
	}
	return 0
}

func (m *SluitemData_SluitemPara) GetLatitude() float64 {
	if m != nil {
		return m.Latitude
	}
	return 0
}

func (m *SluitemData_SluitemPara) GetHasEnableAlarm() int32 {
	if m != nil {
		return m.HasEnableAlarm
	}
	return 0
}

func (m *SluitemData_SluitemPara) GetIsRunning() int32 {
	if m != nil {
		return m.IsRunning
	}
	return 0
}

func (m *SluitemData_SluitemPara) GetAlarmInterval() int32 {
	if m != nil {
		return m.AlarmInterval
	}
	return 0
}

func (m *SluitemData_SluitemPara) GetUplinkReply() int32 {
	if m != nil {
		return m.UplinkReply
	}
	return 0
}

func init() {
	proto.RegisterType((*MsgNBiot)(nil), "wlst.nbiot.MsgNBiot")
	proto.RegisterType((*MsgNBOpen)(nil), "wlst.nbiot.MsgNBOpen")
	proto.RegisterType((*SluitemConfig)(nil), "wlst.nbiot.SluitemConfig")
	proto.RegisterType((*SluitemConfig_DataMark)(nil), "wlst.nbiot.SluitemConfig.Data_mark")
	proto.RegisterType((*SluitemConfig_SetMark)(nil), "wlst.nbiot.SluitemConfig.Set_mark")
	proto.RegisterType((*SluitemConfig_SluitemPara)(nil), "wlst.nbiot.SluitemConfig.Sluitem_para")
	proto.RegisterType((*SluitemConfig_SluitemVer)(nil), "wlst.nbiot.SluitemConfig.Sluitem_ver")
	proto.RegisterType((*SluitemConfig_SluitemSunriseset)(nil), "wlst.nbiot.SluitemConfig.Sluitem_sunriseset")
	proto.RegisterType((*SluitemConfig_SluitemRuntime)(nil), "wlst.nbiot.SluitemConfig.Sluitem_runtime")
	proto.RegisterType((*SluitemReply)(nil), "wlst.nbiot.SluitemReply")
	proto.RegisterType((*SluitemData)(nil), "wlst.nbiot.SluitemData")
	proto.RegisterType((*SluitemData_ModelInfo)(nil), "wlst.nbiot.SluitemData.Model_info")
	proto.RegisterType((*SluitemData_LightData)(nil), "wlst.nbiot.SluitemData.Light_data")
	proto.RegisterType((*SluitemData_LightStatus)(nil), "wlst.nbiot.SluitemData.Light_status")
	proto.RegisterType((*SluitemData_SluitemStatus)(nil), "wlst.nbiot.SluitemData.Sluitem_status")
	proto.RegisterType((*SluitemData_TimeFault)(nil), "wlst.nbiot.SluitemData.Time_fault")
	proto.RegisterType((*SluitemData_SluitemPara)(nil), "wlst.nbiot.SluitemData.Sluitem_para")
}

func init() { proto.RegisterFile("msg_nb.proto", fileDescriptor_7d0ba9a34991f86e) }

var fileDescriptor_7d0ba9a34991f86e = []byte{
	// 1851 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x58, 0x3b, 0x6f, 0x1c, 0xc9,
	0x11, 0xe6, 0x70, 0xb9, 0xdc, 0x9d, 0xda, 0x5d, 0xae, 0x34, 0x96, 0x4e, 0xa3, 0x3d, 0x6b, 0x49,
	0x51, 0x96, 0x44, 0x03, 0x36, 0x61, 0xc8, 0xc6, 0x05, 0x36, 0x0e, 0x38, 0x91, 0x77, 0x3a, 0x13,
	0x20, 0xc5, 0xc3, 0x90, 0x70, 0x62, 0x18, 0x83, 0xe6, 0x6c, 0xef, 0x72, 0xc0, 0x79, 0xa9, 0xa7,
	0x87, 0x14, 0x03, 0x03, 0x0e, 0x1c, 0x38, 0x74, 0xe0, 0x1f, 0xe1, 0xd4, 0x8f, 0xd4, 0x89, 0x23,
	0x87, 0x0a, 0x0f, 0x70, 0x62, 0x51, 0x89, 0x9d, 0x09, 0xfe, 0x05, 0x46, 0x55, 0xf5, 0x3c, 0x96,
	0x0f, 0xc9, 0xd9, 0xf6, 0x57, 0xd5, 0xd5, 0x35, 0xd5, 0x5f, 0x7d, 0x5d, 0x24, 0xf4, 0xe3, 0x7c,
	0xe6, 0x27, 0x47, 0x9b, 0x99, 0x4a, 0x75, 0xea, 0xc0, 0x59, 0x94, 0xeb, 0xcd, 0xe4, 0x28, 0x4c,
	0xf5, 0xfa, 0xef, 0x2c, 0xe8, 0xee, 0xe5, 0xb3, 0x97, 0x5b, 0x61, 0xaa, 0x9d, 0x7b, 0xd0, 0x09,
	0xe2, 0x89, 0x1f, 0x4e, 0x5e, 0xbb, 0xd6, 0x9a, 0xb5, 0xd1, 0xf2, 0x96, 0x83, 0x78, 0xb2, 0x33,
	0x79, 0xed, 0xdc, 0x87, 0x2e, 0x1a, 0x12, 0x11, 0x4b, 0x77, 0x71, 0xcd, 0xda, 0xb0, 0x3d, 0x74,
	0x7c, 0x29, 0x62, 0x59, 0x9a, 0xa6, 0x91, 0x98, 0xb9, 0xad, 0x35, 0x6b, 0xa3, 0x4d, 0xa6, 0x17,
	0x91, 0x98, 0x39, 0x0e, 0x2c, 0x85, 0xb1, 0x0c, 0xdd, 0xa5, 0xb5, 0xd6, 0x46, 0xcb, 0xa3, 0xdf,
	0xe8, 0xae, 0xc4, 0x99, 0x3f, 0x11, 0x5a, 0xb8, 0xed, 0xb5, 0x16, 0xba, 0x2b, 0x71, 0xf6, 0xa5,
	0xd0, 0x62, 0xfd, 0x2f, 0x8b, 0x60, 0x53, 0x2a, 0xfb, 0x99, 0x4c, 0xaa, 0xcd, 0x9c, 0x08, 0x6f,
	0x7e, 0x00, 0x30, 0xd1, 0xbe, 0x92, 0x81, 0x0c, 0x4f, 0x39, 0x91, 0x96, 0x67, 0x4f, 0xb4, 0xc7,
	0x80, 0xf3, 0x29, 0xd8, 0x18, 0xd7, 0xd7, 0xe7, 0x99, 0x34, 0xb9, 0x74, 0x11, 0x38, 0x3c, 0xcf,
	0x28, 0x4f, 0x32, 0x06, 0xf1, 0xc4, 0xb5, 0xf9, 0x13, 0x70, 0xbd, 0x1d, 0x4f, 0x9c, 0x9f, 0x42,
	0x3f, 0x8f, 0x8a, 0x50, 0xcb, 0x98, 0xf3, 0x82, 0x35, 0x6b, 0xa3, 0xf7, 0xec, 0xde, 0x66, 0x5d,
	0xa6, 0xcd, 0x03, 0xb6, 0x63, 0x9e, 0x5e, 0x2f, 0xaf, 0x17, 0xce, 0xe7, 0x30, 0x28, 0xf7, 0x2a,
	0x99, 0x45, 0xe7, 0x6e, 0x8f, 0x36, 0xbb, 0xd7, 0x6c, 0xf6, 0xd0, 0xee, 0x95, 0x47, 0xd1, 0xca,
	0xf9, 0x02, 0x56, 0xca, 0xed, 0x41, 0x9a, 0x4c, 0xc3, 0x99, 0xdb, 0xa7, 0xfd, 0xf7, 0xaf, 0xd9,
	0xbf, 0x4d, 0x0e, 0x5e, 0x79, 0x1e, 0x2f, 0xd7, 0xff, 0x3a, 0x84, 0xc1, 0x9c, 0xc3, 0xe5, 0x5b,
	0x6c, 0x57, 0xb7, 0xb8, 0x0a, 0x65, 0xea, 0x64, 0xe4, 0xfa, 0x81, 0x81, 0xd0, 0xe1, 0x0b, 0x53,
	0xc0, 0x58, 0xa8, 0x13, 0x77, 0x89, 0x12, 0x79, 0x74, 0x63, 0x22, 0x9b, 0x5f, 0x96, 0xae, 0x5c,
	0xe5, 0x3d, 0xa1, 0x4e, 0xf0, 0x86, 0xa2, 0x34, 0xcd, 0xfc, 0x20, 0x2d, 0x12, 0xed, 0xb6, 0xe9,
	0x78, 0x1b, 0x91, 0x6d, 0x04, 0x9c, 0x87, 0x75, 0xa5, 0x75, 0x18, 0x4b, 0xb7, 0x43, 0x29, 0x94,
	0x59, 0x1d, 0x86, 0xb1, 0x74, 0x76, 0x6a, 0x97, 0x4c, 0x28, 0xe1, 0x76, 0x29, 0x8d, 0x27, 0x37,
	0xa7, 0x71, 0xd0, 0xf0, 0xae, 0x42, 0x7d, 0x23, 0x94, 0x70, 0x5e, 0xd4, 0xdf, 0x7b, 0x2a, 0x95,
	0xb9, 0xd6, 0xc7, 0x1f, 0x8f, 0x74, 0x2a, 0x55, 0x55, 0x96, 0x5f, 0x48, 0xe5, 0xfc, 0x12, 0x9c,
	0x32, 0x4e, 0x5e, 0x24, 0x2a, 0xcc, 0x65, 0x2e, 0xb5, 0xb9, 0xe8, 0x1f, 0x7c, 0x3c, 0x5c, 0xbd,
	0xc7, 0xbb, 0x6d, 0xe2, 0x1c, 0x54, 0x90, 0xe3, 0xc1, 0xb0, 0x22, 0x50, 0x91, 0x50, 0x55, 0xfa,
	0x6b, 0xad, 0x8d, 0xde, 0xb3, 0xef, 0x7f, 0x3c, 0xb2, 0xd9, 0xe0, 0x95, 0x1c, 0xf2, 0x78, 0xed,
	0x7c, 0x02, 0xcb, 0xb9, 0x16, 0xba, 0xc8, 0xdd, 0x15, 0x26, 0x00, 0xaf, 0x9c, 0xcf, 0xa1, 0x9b,
	0x4b, 0xcd, 0xd7, 0x3b, 0xa4, 0xf4, 0xd7, 0x3f, 0x70, 0x88, 0xf1, 0xf4, 0x3a, 0xb9, 0xd4, 0x78,
	0xb9, 0xa3, 0x3f, 0x5b, 0x60, 0x57, 0x97, 0x8e, 0x57, 0xad, 0xa4, 0x98, 0xd0, 0x45, 0x2a, 0x22,
	0x53, 0xdb, 0xb3, 0x11, 0xc1, 0x6b, 0x54, 0xd8, 0x8c, 0x64, 0x16, 0x6a, 0x96, 0x97, 0xcd, 0x88,
	0xc0, 0x73, 0x35, 0xcb, 0x49, 0x05, 0xd0, 0x88, 0xd7, 0xc2, 0x24, 0xe9, 0xe0, 0x1a, 0x8b, 0xfd,
	0x14, 0x86, 0x64, 0x6a, 0x54, 0x7a, 0x99, 0x3c, 0x56, 0x10, 0x6e, 0x14, 0xee, 0x31, 0xac, 0x54,
	0xe7, 0x6b, 0x71, 0x14, 0x31, 0x9b, 0xda, 0xde, 0xa0, 0xcc, 0x81, 0xc0, 0xd1, 0x6f, 0x2d, 0xe8,
	0x96, 0x9f, 0x82, 0x49, 0x61, 0x01, 0x38, 0x65, 0x6e, 0x0e, 0xac, 0x08, 0x67, 0x7c, 0x9f, 0xab,
	0x43, 0x09, 0xf3, 0xe7, 0xe0, 0x97, 0x53, 0xbe, 0x66, 0x9f, 0xa2, 0x74, 0x96, 0xaa, 0x7d, 0x1e,
	0x25, 0xf2, 0x08, 0x06, 0x65, 0x50, 0xce, 0x83, 0xbf, 0xa8, 0x6f, 0x02, 0x73, 0x1a, 0x7f, 0x5f,
	0x84, 0x7e, 0x93, 0xa9, 0x98, 0x7e, 0x45, 0x2a, 0xbe, 0x2b, 0x3e, 0xb3, 0x6c, 0xef, 0x03, 0xbe,
	0xb2, 0x1f, 0xc1, 0x9d, 0xd2, 0x4d, 0x26, 0x18, 0xc9, 0x17, 0x91, 0x50, 0xb1, 0xa9, 0x68, 0xc9,
	0xcb, 0xaf, 0xc8, 0xf4, 0x1c, 0x2d, 0xce, 0x4f, 0xea, 0x1d, 0x59, 0x7a, 0x26, 0x95, 0xaf, 0x0b,
	0x95, 0xa4, 0x09, 0xa9, 0x70, 0x7b, 0x6b, 0xf1, 0x96, 0x55, 0xed, 0xfa, 0x06, 0xcd, 0x87, 0x64,
	0x75, 0xbe, 0x0b, 0x76, 0x94, 0x26, 0xb3, 0x50, 0x17, 0x13, 0x49, 0x05, 0xb7, 0xbc, 0x1a, 0x70,
	0x46, 0xd0, 0x8d, 0x84, 0x66, 0x63, 0x87, 0x8c, 0xd5, 0xda, 0x79, 0x04, 0x3d, 0x25, 0xb4, 0x9c,
	0xf0, 0x69, 0x6e, 0xb7, 0x3a, 0x06, 0x08, 0xa6, 0x43, 0xb0, 0xf1, 0x8b, 0x2c, 0x0a, 0x93, 0x13,
	0x53, 0x7b, 0x9b, 0xd2, 0xef, 0x31, 0xc6, 0xe5, 0xaf, 0x5d, 0x58, 0x48, 0xa1, 0xe9, 0x42, 0x6a,
	0x39, 0xfa, 0xc3, 0x22, 0xf4, 0x1a, 0x4d, 0xda, 0x94, 0x13, 0xd4, 0x18, 0x73, 0xa3, 0x65, 0xd3,
	0xef, 0xa6, 0x69, 0x86, 0x97, 0x23, 0x13, 0xa9, 0x66, 0xe7, 0x7e, 0x2e, 0x4e, 0xc3, 0x64, 0x66,
	0xaa, 0xdc, 0x67, 0xf0, 0x80, 0x30, 0xe7, 0x33, 0xb8, 0x27, 0x23, 0x19, 0x68, 0x15, 0x06, 0x7e,
	0x24, 0xc5, 0x89, 0x98, 0x49, 0x3f, 0x4e, 0x27, 0x45, 0x54, 0x3e, 0x23, 0x77, 0x4b, 0xf3, 0x2e,
	0x5b, 0xf7, 0xc8, 0xe8, 0xfc, 0x10, 0x1c, 0x2d, 0xe3, 0x4c, 0x2a, 0xa1, 0x0b, 0x55, 0x6d, 0x61,
	0x7e, 0xdc, 0x6e, 0x58, 0x8c, 0xfb, 0x43, 0xe8, 0xd3, 0xd7, 0x97, 0x8e, 0xcc, 0x93, 0x1e, 0x61,
	0xb5, 0x4b, 0x25, 0x90, 0xf8, 0x8a, 0x2d, 0xd3, 0x4b, 0x55, 0x09, 0x24, 0x3e, 0x64, 0xb7, 0xa0,
	0x85, 0x6d, 0xd3, 0x21, 0x0b, 0xfe, 0x1c, 0xbd, 0x00, 0xe7, 0xaa, 0xd6, 0x38, 0x2e, 0x74, 0xcc,
	0xca, 0xd4, 0xa5, 0x5c, 0x92, 0x3c, 0x14, 0x09, 0x52, 0x79, 0xd1, 0xc8, 0x03, 0xad, 0x46, 0xff,
	0x59, 0x84, 0xe1, 0x25, 0x69, 0x99, 0x7f, 0x53, 0xad, 0x4b, 0x6f, 0xea, 0x2a, 0xf4, 0xd2, 0x42,
	0x67, 0x85, 0x66, 0x33, 0x47, 0x03, 0x86, 0xc8, 0xe1, 0x21, 0xf4, 0x53, 0x2a, 0x82, 0x6c, 0x3e,
	0xca, 0x3d, 0x83, 0x91, 0xcb, 0x23, 0xe8, 0x4d, 0xd0, 0xce, 0xec, 0x6e, 0xb0, 0x14, 0x10, 0x66,
	0x62, 0xcf, 0xc5, 0x41, 0x85, 0x6c, 0xcf, 0xc7, 0xc1, 0x44, 0x1f, 0xc3, 0x4a, 0xe9, 0x92, 0x4e,
	0xa7, 0xb5, 0x6c, 0x0c, 0x0c, 0xba, 0x4f, 0xa0, 0xf3, 0x14, 0x06, 0x4a, 0x46, 0xe2, 0xdc, 0x37,
	0xb0, 0xdb, 0xa9, 0x0e, 0xec, 0x93, 0x61, 0x9f, 0x71, 0xe7, 0x01, 0x74, 0xb3, 0x33, 0xc3, 0xab,
	0x9a, 0xd3, 0x9d, 0xec, 0x8c, 0x79, 0xf5, 0x29, 0xd8, 0x68, 0x66, 0xce, 0x33, 0x9b, 0xd1, 0xbf,
	0x62, 0x3b, 0x1a, 0x8f, 0x44, 0x31, 0xa1, 0x33, 0x0c, 0x95, 0xb3, 0xb3, 0x78, 0xcb, 0x40, 0xeb,
	0x4f, 0x2a, 0x39, 0xe0, 0x41, 0xa0, 0x96, 0x6c, 0xab, 0x29, 0xd9, 0xeb, 0x7f, 0x1b, 0x56, 0x94,
	0xa7, 0x79, 0xe3, 0xc6, 0xc7, 0xfd, 0x39, 0x40, 0x9c, 0x4e, 0x64, 0xe4, 0x87, 0xc9, 0x34, 0xa5,
	0xab, 0xb8, 0x5e, 0xdd, 0x31, 0xca, 0xe6, 0x5e, 0xe5, 0xe9, 0xd9, 0xb4, 0x6b, 0x27, 0x99, 0xa6,
	0x18, 0x22, 0x0a, 0x67, 0xc7, 0x9a, 0xa7, 0xa0, 0x16, 0xbd, 0x42, 0x37, 0x86, 0xd8, 0xad, 0x3c,
	0x3d, 0x9b, 0x76, 0x51, 0x7a, 0x4f, 0x61, 0x58, 0x36, 0x50, 0x50, 0x28, 0x25, 0x13, 0x96, 0x4b,
	0xcb, 0x5b, 0x31, 0xf0, 0x36, 0xa3, 0xce, 0xde, 0x15, 0xf9, 0x6b, 0xdf, 0xf8, 0xd0, 0xd3, 0x79,
	0x07, 0x73, 0xde, 0x97, 0x65, 0xf2, 0x39, 0x00, 0x12, 0xc3, 0x9f, 0x8a, 0x22, 0xe2, 0x9b, 0xff,
	0x40, 0xea, 0x87, 0x95, 0xa7, 0x67, 0xe3, 0xae, 0x17, 0xf8, 0x13, 0xc9, 0x4c, 0xfa, 0x6e, 0x66,
	0x17, 0x7e, 0x4c, 0x80, 0x20, 0x1e, 0x5e, 0xb8, 0x15, 0x0c, 0x03, 0xbb, 0x34, 0xb9, 0x60, 0x2b,
	0x30, 0xfd, 0xbe, 0xbe, 0x34, 0xb6, 0xd8, 0x94, 0xc2, 0xf7, 0x3e, 0xf6, 0x35, 0x57, 0x87, 0x16,
	0x07, 0x96, 0x54, 0xae, 0x32, 0xe2, 0x4c, 0xcb, 0xa3, 0xdf, 0x8c, 0xe5, 0x21, 0x8d, 0x1c, 0x84,
	0xe5, 0x21, 0xca, 0x40, 0x9e, 0x28, 0x1a, 0x17, 0x5b, 0x1e, 0xfe, 0x44, 0x24, 0x0b, 0x42, 0x77,
	0xc0, 0x48, 0x16, 0x84, 0x26, 0xd6, 0x2b, 0x9a, 0x02, 0x38, 0xd6, 0x2b, 0x94, 0x05, 0xfd, 0x9a,
	0x69, 0x3b, 0x24, 0xb8, 0x5c, 0x22, 0x05, 0xa5, 0x50, 0xd3, 0x20, 0x71, 0x6f, 0xf1, 0xf0, 0xcf,
	0x2b, 0x8c, 0x2b, 0x83, 0xc8, 0xbd, 0x4d, 0x05, 0xc1, 0x9f, 0x88, 0x04, 0xf9, 0x2b, 0xd7, 0x61,
	0x24, 0xc8, 0x5f, 0x39, 0x77, 0xa0, 0xad, 0x64, 0x9e, 0x26, 0xee, 0x77, 0x08, 0xe3, 0x05, 0xa3,
	0x5a, 0x9d, 0xbb, 0x77, 0x4a, 0x54, 0xab, 0xf3, 0xa6, 0x30, 0xdd, 0xbd, 0x49, 0x98, 0x3e, 0x99,
	0x13, 0xa6, 0xff, 0x5a, 0x00, 0x35, 0x65, 0xff, 0x1f, 0xd9, 0xc7, 0x0e, 0xa4, 0xc7, 0x6f, 0x4e,
	0xf5, 0x7b, 0x84, 0x19, 0xd1, 0x5f, 0x85, 0xde, 0xb1, 0xc8, 0x4b, 0xbd, 0x37, 0xd2, 0x04, 0xc7,
	0x22, 0x37, 0x1a, 0x8f, 0x5c, 0x46, 0x87, 0x86, 0x8e, 0x1b, 0x69, 0x5f, 0x39, 0x16, 0xf9, 0x61,
	0x8d, 0x22, 0x31, 0xc8, 0x91, 0x5e, 0x36, 0x96, 0xa6, 0x2e, 0xba, 0xd0, 0xb3, 0x76, 0x07, 0xda,
	0xd4, 0x61, 0x46, 0x8e, 0x78, 0x71, 0x45, 0xe7, 0x3b, 0x57, 0x74, 0x7e, 0xf4, 0xa7, 0x16, 0x40,
	0xdd, 0x64, 0x58, 0xb5, 0xd3, 0x34, 0xd2, 0x98, 0xaa, 0x45, 0x1d, 0x55, 0x2e, 0xd1, 0x52, 0xf6,
	0xda, 0x22, 0x5b, 0xcc, 0x12, 0x4f, 0x11, 0x81, 0x0e, 0x4f, 0xa5, 0xd1, 0xa9, 0x16, 0x99, 0x7b,
	0x8c, 0xb1, 0x54, 0xf1, 0x14, 0xd5, 0x74, 0xe2, 0x7e, 0x1d, 0x94, 0x68, 0xe5, 0x26, 0xb2, 0x4c,
	0x60, 0x54, 0xe3, 0xd6, 0x66, 0xb7, 0x12, 0x65, 0xb7, 0x35, 0xe8, 0x95, 0x2f, 0x65, 0xa8, 0xcf,
	0xcd, 0x1c, 0xd1, 0x84, 0xb0, 0xea, 0xe6, 0xb4, 0xea, 0x0f, 0x00, 0xcb, 0x03, 0x86, 0xca, 0x46,
	0x62, 0x11, 0x32, 0xb2, 0xd0, 0xfd, 0x70, 0x23, 0xed, 0x36, 0x7c, 0xbd, 0x1e, 0xed, 0x34, 0x92,
	0xb0, 0x0a, 0x7c, 0xdd, 0x7e, 0x24, 0x4f, 0x65, 0x64, 0x34, 0x1a, 0x08, 0xda, 0x45, 0xa4, 0x39,
	0x5a, 0xcd, 0x0d, 0x4a, 0x30, 0x37, 0x5a, 0x35, 0x87, 0xa4, 0xd5, 0xf9, 0x51, 0xa7, 0x67, 0x24,
	0xa2, 0x1a, 0x73, 0x46, 0xbf, 0x82, 0x7e, 0x33, 0x21, 0xbc, 0x9a, 0x92, 0x5f, 0xe6, 0x0d, 0x36,
	0x4b, 0xa4, 0x05, 0x6b, 0x15, 0x33, 0x93, 0x17, 0x38, 0x53, 0x9f, 0xa5, 0xea, 0x24, 0x4c, 0x66,
	0x7e, 0x9a, 0x18, 0x4a, 0xda, 0x06, 0xd9, 0x4f, 0x46, 0x87, 0xb0, 0x32, 0x2f, 0x83, 0x98, 0xd1,
	0x34, 0x12, 0xf9, 0xb1, 0x11, 0x3e, 0x3e, 0x04, 0x08, 0x62, 0x55, 0x7b, 0x08, 0xfd, 0xb9, 0xb9,
	0xd1, 0x34, 0x82, 0xac, 0x07, 0xc6, 0xd1, 0xaf, 0x01, 0x6a, 0x45, 0xc4, 0x88, 0x41, 0x94, 0x06,
	0x27, 0xf3, 0x11, 0x09, 0xe2, 0x88, 0x4f, 0x60, 0xc8, 0x0e, 0x69, 0xa1, 0xfd, 0xe6, 0x37, 0x0c,
	0x08, 0xde, 0x2f, 0xf4, 0x35, 0x7e, 0xcd, 0xa1, 0xb5, 0xf2, 0xe3, 0xe3, 0xff, 0x69, 0x5d, 0x9a,
	0x8c, 0xe7, 0x46, 0x51, 0xeb, 0x43, 0xa3, 0xe8, 0xe2, 0xa5, 0x51, 0x74, 0x03, 0x6e, 0x61, 0x23,
	0x5e, 0x33, 0x28, 0x63, 0xcb, 0x36, 0x87, 0xe4, 0x07, 0x00, 0x61, 0x8e, 0x43, 0x4e, 0x82, 0xea,
	0xc0, 0x6d, 0x6d, 0x87, 0xb9, 0xc7, 0x00, 0xd1, 0x1d, 0xfd, 0xfc, 0x30, 0xd1, 0x52, 0x9d, 0x8a,
	0xc8, 0xb4, 0xf5, 0x80, 0xd0, 0x1d, 0x03, 0x5e, 0x19, 0x59, 0x97, 0xaf, 0x8c, 0xac, 0xcf, 0xbe,
	0x86, 0xee, 0xcb, 0xad, 0x9d, 0xf4, 0x70, 0x5b, 0x47, 0xce, 0xcf, 0xc0, 0xa6, 0xdf, 0x5f, 0x05,
	0xc7, 0xa9, 0x73, 0xb7, 0xc9, 0xe8, 0xea, 0xdf, 0x1e, 0xa3, 0xeb, 0xe1, 0xf5, 0x85, 0xad, 0xcf,
	0xde, 0xbc, 0x1d, 0x2f, 0x7c, 0xfb, 0x76, 0xbc, 0xf0, 0xfe, 0xed, 0xd8, 0xfa, 0xcd, 0xc5, 0xd8,
	0xfa, 0xe3, 0xc5, 0xd8, 0xfa, 0xc7, 0xc5, 0xd8, 0x7a, 0x73, 0x31, 0xb6, 0xfe, 0x75, 0x31, 0xb6,
	0xfe, 0x7d, 0x31, 0x5e, 0x78, 0x7f, 0x31, 0xb6, 0x7e, 0xff, 0x6e, 0xbc, 0xf0, 0xe6, 0xdd, 0x78,
	0xe1, 0xdb, 0x77, 0xe3, 0x85, 0x9f, 0x5b, 0x47, 0xcb, 0xf4, 0x3f, 0x9f, 0x1f, 0xff, 0x2f, 0x00,
	0x00, 0xff, 0xff, 0x5b, 0x7c, 0x59, 0x92, 0x03, 0x12, 0x00, 0x00,
}

func (this *MsgNBiot) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MsgNBiot)
	if !ok {
		that2, ok := that.(MsgNBiot)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CmdIdx != that1.CmdIdx {
		return false
	}
	if this.CmdName != that1.CmdName {
		return false
	}
	if this.CmdFlag != that1.CmdFlag {
		return false
	}
	if len(this.Imei) != len(that1.Imei) {
		return false
	}
	for i := range this.Imei {
		if this.Imei[i] != that1.Imei[i] {
			return false
		}
	}
	if len(this.RawData) != len(that1.RawData) {
		return false
	}
	for i := range this.RawData {
		if this.RawData[i] != that1.RawData[i] {
			return false
		}
	}
	return true
}
func (this *MsgNBOpen) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MsgNBOpen)
	if !ok {
		that2, ok := that.(MsgNBOpen)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Imei != that1.Imei {
		return false
	}
	if this.DtReceive != that1.DtReceive {
		return false
	}
	if this.DataType != that1.DataType {
		return false
	}
	if this.DataCmd != that1.DataCmd {
		return false
	}
	if !this.SluitemData.Equal(that1.SluitemData) {
		return false
	}
	if !this.SluitemReply.Equal(that1.SluitemReply) {
		return false
	}
	if !this.SluitemConfig.Equal(that1.SluitemConfig) {
		return false
	}
	return true
}
func (this *SluitemConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SluitemConfig)
	if !ok {
		that2, ok := that.(SluitemConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CmdIdx != that1.CmdIdx {
		return false
	}
	if this.SluitemIdx != that1.SluitemIdx {
		return false
	}
	if !this.DataMark.Equal(that1.DataMark) {
		return false
	}
	if this.LoopCount != that1.LoopCount {
		return false
	}
	if this.SluitemTime != that1.SluitemTime {
		return false
	}
	if !this.SluitemPara.Equal(that1.SluitemPara) {
		return false
	}
	if !this.SluitemVer.Equal(that1.SluitemVer) {
		return false
	}
	if !this.SluitemSunriseset.Equal(that1.SluitemSunriseset) {
		return false
	}
	if len(this.SluitemRuntime) != len(that1.SluitemRuntime) {
		return false
	}
	for i := range this.SluitemRuntime {
		if !this.SluitemRuntime[i].Equal(that1.SluitemRuntime[i]) {
			return false
		}
	}
	if this.Status != that1.Status {
		return false
	}
	if !this.SetMark.Equal(that1.SetMark) {
		return false
	}
	return true
}
func (this *SluitemConfig_DataMark) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SluitemConfig_DataMark)
	if !ok {
		that2, ok := that.(SluitemConfig_DataMark)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ReadTimer != that1.ReadTimer {
		return false
	}
	if this.ReadArgs != that1.ReadArgs {
		return false
	}
	if this.ReadVer != that1.ReadVer {
		return false
	}
	if this.ReadSunriseset != that1.ReadSunriseset {
		return false
	}
	if this.ReadTimetable != that1.ReadTimetable {
		return false
	}
	return true
}
func (this *SluitemConfig_SetMark) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SluitemConfig_SetMark)
	if !ok {
		that2, ok := that.(SluitemConfig_SetMark)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SetTimer != that1.SetTimer {
		return false
	}
	if this.SetArgs != that1.SetArgs {
		return false
	}
	if this.SetReset != that1.SetReset {
		return false
	}
	if this.SetTimetable != that1.SetTimetable {
		return false
	}
	return true
}
func (this *SluitemConfig_SluitemPara) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SluitemConfig_SluitemPara)
	if !ok {
		that2, ok := that.(SluitemConfig_SluitemPara)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SluitemStatus != that1.SluitemStatus {
		return false
	}
	if this.SluitemEnableAlarm != that1.SluitemEnableAlarm {
		return false
	}
	if len(this.SluitemPowerTurnon) != len(that1.SluitemPowerTurnon) {
		return false
	}
	for i := range this.SluitemPowerTurnon {
		if this.SluitemPowerTurnon[i] != that1.SluitemPowerTurnon[i] {
			return false
		}
	}
	if this.Longitude != that1.Longitude {
		return false
	}
	if this.Latitude != that1.Latitude {
		return false
	}
	if len(this.RatedPower) != len(that1.RatedPower) {
		return false
	}
	for i := range this.RatedPower {
		if this.RatedPower[i] != that1.RatedPower[i] {
			return false
		}
	}
	if this.UplinkTimer != that1.UplinkTimer {
		return false
	}
	if this.UplinkReply != that1.UplinkReply {
		return false
	}
	return true
}
func (this *SluitemConfig_SluitemVer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SluitemConfig_SluitemVer)
	if !ok {
		that2, ok := that.(SluitemConfig_SluitemVer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SluitemLoop != that1.SluitemLoop {
		return false
	}
	if this.EnergySaving != that1.EnergySaving {
		return false
	}
	if this.ElectricLeakageModule != that1.ElectricLeakageModule {
		return false
	}
	if this.TemperatureModule != that1.TemperatureModule {
		return false
	}
	if this.TimerModule != that1.TimerModule {
		return false
	}
	if this.SluitemType != that1.SluitemType {
		return false
	}
	if this.Ver != that1.Ver {
		return false
	}
	return true
}
func (this *SluitemConfig_SluitemSunriseset) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SluitemConfig_SluitemSunriseset)
	if !ok {
		that2, ok := that.(SluitemConfig_SluitemSunriseset)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Sunrise != that1.Sunrise {
		return false
	}
	if this.Sunset != that1.Sunset {
		return false
	}
	return true
}
func (this *SluitemConfig_SluitemRuntime) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SluitemConfig_SluitemRuntime)
	if !ok {
		that2, ok := that.(SluitemConfig_SluitemRuntime)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DataType != that1.DataType {
		return false
	}
	if this.OutputType != that1.OutputType {
		return false
	}
	if this.OperateType != that1.OperateType {
		return false
	}
	if len(this.DateEnable) != len(that1.DateEnable) {
		return false
	}
	for i := range this.DateEnable {
		if this.DateEnable[i] != that1.DateEnable[i] {
			return false
		}
	}
	if this.OperateTime != that1.OperateTime {
		return false
	}
	if this.OperateOffset != that1.OperateOffset {
		return false
	}
	if len(this.RelayOperate) != len(that1.RelayOperate) {
		return false
	}
	for i := range this.RelayOperate {
		if this.RelayOperate[i] != that1.RelayOperate[i] {
			return false
		}
	}
	if len(this.PwmLoop) != len(that1.PwmLoop) {
		return false
	}
	for i := range this.PwmLoop {
		if this.PwmLoop[i] != that1.PwmLoop[i] {
			return false
		}
	}
	if this.PwmPower != that1.PwmPower {
		return false
	}
	if this.PwmBaudrate != that1.PwmBaudrate {
		return false
	}
	return true
}
func (this *SluitemReply) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SluitemReply)
	if !ok {
		that2, ok := that.(SluitemReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	return true
}
func (this *SluitemData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SluitemData)
	if !ok {
		that2, ok := that.(SluitemData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CmdIdx != that1.CmdIdx {
		return false
	}
	if !this.ModelInfo.Equal(that1.ModelInfo) {
		return false
	}
	if len(this.LightData) != len(that1.LightData) {
		return false
	}
	for i := range this.LightData {
		if !this.LightData[i].Equal(that1.LightData[i]) {
			return false
		}
	}
	if this.LeakageCurrent != that1.LeakageCurrent {
		return false
	}
	if !this.SluitemStatus.Equal(that1.SluitemStatus) {
		return false
	}
	if !this.TimeFault.Equal(that1.TimeFault) {
		return false
	}
	if this.ResetCount != that1.ResetCount {
		return false
	}
	if this.DateTime != that1.DateTime {
		return false
	}
	if !this.SluitemPara.Equal(that1.SluitemPara) {
		return false
	}
	if this.Rsrp != that1.Rsrp {
		return false
	}
	if this.Rssi != that1.Rssi {
		return false
	}
	if this.Snr != that1.Snr {
		return false
	}
	if this.Pci != that1.Pci {
		return false
	}
	if this.Rsrq != that1.Rsrq {
		return false
	}
	if this.Txpower != that1.Txpower {
		return false
	}
	if this.Earfcn != that1.Earfcn {
		return false
	}
	if this.Ecl != that1.Ecl {
		return false
	}
	if this.Csq != that1.Csq {
		return false
	}
	if this.Reson != that1.Reson {
		return false
	}
	if this.Retry != that1.Retry {
		return false
	}
	if this.Sunrise != that1.Sunrise {
		return false
	}
	if this.Sunset != that1.Sunset {
		return false
	}
	return true
}
func (this *SluitemData_ModelInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SluitemData_ModelInfo)
	if !ok {
		that2, ok := that.(SluitemData_ModelInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SluitemLoop != that1.SluitemLoop {
		return false
	}
	if this.PowerSaving != that1.PowerSaving {
		return false
	}
	if this.HasLeakage != that1.HasLeakage {
		return false
	}
	if this.HasTemperature != that1.HasTemperature {
		return false
	}
	if this.HasTimer != that1.HasTimer {
		return false
	}
	if this.Model != that1.Model {
		return false
	}
	if this.SluitemType != that1.SluitemType {
		return false
	}
	return true
}
func (this *SluitemData_LightData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SluitemData_LightData)
	if !ok {
		that2, ok := that.(SluitemData_LightData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Voltage != that1.Voltage {
		return false
	}
	if this.Current != that1.Current {
		return false
	}
	if this.ActivePower != that1.ActivePower {
		return false
	}
	if this.ReactivePower != that1.ReactivePower {
		return false
	}
	if this.ApparentPower != that1.ApparentPower {
		return false
	}
	if this.Electricity != that1.Electricity {
		return false
	}
	if this.ActiveTime != that1.ActiveTime {
		return false
	}
	if !this.LightStatus.Equal(that1.LightStatus) {
		return false
	}
	if this.PowerLevel != that1.PowerLevel {
		return false
	}
	if this.SluitemPowerTurnon != that1.SluitemPowerTurnon {
		return false
	}
	if this.RatedPower != that1.RatedPower {
		return false
	}
	return true
}
func (this *SluitemData_LightStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SluitemData_LightStatus)
	if !ok {
		that2, ok := that.(SluitemData_LightStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Leakage != that1.Leakage {
		return false
	}
	if this.Fault != that1.Fault {
		return false
	}
	if this.WorkingOn != that1.WorkingOn {
		return false
	}
	return true
}
func (this *SluitemData_SluitemStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SluitemData_SluitemStatus)
	if !ok {
		that2, ok := that.(SluitemData_SluitemStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.FlashFault != that1.FlashFault {
		return false
	}
	if this.EnableAlarm != that1.EnableAlarm {
		return false
	}
	return true
}
func (this *SluitemData_TimeFault) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SluitemData_TimeFault)
	if !ok {
		that2, ok := that.(SluitemData_TimeFault)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ClockFault != that1.ClockFault {
		return false
	}
	if this.ClockOutFault != that1.ClockOutFault {
		return false
	}
	if this.ClockOutAlarm != that1.ClockOutAlarm {
		return false
	}
	return true
}
func (this *SluitemData_SluitemPara) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SluitemData_SluitemPara)
	if !ok {
		that2, ok := that.(SluitemData_SluitemPara)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Longitude != that1.Longitude {
		return false
	}
	if this.Latitude != that1.Latitude {
		return false
	}
	if this.HasEnableAlarm != that1.HasEnableAlarm {
		return false
	}
	if this.IsRunning != that1.IsRunning {
		return false
	}
	if this.AlarmInterval != that1.AlarmInterval {
		return false
	}
	if this.UplinkReply != that1.UplinkReply {
		return false
	}
	return true
}
func (this *MsgNBiot) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&wlst_nbiot.MsgNBiot{")
	s = append(s, "CmdIdx: "+fmt.Sprintf("%#v", this.CmdIdx)+",\n")
	s = append(s, "CmdName: "+fmt.Sprintf("%#v", this.CmdName)+",\n")
	s = append(s, "CmdFlag: "+fmt.Sprintf("%#v", this.CmdFlag)+",\n")
	s = append(s, "Imei: "+fmt.Sprintf("%#v", this.Imei)+",\n")
	s = append(s, "RawData: "+fmt.Sprintf("%#v", this.RawData)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MsgNBOpen) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&wlst_nbiot.MsgNBOpen{")
	s = append(s, "Imei: "+fmt.Sprintf("%#v", this.Imei)+",\n")
	s = append(s, "DtReceive: "+fmt.Sprintf("%#v", this.DtReceive)+",\n")
	s = append(s, "DataType: "+fmt.Sprintf("%#v", this.DataType)+",\n")
	s = append(s, "DataCmd: "+fmt.Sprintf("%#v", this.DataCmd)+",\n")
	if this.SluitemData != nil {
		s = append(s, "SluitemData: "+fmt.Sprintf("%#v", this.SluitemData)+",\n")
	}
	if this.SluitemReply != nil {
		s = append(s, "SluitemReply: "+fmt.Sprintf("%#v", this.SluitemReply)+",\n")
	}
	if this.SluitemConfig != nil {
		s = append(s, "SluitemConfig: "+fmt.Sprintf("%#v", this.SluitemConfig)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SluitemConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 15)
	s = append(s, "&wlst_nbiot.SluitemConfig{")
	s = append(s, "CmdIdx: "+fmt.Sprintf("%#v", this.CmdIdx)+",\n")
	s = append(s, "SluitemIdx: "+fmt.Sprintf("%#v", this.SluitemIdx)+",\n")
	if this.DataMark != nil {
		s = append(s, "DataMark: "+fmt.Sprintf("%#v", this.DataMark)+",\n")
	}
	s = append(s, "LoopCount: "+fmt.Sprintf("%#v", this.LoopCount)+",\n")
	s = append(s, "SluitemTime: "+fmt.Sprintf("%#v", this.SluitemTime)+",\n")
	if this.SluitemPara != nil {
		s = append(s, "SluitemPara: "+fmt.Sprintf("%#v", this.SluitemPara)+",\n")
	}
	if this.SluitemVer != nil {
		s = append(s, "SluitemVer: "+fmt.Sprintf("%#v", this.SluitemVer)+",\n")
	}
	if this.SluitemSunriseset != nil {
		s = append(s, "SluitemSunriseset: "+fmt.Sprintf("%#v", this.SluitemSunriseset)+",\n")
	}
	if this.SluitemRuntime != nil {
		s = append(s, "SluitemRuntime: "+fmt.Sprintf("%#v", this.SluitemRuntime)+",\n")
	}
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	if this.SetMark != nil {
		s = append(s, "SetMark: "+fmt.Sprintf("%#v", this.SetMark)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SluitemConfig_DataMark) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&wlst_nbiot.SluitemConfig_DataMark{")
	s = append(s, "ReadTimer: "+fmt.Sprintf("%#v", this.ReadTimer)+",\n")
	s = append(s, "ReadArgs: "+fmt.Sprintf("%#v", this.ReadArgs)+",\n")
	s = append(s, "ReadVer: "+fmt.Sprintf("%#v", this.ReadVer)+",\n")
	s = append(s, "ReadSunriseset: "+fmt.Sprintf("%#v", this.ReadSunriseset)+",\n")
	s = append(s, "ReadTimetable: "+fmt.Sprintf("%#v", this.ReadTimetable)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SluitemConfig_SetMark) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&wlst_nbiot.SluitemConfig_SetMark{")
	s = append(s, "SetTimer: "+fmt.Sprintf("%#v", this.SetTimer)+",\n")
	s = append(s, "SetArgs: "+fmt.Sprintf("%#v", this.SetArgs)+",\n")
	s = append(s, "SetReset: "+fmt.Sprintf("%#v", this.SetReset)+",\n")
	s = append(s, "SetTimetable: "+fmt.Sprintf("%#v", this.SetTimetable)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SluitemConfig_SluitemPara) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&wlst_nbiot.SluitemConfig_SluitemPara{")
	s = append(s, "SluitemStatus: "+fmt.Sprintf("%#v", this.SluitemStatus)+",\n")
	s = append(s, "SluitemEnableAlarm: "+fmt.Sprintf("%#v", this.SluitemEnableAlarm)+",\n")
	s = append(s, "SluitemPowerTurnon: "+fmt.Sprintf("%#v", this.SluitemPowerTurnon)+",\n")
	s = append(s, "Longitude: "+fmt.Sprintf("%#v", this.Longitude)+",\n")
	s = append(s, "Latitude: "+fmt.Sprintf("%#v", this.Latitude)+",\n")
	s = append(s, "RatedPower: "+fmt.Sprintf("%#v", this.RatedPower)+",\n")
	s = append(s, "UplinkTimer: "+fmt.Sprintf("%#v", this.UplinkTimer)+",\n")
	s = append(s, "UplinkReply: "+fmt.Sprintf("%#v", this.UplinkReply)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SluitemConfig_SluitemVer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&wlst_nbiot.SluitemConfig_SluitemVer{")
	s = append(s, "SluitemLoop: "+fmt.Sprintf("%#v", this.SluitemLoop)+",\n")
	s = append(s, "EnergySaving: "+fmt.Sprintf("%#v", this.EnergySaving)+",\n")
	s = append(s, "ElectricLeakageModule: "+fmt.Sprintf("%#v", this.ElectricLeakageModule)+",\n")
	s = append(s, "TemperatureModule: "+fmt.Sprintf("%#v", this.TemperatureModule)+",\n")
	s = append(s, "TimerModule: "+fmt.Sprintf("%#v", this.TimerModule)+",\n")
	s = append(s, "SluitemType: "+fmt.Sprintf("%#v", this.SluitemType)+",\n")
	s = append(s, "Ver: "+fmt.Sprintf("%#v", this.Ver)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SluitemConfig_SluitemSunriseset) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&wlst_nbiot.SluitemConfig_SluitemSunriseset{")
	s = append(s, "Sunrise: "+fmt.Sprintf("%#v", this.Sunrise)+",\n")
	s = append(s, "Sunset: "+fmt.Sprintf("%#v", this.Sunset)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SluitemConfig_SluitemRuntime) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&wlst_nbiot.SluitemConfig_SluitemRuntime{")
	s = append(s, "DataType: "+fmt.Sprintf("%#v", this.DataType)+",\n")
	s = append(s, "OutputType: "+fmt.Sprintf("%#v", this.OutputType)+",\n")
	s = append(s, "OperateType: "+fmt.Sprintf("%#v", this.OperateType)+",\n")
	s = append(s, "DateEnable: "+fmt.Sprintf("%#v", this.DateEnable)+",\n")
	s = append(s, "OperateTime: "+fmt.Sprintf("%#v", this.OperateTime)+",\n")
	s = append(s, "OperateOffset: "+fmt.Sprintf("%#v", this.OperateOffset)+",\n")
	s = append(s, "RelayOperate: "+fmt.Sprintf("%#v", this.RelayOperate)+",\n")
	s = append(s, "PwmLoop: "+fmt.Sprintf("%#v", this.PwmLoop)+",\n")
	s = append(s, "PwmPower: "+fmt.Sprintf("%#v", this.PwmPower)+",\n")
	s = append(s, "PwmBaudrate: "+fmt.Sprintf("%#v", this.PwmBaudrate)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SluitemReply) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&wlst_nbiot.SluitemReply{")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SluitemData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 26)
	s = append(s, "&wlst_nbiot.SluitemData{")
	s = append(s, "CmdIdx: "+fmt.Sprintf("%#v", this.CmdIdx)+",\n")
	if this.ModelInfo != nil {
		s = append(s, "ModelInfo: "+fmt.Sprintf("%#v", this.ModelInfo)+",\n")
	}
	if this.LightData != nil {
		s = append(s, "LightData: "+fmt.Sprintf("%#v", this.LightData)+",\n")
	}
	s = append(s, "LeakageCurrent: "+fmt.Sprintf("%#v", this.LeakageCurrent)+",\n")
	if this.SluitemStatus != nil {
		s = append(s, "SluitemStatus: "+fmt.Sprintf("%#v", this.SluitemStatus)+",\n")
	}
	if this.TimeFault != nil {
		s = append(s, "TimeFault: "+fmt.Sprintf("%#v", this.TimeFault)+",\n")
	}
	s = append(s, "ResetCount: "+fmt.Sprintf("%#v", this.ResetCount)+",\n")
	s = append(s, "DateTime: "+fmt.Sprintf("%#v", this.DateTime)+",\n")
	if this.SluitemPara != nil {
		s = append(s, "SluitemPara: "+fmt.Sprintf("%#v", this.SluitemPara)+",\n")
	}
	s = append(s, "Rsrp: "+fmt.Sprintf("%#v", this.Rsrp)+",\n")
	s = append(s, "Rssi: "+fmt.Sprintf("%#v", this.Rssi)+",\n")
	s = append(s, "Snr: "+fmt.Sprintf("%#v", this.Snr)+",\n")
	s = append(s, "Pci: "+fmt.Sprintf("%#v", this.Pci)+",\n")
	s = append(s, "Rsrq: "+fmt.Sprintf("%#v", this.Rsrq)+",\n")
	s = append(s, "Txpower: "+fmt.Sprintf("%#v", this.Txpower)+",\n")
	s = append(s, "Earfcn: "+fmt.Sprintf("%#v", this.Earfcn)+",\n")
	s = append(s, "Ecl: "+fmt.Sprintf("%#v", this.Ecl)+",\n")
	s = append(s, "Csq: "+fmt.Sprintf("%#v", this.Csq)+",\n")
	s = append(s, "Reson: "+fmt.Sprintf("%#v", this.Reson)+",\n")
	s = append(s, "Retry: "+fmt.Sprintf("%#v", this.Retry)+",\n")
	s = append(s, "Sunrise: "+fmt.Sprintf("%#v", this.Sunrise)+",\n")
	s = append(s, "Sunset: "+fmt.Sprintf("%#v", this.Sunset)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SluitemData_ModelInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&wlst_nbiot.SluitemData_ModelInfo{")
	s = append(s, "SluitemLoop: "+fmt.Sprintf("%#v", this.SluitemLoop)+",\n")
	s = append(s, "PowerSaving: "+fmt.Sprintf("%#v", this.PowerSaving)+",\n")
	s = append(s, "HasLeakage: "+fmt.Sprintf("%#v", this.HasLeakage)+",\n")
	s = append(s, "HasTemperature: "+fmt.Sprintf("%#v", this.HasTemperature)+",\n")
	s = append(s, "HasTimer: "+fmt.Sprintf("%#v", this.HasTimer)+",\n")
	s = append(s, "Model: "+fmt.Sprintf("%#v", this.Model)+",\n")
	s = append(s, "SluitemType: "+fmt.Sprintf("%#v", this.SluitemType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SluitemData_LightData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 15)
	s = append(s, "&wlst_nbiot.SluitemData_LightData{")
	s = append(s, "Voltage: "+fmt.Sprintf("%#v", this.Voltage)+",\n")
	s = append(s, "Current: "+fmt.Sprintf("%#v", this.Current)+",\n")
	s = append(s, "ActivePower: "+fmt.Sprintf("%#v", this.ActivePower)+",\n")
	s = append(s, "ReactivePower: "+fmt.Sprintf("%#v", this.ReactivePower)+",\n")
	s = append(s, "ApparentPower: "+fmt.Sprintf("%#v", this.ApparentPower)+",\n")
	s = append(s, "Electricity: "+fmt.Sprintf("%#v", this.Electricity)+",\n")
	s = append(s, "ActiveTime: "+fmt.Sprintf("%#v", this.ActiveTime)+",\n")
	if this.LightStatus != nil {
		s = append(s, "LightStatus: "+fmt.Sprintf("%#v", this.LightStatus)+",\n")
	}
	s = append(s, "PowerLevel: "+fmt.Sprintf("%#v", this.PowerLevel)+",\n")
	s = append(s, "SluitemPowerTurnon: "+fmt.Sprintf("%#v", this.SluitemPowerTurnon)+",\n")
	s = append(s, "RatedPower: "+fmt.Sprintf("%#v", this.RatedPower)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SluitemData_LightStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&wlst_nbiot.SluitemData_LightStatus{")
	s = append(s, "Leakage: "+fmt.Sprintf("%#v", this.Leakage)+",\n")
	s = append(s, "Fault: "+fmt.Sprintf("%#v", this.Fault)+",\n")
	s = append(s, "WorkingOn: "+fmt.Sprintf("%#v", this.WorkingOn)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SluitemData_SluitemStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&wlst_nbiot.SluitemData_SluitemStatus{")
	s = append(s, "FlashFault: "+fmt.Sprintf("%#v", this.FlashFault)+",\n")
	s = append(s, "EnableAlarm: "+fmt.Sprintf("%#v", this.EnableAlarm)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SluitemData_TimeFault) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&wlst_nbiot.SluitemData_TimeFault{")
	s = append(s, "ClockFault: "+fmt.Sprintf("%#v", this.ClockFault)+",\n")
	s = append(s, "ClockOutFault: "+fmt.Sprintf("%#v", this.ClockOutFault)+",\n")
	s = append(s, "ClockOutAlarm: "+fmt.Sprintf("%#v", this.ClockOutAlarm)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SluitemData_SluitemPara) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&wlst_nbiot.SluitemData_SluitemPara{")
	s = append(s, "Longitude: "+fmt.Sprintf("%#v", this.Longitude)+",\n")
	s = append(s, "Latitude: "+fmt.Sprintf("%#v", this.Latitude)+",\n")
	s = append(s, "HasEnableAlarm: "+fmt.Sprintf("%#v", this.HasEnableAlarm)+",\n")
	s = append(s, "IsRunning: "+fmt.Sprintf("%#v", this.IsRunning)+",\n")
	s = append(s, "AlarmInterval: "+fmt.Sprintf("%#v", this.AlarmInterval)+",\n")
	s = append(s, "UplinkReply: "+fmt.Sprintf("%#v", this.UplinkReply)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringMsgNb(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// NBIoTCtlClient is the client API for NBIoTCtl service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type NBIoTCtlClient interface {
	NBIoTEcho(ctx context.Context, in *MsgNBOpen, opts ...grpc.CallOption) (*MsgNBOpen, error)
}

type nBIoTCtlClient struct {
	cc *grpc.ClientConn
}

func NewNBIoTCtlClient(cc *grpc.ClientConn) NBIoTCtlClient {
	return &nBIoTCtlClient{cc}
}

func (c *nBIoTCtlClient) NBIoTEcho(ctx context.Context, in *MsgNBOpen, opts ...grpc.CallOption) (*MsgNBOpen, error) {
	out := new(MsgNBOpen)
	err := c.cc.Invoke(ctx, "/wlst.nbiot.NBIoTCtl/NBIoTEcho", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NBIoTCtlServer is the server API for NBIoTCtl service.
type NBIoTCtlServer interface {
	NBIoTEcho(context.Context, *MsgNBOpen) (*MsgNBOpen, error)
}

// UnimplementedNBIoTCtlServer can be embedded to have forward compatible implementations.
type UnimplementedNBIoTCtlServer struct {
}

func (*UnimplementedNBIoTCtlServer) NBIoTEcho(ctx context.Context, req *MsgNBOpen) (*MsgNBOpen, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NBIoTEcho not implemented")
}

func RegisterNBIoTCtlServer(s *grpc.Server, srv NBIoTCtlServer) {
	s.RegisterService(&_NBIoTCtl_serviceDesc, srv)
}

func _NBIoTCtl_NBIoTEcho_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgNBOpen)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NBIoTCtlServer).NBIoTEcho(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/wlst.nbiot.NBIoTCtl/NBIoTEcho",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NBIoTCtlServer).NBIoTEcho(ctx, req.(*MsgNBOpen))
	}
	return interceptor(ctx, in, info, handler)
}

var _NBIoTCtl_serviceDesc = grpc.ServiceDesc{
	ServiceName: "wlst.nbiot.NBIoTCtl",
	HandlerType: (*NBIoTCtlServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NBIoTEcho",
			Handler:    _NBIoTCtl_NBIoTEcho_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "msg_nb.proto",
}

func (m *MsgNBiot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgNBiot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgNBiot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RawData) > 0 {
		dAtA2 := make([]byte, len(m.RawData)*10)
		var j1 int
		for _, num1 := range m.RawData {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintMsgNb(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Imei) > 0 {
		dAtA4 := make([]byte, len(m.Imei)*10)
		var j3 int
		for _, num1 := range m.Imei {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintMsgNb(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x22
	}
	if m.CmdFlag != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.CmdFlag))
		i--
		dAtA[i] = 0x18
	}
	if len(m.CmdName) > 0 {
		i -= len(m.CmdName)
		copy(dAtA[i:], m.CmdName)
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.CmdName)))
		i--
		dAtA[i] = 0x12
	}
	if m.CmdIdx != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgNBOpen) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgNBOpen) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgNBOpen) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SluitemConfig != nil {
		{
			size, err := m.SluitemConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.SluitemReply != nil {
		{
			size, err := m.SluitemReply.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.SluitemData != nil {
		{
			size, err := m.SluitemData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.DataCmd) > 0 {
		i -= len(m.DataCmd)
		copy(dAtA[i:], m.DataCmd)
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.DataCmd)))
		i--
		dAtA[i] = 0x4a
	}
	if m.DataType != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.DataType))
		i--
		dAtA[i] = 0x18
	}
	if m.DtReceive != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.DtReceive))
		i--
		dAtA[i] = 0x10
	}
	if m.Imei != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Imei))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SluitemConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SluitemConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SluitemConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SetMark != nil {
		{
			size, err := m.SetMark.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.Status != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x70
	}
	if len(m.SluitemRuntime) > 0 {
		for iNdEx := len(m.SluitemRuntime) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SluitemRuntime[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsgNb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if m.SluitemSunriseset != nil {
		{
			size, err := m.SluitemSunriseset.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.SluitemVer != nil {
		{
			size, err := m.SluitemVer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.SluitemPara != nil {
		{
			size, err := m.SluitemPara.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.SluitemTime != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.SluitemTime))
		i--
		dAtA[i] = 0x38
	}
	if m.LoopCount != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.LoopCount))
		i--
		dAtA[i] = 0x28
	}
	if m.DataMark != nil {
		{
			size, err := m.DataMark.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.SluitemIdx != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.SluitemIdx))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SluitemConfig_DataMark) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SluitemConfig_DataMark) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SluitemConfig_DataMark) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReadTimetable != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.ReadTimetable))
		i--
		dAtA[i] = 0x38
	}
	if m.ReadSunriseset != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.ReadSunriseset))
		i--
		dAtA[i] = 0x30
	}
	if m.ReadVer != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.ReadVer))
		i--
		dAtA[i] = 0x28
	}
	if m.ReadArgs != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.ReadArgs))
		i--
		dAtA[i] = 0x18
	}
	if m.ReadTimer != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.ReadTimer))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *SluitemConfig_SetMark) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SluitemConfig_SetMark) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SluitemConfig_SetMark) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SetTimetable != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.SetTimetable))
		i--
		dAtA[i] = 0x28
	}
	if m.SetReset != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.SetReset))
		i--
		dAtA[i] = 0x20
	}
	if m.SetArgs != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.SetArgs))
		i--
		dAtA[i] = 0x10
	}
	if m.SetTimer != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.SetTimer))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SluitemConfig_SluitemPara) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SluitemConfig_SluitemPara) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SluitemConfig_SluitemPara) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UplinkReply != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.UplinkReply))
		i--
		dAtA[i] = 0x50
	}
	if m.UplinkTimer != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.UplinkTimer))
		i--
		dAtA[i] = 0x48
	}
	if len(m.RatedPower) > 0 {
		dAtA14 := make([]byte, len(m.RatedPower)*10)
		var j13 int
		for _, num1 := range m.RatedPower {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		i -= j13
		copy(dAtA[i:], dAtA14[:j13])
		i = encodeVarintMsgNb(dAtA, i, uint64(j13))
		i--
		dAtA[i] = 0x42
	}
	if m.Latitude != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Latitude))))
		i--
		dAtA[i] = 0x39
	}
	if m.Longitude != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Longitude))))
		i--
		dAtA[i] = 0x31
	}
	if len(m.SluitemPowerTurnon) > 0 {
		dAtA16 := make([]byte, len(m.SluitemPowerTurnon)*10)
		var j15 int
		for _, num1 := range m.SluitemPowerTurnon {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA16[j15] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j15++
			}
			dAtA16[j15] = uint8(num)
			j15++
		}
		i -= j15
		copy(dAtA[i:], dAtA16[:j15])
		i = encodeVarintMsgNb(dAtA, i, uint64(j15))
		i--
		dAtA[i] = 0x22
	}
	if m.SluitemEnableAlarm != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.SluitemEnableAlarm))
		i--
		dAtA[i] = 0x18
	}
	if m.SluitemStatus != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.SluitemStatus))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *SluitemConfig_SluitemVer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SluitemConfig_SluitemVer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SluitemConfig_SluitemVer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ver) > 0 {
		i -= len(m.Ver)
		copy(dAtA[i:], m.Ver)
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.Ver)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.SluitemType) > 0 {
		i -= len(m.SluitemType)
		copy(dAtA[i:], m.SluitemType)
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.SluitemType)))
		i--
		dAtA[i] = 0x32
	}
	if m.TimerModule != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.TimerModule))
		i--
		dAtA[i] = 0x28
	}
	if m.TemperatureModule != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.TemperatureModule))
		i--
		dAtA[i] = 0x20
	}
	if m.ElectricLeakageModule != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.ElectricLeakageModule))
		i--
		dAtA[i] = 0x18
	}
	if m.EnergySaving != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.EnergySaving))
		i--
		dAtA[i] = 0x10
	}
	if m.SluitemLoop != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.SluitemLoop))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SluitemConfig_SluitemSunriseset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SluitemConfig_SluitemSunriseset) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SluitemConfig_SluitemSunriseset) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sunset != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Sunset))
		i--
		dAtA[i] = 0x10
	}
	if m.Sunrise != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Sunrise))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SluitemConfig_SluitemRuntime) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SluitemConfig_SluitemRuntime) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SluitemConfig_SluitemRuntime) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PwmBaudrate != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.PwmBaudrate))
		i--
		dAtA[i] = 0x50
	}
	if m.PwmPower != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.PwmPower))
		i--
		dAtA[i] = 0x48
	}
	if len(m.PwmLoop) > 0 {
		dAtA18 := make([]byte, len(m.PwmLoop)*10)
		var j17 int
		for _, num1 := range m.PwmLoop {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA18[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA18[j17] = uint8(num)
			j17++
		}
		i -= j17
		copy(dAtA[i:], dAtA18[:j17])
		i = encodeVarintMsgNb(dAtA, i, uint64(j17))
		i--
		dAtA[i] = 0x42
	}
	if len(m.RelayOperate) > 0 {
		dAtA20 := make([]byte, len(m.RelayOperate)*10)
		var j19 int
		for _, num1 := range m.RelayOperate {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA20[j19] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j19++
			}
			dAtA20[j19] = uint8(num)
			j19++
		}
		i -= j19
		copy(dAtA[i:], dAtA20[:j19])
		i = encodeVarintMsgNb(dAtA, i, uint64(j19))
		i--
		dAtA[i] = 0x3a
	}
	if m.OperateOffset != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.OperateOffset))
		i--
		dAtA[i] = 0x30
	}
	if m.OperateTime != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.OperateTime))
		i--
		dAtA[i] = 0x28
	}
	if len(m.DateEnable) > 0 {
		dAtA22 := make([]byte, len(m.DateEnable)*10)
		var j21 int
		for _, num1 := range m.DateEnable {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA22[j21] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j21++
			}
			dAtA22[j21] = uint8(num)
			j21++
		}
		i -= j21
		copy(dAtA[i:], dAtA22[:j21])
		i = encodeVarintMsgNb(dAtA, i, uint64(j21))
		i--
		dAtA[i] = 0x22
	}
	if m.OperateType != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.OperateType))
		i--
		dAtA[i] = 0x18
	}
	if m.OutputType != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.OutputType))
		i--
		dAtA[i] = 0x10
	}
	if m.DataType != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.DataType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SluitemReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SluitemReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SluitemReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SluitemData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SluitemData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SluitemData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sunset != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Sunset))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.Sunrise != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Sunrise))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.Retry != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Retry))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.Reson != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Reson))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.Csq != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Csq))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.Ecl != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Ecl))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.Earfcn != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Earfcn))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.Txpower != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Txpower))
		i--
		dAtA[i] = 0x78
	}
	if m.Rsrq != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Rsrq))
		i--
		dAtA[i] = 0x70
	}
	if m.Pci != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Pci))
		i--
		dAtA[i] = 0x68
	}
	if m.Snr != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Snr))
		i--
		dAtA[i] = 0x60
	}
	if m.Rssi != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Rssi))
		i--
		dAtA[i] = 0x58
	}
	if m.Rsrp != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Rsrp))
		i--
		dAtA[i] = 0x50
	}
	if m.SluitemPara != nil {
		{
			size, err := m.SluitemPara.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.DateTime != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.DateTime))
		i--
		dAtA[i] = 0x40
	}
	if m.ResetCount != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.ResetCount))
		i--
		dAtA[i] = 0x38
	}
	if m.TimeFault != nil {
		{
			size, err := m.TimeFault.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.SluitemStatus != nil {
		{
			size, err := m.SluitemStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.LeakageCurrent != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.LeakageCurrent))))
		i--
		dAtA[i] = 0x21
	}
	if len(m.LightData) > 0 {
		for iNdEx := len(m.LightData) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LightData[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsgNb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.ModelInfo != nil {
		{
			size, err := m.ModelInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.CmdIdx != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SluitemData_ModelInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SluitemData_ModelInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SluitemData_ModelInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SluitemType) > 0 {
		i -= len(m.SluitemType)
		copy(dAtA[i:], m.SluitemType)
		i = encodeVarintMsgNb(dAtA, i, uint64(len(m.SluitemType)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Model != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Model))
		i--
		dAtA[i] = 0x30
	}
	if m.HasTimer != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.HasTimer))
		i--
		dAtA[i] = 0x28
	}
	if m.HasTemperature != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.HasTemperature))
		i--
		dAtA[i] = 0x20
	}
	if m.HasLeakage != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.HasLeakage))
		i--
		dAtA[i] = 0x18
	}
	if m.PowerSaving != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.PowerSaving))
		i--
		dAtA[i] = 0x10
	}
	if m.SluitemLoop != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.SluitemLoop))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SluitemData_LightData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SluitemData_LightData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SluitemData_LightData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RatedPower != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.RatedPower))
		i--
		dAtA[i] = 0x58
	}
	if m.SluitemPowerTurnon != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.SluitemPowerTurnon))
		i--
		dAtA[i] = 0x50
	}
	if m.PowerLevel != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.PowerLevel))
		i--
		dAtA[i] = 0x48
	}
	if m.LightStatus != nil {
		{
			size, err := m.LightStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsgNb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.ActiveTime != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ActiveTime))))
		i--
		dAtA[i] = 0x39
	}
	if m.Electricity != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Electricity))))
		i--
		dAtA[i] = 0x31
	}
	if m.ApparentPower != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ApparentPower))))
		i--
		dAtA[i] = 0x29
	}
	if m.ReactivePower != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ReactivePower))))
		i--
		dAtA[i] = 0x21
	}
	if m.ActivePower != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ActivePower))))
		i--
		dAtA[i] = 0x19
	}
	if m.Current != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Current))))
		i--
		dAtA[i] = 0x11
	}
	if m.Voltage != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Voltage))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *SluitemData_LightStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SluitemData_LightStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SluitemData_LightStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WorkingOn != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.WorkingOn))
		i--
		dAtA[i] = 0x18
	}
	if m.Fault != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Fault))
		i--
		dAtA[i] = 0x10
	}
	if m.Leakage != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.Leakage))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SluitemData_SluitemStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SluitemData_SluitemStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SluitemData_SluitemStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EnableAlarm != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.EnableAlarm))
		i--
		dAtA[i] = 0x10
	}
	if m.FlashFault != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.FlashFault))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SluitemData_TimeFault) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SluitemData_TimeFault) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SluitemData_TimeFault) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ClockOutAlarm != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.ClockOutAlarm))
		i--
		dAtA[i] = 0x18
	}
	if m.ClockOutFault != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.ClockOutFault))
		i--
		dAtA[i] = 0x10
	}
	if m.ClockFault != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.ClockFault))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SluitemData_SluitemPara) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SluitemData_SluitemPara) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SluitemData_SluitemPara) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UplinkReply != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.UplinkReply))
		i--
		dAtA[i] = 0x30
	}
	if m.AlarmInterval != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.AlarmInterval))
		i--
		dAtA[i] = 0x28
	}
	if m.IsRunning != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.IsRunning))
		i--
		dAtA[i] = 0x20
	}
	if m.HasEnableAlarm != 0 {
		i = encodeVarintMsgNb(dAtA, i, uint64(m.HasEnableAlarm))
		i--
		dAtA[i] = 0x18
	}
	if m.Latitude != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Latitude))))
		i--
		dAtA[i] = 0x11
	}
	if m.Longitude != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Longitude))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func encodeVarintMsgNb(dAtA []byte, offset int, v uint64) int {
	offset -= sovMsgNb(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgNBiot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovMsgNb(uint64(m.CmdIdx))
	}
	l = len(m.CmdName)
	if l > 0 {
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.CmdFlag != 0 {
		n += 1 + sovMsgNb(uint64(m.CmdFlag))
	}
	if len(m.Imei) > 0 {
		l = 0
		for _, e := range m.Imei {
			l += sovMsgNb(uint64(e))
		}
		n += 1 + sovMsgNb(uint64(l)) + l
	}
	if len(m.RawData) > 0 {
		l = 0
		for _, e := range m.RawData {
			l += sovMsgNb(uint64(e))
		}
		n += 1 + sovMsgNb(uint64(l)) + l
	}
	return n
}

func (m *MsgNBOpen) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Imei != 0 {
		n += 1 + sovMsgNb(uint64(m.Imei))
	}
	if m.DtReceive != 0 {
		n += 1 + sovMsgNb(uint64(m.DtReceive))
	}
	if m.DataType != 0 {
		n += 1 + sovMsgNb(uint64(m.DataType))
	}
	l = len(m.DataCmd)
	if l > 0 {
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.SluitemData != nil {
		l = m.SluitemData.Size()
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.SluitemReply != nil {
		l = m.SluitemReply.Size()
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.SluitemConfig != nil {
		l = m.SluitemConfig.Size()
		n += 1 + l + sovMsgNb(uint64(l))
	}
	return n
}

func (m *SluitemConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovMsgNb(uint64(m.CmdIdx))
	}
	if m.SluitemIdx != 0 {
		n += 1 + sovMsgNb(uint64(m.SluitemIdx))
	}
	if m.DataMark != nil {
		l = m.DataMark.Size()
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.LoopCount != 0 {
		n += 1 + sovMsgNb(uint64(m.LoopCount))
	}
	if m.SluitemTime != 0 {
		n += 1 + sovMsgNb(uint64(m.SluitemTime))
	}
	if m.SluitemPara != nil {
		l = m.SluitemPara.Size()
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.SluitemVer != nil {
		l = m.SluitemVer.Size()
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.SluitemSunriseset != nil {
		l = m.SluitemSunriseset.Size()
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if len(m.SluitemRuntime) > 0 {
		for _, e := range m.SluitemRuntime {
			l = e.Size()
			n += 1 + l + sovMsgNb(uint64(l))
		}
	}
	if m.Status != 0 {
		n += 1 + sovMsgNb(uint64(m.Status))
	}
	if m.SetMark != nil {
		l = m.SetMark.Size()
		n += 1 + l + sovMsgNb(uint64(l))
	}
	return n
}

func (m *SluitemConfig_DataMark) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReadTimer != 0 {
		n += 1 + sovMsgNb(uint64(m.ReadTimer))
	}
	if m.ReadArgs != 0 {
		n += 1 + sovMsgNb(uint64(m.ReadArgs))
	}
	if m.ReadVer != 0 {
		n += 1 + sovMsgNb(uint64(m.ReadVer))
	}
	if m.ReadSunriseset != 0 {
		n += 1 + sovMsgNb(uint64(m.ReadSunriseset))
	}
	if m.ReadTimetable != 0 {
		n += 1 + sovMsgNb(uint64(m.ReadTimetable))
	}
	return n
}

func (m *SluitemConfig_SetMark) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SetTimer != 0 {
		n += 1 + sovMsgNb(uint64(m.SetTimer))
	}
	if m.SetArgs != 0 {
		n += 1 + sovMsgNb(uint64(m.SetArgs))
	}
	if m.SetReset != 0 {
		n += 1 + sovMsgNb(uint64(m.SetReset))
	}
	if m.SetTimetable != 0 {
		n += 1 + sovMsgNb(uint64(m.SetTimetable))
	}
	return n
}

func (m *SluitemConfig_SluitemPara) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SluitemStatus != 0 {
		n += 1 + sovMsgNb(uint64(m.SluitemStatus))
	}
	if m.SluitemEnableAlarm != 0 {
		n += 1 + sovMsgNb(uint64(m.SluitemEnableAlarm))
	}
	if len(m.SluitemPowerTurnon) > 0 {
		l = 0
		for _, e := range m.SluitemPowerTurnon {
			l += sovMsgNb(uint64(e))
		}
		n += 1 + sovMsgNb(uint64(l)) + l
	}
	if m.Longitude != 0 {
		n += 9
	}
	if m.Latitude != 0 {
		n += 9
	}
	if len(m.RatedPower) > 0 {
		l = 0
		for _, e := range m.RatedPower {
			l += sovMsgNb(uint64(e))
		}
		n += 1 + sovMsgNb(uint64(l)) + l
	}
	if m.UplinkTimer != 0 {
		n += 1 + sovMsgNb(uint64(m.UplinkTimer))
	}
	if m.UplinkReply != 0 {
		n += 1 + sovMsgNb(uint64(m.UplinkReply))
	}
	return n
}

func (m *SluitemConfig_SluitemVer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SluitemLoop != 0 {
		n += 1 + sovMsgNb(uint64(m.SluitemLoop))
	}
	if m.EnergySaving != 0 {
		n += 1 + sovMsgNb(uint64(m.EnergySaving))
	}
	if m.ElectricLeakageModule != 0 {
		n += 1 + sovMsgNb(uint64(m.ElectricLeakageModule))
	}
	if m.TemperatureModule != 0 {
		n += 1 + sovMsgNb(uint64(m.TemperatureModule))
	}
	if m.TimerModule != 0 {
		n += 1 + sovMsgNb(uint64(m.TimerModule))
	}
	l = len(m.SluitemType)
	if l > 0 {
		n += 1 + l + sovMsgNb(uint64(l))
	}
	l = len(m.Ver)
	if l > 0 {
		n += 1 + l + sovMsgNb(uint64(l))
	}
	return n
}

func (m *SluitemConfig_SluitemSunriseset) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sunrise != 0 {
		n += 1 + sovMsgNb(uint64(m.Sunrise))
	}
	if m.Sunset != 0 {
		n += 1 + sovMsgNb(uint64(m.Sunset))
	}
	return n
}

func (m *SluitemConfig_SluitemRuntime) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DataType != 0 {
		n += 1 + sovMsgNb(uint64(m.DataType))
	}
	if m.OutputType != 0 {
		n += 1 + sovMsgNb(uint64(m.OutputType))
	}
	if m.OperateType != 0 {
		n += 1 + sovMsgNb(uint64(m.OperateType))
	}
	if len(m.DateEnable) > 0 {
		l = 0
		for _, e := range m.DateEnable {
			l += sovMsgNb(uint64(e))
		}
		n += 1 + sovMsgNb(uint64(l)) + l
	}
	if m.OperateTime != 0 {
		n += 1 + sovMsgNb(uint64(m.OperateTime))
	}
	if m.OperateOffset != 0 {
		n += 1 + sovMsgNb(uint64(m.OperateOffset))
	}
	if len(m.RelayOperate) > 0 {
		l = 0
		for _, e := range m.RelayOperate {
			l += sovMsgNb(uint64(e))
		}
		n += 1 + sovMsgNb(uint64(l)) + l
	}
	if len(m.PwmLoop) > 0 {
		l = 0
		for _, e := range m.PwmLoop {
			l += sovMsgNb(uint64(e))
		}
		n += 1 + sovMsgNb(uint64(l)) + l
	}
	if m.PwmPower != 0 {
		n += 1 + sovMsgNb(uint64(m.PwmPower))
	}
	if m.PwmBaudrate != 0 {
		n += 1 + sovMsgNb(uint64(m.PwmBaudrate))
	}
	return n
}

func (m *SluitemReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovMsgNb(uint64(m.Status))
	}
	return n
}

func (m *SluitemData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovMsgNb(uint64(m.CmdIdx))
	}
	if m.ModelInfo != nil {
		l = m.ModelInfo.Size()
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if len(m.LightData) > 0 {
		for _, e := range m.LightData {
			l = e.Size()
			n += 1 + l + sovMsgNb(uint64(l))
		}
	}
	if m.LeakageCurrent != 0 {
		n += 9
	}
	if m.SluitemStatus != nil {
		l = m.SluitemStatus.Size()
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.TimeFault != nil {
		l = m.TimeFault.Size()
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.ResetCount != 0 {
		n += 1 + sovMsgNb(uint64(m.ResetCount))
	}
	if m.DateTime != 0 {
		n += 1 + sovMsgNb(uint64(m.DateTime))
	}
	if m.SluitemPara != nil {
		l = m.SluitemPara.Size()
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.Rsrp != 0 {
		n += 1 + sovMsgNb(uint64(m.Rsrp))
	}
	if m.Rssi != 0 {
		n += 1 + sovMsgNb(uint64(m.Rssi))
	}
	if m.Snr != 0 {
		n += 1 + sovMsgNb(uint64(m.Snr))
	}
	if m.Pci != 0 {
		n += 1 + sovMsgNb(uint64(m.Pci))
	}
	if m.Rsrq != 0 {
		n += 1 + sovMsgNb(uint64(m.Rsrq))
	}
	if m.Txpower != 0 {
		n += 1 + sovMsgNb(uint64(m.Txpower))
	}
	if m.Earfcn != 0 {
		n += 2 + sovMsgNb(uint64(m.Earfcn))
	}
	if m.Ecl != 0 {
		n += 2 + sovMsgNb(uint64(m.Ecl))
	}
	if m.Csq != 0 {
		n += 2 + sovMsgNb(uint64(m.Csq))
	}
	if m.Reson != 0 {
		n += 2 + sovMsgNb(uint64(m.Reson))
	}
	if m.Retry != 0 {
		n += 2 + sovMsgNb(uint64(m.Retry))
	}
	if m.Sunrise != 0 {
		n += 2 + sovMsgNb(uint64(m.Sunrise))
	}
	if m.Sunset != 0 {
		n += 2 + sovMsgNb(uint64(m.Sunset))
	}
	return n
}

func (m *SluitemData_ModelInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SluitemLoop != 0 {
		n += 1 + sovMsgNb(uint64(m.SluitemLoop))
	}
	if m.PowerSaving != 0 {
		n += 1 + sovMsgNb(uint64(m.PowerSaving))
	}
	if m.HasLeakage != 0 {
		n += 1 + sovMsgNb(uint64(m.HasLeakage))
	}
	if m.HasTemperature != 0 {
		n += 1 + sovMsgNb(uint64(m.HasTemperature))
	}
	if m.HasTimer != 0 {
		n += 1 + sovMsgNb(uint64(m.HasTimer))
	}
	if m.Model != 0 {
		n += 1 + sovMsgNb(uint64(m.Model))
	}
	l = len(m.SluitemType)
	if l > 0 {
		n += 1 + l + sovMsgNb(uint64(l))
	}
	return n
}

func (m *SluitemData_LightData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Voltage != 0 {
		n += 9
	}
	if m.Current != 0 {
		n += 9
	}
	if m.ActivePower != 0 {
		n += 9
	}
	if m.ReactivePower != 0 {
		n += 9
	}
	if m.ApparentPower != 0 {
		n += 9
	}
	if m.Electricity != 0 {
		n += 9
	}
	if m.ActiveTime != 0 {
		n += 9
	}
	if m.LightStatus != nil {
		l = m.LightStatus.Size()
		n += 1 + l + sovMsgNb(uint64(l))
	}
	if m.PowerLevel != 0 {
		n += 1 + sovMsgNb(uint64(m.PowerLevel))
	}
	if m.SluitemPowerTurnon != 0 {
		n += 1 + sovMsgNb(uint64(m.SluitemPowerTurnon))
	}
	if m.RatedPower != 0 {
		n += 1 + sovMsgNb(uint64(m.RatedPower))
	}
	return n
}

func (m *SluitemData_LightStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Leakage != 0 {
		n += 1 + sovMsgNb(uint64(m.Leakage))
	}
	if m.Fault != 0 {
		n += 1 + sovMsgNb(uint64(m.Fault))
	}
	if m.WorkingOn != 0 {
		n += 1 + sovMsgNb(uint64(m.WorkingOn))
	}
	return n
}

func (m *SluitemData_SluitemStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FlashFault != 0 {
		n += 1 + sovMsgNb(uint64(m.FlashFault))
	}
	if m.EnableAlarm != 0 {
		n += 1 + sovMsgNb(uint64(m.EnableAlarm))
	}
	return n
}

func (m *SluitemData_TimeFault) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClockFault != 0 {
		n += 1 + sovMsgNb(uint64(m.ClockFault))
	}
	if m.ClockOutFault != 0 {
		n += 1 + sovMsgNb(uint64(m.ClockOutFault))
	}
	if m.ClockOutAlarm != 0 {
		n += 1 + sovMsgNb(uint64(m.ClockOutAlarm))
	}
	return n
}

func (m *SluitemData_SluitemPara) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Longitude != 0 {
		n += 9
	}
	if m.Latitude != 0 {
		n += 9
	}
	if m.HasEnableAlarm != 0 {
		n += 1 + sovMsgNb(uint64(m.HasEnableAlarm))
	}
	if m.IsRunning != 0 {
		n += 1 + sovMsgNb(uint64(m.IsRunning))
	}
	if m.AlarmInterval != 0 {
		n += 1 + sovMsgNb(uint64(m.AlarmInterval))
	}
	if m.UplinkReply != 0 {
		n += 1 + sovMsgNb(uint64(m.UplinkReply))
	}
	return n
}

func sovMsgNb(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMsgNb(x uint64) (n int) {
	return sovMsgNb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *MsgNBiot) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MsgNBiot{`,
		`CmdIdx:` + fmt.Sprintf("%v", this.CmdIdx) + `,`,
		`CmdName:` + fmt.Sprintf("%v", this.CmdName) + `,`,
		`CmdFlag:` + fmt.Sprintf("%v", this.CmdFlag) + `,`,
		`Imei:` + fmt.Sprintf("%v", this.Imei) + `,`,
		`RawData:` + fmt.Sprintf("%v", this.RawData) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MsgNBOpen) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MsgNBOpen{`,
		`Imei:` + fmt.Sprintf("%v", this.Imei) + `,`,
		`DtReceive:` + fmt.Sprintf("%v", this.DtReceive) + `,`,
		`DataType:` + fmt.Sprintf("%v", this.DataType) + `,`,
		`DataCmd:` + fmt.Sprintf("%v", this.DataCmd) + `,`,
		`SluitemData:` + strings.Replace(this.SluitemData.String(), "SluitemData", "SluitemData", 1) + `,`,
		`SluitemReply:` + strings.Replace(this.SluitemReply.String(), "SluitemReply", "SluitemReply", 1) + `,`,
		`SluitemConfig:` + strings.Replace(this.SluitemConfig.String(), "SluitemConfig", "SluitemConfig", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SluitemConfig) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSluitemRuntime := "[]*SluitemConfig_SluitemRuntime{"
	for _, f := range this.SluitemRuntime {
		repeatedStringForSluitemRuntime += strings.Replace(fmt.Sprintf("%v", f), "SluitemConfig_SluitemRuntime", "SluitemConfig_SluitemRuntime", 1) + ","
	}
	repeatedStringForSluitemRuntime += "}"
	s := strings.Join([]string{`&SluitemConfig{`,
		`CmdIdx:` + fmt.Sprintf("%v", this.CmdIdx) + `,`,
		`SluitemIdx:` + fmt.Sprintf("%v", this.SluitemIdx) + `,`,
		`DataMark:` + strings.Replace(fmt.Sprintf("%v", this.DataMark), "SluitemConfig_DataMark", "SluitemConfig_DataMark", 1) + `,`,
		`LoopCount:` + fmt.Sprintf("%v", this.LoopCount) + `,`,
		`SluitemTime:` + fmt.Sprintf("%v", this.SluitemTime) + `,`,
		`SluitemPara:` + strings.Replace(fmt.Sprintf("%v", this.SluitemPara), "SluitemConfig_SluitemPara", "SluitemConfig_SluitemPara", 1) + `,`,
		`SluitemVer:` + strings.Replace(fmt.Sprintf("%v", this.SluitemVer), "SluitemConfig_SluitemVer", "SluitemConfig_SluitemVer", 1) + `,`,
		`SluitemSunriseset:` + strings.Replace(fmt.Sprintf("%v", this.SluitemSunriseset), "SluitemConfig_SluitemSunriseset", "SluitemConfig_SluitemSunriseset", 1) + `,`,
		`SluitemRuntime:` + repeatedStringForSluitemRuntime + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`SetMark:` + strings.Replace(fmt.Sprintf("%v", this.SetMark), "SluitemConfig_SetMark", "SluitemConfig_SetMark", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SluitemConfig_DataMark) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SluitemConfig_DataMark{`,
		`ReadTimer:` + fmt.Sprintf("%v", this.ReadTimer) + `,`,
		`ReadArgs:` + fmt.Sprintf("%v", this.ReadArgs) + `,`,
		`ReadVer:` + fmt.Sprintf("%v", this.ReadVer) + `,`,
		`ReadSunriseset:` + fmt.Sprintf("%v", this.ReadSunriseset) + `,`,
		`ReadTimetable:` + fmt.Sprintf("%v", this.ReadTimetable) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SluitemConfig_SetMark) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SluitemConfig_SetMark{`,
		`SetTimer:` + fmt.Sprintf("%v", this.SetTimer) + `,`,
		`SetArgs:` + fmt.Sprintf("%v", this.SetArgs) + `,`,
		`SetReset:` + fmt.Sprintf("%v", this.SetReset) + `,`,
		`SetTimetable:` + fmt.Sprintf("%v", this.SetTimetable) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SluitemConfig_SluitemPara) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SluitemConfig_SluitemPara{`,
		`SluitemStatus:` + fmt.Sprintf("%v", this.SluitemStatus) + `,`,
		`SluitemEnableAlarm:` + fmt.Sprintf("%v", this.SluitemEnableAlarm) + `,`,
		`SluitemPowerTurnon:` + fmt.Sprintf("%v", this.SluitemPowerTurnon) + `,`,
		`Longitude:` + fmt.Sprintf("%v", this.Longitude) + `,`,
		`Latitude:` + fmt.Sprintf("%v", this.Latitude) + `,`,
		`RatedPower:` + fmt.Sprintf("%v", this.RatedPower) + `,`,
		`UplinkTimer:` + fmt.Sprintf("%v", this.UplinkTimer) + `,`,
		`UplinkReply:` + fmt.Sprintf("%v", this.UplinkReply) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SluitemConfig_SluitemVer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SluitemConfig_SluitemVer{`,
		`SluitemLoop:` + fmt.Sprintf("%v", this.SluitemLoop) + `,`,
		`EnergySaving:` + fmt.Sprintf("%v", this.EnergySaving) + `,`,
		`ElectricLeakageModule:` + fmt.Sprintf("%v", this.ElectricLeakageModule) + `,`,
		`TemperatureModule:` + fmt.Sprintf("%v", this.TemperatureModule) + `,`,
		`TimerModule:` + fmt.Sprintf("%v", this.TimerModule) + `,`,
		`SluitemType:` + fmt.Sprintf("%v", this.SluitemType) + `,`,
		`Ver:` + fmt.Sprintf("%v", this.Ver) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SluitemConfig_SluitemSunriseset) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SluitemConfig_SluitemSunriseset{`,
		`Sunrise:` + fmt.Sprintf("%v", this.Sunrise) + `,`,
		`Sunset:` + fmt.Sprintf("%v", this.Sunset) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SluitemConfig_SluitemRuntime) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SluitemConfig_SluitemRuntime{`,
		`DataType:` + fmt.Sprintf("%v", this.DataType) + `,`,
		`OutputType:` + fmt.Sprintf("%v", this.OutputType) + `,`,
		`OperateType:` + fmt.Sprintf("%v", this.OperateType) + `,`,
		`DateEnable:` + fmt.Sprintf("%v", this.DateEnable) + `,`,
		`OperateTime:` + fmt.Sprintf("%v", this.OperateTime) + `,`,
		`OperateOffset:` + fmt.Sprintf("%v", this.OperateOffset) + `,`,
		`RelayOperate:` + fmt.Sprintf("%v", this.RelayOperate) + `,`,
		`PwmLoop:` + fmt.Sprintf("%v", this.PwmLoop) + `,`,
		`PwmPower:` + fmt.Sprintf("%v", this.PwmPower) + `,`,
		`PwmBaudrate:` + fmt.Sprintf("%v", this.PwmBaudrate) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SluitemReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SluitemReply{`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SluitemData) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForLightData := "[]*SluitemData_LightData{"
	for _, f := range this.LightData {
		repeatedStringForLightData += strings.Replace(fmt.Sprintf("%v", f), "SluitemData_LightData", "SluitemData_LightData", 1) + ","
	}
	repeatedStringForLightData += "}"
	s := strings.Join([]string{`&SluitemData{`,
		`CmdIdx:` + fmt.Sprintf("%v", this.CmdIdx) + `,`,
		`ModelInfo:` + strings.Replace(fmt.Sprintf("%v", this.ModelInfo), "SluitemData_ModelInfo", "SluitemData_ModelInfo", 1) + `,`,
		`LightData:` + repeatedStringForLightData + `,`,
		`LeakageCurrent:` + fmt.Sprintf("%v", this.LeakageCurrent) + `,`,
		`SluitemStatus:` + strings.Replace(fmt.Sprintf("%v", this.SluitemStatus), "SluitemData_SluitemStatus", "SluitemData_SluitemStatus", 1) + `,`,
		`TimeFault:` + strings.Replace(fmt.Sprintf("%v", this.TimeFault), "SluitemData_TimeFault", "SluitemData_TimeFault", 1) + `,`,
		`ResetCount:` + fmt.Sprintf("%v", this.ResetCount) + `,`,
		`DateTime:` + fmt.Sprintf("%v", this.DateTime) + `,`,
		`SluitemPara:` + strings.Replace(fmt.Sprintf("%v", this.SluitemPara), "SluitemData_SluitemPara", "SluitemData_SluitemPara", 1) + `,`,
		`Rsrp:` + fmt.Sprintf("%v", this.Rsrp) + `,`,
		`Rssi:` + fmt.Sprintf("%v", this.Rssi) + `,`,
		`Snr:` + fmt.Sprintf("%v", this.Snr) + `,`,
		`Pci:` + fmt.Sprintf("%v", this.Pci) + `,`,
		`Rsrq:` + fmt.Sprintf("%v", this.Rsrq) + `,`,
		`Txpower:` + fmt.Sprintf("%v", this.Txpower) + `,`,
		`Earfcn:` + fmt.Sprintf("%v", this.Earfcn) + `,`,
		`Ecl:` + fmt.Sprintf("%v", this.Ecl) + `,`,
		`Csq:` + fmt.Sprintf("%v", this.Csq) + `,`,
		`Reson:` + fmt.Sprintf("%v", this.Reson) + `,`,
		`Retry:` + fmt.Sprintf("%v", this.Retry) + `,`,
		`Sunrise:` + fmt.Sprintf("%v", this.Sunrise) + `,`,
		`Sunset:` + fmt.Sprintf("%v", this.Sunset) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SluitemData_ModelInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SluitemData_ModelInfo{`,
		`SluitemLoop:` + fmt.Sprintf("%v", this.SluitemLoop) + `,`,
		`PowerSaving:` + fmt.Sprintf("%v", this.PowerSaving) + `,`,
		`HasLeakage:` + fmt.Sprintf("%v", this.HasLeakage) + `,`,
		`HasTemperature:` + fmt.Sprintf("%v", this.HasTemperature) + `,`,
		`HasTimer:` + fmt.Sprintf("%v", this.HasTimer) + `,`,
		`Model:` + fmt.Sprintf("%v", this.Model) + `,`,
		`SluitemType:` + fmt.Sprintf("%v", this.SluitemType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SluitemData_LightData) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SluitemData_LightData{`,
		`Voltage:` + fmt.Sprintf("%v", this.Voltage) + `,`,
		`Current:` + fmt.Sprintf("%v", this.Current) + `,`,
		`ActivePower:` + fmt.Sprintf("%v", this.ActivePower) + `,`,
		`ReactivePower:` + fmt.Sprintf("%v", this.ReactivePower) + `,`,
		`ApparentPower:` + fmt.Sprintf("%v", this.ApparentPower) + `,`,
		`Electricity:` + fmt.Sprintf("%v", this.Electricity) + `,`,
		`ActiveTime:` + fmt.Sprintf("%v", this.ActiveTime) + `,`,
		`LightStatus:` + strings.Replace(fmt.Sprintf("%v", this.LightStatus), "SluitemData_LightStatus", "SluitemData_LightStatus", 1) + `,`,
		`PowerLevel:` + fmt.Sprintf("%v", this.PowerLevel) + `,`,
		`SluitemPowerTurnon:` + fmt.Sprintf("%v", this.SluitemPowerTurnon) + `,`,
		`RatedPower:` + fmt.Sprintf("%v", this.RatedPower) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SluitemData_LightStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SluitemData_LightStatus{`,
		`Leakage:` + fmt.Sprintf("%v", this.Leakage) + `,`,
		`Fault:` + fmt.Sprintf("%v", this.Fault) + `,`,
		`WorkingOn:` + fmt.Sprintf("%v", this.WorkingOn) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SluitemData_SluitemStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SluitemData_SluitemStatus{`,
		`FlashFault:` + fmt.Sprintf("%v", this.FlashFault) + `,`,
		`EnableAlarm:` + fmt.Sprintf("%v", this.EnableAlarm) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SluitemData_TimeFault) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SluitemData_TimeFault{`,
		`ClockFault:` + fmt.Sprintf("%v", this.ClockFault) + `,`,
		`ClockOutFault:` + fmt.Sprintf("%v", this.ClockOutFault) + `,`,
		`ClockOutAlarm:` + fmt.Sprintf("%v", this.ClockOutAlarm) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SluitemData_SluitemPara) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SluitemData_SluitemPara{`,
		`Longitude:` + fmt.Sprintf("%v", this.Longitude) + `,`,
		`Latitude:` + fmt.Sprintf("%v", this.Latitude) + `,`,
		`HasEnableAlarm:` + fmt.Sprintf("%v", this.HasEnableAlarm) + `,`,
		`IsRunning:` + fmt.Sprintf("%v", this.IsRunning) + `,`,
		`AlarmInterval:` + fmt.Sprintf("%v", this.AlarmInterval) + `,`,
		`UplinkReply:` + fmt.Sprintf("%v", this.UplinkReply) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringMsgNb(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *MsgNBiot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgNBiot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgNBiot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CmdName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdFlag", wireType)
			}
			m.CmdFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdFlag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Imei = append(m.Imei, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsgNb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsgNb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Imei) == 0 {
					m.Imei = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsgNb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Imei = append(m.Imei, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Imei", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RawData = append(m.RawData, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsgNb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsgNb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RawData) == 0 {
					m.RawData = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsgNb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RawData = append(m.RawData, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RawData", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgNBOpen) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgNBOpen: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgNBOpen: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Imei", wireType)
			}
			m.Imei = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Imei |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DtReceive", wireType)
			}
			m.DtReceive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DtReceive |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataType", wireType)
			}
			m.DataType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataCmd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataCmd = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SluitemData == nil {
				m.SluitemData = &SluitemData{}
			}
			if err := m.SluitemData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemReply", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SluitemReply == nil {
				m.SluitemReply = &SluitemReply{}
			}
			if err := m.SluitemReply.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SluitemConfig == nil {
				m.SluitemConfig = &SluitemConfig{}
			}
			if err := m.SluitemConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SluitemConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SluitemConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SluitemConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemIdx", wireType)
			}
			m.SluitemIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemIdx |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataMark", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DataMark == nil {
				m.DataMark = &SluitemConfig_DataMark{}
			}
			if err := m.DataMark.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoopCount", wireType)
			}
			m.LoopCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoopCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemTime", wireType)
			}
			m.SluitemTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemPara", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SluitemPara == nil {
				m.SluitemPara = &SluitemConfig_SluitemPara{}
			}
			if err := m.SluitemPara.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemVer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SluitemVer == nil {
				m.SluitemVer = &SluitemConfig_SluitemVer{}
			}
			if err := m.SluitemVer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemSunriseset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SluitemSunriseset == nil {
				m.SluitemSunriseset = &SluitemConfig_SluitemSunriseset{}
			}
			if err := m.SluitemSunriseset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemRuntime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SluitemRuntime = append(m.SluitemRuntime, &SluitemConfig_SluitemRuntime{})
			if err := m.SluitemRuntime[len(m.SluitemRuntime)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetMark", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SetMark == nil {
				m.SetMark = &SluitemConfig_SetMark{}
			}
			if err := m.SetMark.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SluitemConfig_DataMark) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Data_mark: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Data_mark: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadTimer", wireType)
			}
			m.ReadTimer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadTimer |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadArgs", wireType)
			}
			m.ReadArgs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadArgs |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadVer", wireType)
			}
			m.ReadVer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadVer |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadSunriseset", wireType)
			}
			m.ReadSunriseset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadSunriseset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadTimetable", wireType)
			}
			m.ReadTimetable = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadTimetable |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SluitemConfig_SetMark) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Set_mark: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Set_mark: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetTimer", wireType)
			}
			m.SetTimer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SetTimer |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetArgs", wireType)
			}
			m.SetArgs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SetArgs |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetReset", wireType)
			}
			m.SetReset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SetReset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetTimetable", wireType)
			}
			m.SetTimetable = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SetTimetable |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SluitemConfig_SluitemPara) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sluitem_para: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sluitem_para: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemStatus", wireType)
			}
			m.SluitemStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemStatus |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemEnableAlarm", wireType)
			}
			m.SluitemEnableAlarm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemEnableAlarm |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SluitemPowerTurnon = append(m.SluitemPowerTurnon, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsgNb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsgNb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SluitemPowerTurnon) == 0 {
					m.SluitemPowerTurnon = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsgNb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SluitemPowerTurnon = append(m.SluitemPowerTurnon, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemPowerTurnon", wireType)
			}
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longitude", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Longitude = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latitude", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Latitude = float64(math.Float64frombits(v))
		case 8:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RatedPower = append(m.RatedPower, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsgNb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsgNb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RatedPower) == 0 {
					m.RatedPower = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsgNb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RatedPower = append(m.RatedPower, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RatedPower", wireType)
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UplinkTimer", wireType)
			}
			m.UplinkTimer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UplinkTimer |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UplinkReply", wireType)
			}
			m.UplinkReply = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UplinkReply |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SluitemConfig_SluitemVer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sluitem_ver: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sluitem_ver: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemLoop", wireType)
			}
			m.SluitemLoop = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemLoop |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnergySaving", wireType)
			}
			m.EnergySaving = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EnergySaving |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElectricLeakageModule", wireType)
			}
			m.ElectricLeakageModule = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ElectricLeakageModule |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemperatureModule", wireType)
			}
			m.TemperatureModule = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TemperatureModule |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimerModule", wireType)
			}
			m.TimerModule = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimerModule |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SluitemType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SluitemConfig_SluitemSunriseset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sluitem_sunriseset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sluitem_sunriseset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sunrise", wireType)
			}
			m.Sunrise = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sunrise |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sunset", wireType)
			}
			m.Sunset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sunset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SluitemConfig_SluitemRuntime) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sluitem_runtime: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sluitem_runtime: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataType", wireType)
			}
			m.DataType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputType", wireType)
			}
			m.OutputType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperateType", wireType)
			}
			m.OperateType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperateType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DateEnable = append(m.DateEnable, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsgNb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsgNb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DateEnable) == 0 {
					m.DateEnable = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsgNb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DateEnable = append(m.DateEnable, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DateEnable", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperateTime", wireType)
			}
			m.OperateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperateTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperateOffset", wireType)
			}
			m.OperateOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperateOffset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RelayOperate = append(m.RelayOperate, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsgNb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsgNb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RelayOperate) == 0 {
					m.RelayOperate = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsgNb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RelayOperate = append(m.RelayOperate, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayOperate", wireType)
			}
		case 8:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PwmLoop = append(m.PwmLoop, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsgNb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsgNb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PwmLoop) == 0 {
					m.PwmLoop = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsgNb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PwmLoop = append(m.PwmLoop, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PwmLoop", wireType)
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PwmPower", wireType)
			}
			m.PwmPower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PwmPower |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PwmBaudrate", wireType)
			}
			m.PwmBaudrate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PwmBaudrate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SluitemReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SluitemReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SluitemReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SluitemData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SluitemData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SluitemData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ModelInfo == nil {
				m.ModelInfo = &SluitemData_ModelInfo{}
			}
			if err := m.ModelInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LightData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LightData = append(m.LightData, &SluitemData_LightData{})
			if err := m.LightData[len(m.LightData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeakageCurrent", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.LeakageCurrent = float64(math.Float64frombits(v))
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SluitemStatus == nil {
				m.SluitemStatus = &SluitemData_SluitemStatus{}
			}
			if err := m.SluitemStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeFault", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TimeFault == nil {
				m.TimeFault = &SluitemData_TimeFault{}
			}
			if err := m.TimeFault.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResetCount", wireType)
			}
			m.ResetCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResetCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateTime", wireType)
			}
			m.DateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DateTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemPara", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SluitemPara == nil {
				m.SluitemPara = &SluitemData_SluitemPara{}
			}
			if err := m.SluitemPara.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rsrp", wireType)
			}
			m.Rsrp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rsrp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rssi", wireType)
			}
			m.Rssi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rssi |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snr", wireType)
			}
			m.Snr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Snr |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pci", wireType)
			}
			m.Pci = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pci |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rsrq", wireType)
			}
			m.Rsrq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rsrq |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txpower", wireType)
			}
			m.Txpower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Txpower |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Earfcn", wireType)
			}
			m.Earfcn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Earfcn |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecl", wireType)
			}
			m.Ecl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ecl |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Csq", wireType)
			}
			m.Csq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Csq |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reson", wireType)
			}
			m.Reson = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reson |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Retry", wireType)
			}
			m.Retry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Retry |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sunrise", wireType)
			}
			m.Sunrise = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sunrise |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sunset", wireType)
			}
			m.Sunset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sunset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SluitemData_ModelInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Model_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Model_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemLoop", wireType)
			}
			m.SluitemLoop = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemLoop |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PowerSaving", wireType)
			}
			m.PowerSaving = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PowerSaving |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasLeakage", wireType)
			}
			m.HasLeakage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HasLeakage |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasTemperature", wireType)
			}
			m.HasTemperature = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HasTemperature |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasTimer", wireType)
			}
			m.HasTimer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HasTimer |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			m.Model = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Model |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SluitemType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SluitemData_LightData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Light_data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Light_data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voltage", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Voltage = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Current", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Current = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivePower", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ActivePower = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReactivePower", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ReactivePower = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApparentPower", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ApparentPower = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Electricity", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Electricity = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveTime", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ActiveTime = float64(math.Float64frombits(v))
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LightStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsgNb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsgNb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LightStatus == nil {
				m.LightStatus = &SluitemData_LightStatus{}
			}
			if err := m.LightStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PowerLevel", wireType)
			}
			m.PowerLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PowerLevel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemPowerTurnon", wireType)
			}
			m.SluitemPowerTurnon = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemPowerTurnon |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RatedPower", wireType)
			}
			m.RatedPower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RatedPower |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SluitemData_LightStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Light_status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Light_status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leakage", wireType)
			}
			m.Leakage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Leakage |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fault", wireType)
			}
			m.Fault = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fault |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkingOn", wireType)
			}
			m.WorkingOn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkingOn |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SluitemData_SluitemStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sluitem_status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sluitem_status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlashFault", wireType)
			}
			m.FlashFault = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FlashFault |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableAlarm", wireType)
			}
			m.EnableAlarm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EnableAlarm |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SluitemData_TimeFault) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Time_fault: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Time_fault: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClockFault", wireType)
			}
			m.ClockFault = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClockFault |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClockOutFault", wireType)
			}
			m.ClockOutFault = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClockOutFault |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClockOutAlarm", wireType)
			}
			m.ClockOutAlarm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClockOutAlarm |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SluitemData_SluitemPara) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sluitem_para: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sluitem_para: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longitude", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Longitude = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latitude", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Latitude = float64(math.Float64frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasEnableAlarm", wireType)
			}
			m.HasEnableAlarm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HasEnableAlarm |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRunning", wireType)
			}
			m.IsRunning = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsRunning |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlarmInterval", wireType)
			}
			m.AlarmInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlarmInterval |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UplinkReply", wireType)
			}
			m.UplinkReply = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UplinkReply |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsgNb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsgNb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMsgNb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMsgNb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMsgNb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMsgNb
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthMsgNb
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMsgNb
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMsgNb(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthMsgNb
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMsgNb = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMsgNb   = fmt.Errorf("proto: integer overflow")
)
