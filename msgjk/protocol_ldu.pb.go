// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: protocol_ldu.proto

package wlst_pb2

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

//Wlst_ldu_5b00_c900_4a01_ca01_4d01_4d02_cd02_4d03_cd03
type WlstLdu_2600 struct {
	//回路标识，二进制转十进制
	LoopMark int32 `protobuf:"varint,1,opt,name=loop_mark,json=loopMark,proto3" json:"loop_mark,omitempty"`
}

func (m *WlstLdu_2600) Reset()      { *m = WlstLdu_2600{} }
func (*WlstLdu_2600) ProtoMessage() {}
func (*WlstLdu_2600) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd0100c6a8148d48, []int{0}
}
func (m *WlstLdu_2600) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstLdu_2600) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstLdu_2600.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstLdu_2600) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstLdu_2600.Merge(m, src)
}
func (m *WlstLdu_2600) XXX_Size() int {
	return m.Size()
}
func (m *WlstLdu_2600) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstLdu_2600.DiscardUnknown(m)
}

var xxx_messageInfo_WlstLdu_2600 proto.InternalMessageInfo

func (m *WlstLdu_2600) GetLoopMark() int32 {
	if m != nil {
		return m.LoopMark
	}
	return 0
}

type WlstLduA600 struct {
	//回路标识，二进制转十进制
	LoopMark    int32                      `protobuf:"varint,1,opt,name=loop_mark,json=loopMark,proto3" json:"loop_mark,omitempty"`
	LduLoopData []*WlstLduA600_LduLoopData `protobuf:"bytes,2,rep,name=ldu_loop_data,json=lduLoopData,proto3" json:"ldu_loop_data,omitempty"`
}

func (m *WlstLduA600) Reset()      { *m = WlstLduA600{} }
func (*WlstLduA600) ProtoMessage() {}
func (*WlstLduA600) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd0100c6a8148d48, []int{1}
}
func (m *WlstLduA600) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstLduA600) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstLduA600.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstLduA600) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstLduA600.Merge(m, src)
}
func (m *WlstLduA600) XXX_Size() int {
	return m.Size()
}
func (m *WlstLduA600) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstLduA600.DiscardUnknown(m)
}

var xxx_messageInfo_WlstLduA600 proto.InternalMessageInfo

func (m *WlstLduA600) GetLoopMark() int32 {
	if m != nil {
		return m.LoopMark
	}
	return 0
}

func (m *WlstLduA600) GetLduLoopData() []*WlstLduA600_LduLoopData {
	if m != nil {
		return m.LduLoopData
	}
	return nil
}

type WlstLduA600_LduLoopData struct {
	//回路x电压
	XVoltage float64 `protobuf:"fixed64,2,opt,name=x_voltage,json=xVoltage,proto3" json:"x_voltage,omitempty"`
	//回路x电流
	XCurrent float64 `protobuf:"fixed64,3,opt,name=x_current,json=xCurrent,proto3" json:"x_current,omitempty"`
	//回路x有功功率
	XActivePower float64 `protobuf:"fixed64,4,opt,name=x_active_power,json=xActivePower,proto3" json:"x_active_power,omitempty"`
	//回路x无功功率
	XReactivePower float64 `protobuf:"fixed64,5,opt,name=x_reactive_power,json=xReactivePower,proto3" json:"x_reactive_power,omitempty"`
	//回路x功率因数
	XPowerFactor float64 `protobuf:"fixed64,6,opt,name=x_power_factor,json=xPowerFactor,proto3" json:"x_power_factor,omitempty"`
	//回路x亮灯率
	XLightingRate float64 `protobuf:"fixed64,7,opt,name=x_lighting_rate,json=xLightingRate,proto3" json:"x_lighting_rate,omitempty"`
	//回路x信号强度
	XSignalStrength int32 `protobuf:"varint,8,opt,name=x_signal_strength,json=xSignalStrength,proto3" json:"x_signal_strength,omitempty"`
	//回路x阻抗
	XImpedance int32 `protobuf:"varint,9,opt,name=x_impedance,json=xImpedance,proto3" json:"x_impedance,omitempty"`
	//回路x 12s有用信号数量
	XUsefulSignal int32 `protobuf:"varint,10,opt,name=x_useful_signal,json=xUsefulSignal,proto3" json:"x_useful_signal,omitempty"`
	//回路x 12s信号数量
	XAllSignal int32 `protobuf:"varint,11,opt,name=x_all_signal,json=xAllSignal,proto3" json:"x_all_signal,omitempty"`
	//回路x检测标识
	XDetectionFlag int32 `protobuf:"varint,12,opt,name=x_detection_flag,json=xDetectionFlag,proto3" json:"x_detection_flag,omitempty"`
	//回路x报警标识
	XAlarmFlag int32 `protobuf:"varint,13,opt,name=x_alarm_flag,json=xAlarmFlag,proto3" json:"x_alarm_flag,omitempty"`
}

func (m *WlstLduA600_LduLoopData) Reset()      { *m = WlstLduA600_LduLoopData{} }
func (*WlstLduA600_LduLoopData) ProtoMessage() {}
func (*WlstLduA600_LduLoopData) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd0100c6a8148d48, []int{1, 0}
}
func (m *WlstLduA600_LduLoopData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstLduA600_LduLoopData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstLduA600_LduLoopData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstLduA600_LduLoopData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstLduA600_LduLoopData.Merge(m, src)
}
func (m *WlstLduA600_LduLoopData) XXX_Size() int {
	return m.Size()
}
func (m *WlstLduA600_LduLoopData) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstLduA600_LduLoopData.DiscardUnknown(m)
}

var xxx_messageInfo_WlstLduA600_LduLoopData proto.InternalMessageInfo

func (m *WlstLduA600_LduLoopData) GetXVoltage() float64 {
	if m != nil {
		return m.XVoltage
	}
	return 0
}

func (m *WlstLduA600_LduLoopData) GetXCurrent() float64 {
	if m != nil {
		return m.XCurrent
	}
	return 0
}

func (m *WlstLduA600_LduLoopData) GetXActivePower() float64 {
	if m != nil {
		return m.XActivePower
	}
	return 0
}

func (m *WlstLduA600_LduLoopData) GetXReactivePower() float64 {
	if m != nil {
		return m.XReactivePower
	}
	return 0
}

func (m *WlstLduA600_LduLoopData) GetXPowerFactor() float64 {
	if m != nil {
		return m.XPowerFactor
	}
	return 0
}

func (m *WlstLduA600_LduLoopData) GetXLightingRate() float64 {
	if m != nil {
		return m.XLightingRate
	}
	return 0
}

func (m *WlstLduA600_LduLoopData) GetXSignalStrength() int32 {
	if m != nil {
		return m.XSignalStrength
	}
	return 0
}

func (m *WlstLduA600_LduLoopData) GetXImpedance() int32 {
	if m != nil {
		return m.XImpedance
	}
	return 0
}

func (m *WlstLduA600_LduLoopData) GetXUsefulSignal() int32 {
	if m != nil {
		return m.XUsefulSignal
	}
	return 0
}

func (m *WlstLduA600_LduLoopData) GetXAllSignal() int32 {
	if m != nil {
		return m.XAllSignal
	}
	return 0
}

func (m *WlstLduA600_LduLoopData) GetXDetectionFlag() int32 {
	if m != nil {
		return m.XDetectionFlag
	}
	return 0
}

func (m *WlstLduA600_LduLoopData) GetXAlarmFlag() int32 {
	if m != nil {
		return m.XAlarmFlag
	}
	return 0
}

//Wlst_ldu_db00
type WlstLdu_4900 struct {
	//回路标识，二进制转十进制
	LoopMark    int32                       `protobuf:"varint,1,opt,name=loop_mark,json=loopMark,proto3" json:"loop_mark,omitempty"`
	LduLoopArgv []*WlstLdu_4900_LduLoopArgv `protobuf:"bytes,2,rep,name=ldu_loop_argv,json=lduLoopArgv,proto3" json:"ldu_loop_argv,omitempty"`
}

func (m *WlstLdu_4900) Reset()      { *m = WlstLdu_4900{} }
func (*WlstLdu_4900) ProtoMessage() {}
func (*WlstLdu_4900) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd0100c6a8148d48, []int{2}
}
func (m *WlstLdu_4900) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstLdu_4900) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstLdu_4900.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstLdu_4900) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstLdu_4900.Merge(m, src)
}
func (m *WlstLdu_4900) XXX_Size() int {
	return m.Size()
}
func (m *WlstLdu_4900) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstLdu_4900.DiscardUnknown(m)
}

var xxx_messageInfo_WlstLdu_4900 proto.InternalMessageInfo

func (m *WlstLdu_4900) GetLoopMark() int32 {
	if m != nil {
		return m.LoopMark
	}
	return 0
}

func (m *WlstLdu_4900) GetLduLoopArgv() []*WlstLdu_4900_LduLoopArgv {
	if m != nil {
		return m.LduLoopArgv
	}
	return nil
}

type WlstLdu_4900_LduLoopArgv struct {
	//回路x检测标识
	XDetectionFlag int32 `protobuf:"varint,2,opt,name=x_detection_flag,json=xDetectionFlag,proto3" json:"x_detection_flag,omitempty"`
	//回路x互感器比值
	XTransformer int32 `protobuf:"varint,3,opt,name=x_transformer,json=xTransformer,proto3" json:"x_transformer,omitempty"`
	//回路x相位
	XPhase int32 `protobuf:"varint,4,opt,name=x_phase,json=xPhase,proto3" json:"x_phase,omitempty"`
	//回路x开灯信号强度门限
	XOnSignalStrength int32 `protobuf:"varint,5,opt,name=x_on_signal_strength,json=xOnSignalStrength,proto3" json:"x_on_signal_strength,omitempty"`
	//回路x开灯阻抗报警门限
	XOnImpedanceAlarm int32 `protobuf:"varint,6,opt,name=x_on_impedance_alarm,json=xOnImpedanceAlarm,proto3" json:"x_on_impedance_alarm,omitempty"`
	//回路x亮灯率信号门限
	XLightingRate int32 `protobuf:"varint,7,opt,name=x_lighting_rate,json=xLightingRate,proto3" json:"x_lighting_rate,omitempty"`
	//回路x关灯信号强度门限
	XOffSignalStrength int32 `protobuf:"varint,8,opt,name=x_off_signal_strength,json=xOffSignalStrength,proto3" json:"x_off_signal_strength,omitempty"`
	//回路x关灯阻抗报警门限
	XOffImpedanceAlarm int32 `protobuf:"varint,9,opt,name=x_off_impedance_alarm,json=xOffImpedanceAlarm,proto3" json:"x_off_impedance_alarm,omitempty"`
	//回路x末端灯杆
	XPoleNo int32 `protobuf:"varint,10,opt,name=x_pole_no,json=xPoleNo,proto3" json:"x_pole_no,omitempty"`
}

func (m *WlstLdu_4900_LduLoopArgv) Reset()      { *m = WlstLdu_4900_LduLoopArgv{} }
func (*WlstLdu_4900_LduLoopArgv) ProtoMessage() {}
func (*WlstLdu_4900_LduLoopArgv) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd0100c6a8148d48, []int{2, 0}
}
func (m *WlstLdu_4900_LduLoopArgv) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstLdu_4900_LduLoopArgv) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstLdu_4900_LduLoopArgv.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstLdu_4900_LduLoopArgv) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstLdu_4900_LduLoopArgv.Merge(m, src)
}
func (m *WlstLdu_4900_LduLoopArgv) XXX_Size() int {
	return m.Size()
}
func (m *WlstLdu_4900_LduLoopArgv) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstLdu_4900_LduLoopArgv.DiscardUnknown(m)
}

var xxx_messageInfo_WlstLdu_4900_LduLoopArgv proto.InternalMessageInfo

func (m *WlstLdu_4900_LduLoopArgv) GetXDetectionFlag() int32 {
	if m != nil {
		return m.XDetectionFlag
	}
	return 0
}

func (m *WlstLdu_4900_LduLoopArgv) GetXTransformer() int32 {
	if m != nil {
		return m.XTransformer
	}
	return 0
}

func (m *WlstLdu_4900_LduLoopArgv) GetXPhase() int32 {
	if m != nil {
		return m.XPhase
	}
	return 0
}

func (m *WlstLdu_4900_LduLoopArgv) GetXOnSignalStrength() int32 {
	if m != nil {
		return m.XOnSignalStrength
	}
	return 0
}

func (m *WlstLdu_4900_LduLoopArgv) GetXOnImpedanceAlarm() int32 {
	if m != nil {
		return m.XOnImpedanceAlarm
	}
	return 0
}

func (m *WlstLdu_4900_LduLoopArgv) GetXLightingRate() int32 {
	if m != nil {
		return m.XLightingRate
	}
	return 0
}

func (m *WlstLdu_4900_LduLoopArgv) GetXOffSignalStrength() int32 {
	if m != nil {
		return m.XOffSignalStrength
	}
	return 0
}

func (m *WlstLdu_4900_LduLoopArgv) GetXOffImpedanceAlarm() int32 {
	if m != nil {
		return m.XOffImpedanceAlarm
	}
	return 0
}

func (m *WlstLdu_4900_LduLoopArgv) GetXPoleNo() int32 {
	if m != nil {
		return m.XPoleNo
	}
	return 0
}

type WlstLduCd01 struct {
	//回路标识，二进制转十进制
	LoopMark int32 `protobuf:"varint,1,opt,name=loop_mark,json=loopMark,proto3" json:"loop_mark,omitempty"`
	//回路x阻抗基准
	XImpedance []int32 `protobuf:"varint,2,rep,packed,name=x_impedance,json=xImpedance,proto3" json:"x_impedance,omitempty"`
}

func (m *WlstLduCd01) Reset()      { *m = WlstLduCd01{} }
func (*WlstLduCd01) ProtoMessage() {}
func (*WlstLduCd01) Descriptor() ([]byte, []int) {
	return fileDescriptor_dd0100c6a8148d48, []int{3}
}
func (m *WlstLduCd01) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstLduCd01) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstLduCd01.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstLduCd01) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstLduCd01.Merge(m, src)
}
func (m *WlstLduCd01) XXX_Size() int {
	return m.Size()
}
func (m *WlstLduCd01) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstLduCd01.DiscardUnknown(m)
}

var xxx_messageInfo_WlstLduCd01 proto.InternalMessageInfo

func (m *WlstLduCd01) GetLoopMark() int32 {
	if m != nil {
		return m.LoopMark
	}
	return 0
}

func (m *WlstLduCd01) GetXImpedance() []int32 {
	if m != nil {
		return m.XImpedance
	}
	return nil
}

func init() {
	proto.RegisterType((*WlstLdu_2600)(nil), "wlst.pb2.Wlst_ldu_2600")
	proto.RegisterType((*WlstLduA600)(nil), "wlst.pb2.Wlst_ldu_a600")
	proto.RegisterType((*WlstLduA600_LduLoopData)(nil), "wlst.pb2.Wlst_ldu_a600.LduLoopData")
	proto.RegisterType((*WlstLdu_4900)(nil), "wlst.pb2.Wlst_ldu_4900")
	proto.RegisterType((*WlstLdu_4900_LduLoopArgv)(nil), "wlst.pb2.Wlst_ldu_4900.LduLoopArgv")
	proto.RegisterType((*WlstLduCd01)(nil), "wlst.pb2.Wlst_ldu_cd01")
}

func init() { proto.RegisterFile("protocol_ldu.proto", fileDescriptor_dd0100c6a8148d48) }

var fileDescriptor_dd0100c6a8148d48 = []byte{
	// 646 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x94, 0x4d, 0x4f, 0x13, 0x41,
	0x18, 0xc7, 0x3b, 0x2d, 0x0b, 0x65, 0xda, 0xf2, 0x32, 0xd1, 0xb8, 0xc1, 0x64, 0x6c, 0x8a, 0x31,
	0x8d, 0x31, 0x15, 0xd0, 0x90, 0x78, 0x04, 0x09, 0x6a, 0x82, 0x82, 0x8b, 0x2f, 0xc7, 0xc9, 0xb0,
	0x9d, 0x5d, 0x1a, 0xa6, 0x3b, 0x9b, 0xd9, 0x69, 0x99, 0xa3, 0x7e, 0x03, 0x3f, 0x86, 0x1f, 0xc3,
	0x23, 0x47, 0x8e, 0x1c, 0x65, 0xb9, 0x78, 0xe4, 0xea, 0xcd, 0xec, 0xec, 0x4b, 0x4b, 0x05, 0x8c,
	0xc7, 0xe7, 0xff, 0xfc, 0xe6, 0x3f, 0xb3, 0xcf, 0xf3, 0x6f, 0x21, 0x0a, 0xa5, 0x50, 0xc2, 0x15,
	0x9c, 0xf0, 0xee, 0xa0, 0x63, 0x0a, 0x54, 0x3d, 0xe6, 0x91, 0xea, 0x84, 0x07, 0x6b, 0xad, 0x27,
	0xb0, 0xf1, 0x99, 0x47, 0x2a, 0xe9, 0x91, 0xb5, 0xf5, 0x95, 0x15, 0x74, 0x1f, 0xce, 0x72, 0x21,
	0x42, 0xd2, 0xa7, 0xf2, 0xc8, 0x06, 0x4d, 0xd0, 0xb6, 0x9c, 0x6a, 0x22, 0xbc, 0xa5, 0xf2, 0xa8,
	0xf5, 0x63, 0x6a, 0x0c, 0xa7, 0xff, 0xc2, 0xd1, 0x2b, 0xd8, 0x48, 0x40, 0x03, 0x74, 0xa9, 0xa2,
	0x76, 0xb9, 0x59, 0x69, 0xd7, 0xd6, 0x96, 0x3b, 0xf9, 0xf5, 0x9d, 0x2b, 0x66, 0x9d, 0x9d, 0xee,
	0x60, 0x47, 0x88, 0x70, 0x8b, 0x2a, 0xea, 0xd4, 0xf8, 0xa8, 0x58, 0x3a, 0xa9, 0xc0, 0xda, 0x58,
	0x33, 0xb9, 0x55, 0x93, 0xa1, 0xe0, 0x8a, 0xfa, 0xcc, 0x2e, 0x37, 0x41, 0x1b, 0x38, 0x55, 0xfd,
	0x29, 0xad, 0xd3, 0xa6, 0x3b, 0x90, 0x92, 0x05, 0xca, 0xae, 0x64, 0xcd, 0x97, 0x69, 0x8d, 0x1e,
	0xc2, 0x39, 0x4d, 0xa8, 0xab, 0x7a, 0x43, 0x46, 0x42, 0x71, 0xcc, 0xa4, 0x3d, 0x65, 0x88, 0xba,
	0xde, 0x30, 0xe2, 0x5e, 0xa2, 0xa1, 0x36, 0x5c, 0xd0, 0x44, 0xb2, 0x2b, 0x9c, 0x65, 0xb8, 0x39,
	0xed, 0x64, 0x72, 0x4a, 0x1a, 0x3f, 0x03, 0x10, 0x8f, 0xba, 0x4a, 0x48, 0x7b, 0x3a, 0xf3, 0x33,
	0xfd, 0x6d, 0xa3, 0xa1, 0x47, 0x70, 0x5e, 0x13, 0xde, 0xf3, 0x0f, 0x55, 0x2f, 0xf0, 0x89, 0xa4,
	0x8a, 0xd9, 0x33, 0x06, 0x6b, 0xe8, 0x9d, 0x4c, 0x75, 0xa8, 0x62, 0xe8, 0x31, 0x5c, 0xd4, 0x24,
	0xea, 0xf9, 0x01, 0xe5, 0x24, 0x52, 0x92, 0x05, 0xbe, 0x3a, 0xb4, 0xab, 0x66, 0xaa, 0xf3, 0x7a,
	0xdf, 0xe8, 0xfb, 0x99, 0x8c, 0x1e, 0xc0, 0x9a, 0x26, 0xbd, 0x7e, 0xc8, 0xba, 0x34, 0x70, 0x99,
	0x3d, 0x6b, 0x28, 0xa8, 0xdf, 0xe4, 0x4a, 0x7a, 0xe9, 0x20, 0x62, 0xde, 0x80, 0x67, 0x9e, 0x36,
	0x34, 0x50, 0x43, 0x7f, 0x34, 0x6a, 0x6a, 0x88, 0x9a, 0xb0, 0xae, 0x09, 0xe5, 0x05, 0x54, 0xcb,
	0x9c, 0x36, 0x78, 0x4e, 0x98, 0x71, 0x74, 0x99, 0x62, 0xae, 0xea, 0x89, 0x80, 0x78, 0x9c, 0xfa,
	0x76, 0xdd, 0x50, 0x73, 0x7a, 0x2b, 0x97, 0xb7, 0x39, 0xf5, 0x73, 0x2f, 0x2a, 0xfb, 0x29, 0xd5,
	0x28, 0xbc, 0xa8, 0xec, 0x27, 0x44, 0xeb, 0x77, 0x65, 0x2c, 0x42, 0xcf, 0x5f, 0xfc, 0x4f, 0x84,
	0xa8, 0xf4, 0x87, 0xb7, 0x44, 0x28, 0x31, 0xcb, 0x23, 0xb4, 0x21, 0xfd, 0x61, 0x11, 0xa1, 0xa4,
	0x58, 0xfa, 0x3a, 0x8a, 0x50, 0x52, 0x5f, 0xfb, 0x4d, 0xe5, 0x6b, 0xbf, 0x69, 0x19, 0x36, 0x34,
	0x51, 0x92, 0x06, 0x91, 0x27, 0x64, 0x9f, 0x49, 0x93, 0x29, 0xcb, 0xa9, 0xeb, 0x0f, 0x23, 0x0d,
	0xdd, 0x83, 0x33, 0x9a, 0x84, 0x87, 0x34, 0x62, 0x26, 0x50, 0x96, 0x33, 0xad, 0xf7, 0x92, 0x0a,
	0x3d, 0x85, 0x77, 0x34, 0x11, 0xc1, 0x5f, 0x5b, 0xb5, 0x0c, 0xb5, 0xa8, 0x77, 0x83, 0x89, 0xbd,
	0xe6, 0x07, 0x8a, 0xd5, 0xa6, 0xf3, 0x34, 0xb9, 0x4a, 0x0f, 0x14, 0x2b, 0x36, 0x53, 0xbd, 0x29,
	0x5c, 0xd6, 0x64, 0xb8, 0x56, 0xe1, 0x5d, 0x4d, 0x84, 0xe7, 0xdd, 0x10, 0x30, 0xa4, 0x77, 0x3d,
	0x6f, 0xe2, 0x2d, 0xc5, 0x91, 0xc9, 0xc7, 0xcc, 0x8e, 0x8e, 0x4c, 0xbc, 0x66, 0x29, 0xf9, 0xf5,
	0x85, 0x82, 0x33, 0x12, 0x88, 0x2c, 0x6f, 0x33, 0x7a, 0x4f, 0x70, 0xf6, 0x4e, 0xb4, 0xde, 0x8f,
	0xad, 0xde, 0xed, 0xae, 0xac, 0xde, 0xbe, 0xfa, 0xe5, 0xab, 0x01, 0x4f, 0x16, 0x6f, 0x6d, 0x96,
	0x17, 0xc0, 0x78, 0xc8, 0x37, 0xd7, 0x4f, 0xcf, 0x71, 0xe9, 0xec, 0x1c, 0x97, 0x2e, 0xcf, 0x31,
	0xf8, 0x12, 0x63, 0xf0, 0x3d, 0xc6, 0xe0, 0x24, 0xc6, 0xe0, 0x34, 0xc6, 0xe0, 0x67, 0x8c, 0xc1,
	0xaf, 0x18, 0x97, 0x2e, 0x63, 0x0c, 0xbe, 0x5d, 0xe0, 0xd2, 0xe9, 0x05, 0x2e, 0x9d, 0x5d, 0xe0,
	0xd2, 0x6b, 0x70, 0x30, 0x6d, 0xfe, 0x08, 0x9f, 0xfd, 0x09, 0x00, 0x00, 0xff, 0xff, 0xd5, 0x6a,
	0xec, 0x96, 0x1e, 0x05, 0x00, 0x00,
}

func (this *WlstLdu_2600) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstLdu_2600)
	if !ok {
		that2, ok := that.(WlstLdu_2600)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.LoopMark != that1.LoopMark {
		return false
	}
	return true
}
func (this *WlstLduA600) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstLduA600)
	if !ok {
		that2, ok := that.(WlstLduA600)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.LoopMark != that1.LoopMark {
		return false
	}
	if len(this.LduLoopData) != len(that1.LduLoopData) {
		return false
	}
	for i := range this.LduLoopData {
		if !this.LduLoopData[i].Equal(that1.LduLoopData[i]) {
			return false
		}
	}
	return true
}
func (this *WlstLduA600_LduLoopData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstLduA600_LduLoopData)
	if !ok {
		that2, ok := that.(WlstLduA600_LduLoopData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.XVoltage != that1.XVoltage {
		return false
	}
	if this.XCurrent != that1.XCurrent {
		return false
	}
	if this.XActivePower != that1.XActivePower {
		return false
	}
	if this.XReactivePower != that1.XReactivePower {
		return false
	}
	if this.XPowerFactor != that1.XPowerFactor {
		return false
	}
	if this.XLightingRate != that1.XLightingRate {
		return false
	}
	if this.XSignalStrength != that1.XSignalStrength {
		return false
	}
	if this.XImpedance != that1.XImpedance {
		return false
	}
	if this.XUsefulSignal != that1.XUsefulSignal {
		return false
	}
	if this.XAllSignal != that1.XAllSignal {
		return false
	}
	if this.XDetectionFlag != that1.XDetectionFlag {
		return false
	}
	if this.XAlarmFlag != that1.XAlarmFlag {
		return false
	}
	return true
}
func (this *WlstLdu_4900) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstLdu_4900)
	if !ok {
		that2, ok := that.(WlstLdu_4900)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.LoopMark != that1.LoopMark {
		return false
	}
	if len(this.LduLoopArgv) != len(that1.LduLoopArgv) {
		return false
	}
	for i := range this.LduLoopArgv {
		if !this.LduLoopArgv[i].Equal(that1.LduLoopArgv[i]) {
			return false
		}
	}
	return true
}
func (this *WlstLdu_4900_LduLoopArgv) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstLdu_4900_LduLoopArgv)
	if !ok {
		that2, ok := that.(WlstLdu_4900_LduLoopArgv)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.XDetectionFlag != that1.XDetectionFlag {
		return false
	}
	if this.XTransformer != that1.XTransformer {
		return false
	}
	if this.XPhase != that1.XPhase {
		return false
	}
	if this.XOnSignalStrength != that1.XOnSignalStrength {
		return false
	}
	if this.XOnImpedanceAlarm != that1.XOnImpedanceAlarm {
		return false
	}
	if this.XLightingRate != that1.XLightingRate {
		return false
	}
	if this.XOffSignalStrength != that1.XOffSignalStrength {
		return false
	}
	if this.XOffImpedanceAlarm != that1.XOffImpedanceAlarm {
		return false
	}
	if this.XPoleNo != that1.XPoleNo {
		return false
	}
	return true
}
func (this *WlstLduCd01) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstLduCd01)
	if !ok {
		that2, ok := that.(WlstLduCd01)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.LoopMark != that1.LoopMark {
		return false
	}
	if len(this.XImpedance) != len(that1.XImpedance) {
		return false
	}
	for i := range this.XImpedance {
		if this.XImpedance[i] != that1.XImpedance[i] {
			return false
		}
	}
	return true
}
func (this *WlstLdu_2600) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&wlst_pb2.WlstLdu_2600{")
	s = append(s, "LoopMark: "+fmt.Sprintf("%#v", this.LoopMark)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstLduA600) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&wlst_pb2.WlstLduA600{")
	s = append(s, "LoopMark: "+fmt.Sprintf("%#v", this.LoopMark)+",\n")
	if this.LduLoopData != nil {
		s = append(s, "LduLoopData: "+fmt.Sprintf("%#v", this.LduLoopData)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstLduA600_LduLoopData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 16)
	s = append(s, "&wlst_pb2.WlstLduA600_LduLoopData{")
	s = append(s, "XVoltage: "+fmt.Sprintf("%#v", this.XVoltage)+",\n")
	s = append(s, "XCurrent: "+fmt.Sprintf("%#v", this.XCurrent)+",\n")
	s = append(s, "XActivePower: "+fmt.Sprintf("%#v", this.XActivePower)+",\n")
	s = append(s, "XReactivePower: "+fmt.Sprintf("%#v", this.XReactivePower)+",\n")
	s = append(s, "XPowerFactor: "+fmt.Sprintf("%#v", this.XPowerFactor)+",\n")
	s = append(s, "XLightingRate: "+fmt.Sprintf("%#v", this.XLightingRate)+",\n")
	s = append(s, "XSignalStrength: "+fmt.Sprintf("%#v", this.XSignalStrength)+",\n")
	s = append(s, "XImpedance: "+fmt.Sprintf("%#v", this.XImpedance)+",\n")
	s = append(s, "XUsefulSignal: "+fmt.Sprintf("%#v", this.XUsefulSignal)+",\n")
	s = append(s, "XAllSignal: "+fmt.Sprintf("%#v", this.XAllSignal)+",\n")
	s = append(s, "XDetectionFlag: "+fmt.Sprintf("%#v", this.XDetectionFlag)+",\n")
	s = append(s, "XAlarmFlag: "+fmt.Sprintf("%#v", this.XAlarmFlag)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstLdu_4900) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&wlst_pb2.WlstLdu_4900{")
	s = append(s, "LoopMark: "+fmt.Sprintf("%#v", this.LoopMark)+",\n")
	if this.LduLoopArgv != nil {
		s = append(s, "LduLoopArgv: "+fmt.Sprintf("%#v", this.LduLoopArgv)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstLdu_4900_LduLoopArgv) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&wlst_pb2.WlstLdu_4900_LduLoopArgv{")
	s = append(s, "XDetectionFlag: "+fmt.Sprintf("%#v", this.XDetectionFlag)+",\n")
	s = append(s, "XTransformer: "+fmt.Sprintf("%#v", this.XTransformer)+",\n")
	s = append(s, "XPhase: "+fmt.Sprintf("%#v", this.XPhase)+",\n")
	s = append(s, "XOnSignalStrength: "+fmt.Sprintf("%#v", this.XOnSignalStrength)+",\n")
	s = append(s, "XOnImpedanceAlarm: "+fmt.Sprintf("%#v", this.XOnImpedanceAlarm)+",\n")
	s = append(s, "XLightingRate: "+fmt.Sprintf("%#v", this.XLightingRate)+",\n")
	s = append(s, "XOffSignalStrength: "+fmt.Sprintf("%#v", this.XOffSignalStrength)+",\n")
	s = append(s, "XOffImpedanceAlarm: "+fmt.Sprintf("%#v", this.XOffImpedanceAlarm)+",\n")
	s = append(s, "XPoleNo: "+fmt.Sprintf("%#v", this.XPoleNo)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstLduCd01) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&wlst_pb2.WlstLduCd01{")
	s = append(s, "LoopMark: "+fmt.Sprintf("%#v", this.LoopMark)+",\n")
	s = append(s, "XImpedance: "+fmt.Sprintf("%#v", this.XImpedance)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringProtocolLdu(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *WlstLdu_2600) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstLdu_2600) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstLdu_2600) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LoopMark != 0 {
		i = encodeVarintProtocolLdu(dAtA, i, uint64(m.LoopMark))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstLduA600) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstLduA600) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstLduA600) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LduLoopData) > 0 {
		for iNdEx := len(m.LduLoopData) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LduLoopData[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProtocolLdu(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.LoopMark != 0 {
		i = encodeVarintProtocolLdu(dAtA, i, uint64(m.LoopMark))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstLduA600_LduLoopData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstLduA600_LduLoopData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstLduA600_LduLoopData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XAlarmFlag != 0 {
		i = encodeVarintProtocolLdu(dAtA, i, uint64(m.XAlarmFlag))
		i--
		dAtA[i] = 0x68
	}
	if m.XDetectionFlag != 0 {
		i = encodeVarintProtocolLdu(dAtA, i, uint64(m.XDetectionFlag))
		i--
		dAtA[i] = 0x60
	}
	if m.XAllSignal != 0 {
		i = encodeVarintProtocolLdu(dAtA, i, uint64(m.XAllSignal))
		i--
		dAtA[i] = 0x58
	}
	if m.XUsefulSignal != 0 {
		i = encodeVarintProtocolLdu(dAtA, i, uint64(m.XUsefulSignal))
		i--
		dAtA[i] = 0x50
	}
	if m.XImpedance != 0 {
		i = encodeVarintProtocolLdu(dAtA, i, uint64(m.XImpedance))
		i--
		dAtA[i] = 0x48
	}
	if m.XSignalStrength != 0 {
		i = encodeVarintProtocolLdu(dAtA, i, uint64(m.XSignalStrength))
		i--
		dAtA[i] = 0x40
	}
	if m.XLightingRate != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.XLightingRate))))
		i--
		dAtA[i] = 0x39
	}
	if m.XPowerFactor != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.XPowerFactor))))
		i--
		dAtA[i] = 0x31
	}
	if m.XReactivePower != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.XReactivePower))))
		i--
		dAtA[i] = 0x29
	}
	if m.XActivePower != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.XActivePower))))
		i--
		dAtA[i] = 0x21
	}
	if m.XCurrent != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.XCurrent))))
		i--
		dAtA[i] = 0x19
	}
	if m.XVoltage != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.XVoltage))))
		i--
		dAtA[i] = 0x11
	}
	return len(dAtA) - i, nil
}

func (m *WlstLdu_4900) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstLdu_4900) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstLdu_4900) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LduLoopArgv) > 0 {
		for iNdEx := len(m.LduLoopArgv) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LduLoopArgv[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProtocolLdu(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.LoopMark != 0 {
		i = encodeVarintProtocolLdu(dAtA, i, uint64(m.LoopMark))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstLdu_4900_LduLoopArgv) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstLdu_4900_LduLoopArgv) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstLdu_4900_LduLoopArgv) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XPoleNo != 0 {
		i = encodeVarintProtocolLdu(dAtA, i, uint64(m.XPoleNo))
		i--
		dAtA[i] = 0x50
	}
	if m.XOffImpedanceAlarm != 0 {
		i = encodeVarintProtocolLdu(dAtA, i, uint64(m.XOffImpedanceAlarm))
		i--
		dAtA[i] = 0x48
	}
	if m.XOffSignalStrength != 0 {
		i = encodeVarintProtocolLdu(dAtA, i, uint64(m.XOffSignalStrength))
		i--
		dAtA[i] = 0x40
	}
	if m.XLightingRate != 0 {
		i = encodeVarintProtocolLdu(dAtA, i, uint64(m.XLightingRate))
		i--
		dAtA[i] = 0x38
	}
	if m.XOnImpedanceAlarm != 0 {
		i = encodeVarintProtocolLdu(dAtA, i, uint64(m.XOnImpedanceAlarm))
		i--
		dAtA[i] = 0x30
	}
	if m.XOnSignalStrength != 0 {
		i = encodeVarintProtocolLdu(dAtA, i, uint64(m.XOnSignalStrength))
		i--
		dAtA[i] = 0x28
	}
	if m.XPhase != 0 {
		i = encodeVarintProtocolLdu(dAtA, i, uint64(m.XPhase))
		i--
		dAtA[i] = 0x20
	}
	if m.XTransformer != 0 {
		i = encodeVarintProtocolLdu(dAtA, i, uint64(m.XTransformer))
		i--
		dAtA[i] = 0x18
	}
	if m.XDetectionFlag != 0 {
		i = encodeVarintProtocolLdu(dAtA, i, uint64(m.XDetectionFlag))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *WlstLduCd01) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstLduCd01) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstLduCd01) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.XImpedance) > 0 {
		dAtA2 := make([]byte, len(m.XImpedance)*10)
		var j1 int
		for _, num1 := range m.XImpedance {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintProtocolLdu(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x12
	}
	if m.LoopMark != 0 {
		i = encodeVarintProtocolLdu(dAtA, i, uint64(m.LoopMark))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintProtocolLdu(dAtA []byte, offset int, v uint64) int {
	offset -= sovProtocolLdu(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *WlstLdu_2600) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LoopMark != 0 {
		n += 1 + sovProtocolLdu(uint64(m.LoopMark))
	}
	return n
}

func (m *WlstLduA600) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LoopMark != 0 {
		n += 1 + sovProtocolLdu(uint64(m.LoopMark))
	}
	if len(m.LduLoopData) > 0 {
		for _, e := range m.LduLoopData {
			l = e.Size()
			n += 1 + l + sovProtocolLdu(uint64(l))
		}
	}
	return n
}

func (m *WlstLduA600_LduLoopData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XVoltage != 0 {
		n += 9
	}
	if m.XCurrent != 0 {
		n += 9
	}
	if m.XActivePower != 0 {
		n += 9
	}
	if m.XReactivePower != 0 {
		n += 9
	}
	if m.XPowerFactor != 0 {
		n += 9
	}
	if m.XLightingRate != 0 {
		n += 9
	}
	if m.XSignalStrength != 0 {
		n += 1 + sovProtocolLdu(uint64(m.XSignalStrength))
	}
	if m.XImpedance != 0 {
		n += 1 + sovProtocolLdu(uint64(m.XImpedance))
	}
	if m.XUsefulSignal != 0 {
		n += 1 + sovProtocolLdu(uint64(m.XUsefulSignal))
	}
	if m.XAllSignal != 0 {
		n += 1 + sovProtocolLdu(uint64(m.XAllSignal))
	}
	if m.XDetectionFlag != 0 {
		n += 1 + sovProtocolLdu(uint64(m.XDetectionFlag))
	}
	if m.XAlarmFlag != 0 {
		n += 1 + sovProtocolLdu(uint64(m.XAlarmFlag))
	}
	return n
}

func (m *WlstLdu_4900) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LoopMark != 0 {
		n += 1 + sovProtocolLdu(uint64(m.LoopMark))
	}
	if len(m.LduLoopArgv) > 0 {
		for _, e := range m.LduLoopArgv {
			l = e.Size()
			n += 1 + l + sovProtocolLdu(uint64(l))
		}
	}
	return n
}

func (m *WlstLdu_4900_LduLoopArgv) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XDetectionFlag != 0 {
		n += 1 + sovProtocolLdu(uint64(m.XDetectionFlag))
	}
	if m.XTransformer != 0 {
		n += 1 + sovProtocolLdu(uint64(m.XTransformer))
	}
	if m.XPhase != 0 {
		n += 1 + sovProtocolLdu(uint64(m.XPhase))
	}
	if m.XOnSignalStrength != 0 {
		n += 1 + sovProtocolLdu(uint64(m.XOnSignalStrength))
	}
	if m.XOnImpedanceAlarm != 0 {
		n += 1 + sovProtocolLdu(uint64(m.XOnImpedanceAlarm))
	}
	if m.XLightingRate != 0 {
		n += 1 + sovProtocolLdu(uint64(m.XLightingRate))
	}
	if m.XOffSignalStrength != 0 {
		n += 1 + sovProtocolLdu(uint64(m.XOffSignalStrength))
	}
	if m.XOffImpedanceAlarm != 0 {
		n += 1 + sovProtocolLdu(uint64(m.XOffImpedanceAlarm))
	}
	if m.XPoleNo != 0 {
		n += 1 + sovProtocolLdu(uint64(m.XPoleNo))
	}
	return n
}

func (m *WlstLduCd01) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LoopMark != 0 {
		n += 1 + sovProtocolLdu(uint64(m.LoopMark))
	}
	if len(m.XImpedance) > 0 {
		l = 0
		for _, e := range m.XImpedance {
			l += sovProtocolLdu(uint64(e))
		}
		n += 1 + sovProtocolLdu(uint64(l)) + l
	}
	return n
}

func sovProtocolLdu(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozProtocolLdu(x uint64) (n int) {
	return sovProtocolLdu(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *WlstLdu_2600) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstLdu_2600{`,
		`LoopMark:` + fmt.Sprintf("%v", this.LoopMark) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstLduA600) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForLduLoopData := "[]*WlstLduA600_LduLoopData{"
	for _, f := range this.LduLoopData {
		repeatedStringForLduLoopData += strings.Replace(fmt.Sprintf("%v", f), "WlstLduA600_LduLoopData", "WlstLduA600_LduLoopData", 1) + ","
	}
	repeatedStringForLduLoopData += "}"
	s := strings.Join([]string{`&WlstLduA600{`,
		`LoopMark:` + fmt.Sprintf("%v", this.LoopMark) + `,`,
		`LduLoopData:` + repeatedStringForLduLoopData + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstLduA600_LduLoopData) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstLduA600_LduLoopData{`,
		`XVoltage:` + fmt.Sprintf("%v", this.XVoltage) + `,`,
		`XCurrent:` + fmt.Sprintf("%v", this.XCurrent) + `,`,
		`XActivePower:` + fmt.Sprintf("%v", this.XActivePower) + `,`,
		`XReactivePower:` + fmt.Sprintf("%v", this.XReactivePower) + `,`,
		`XPowerFactor:` + fmt.Sprintf("%v", this.XPowerFactor) + `,`,
		`XLightingRate:` + fmt.Sprintf("%v", this.XLightingRate) + `,`,
		`XSignalStrength:` + fmt.Sprintf("%v", this.XSignalStrength) + `,`,
		`XImpedance:` + fmt.Sprintf("%v", this.XImpedance) + `,`,
		`XUsefulSignal:` + fmt.Sprintf("%v", this.XUsefulSignal) + `,`,
		`XAllSignal:` + fmt.Sprintf("%v", this.XAllSignal) + `,`,
		`XDetectionFlag:` + fmt.Sprintf("%v", this.XDetectionFlag) + `,`,
		`XAlarmFlag:` + fmt.Sprintf("%v", this.XAlarmFlag) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstLdu_4900) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForLduLoopArgv := "[]*WlstLdu_4900_LduLoopArgv{"
	for _, f := range this.LduLoopArgv {
		repeatedStringForLduLoopArgv += strings.Replace(fmt.Sprintf("%v", f), "WlstLdu_4900_LduLoopArgv", "WlstLdu_4900_LduLoopArgv", 1) + ","
	}
	repeatedStringForLduLoopArgv += "}"
	s := strings.Join([]string{`&WlstLdu_4900{`,
		`LoopMark:` + fmt.Sprintf("%v", this.LoopMark) + `,`,
		`LduLoopArgv:` + repeatedStringForLduLoopArgv + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstLdu_4900_LduLoopArgv) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstLdu_4900_LduLoopArgv{`,
		`XDetectionFlag:` + fmt.Sprintf("%v", this.XDetectionFlag) + `,`,
		`XTransformer:` + fmt.Sprintf("%v", this.XTransformer) + `,`,
		`XPhase:` + fmt.Sprintf("%v", this.XPhase) + `,`,
		`XOnSignalStrength:` + fmt.Sprintf("%v", this.XOnSignalStrength) + `,`,
		`XOnImpedanceAlarm:` + fmt.Sprintf("%v", this.XOnImpedanceAlarm) + `,`,
		`XLightingRate:` + fmt.Sprintf("%v", this.XLightingRate) + `,`,
		`XOffSignalStrength:` + fmt.Sprintf("%v", this.XOffSignalStrength) + `,`,
		`XOffImpedanceAlarm:` + fmt.Sprintf("%v", this.XOffImpedanceAlarm) + `,`,
		`XPoleNo:` + fmt.Sprintf("%v", this.XPoleNo) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstLduCd01) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstLduCd01{`,
		`LoopMark:` + fmt.Sprintf("%v", this.LoopMark) + `,`,
		`XImpedance:` + fmt.Sprintf("%v", this.XImpedance) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringProtocolLdu(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *WlstLdu_2600) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolLdu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_ldu_2600: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_ldu_2600: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoopMark", wireType)
			}
			m.LoopMark = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolLdu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoopMark |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolLdu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolLdu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolLdu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstLduA600) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolLdu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_ldu_a600: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_ldu_a600: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoopMark", wireType)
			}
			m.LoopMark = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolLdu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoopMark |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LduLoopData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolLdu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolLdu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolLdu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LduLoopData = append(m.LduLoopData, &WlstLduA600_LduLoopData{})
			if err := m.LduLoopData[len(m.LduLoopData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolLdu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolLdu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolLdu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstLduA600_LduLoopData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolLdu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LduLoopData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LduLoopData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field XVoltage", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.XVoltage = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field XCurrent", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.XCurrent = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field XActivePower", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.XActivePower = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field XReactivePower", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.XReactivePower = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field XPowerFactor", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.XPowerFactor = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field XLightingRate", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.XLightingRate = float64(math.Float64frombits(v))
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XSignalStrength", wireType)
			}
			m.XSignalStrength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolLdu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.XSignalStrength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XImpedance", wireType)
			}
			m.XImpedance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolLdu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.XImpedance |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XUsefulSignal", wireType)
			}
			m.XUsefulSignal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolLdu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.XUsefulSignal |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XAllSignal", wireType)
			}
			m.XAllSignal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolLdu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.XAllSignal |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XDetectionFlag", wireType)
			}
			m.XDetectionFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolLdu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.XDetectionFlag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XAlarmFlag", wireType)
			}
			m.XAlarmFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolLdu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.XAlarmFlag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolLdu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolLdu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolLdu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstLdu_4900) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolLdu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_ldu_4900: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_ldu_4900: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoopMark", wireType)
			}
			m.LoopMark = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolLdu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoopMark |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LduLoopArgv", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolLdu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolLdu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolLdu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LduLoopArgv = append(m.LduLoopArgv, &WlstLdu_4900_LduLoopArgv{})
			if err := m.LduLoopArgv[len(m.LduLoopArgv)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolLdu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolLdu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolLdu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstLdu_4900_LduLoopArgv) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolLdu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LduLoopArgv: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LduLoopArgv: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XDetectionFlag", wireType)
			}
			m.XDetectionFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolLdu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.XDetectionFlag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XTransformer", wireType)
			}
			m.XTransformer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolLdu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.XTransformer |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XPhase", wireType)
			}
			m.XPhase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolLdu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.XPhase |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XOnSignalStrength", wireType)
			}
			m.XOnSignalStrength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolLdu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.XOnSignalStrength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XOnImpedanceAlarm", wireType)
			}
			m.XOnImpedanceAlarm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolLdu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.XOnImpedanceAlarm |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XLightingRate", wireType)
			}
			m.XLightingRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolLdu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.XLightingRate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XOffSignalStrength", wireType)
			}
			m.XOffSignalStrength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolLdu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.XOffSignalStrength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XOffImpedanceAlarm", wireType)
			}
			m.XOffImpedanceAlarm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolLdu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.XOffImpedanceAlarm |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XPoleNo", wireType)
			}
			m.XPoleNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolLdu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.XPoleNo |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolLdu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolLdu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolLdu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstLduCd01) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolLdu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_ldu_cd01: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_ldu_cd01: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoopMark", wireType)
			}
			m.LoopMark = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolLdu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoopMark |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolLdu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.XImpedance = append(m.XImpedance, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolLdu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolLdu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolLdu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.XImpedance) == 0 {
					m.XImpedance = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolLdu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.XImpedance = append(m.XImpedance, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field XImpedance", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolLdu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolLdu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolLdu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipProtocolLdu(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProtocolLdu
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProtocolLdu
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProtocolLdu
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthProtocolLdu
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthProtocolLdu
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowProtocolLdu
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipProtocolLdu(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthProtocolLdu
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthProtocolLdu = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProtocolLdu   = fmt.Errorf("proto: integer overflow")
)
