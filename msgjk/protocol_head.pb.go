// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: protocol_head.proto

package wlst_pb2

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Head struct {
	// mod：1-系统指令，2-数传指令，3-SQL指令，4-错误数据
	Mod int32 `protobuf:"varint,1,opt,name=mod,proto3" json:"mod,omitempty"`
	// src：1-通讯服务，2-数据服务，3-客户端，4-串口采集（光照度，GPS），5-控制台，6-远程升级,
	// 7-webservice接口
	Src int32 `protobuf:"varint,2,opt,name=src,proto3" json:"src,omitempty"`
	// ver：1-内部协议版本v1.0
	Ver int32 `protobuf:"varint,3,opt,name=ver,proto3" json:"ver,omitempty"`
	// tver：1-公司终端协议版本,2-合肥版本协议
	Tver int32 `protobuf:"varint,4,opt,name=tver,proto3" json:"tver,omitempty"`
	// tra：1-数据通过模块直接传输，2-数据通过485传输
	Tra int32 `protobuf:"varint,5,opt,name=tra,proto3" json:"tra,omitempty"`
	// ret: 发送等级，0-normal，1-high
	Ret int32 `protobuf:"varint,6,opt,name=ret,proto3" json:"ret,omitempty"`
	// cmd：单位.设备.指令
	Cmd  string  `protobuf:"bytes,7,opt,name=cmd,proto3" json:"cmd,omitempty"`
	Code float64 `protobuf:"fixed64,8,opt,name=code,proto3" json:"code,omitempty"`
	//目的地:1-终端，2-数据服务
	Dst int32 `protobuf:"varint,9,opt,name=dst,proto3" json:"dst,omitempty"`
	//多路通信的绑定基础地址
	BaseAddr int32 `protobuf:"varint,10,opt,name=base_addr,json=baseAddr,proto3" json:"base_addr,omitempty"`
	Gid      int32 `protobuf:"varint,11,opt,name=gid,proto3" json:"gid,omitempty"`
	Rcv      int32 `protobuf:"varint,12,opt,name=rcv,proto3" json:"rcv,omitempty"`
	// 命令序号，long型递增循环
	Idx int64 `protobuf:"varint,13,opt,name=idx,proto3" json:"idx,omitempty"`
	// 当前消息发出时间戳
	Dt int64 `protobuf:"varint,15,opt,name=dt,proto3" json:"dt,omitempty"`
}

func (m *Head) Reset()         { *m = Head{} }
func (m *Head) String() string { return proto.CompactTextString(m) }
func (*Head) ProtoMessage()    {}
func (*Head) Descriptor() ([]byte, []int) {
	return fileDescriptor_0cecebaa1d05d52d, []int{0}
}
func (m *Head) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Head) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Head.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Head) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Head.Merge(m, src)
}
func (m *Head) XXX_Size() int {
	return m.Size()
}
func (m *Head) XXX_DiscardUnknown() {
	xxx_messageInfo_Head.DiscardUnknown(m)
}

var xxx_messageInfo_Head proto.InternalMessageInfo

func (m *Head) GetMod() int32 {
	if m != nil {
		return m.Mod
	}
	return 0
}

func (m *Head) GetSrc() int32 {
	if m != nil {
		return m.Src
	}
	return 0
}

func (m *Head) GetVer() int32 {
	if m != nil {
		return m.Ver
	}
	return 0
}

func (m *Head) GetTver() int32 {
	if m != nil {
		return m.Tver
	}
	return 0
}

func (m *Head) GetTra() int32 {
	if m != nil {
		return m.Tra
	}
	return 0
}

func (m *Head) GetRet() int32 {
	if m != nil {
		return m.Ret
	}
	return 0
}

func (m *Head) GetCmd() string {
	if m != nil {
		return m.Cmd
	}
	return ""
}

func (m *Head) GetCode() float64 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *Head) GetDst() int32 {
	if m != nil {
		return m.Dst
	}
	return 0
}

func (m *Head) GetBaseAddr() int32 {
	if m != nil {
		return m.BaseAddr
	}
	return 0
}

func (m *Head) GetGid() int32 {
	if m != nil {
		return m.Gid
	}
	return 0
}

func (m *Head) GetRcv() int32 {
	if m != nil {
		return m.Rcv
	}
	return 0
}

func (m *Head) GetIdx() int64 {
	if m != nil {
		return m.Idx
	}
	return 0
}

func (m *Head) GetDt() int64 {
	if m != nil {
		return m.Dt
	}
	return 0
}

type Args struct {
	// ip：目的ip
	Ip []int64 `protobuf:"varint,1,rep,packed,name=ip,proto3" json:"ip,omitempty"`
	// port：目的端口
	Port int32 `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
	// addr：终端地址，列表格式
	Addr []int64 `protobuf:"varint,3,rep,packed,name=addr,proto3" json:"addr,omitempty"`
	// sim：手机卡号，字符串格式
	Sim string `protobuf:"bytes,4,opt,name=sim,proto3" json:"sim,omitempty"`
	// cid：集中器地址
	Cid int32 `protobuf:"varint,5,opt,name=cid,proto3" json:"cid,omitempty"`
	// 手机卡号，和ip对应
	Sims []int64 `protobuf:"varint,6,rep,packed,name=sims,proto3" json:"sims,omitempty"`
	//字符串压缩格式地址（xx-xx）
	Saddr []string `protobuf:"bytes,7,rep,name=saddr,proto3" json:"saddr,omitempty"`
	// 1-ip目标掉线或无法连接，0-正常（下行不填充，用于通讯层通知数据层指令对象状态，暂未启用）
	Status []int64 `protobuf:"varint,8,rep,packed,name=status,proto3" json:"status,omitempty"`
	// 485校验, 0-无校验，1-偶校验,防盗默认1,其他默认0
	Rc int32 `protobuf:"varint,9,opt,name=rc,proto3" json:"rc,omitempty"`
	// 485波特率，0-300,1-600,2-1200,3-2400,4-4800,5-9600，防盗默认2,其他默认5
	Br int32 `protobuf:"varint,10,opt,name=br,proto3" json:"br,omitempty"`
	// 设备标识，用于电信nb平台，本公司产品使用0xd0
	DataFlag []int32 `protobuf:"varint,11,rep,packed,name=data_flag,json=dataFlag,proto3" json:"data_flag,omitempty"`
	// 区域码(国标用)，4位字符串，如果下行不提供，则忽略区域码，仅匹配设备地址，提供区域码时，需同时匹配区域码和设备地址
	Area string `protobuf:"bytes,12,opt,name=area,proto3" json:"area,omitempty"`
}

func (m *Args) Reset()         { *m = Args{} }
func (m *Args) String() string { return proto.CompactTextString(m) }
func (*Args) ProtoMessage()    {}
func (*Args) Descriptor() ([]byte, []int) {
	return fileDescriptor_0cecebaa1d05d52d, []int{1}
}
func (m *Args) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Args) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Args.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Args) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Args.Merge(m, src)
}
func (m *Args) XXX_Size() int {
	return m.Size()
}
func (m *Args) XXX_DiscardUnknown() {
	xxx_messageInfo_Args.DiscardUnknown(m)
}

var xxx_messageInfo_Args proto.InternalMessageInfo

func (m *Args) GetIp() []int64 {
	if m != nil {
		return m.Ip
	}
	return nil
}

func (m *Args) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *Args) GetAddr() []int64 {
	if m != nil {
		return m.Addr
	}
	return nil
}

func (m *Args) GetSim() string {
	if m != nil {
		return m.Sim
	}
	return ""
}

func (m *Args) GetCid() int32 {
	if m != nil {
		return m.Cid
	}
	return 0
}

func (m *Args) GetSims() []int64 {
	if m != nil {
		return m.Sims
	}
	return nil
}

func (m *Args) GetSaddr() []string {
	if m != nil {
		return m.Saddr
	}
	return nil
}

func (m *Args) GetStatus() []int64 {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *Args) GetRc() int32 {
	if m != nil {
		return m.Rc
	}
	return 0
}

func (m *Args) GetBr() int32 {
	if m != nil {
		return m.Br
	}
	return 0
}

func (m *Args) GetDataFlag() []int32 {
	if m != nil {
		return m.DataFlag
	}
	return nil
}

func (m *Args) GetArea() string {
	if m != nil {
		return m.Area
	}
	return ""
}

type SysCommands struct {
	Port int32 `protobuf:"varint,1,opt,name=port,proto3" json:"port,omitempty"`
	//在线
	OnlineRtus []int64 `protobuf:"varint,2,rep,packed,name=online_rtus,json=onlineRtus,proto3" json:"online_rtus,omitempty"`
	OnlineId   []int32 `protobuf:"varint,3,rep,packed,name=online_id,json=onlineId,proto3" json:"online_id,omitempty"`
	OnlineIp   []int64 `protobuf:"varint,4,rep,packed,name=online_ip,json=onlineIp,proto3" json:"online_ip,omitempty"`
	//日志信息
	LoggerMsg  string                    `protobuf:"bytes,5,opt,name=logger_msg,json=loggerMsg,proto3" json:"logger_msg,omitempty"`
	OnlineInfo []*SysCommands_OnlineInfo `protobuf:"bytes,6,rep,name=online_info,json=onlineInfo,proto3" json:"online_info,omitempty"`
}

func (m *SysCommands) Reset()         { *m = SysCommands{} }
func (m *SysCommands) String() string { return proto.CompactTextString(m) }
func (*SysCommands) ProtoMessage()    {}
func (*SysCommands) Descriptor() ([]byte, []int) {
	return fileDescriptor_0cecebaa1d05d52d, []int{2}
}
func (m *SysCommands) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SysCommands) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SysCommands.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SysCommands) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SysCommands.Merge(m, src)
}
func (m *SysCommands) XXX_Size() int {
	return m.Size()
}
func (m *SysCommands) XXX_DiscardUnknown() {
	xxx_messageInfo_SysCommands.DiscardUnknown(m)
}

var xxx_messageInfo_SysCommands proto.InternalMessageInfo

func (m *SysCommands) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *SysCommands) GetOnlineRtus() []int64 {
	if m != nil {
		return m.OnlineRtus
	}
	return nil
}

func (m *SysCommands) GetOnlineId() []int32 {
	if m != nil {
		return m.OnlineId
	}
	return nil
}

func (m *SysCommands) GetOnlineIp() []int64 {
	if m != nil {
		return m.OnlineIp
	}
	return nil
}

func (m *SysCommands) GetLoggerMsg() string {
	if m != nil {
		return m.LoggerMsg
	}
	return ""
}

func (m *SysCommands) GetOnlineInfo() []*SysCommands_OnlineInfo {
	if m != nil {
		return m.OnlineInfo
	}
	return nil
}

type SysCommands_OnlineInfo struct {
	// ip地址
	Ip int64 `protobuf:"varint,1,opt,name=ip,proto3" json:"ip,omitempty"`
	// 该ip下各主设备信息 格式为厂商-型号-物理地址 如wlst-rtu-1
	// 其中型号有rtu-终端/slu-单灯/als-光控/mru-电表/elu-漏电/sim-通讯模块/com-通讯模块
	Members []string `protobuf:"bytes,2,rep,name=members,proto3" json:"members,omitempty"`
	// 网络模式 0-未知 2-2G/3G网络 4-4G网络
	NetType int32 `protobuf:"varint,3,opt,name=net_type,json=netType,proto3" json:"net_type,omitempty"`
	// 通讯模块信号
	Signal int32 `protobuf:"varint,4,opt,name=signal,proto3" json:"signal,omitempty"`
	// 主设备物理地址 填充顺序为终端、单灯、其它设备
	PhyId int64 `protobuf:"varint,5,opt,name=phy_id,json=phyId,proto3" json:"phy_id,omitempty"`
	// SIM卡IMEI
	Imei int64 `protobuf:"varint,6,opt,name=imei,proto3" json:"imei,omitempty"`
}

func (m *SysCommands_OnlineInfo) Reset()         { *m = SysCommands_OnlineInfo{} }
func (m *SysCommands_OnlineInfo) String() string { return proto.CompactTextString(m) }
func (*SysCommands_OnlineInfo) ProtoMessage()    {}
func (*SysCommands_OnlineInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0cecebaa1d05d52d, []int{2, 0}
}
func (m *SysCommands_OnlineInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SysCommands_OnlineInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SysCommands_OnlineInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SysCommands_OnlineInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SysCommands_OnlineInfo.Merge(m, src)
}
func (m *SysCommands_OnlineInfo) XXX_Size() int {
	return m.Size()
}
func (m *SysCommands_OnlineInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SysCommands_OnlineInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SysCommands_OnlineInfo proto.InternalMessageInfo

func (m *SysCommands_OnlineInfo) GetIp() int64 {
	if m != nil {
		return m.Ip
	}
	return 0
}

func (m *SysCommands_OnlineInfo) GetMembers() []string {
	if m != nil {
		return m.Members
	}
	return nil
}

func (m *SysCommands_OnlineInfo) GetNetType() int32 {
	if m != nil {
		return m.NetType
	}
	return 0
}

func (m *SysCommands_OnlineInfo) GetSignal() int32 {
	if m != nil {
		return m.Signal
	}
	return 0
}

func (m *SysCommands_OnlineInfo) GetPhyId() int64 {
	if m != nil {
		return m.PhyId
	}
	return 0
}

func (m *SysCommands_OnlineInfo) GetImei() int64 {
	if m != nil {
		return m.Imei
	}
	return 0
}

type Passthrough struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 标识
	DataMark int32 `protobuf:"varint,2,opt,name=data_mark,json=dataMark,proto3" json:"data_mark,omitempty"`
	// 数据
	PkgData []int32 `protobuf:"varint,3,rep,packed,name=pkg_data,json=pkgData,proto3" json:"pkg_data,omitempty"`
	// 状态
	Status int32 `protobuf:"varint,4,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *Passthrough) Reset()         { *m = Passthrough{} }
func (m *Passthrough) String() string { return proto.CompactTextString(m) }
func (*Passthrough) ProtoMessage()    {}
func (*Passthrough) Descriptor() ([]byte, []int) {
	return fileDescriptor_0cecebaa1d05d52d, []int{3}
}
func (m *Passthrough) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Passthrough) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Passthrough.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Passthrough) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Passthrough.Merge(m, src)
}
func (m *Passthrough) XXX_Size() int {
	return m.Size()
}
func (m *Passthrough) XXX_DiscardUnknown() {
	xxx_messageInfo_Passthrough.DiscardUnknown(m)
}

var xxx_messageInfo_Passthrough proto.InternalMessageInfo

func (m *Passthrough) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *Passthrough) GetDataMark() int32 {
	if m != nil {
		return m.DataMark
	}
	return 0
}

func (m *Passthrough) GetPkgData() []int32 {
	if m != nil {
		return m.PkgData
	}
	return nil
}

func (m *Passthrough) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func init() {
	proto.RegisterType((*Head)(nil), "wlst.pb2.Head")
	proto.RegisterType((*Args)(nil), "wlst.pb2.Args")
	proto.RegisterType((*SysCommands)(nil), "wlst.pb2.SysCommands")
	proto.RegisterType((*SysCommands_OnlineInfo)(nil), "wlst.pb2.SysCommands.OnlineInfo")
	proto.RegisterType((*Passthrough)(nil), "wlst.pb2.Passthrough")
}

func init() { proto.RegisterFile("protocol_head.proto", fileDescriptor_0cecebaa1d05d52d) }

var fileDescriptor_0cecebaa1d05d52d = []byte{
	// 658 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x4c, 0x94, 0xbd, 0x72, 0x13, 0x31,
	0x10, 0xc7, 0x73, 0x77, 0xfe, 0xba, 0x35, 0x1f, 0x19, 0x01, 0x41, 0x84, 0x89, 0x73, 0x63, 0x1a,
	0x57, 0x2e, 0xc2, 0x13, 0x24, 0x30, 0x4c, 0x52, 0x64, 0x60, 0x0e, 0xfa, 0x1b, 0xf9, 0xa4, 0x9c,
	0x35, 0xf6, 0x7d, 0x8c, 0xa4, 0x98, 0x98, 0x8e, 0x92, 0x0a, 0x0a, 0x1e, 0x8a, 0x32, 0x25, 0x25,
	0x93, 0xbc, 0x08, 0xb3, 0xab, 0xb3, 0xe3, 0xee, 0xbf, 0x3f, 0xaf, 0x74, 0xbb, 0x7f, 0xed, 0x1a,
	0x9e, 0x35, 0xa6, 0x76, 0x75, 0x5e, 0x2f, 0xb3, 0xb9, 0x12, 0x72, 0x4a, 0x11, 0x1b, 0x7c, 0x5d,
	0x5a, 0x37, 0x6d, 0x66, 0x27, 0xe3, 0x9f, 0x21, 0x74, 0xce, 0x95, 0x90, 0x6c, 0x1f, 0xa2, 0xb2,
	0x96, 0x3c, 0x48, 0x82, 0x49, 0x37, 0x45, 0x89, 0xc4, 0x9a, 0x9c, 0x87, 0x9e, 0x58, 0x93, 0x23,
	0x59, 0x29, 0xc3, 0x23, 0x4f, 0x56, 0xca, 0x30, 0x06, 0x1d, 0x87, 0xa8, 0x43, 0x88, 0x34, 0x66,
	0x39, 0x23, 0x78, 0xd7, 0x67, 0x39, 0x23, 0x90, 0x18, 0xe5, 0x78, 0xcf, 0x13, 0xa3, 0x1c, 0x92,
	0xbc, 0x94, 0xbc, 0x9f, 0x04, 0x93, 0x38, 0x45, 0x89, 0x37, 0xe5, 0xb5, 0x54, 0x7c, 0x90, 0x04,
	0x93, 0x20, 0x25, 0x8d, 0x59, 0xd2, 0x3a, 0x1e, 0xfb, 0x73, 0xd2, 0x3a, 0xf6, 0x1a, 0xe2, 0x99,
	0xb0, 0x2a, 0x13, 0x52, 0x1a, 0x0e, 0xc4, 0x07, 0x08, 0x4e, 0xa5, 0xa4, 0x0f, 0x17, 0x5a, 0xf2,
	0xa1, 0x4f, 0x2f, 0x34, 0xb5, 0x60, 0xf2, 0x15, 0x7f, 0xd4, 0x7e, 0x38, 0x5f, 0x21, 0xd1, 0xf2,
	0x86, 0x3f, 0x4e, 0x82, 0x49, 0x94, 0xa2, 0x64, 0x4f, 0x20, 0x94, 0x8e, 0x3f, 0x25, 0x10, 0x4a,
	0x37, 0xfe, 0x11, 0x42, 0xe7, 0xd4, 0x14, 0x96, 0x31, 0x08, 0x75, 0xc3, 0x83, 0x24, 0x9a, 0x44,
	0x67, 0xe1, 0x7e, 0x90, 0x86, 0xba, 0xc1, 0x2a, 0x9b, 0xda, 0xb8, 0xd6, 0x14, 0xd2, 0xec, 0x00,
	0x3a, 0x54, 0x4e, 0xb4, 0xcd, 0xa4, 0x98, 0xfc, 0xd3, 0x25, 0x59, 0x13, 0xa7, 0x28, 0xa9, 0x6b,
	0x2d, 0x37, 0xce, 0xe4, 0x5a, 0xe2, 0x59, 0xab, 0x4b, 0xcb, 0x7b, 0x0f, 0x67, 0x31, 0x66, 0xcf,
	0xa1, 0x6b, 0xe9, 0xd2, 0x7e, 0x12, 0x4d, 0xe2, 0xd4, 0x07, 0xec, 0x10, 0x7a, 0xd6, 0x09, 0x77,
	0x6d, 0xf9, 0x60, 0x9b, 0xdf, 0x12, 0x6c, 0xc3, 0xe4, 0xad, 0x55, 0xa1, 0xc9, 0x31, 0x9e, 0x6d,
	0x2c, 0x0a, 0x67, 0x86, 0x1d, 0x43, 0x2c, 0x85, 0x13, 0xd9, 0xd5, 0x52, 0x14, 0x7c, 0x98, 0x44,
	0x93, 0x2e, 0x1d, 0x1f, 0x20, 0xfc, 0xb0, 0x14, 0x05, 0xb6, 0x26, 0x8c, 0x12, 0x64, 0x56, 0x9c,
	0x92, 0x1e, 0x7f, 0x8f, 0x60, 0xf8, 0x79, 0x6d, 0xdf, 0xd5, 0x65, 0x29, 0x2a, 0x69, 0xb7, 0xed,
	0x07, 0x3b, 0xed, 0xbf, 0x81, 0x61, 0x5d, 0x2d, 0x75, 0xa5, 0x32, 0x83, 0x95, 0x85, 0xdb, 0xca,
	0xc0, 0xe3, 0x14, 0xab, 0x3b, 0x86, 0xb8, 0x4d, 0xd2, 0x92, 0x8c, 0x6a, 0xbf, 0xee, 0xe1, 0x85,
	0xdc, 0x4d, 0x68, 0x78, 0x67, 0x7b, 0xc7, 0x26, 0xa1, 0x61, 0x47, 0x00, 0xcb, 0xba, 0x28, 0x94,
	0xc9, 0x4a, 0x5b, 0x90, 0x85, 0x71, 0x1a, 0x7b, 0x72, 0x69, 0x0b, 0x76, 0xba, 0xad, 0x42, 0x57,
	0x57, 0x35, 0xf9, 0x39, 0x3c, 0x49, 0xa6, 0x9b, 0x39, 0x9f, 0xee, 0x74, 0x31, 0xfd, 0xe8, 0xef,
	0xac, 0xae, 0xea, 0x4d, 0x8d, 0xa8, 0x0f, 0x7f, 0x07, 0x00, 0x0f, 0x3f, 0xa1, 0x81, 0xf4, 0xfc,
	0x34, 0x17, 0xba, 0x61, 0x1c, 0xfa, 0xa5, 0x2a, 0x67, 0xca, 0xf8, 0x1e, 0xe3, 0x74, 0x13, 0xb2,
	0x57, 0x30, 0xa8, 0x94, 0xcb, 0xdc, 0xba, 0x51, 0xed, 0x6e, 0xf4, 0x2b, 0xe5, 0xbe, 0xac, 0x1b,
	0xc5, 0x0e, 0xa0, 0x67, 0x75, 0x51, 0x89, 0x65, 0xbb, 0x21, 0x6d, 0xc4, 0x5e, 0x40, 0xaf, 0x99,
	0xaf, 0xb3, 0x76, 0x18, 0xa2, 0xb4, 0xdb, 0xcc, 0xd7, 0x17, 0xb4, 0x04, 0xba, 0x54, 0x9a, 0x36,
	0x25, 0x4a, 0x49, 0x8f, 0xbf, 0xc1, 0xf0, 0x93, 0xb0, 0xd6, 0xcd, 0x4d, 0x7d, 0x5d, 0xcc, 0xd9,
	0x4b, 0xe8, 0xe7, 0xa5, 0xcc, 0x70, 0x88, 0xfd, 0x2b, 0xf4, 0xf2, 0x52, 0x5e, 0xc8, 0x1b, 0x5c,
	0x0d, 0x7a, 0xe0, 0x52, 0x98, 0x45, 0x3b, 0x9f, 0xf4, 0xb8, 0x97, 0xc2, 0x2c, 0xd8, 0x11, 0x0c,
	0x9a, 0x45, 0x91, 0x61, 0xbc, 0x63, 0x7f, 0xbf, 0x59, 0x14, 0xef, 0x85, 0x13, 0x54, 0xa6, 0x1f,
	0xac, 0x4d, 0x99, 0x14, 0x9d, 0x1d, 0xfe, 0xb9, 0x1b, 0x05, 0xb7, 0x77, 0xa3, 0xe0, 0xdf, 0xdd,
	0x28, 0xf8, 0x75, 0x3f, 0xda, 0xbb, 0xbd, 0x1f, 0xed, 0xfd, 0xbd, 0x1f, 0xed, 0x9d, 0x07, 0xb3,
	0x1e, 0xfd, 0x95, 0xbc, 0xfd, 0x1f, 0x00, 0x00, 0xff, 0xff, 0x39, 0x69, 0x12, 0x00, 0x61, 0x04,
	0x00, 0x00,
}

func (m *Head) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Head) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Head) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Dt != 0 {
		i = encodeVarintProtocolHead(dAtA, i, uint64(m.Dt))
		i--
		dAtA[i] = 0x78
	}
	if m.Idx != 0 {
		i = encodeVarintProtocolHead(dAtA, i, uint64(m.Idx))
		i--
		dAtA[i] = 0x68
	}
	if m.Rcv != 0 {
		i = encodeVarintProtocolHead(dAtA, i, uint64(m.Rcv))
		i--
		dAtA[i] = 0x60
	}
	if m.Gid != 0 {
		i = encodeVarintProtocolHead(dAtA, i, uint64(m.Gid))
		i--
		dAtA[i] = 0x58
	}
	if m.BaseAddr != 0 {
		i = encodeVarintProtocolHead(dAtA, i, uint64(m.BaseAddr))
		i--
		dAtA[i] = 0x50
	}
	if m.Dst != 0 {
		i = encodeVarintProtocolHead(dAtA, i, uint64(m.Dst))
		i--
		dAtA[i] = 0x48
	}
	if m.Code != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Code))))
		i--
		dAtA[i] = 0x41
	}
	if len(m.Cmd) > 0 {
		i -= len(m.Cmd)
		copy(dAtA[i:], m.Cmd)
		i = encodeVarintProtocolHead(dAtA, i, uint64(len(m.Cmd)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Ret != 0 {
		i = encodeVarintProtocolHead(dAtA, i, uint64(m.Ret))
		i--
		dAtA[i] = 0x30
	}
	if m.Tra != 0 {
		i = encodeVarintProtocolHead(dAtA, i, uint64(m.Tra))
		i--
		dAtA[i] = 0x28
	}
	if m.Tver != 0 {
		i = encodeVarintProtocolHead(dAtA, i, uint64(m.Tver))
		i--
		dAtA[i] = 0x20
	}
	if m.Ver != 0 {
		i = encodeVarintProtocolHead(dAtA, i, uint64(m.Ver))
		i--
		dAtA[i] = 0x18
	}
	if m.Src != 0 {
		i = encodeVarintProtocolHead(dAtA, i, uint64(m.Src))
		i--
		dAtA[i] = 0x10
	}
	if m.Mod != 0 {
		i = encodeVarintProtocolHead(dAtA, i, uint64(m.Mod))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Args) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Args) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Args) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Area) > 0 {
		i -= len(m.Area)
		copy(dAtA[i:], m.Area)
		i = encodeVarintProtocolHead(dAtA, i, uint64(len(m.Area)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.DataFlag) > 0 {
		dAtA2 := make([]byte, len(m.DataFlag)*10)
		var j1 int
		for _, num1 := range m.DataFlag {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintProtocolHead(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x5a
	}
	if m.Br != 0 {
		i = encodeVarintProtocolHead(dAtA, i, uint64(m.Br))
		i--
		dAtA[i] = 0x50
	}
	if m.Rc != 0 {
		i = encodeVarintProtocolHead(dAtA, i, uint64(m.Rc))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Status) > 0 {
		dAtA4 := make([]byte, len(m.Status)*10)
		var j3 int
		for _, num1 := range m.Status {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintProtocolHead(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Saddr) > 0 {
		for iNdEx := len(m.Saddr) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Saddr[iNdEx])
			copy(dAtA[i:], m.Saddr[iNdEx])
			i = encodeVarintProtocolHead(dAtA, i, uint64(len(m.Saddr[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Sims) > 0 {
		dAtA6 := make([]byte, len(m.Sims)*10)
		var j5 int
		for _, num1 := range m.Sims {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintProtocolHead(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0x32
	}
	if m.Cid != 0 {
		i = encodeVarintProtocolHead(dAtA, i, uint64(m.Cid))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Sim) > 0 {
		i -= len(m.Sim)
		copy(dAtA[i:], m.Sim)
		i = encodeVarintProtocolHead(dAtA, i, uint64(len(m.Sim)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Addr) > 0 {
		dAtA8 := make([]byte, len(m.Addr)*10)
		var j7 int
		for _, num1 := range m.Addr {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		i -= j7
		copy(dAtA[i:], dAtA8[:j7])
		i = encodeVarintProtocolHead(dAtA, i, uint64(j7))
		i--
		dAtA[i] = 0x1a
	}
	if m.Port != 0 {
		i = encodeVarintProtocolHead(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Ip) > 0 {
		dAtA10 := make([]byte, len(m.Ip)*10)
		var j9 int
		for _, num1 := range m.Ip {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		i -= j9
		copy(dAtA[i:], dAtA10[:j9])
		i = encodeVarintProtocolHead(dAtA, i, uint64(j9))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SysCommands) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SysCommands) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SysCommands) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OnlineInfo) > 0 {
		for iNdEx := len(m.OnlineInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OnlineInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProtocolHead(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.LoggerMsg) > 0 {
		i -= len(m.LoggerMsg)
		copy(dAtA[i:], m.LoggerMsg)
		i = encodeVarintProtocolHead(dAtA, i, uint64(len(m.LoggerMsg)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.OnlineIp) > 0 {
		dAtA12 := make([]byte, len(m.OnlineIp)*10)
		var j11 int
		for _, num1 := range m.OnlineIp {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		i -= j11
		copy(dAtA[i:], dAtA12[:j11])
		i = encodeVarintProtocolHead(dAtA, i, uint64(j11))
		i--
		dAtA[i] = 0x22
	}
	if len(m.OnlineId) > 0 {
		dAtA14 := make([]byte, len(m.OnlineId)*10)
		var j13 int
		for _, num1 := range m.OnlineId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		i -= j13
		copy(dAtA[i:], dAtA14[:j13])
		i = encodeVarintProtocolHead(dAtA, i, uint64(j13))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.OnlineRtus) > 0 {
		dAtA16 := make([]byte, len(m.OnlineRtus)*10)
		var j15 int
		for _, num1 := range m.OnlineRtus {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA16[j15] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j15++
			}
			dAtA16[j15] = uint8(num)
			j15++
		}
		i -= j15
		copy(dAtA[i:], dAtA16[:j15])
		i = encodeVarintProtocolHead(dAtA, i, uint64(j15))
		i--
		dAtA[i] = 0x12
	}
	if m.Port != 0 {
		i = encodeVarintProtocolHead(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SysCommands_OnlineInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SysCommands_OnlineInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SysCommands_OnlineInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Imei != 0 {
		i = encodeVarintProtocolHead(dAtA, i, uint64(m.Imei))
		i--
		dAtA[i] = 0x30
	}
	if m.PhyId != 0 {
		i = encodeVarintProtocolHead(dAtA, i, uint64(m.PhyId))
		i--
		dAtA[i] = 0x28
	}
	if m.Signal != 0 {
		i = encodeVarintProtocolHead(dAtA, i, uint64(m.Signal))
		i--
		dAtA[i] = 0x20
	}
	if m.NetType != 0 {
		i = encodeVarintProtocolHead(dAtA, i, uint64(m.NetType))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Members) > 0 {
		for iNdEx := len(m.Members) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Members[iNdEx])
			copy(dAtA[i:], m.Members[iNdEx])
			i = encodeVarintProtocolHead(dAtA, i, uint64(len(m.Members[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Ip != 0 {
		i = encodeVarintProtocolHead(dAtA, i, uint64(m.Ip))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Passthrough) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Passthrough) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Passthrough) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintProtocolHead(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x20
	}
	if len(m.PkgData) > 0 {
		dAtA18 := make([]byte, len(m.PkgData)*10)
		var j17 int
		for _, num1 := range m.PkgData {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA18[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA18[j17] = uint8(num)
			j17++
		}
		i -= j17
		copy(dAtA[i:], dAtA18[:j17])
		i = encodeVarintProtocolHead(dAtA, i, uint64(j17))
		i--
		dAtA[i] = 0x1a
	}
	if m.DataMark != 0 {
		i = encodeVarintProtocolHead(dAtA, i, uint64(m.DataMark))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintProtocolHead(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintProtocolHead(dAtA []byte, offset int, v uint64) int {
	offset -= sovProtocolHead(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Head) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mod != 0 {
		n += 1 + sovProtocolHead(uint64(m.Mod))
	}
	if m.Src != 0 {
		n += 1 + sovProtocolHead(uint64(m.Src))
	}
	if m.Ver != 0 {
		n += 1 + sovProtocolHead(uint64(m.Ver))
	}
	if m.Tver != 0 {
		n += 1 + sovProtocolHead(uint64(m.Tver))
	}
	if m.Tra != 0 {
		n += 1 + sovProtocolHead(uint64(m.Tra))
	}
	if m.Ret != 0 {
		n += 1 + sovProtocolHead(uint64(m.Ret))
	}
	l = len(m.Cmd)
	if l > 0 {
		n += 1 + l + sovProtocolHead(uint64(l))
	}
	if m.Code != 0 {
		n += 9
	}
	if m.Dst != 0 {
		n += 1 + sovProtocolHead(uint64(m.Dst))
	}
	if m.BaseAddr != 0 {
		n += 1 + sovProtocolHead(uint64(m.BaseAddr))
	}
	if m.Gid != 0 {
		n += 1 + sovProtocolHead(uint64(m.Gid))
	}
	if m.Rcv != 0 {
		n += 1 + sovProtocolHead(uint64(m.Rcv))
	}
	if m.Idx != 0 {
		n += 1 + sovProtocolHead(uint64(m.Idx))
	}
	if m.Dt != 0 {
		n += 1 + sovProtocolHead(uint64(m.Dt))
	}
	return n
}

func (m *Args) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ip) > 0 {
		l = 0
		for _, e := range m.Ip {
			l += sovProtocolHead(uint64(e))
		}
		n += 1 + sovProtocolHead(uint64(l)) + l
	}
	if m.Port != 0 {
		n += 1 + sovProtocolHead(uint64(m.Port))
	}
	if len(m.Addr) > 0 {
		l = 0
		for _, e := range m.Addr {
			l += sovProtocolHead(uint64(e))
		}
		n += 1 + sovProtocolHead(uint64(l)) + l
	}
	l = len(m.Sim)
	if l > 0 {
		n += 1 + l + sovProtocolHead(uint64(l))
	}
	if m.Cid != 0 {
		n += 1 + sovProtocolHead(uint64(m.Cid))
	}
	if len(m.Sims) > 0 {
		l = 0
		for _, e := range m.Sims {
			l += sovProtocolHead(uint64(e))
		}
		n += 1 + sovProtocolHead(uint64(l)) + l
	}
	if len(m.Saddr) > 0 {
		for _, s := range m.Saddr {
			l = len(s)
			n += 1 + l + sovProtocolHead(uint64(l))
		}
	}
	if len(m.Status) > 0 {
		l = 0
		for _, e := range m.Status {
			l += sovProtocolHead(uint64(e))
		}
		n += 1 + sovProtocolHead(uint64(l)) + l
	}
	if m.Rc != 0 {
		n += 1 + sovProtocolHead(uint64(m.Rc))
	}
	if m.Br != 0 {
		n += 1 + sovProtocolHead(uint64(m.Br))
	}
	if len(m.DataFlag) > 0 {
		l = 0
		for _, e := range m.DataFlag {
			l += sovProtocolHead(uint64(e))
		}
		n += 1 + sovProtocolHead(uint64(l)) + l
	}
	l = len(m.Area)
	if l > 0 {
		n += 1 + l + sovProtocolHead(uint64(l))
	}
	return n
}

func (m *SysCommands) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Port != 0 {
		n += 1 + sovProtocolHead(uint64(m.Port))
	}
	if len(m.OnlineRtus) > 0 {
		l = 0
		for _, e := range m.OnlineRtus {
			l += sovProtocolHead(uint64(e))
		}
		n += 1 + sovProtocolHead(uint64(l)) + l
	}
	if len(m.OnlineId) > 0 {
		l = 0
		for _, e := range m.OnlineId {
			l += sovProtocolHead(uint64(e))
		}
		n += 1 + sovProtocolHead(uint64(l)) + l
	}
	if len(m.OnlineIp) > 0 {
		l = 0
		for _, e := range m.OnlineIp {
			l += sovProtocolHead(uint64(e))
		}
		n += 1 + sovProtocolHead(uint64(l)) + l
	}
	l = len(m.LoggerMsg)
	if l > 0 {
		n += 1 + l + sovProtocolHead(uint64(l))
	}
	if len(m.OnlineInfo) > 0 {
		for _, e := range m.OnlineInfo {
			l = e.Size()
			n += 1 + l + sovProtocolHead(uint64(l))
		}
	}
	return n
}

func (m *SysCommands_OnlineInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ip != 0 {
		n += 1 + sovProtocolHead(uint64(m.Ip))
	}
	if len(m.Members) > 0 {
		for _, s := range m.Members {
			l = len(s)
			n += 1 + l + sovProtocolHead(uint64(l))
		}
	}
	if m.NetType != 0 {
		n += 1 + sovProtocolHead(uint64(m.NetType))
	}
	if m.Signal != 0 {
		n += 1 + sovProtocolHead(uint64(m.Signal))
	}
	if m.PhyId != 0 {
		n += 1 + sovProtocolHead(uint64(m.PhyId))
	}
	if m.Imei != 0 {
		n += 1 + sovProtocolHead(uint64(m.Imei))
	}
	return n
}

func (m *Passthrough) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovProtocolHead(uint64(m.CmdIdx))
	}
	if m.DataMark != 0 {
		n += 1 + sovProtocolHead(uint64(m.DataMark))
	}
	if len(m.PkgData) > 0 {
		l = 0
		for _, e := range m.PkgData {
			l += sovProtocolHead(uint64(e))
		}
		n += 1 + sovProtocolHead(uint64(l)) + l
	}
	if m.Status != 0 {
		n += 1 + sovProtocolHead(uint64(m.Status))
	}
	return n
}

func sovProtocolHead(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozProtocolHead(x uint64) (n int) {
	return sovProtocolHead(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Head) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolHead
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Head: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Head: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mod", wireType)
			}
			m.Mod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolHead
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mod |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Src", wireType)
			}
			m.Src = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolHead
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Src |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			m.Ver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolHead
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ver |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tver", wireType)
			}
			m.Tver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolHead
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tver |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tra", wireType)
			}
			m.Tra = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolHead
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tra |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ret", wireType)
			}
			m.Ret = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolHead
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ret |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolHead
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolHead
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolHead
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cmd = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Code = float64(math.Float64frombits(v))
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dst", wireType)
			}
			m.Dst = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolHead
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dst |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseAddr", wireType)
			}
			m.BaseAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolHead
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseAddr |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gid", wireType)
			}
			m.Gid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolHead
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rcv", wireType)
			}
			m.Rcv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolHead
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rcv |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			m.Idx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolHead
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Idx |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dt", wireType)
			}
			m.Dt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolHead
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolHead(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolHead
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolHead
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Args) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolHead
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Args: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Args: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolHead
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Ip = append(m.Ip, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolHead
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolHead
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolHead
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Ip) == 0 {
					m.Ip = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolHead
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Ip = append(m.Ip, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolHead
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolHead
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Addr = append(m.Addr, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolHead
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolHead
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolHead
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Addr) == 0 {
					m.Addr = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolHead
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Addr = append(m.Addr, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sim", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolHead
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolHead
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolHead
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sim = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			m.Cid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolHead
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolHead
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Sims = append(m.Sims, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolHead
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolHead
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolHead
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Sims) == 0 {
					m.Sims = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolHead
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Sims = append(m.Sims, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Sims", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Saddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolHead
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolHead
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolHead
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Saddr = append(m.Saddr, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolHead
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Status = append(m.Status, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolHead
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolHead
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolHead
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Status) == 0 {
					m.Status = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolHead
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Status = append(m.Status, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rc", wireType)
			}
			m.Rc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolHead
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rc |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Br", wireType)
			}
			m.Br = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolHead
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Br |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolHead
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DataFlag = append(m.DataFlag, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolHead
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolHead
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolHead
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DataFlag) == 0 {
					m.DataFlag = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolHead
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DataFlag = append(m.DataFlag, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DataFlag", wireType)
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Area", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolHead
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolHead
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolHead
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Area = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolHead(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolHead
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolHead
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SysCommands) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolHead
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SysCommands: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SysCommands: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolHead
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolHead
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OnlineRtus = append(m.OnlineRtus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolHead
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolHead
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolHead
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OnlineRtus) == 0 {
					m.OnlineRtus = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolHead
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OnlineRtus = append(m.OnlineRtus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OnlineRtus", wireType)
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolHead
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OnlineId = append(m.OnlineId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolHead
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolHead
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolHead
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OnlineId) == 0 {
					m.OnlineId = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolHead
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OnlineId = append(m.OnlineId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OnlineId", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolHead
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OnlineIp = append(m.OnlineIp, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolHead
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolHead
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolHead
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OnlineIp) == 0 {
					m.OnlineIp = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolHead
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OnlineIp = append(m.OnlineIp, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OnlineIp", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoggerMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolHead
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolHead
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolHead
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LoggerMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnlineInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolHead
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolHead
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolHead
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OnlineInfo = append(m.OnlineInfo, &SysCommands_OnlineInfo{})
			if err := m.OnlineInfo[len(m.OnlineInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolHead(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolHead
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolHead
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SysCommands_OnlineInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolHead
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OnlineInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OnlineInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			m.Ip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolHead
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ip |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolHead
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolHead
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolHead
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = append(m.Members, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetType", wireType)
			}
			m.NetType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolHead
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signal", wireType)
			}
			m.Signal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolHead
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Signal |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhyId", wireType)
			}
			m.PhyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolHead
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PhyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Imei", wireType)
			}
			m.Imei = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolHead
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Imei |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolHead(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolHead
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolHead
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Passthrough) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolHead
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Passthrough: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Passthrough: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolHead
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataMark", wireType)
			}
			m.DataMark = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolHead
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataMark |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolHead
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PkgData = append(m.PkgData, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolHead
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolHead
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolHead
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PkgData) == 0 {
					m.PkgData = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolHead
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PkgData = append(m.PkgData, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PkgData", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolHead
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolHead(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolHead
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolHead
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipProtocolHead(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProtocolHead
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProtocolHead
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProtocolHead
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthProtocolHead
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupProtocolHead
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthProtocolHead
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthProtocolHead        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProtocolHead          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupProtocolHead = fmt.Errorf("proto: unexpected end of group")
)
