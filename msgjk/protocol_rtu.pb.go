// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: protocol_rtu.proto

package wlst_pb2

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type WlstRtuAns struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 数据标记
	DataMark []int32 `protobuf:"varint,2,rep,packed,name=data_mark,json=dataMark,proto3" json:"data_mark,omitempty"`
	// 信息点，暂不用
	DataPoint []int32 `protobuf:"varint,3,rep,packed,name=data_point,json=dataPoint,proto3" json:"data_point,omitempty"`
	// 应答,0-失败，1-成功，填充顺序和data_mark相同
	Status []int32 `protobuf:"varint,4,rep,packed,name=status,proto3" json:"status,omitempty"`
	// 状态码，详细参考文档
	StatusCode int32 `protobuf:"varint,5,opt,name=status_code,json=statusCode,proto3" json:"status_code,omitempty"`
}

func (m *WlstRtuAns) Reset()         { *m = WlstRtuAns{} }
func (m *WlstRtuAns) String() string { return proto.CompactTextString(m) }
func (*WlstRtuAns) ProtoMessage()    {}
func (*WlstRtuAns) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{0}
}
func (m *WlstRtuAns) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtuAns) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtuAns.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtuAns) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtuAns.Merge(m, src)
}
func (m *WlstRtuAns) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtuAns) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtuAns.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtuAns proto.InternalMessageInfo

func (m *WlstRtuAns) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *WlstRtuAns) GetDataMark() []int32 {
	if m != nil {
		return m.DataMark
	}
	return nil
}

func (m *WlstRtuAns) GetDataPoint() []int32 {
	if m != nil {
		return m.DataPoint
	}
	return nil
}

func (m *WlstRtuAns) GetStatus() []int32 {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *WlstRtuAns) GetStatusCode() int32 {
	if m != nil {
		return m.StatusCode
	}
	return 0
}

// 3006主动上报
type WlstRtu_7094 struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 报警类型，400-火零不平衡,401-24路设备开关灯操作后应答
	AlarmType int32 `protobuf:"varint,2,opt,name=alarm_type,json=alarmType,proto3" json:"alarm_type,omitempty"`
	// 火零不平衡报警内容
	Alarmln *WlstRtu_7094_Alarm_LN `protobuf:"bytes,3,opt,name=alarmln,proto3" json:"alarmln,omitempty"`
	// 24路开关灯后操作结果，依次为1-24路输出状态，1-通，0-断
	SwitchOutStPacked []int32 `protobuf:"varint,4,rep,packed,name=switch_out_st_packed,json=switchOutStPacked,proto3" json:"switch_out_st_packed,omitempty"`
}

func (m *WlstRtu_7094) Reset()         { *m = WlstRtu_7094{} }
func (m *WlstRtu_7094) String() string { return proto.CompactTextString(m) }
func (*WlstRtu_7094) ProtoMessage()    {}
func (*WlstRtu_7094) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{1}
}
func (m *WlstRtu_7094) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtu_7094) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtu_7094.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtu_7094) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtu_7094.Merge(m, src)
}
func (m *WlstRtu_7094) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtu_7094) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtu_7094.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtu_7094 proto.InternalMessageInfo

func (m *WlstRtu_7094) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *WlstRtu_7094) GetAlarmType() int32 {
	if m != nil {
		return m.AlarmType
	}
	return 0
}

func (m *WlstRtu_7094) GetAlarmln() *WlstRtu_7094_Alarm_LN {
	if m != nil {
		return m.Alarmln
	}
	return nil
}

func (m *WlstRtu_7094) GetSwitchOutStPacked() []int32 {
	if m != nil {
		return m.SwitchOutStPacked
	}
	return nil
}

type WlstRtu_7094_Alarm_LN struct {
	// 回路序号，1-12
	LoopNo int32 `protobuf:"varint,1,opt,name=loop_no,json=loopNo,proto3" json:"loop_no,omitempty"`
	// 报警类型，1-报警，2-报警并分匝
	AlarmStatus int32 `protobuf:"varint,2,opt,name=alarm_status,json=alarmStatus,proto3" json:"alarm_status,omitempty"`
	// 报警电流
	AlarmCurrent float64 `protobuf:"fixed64,3,opt,name=alarm_current,json=alarmCurrent,proto3" json:"alarm_current,omitempty"`
}

func (m *WlstRtu_7094_Alarm_LN) Reset()         { *m = WlstRtu_7094_Alarm_LN{} }
func (m *WlstRtu_7094_Alarm_LN) String() string { return proto.CompactTextString(m) }
func (*WlstRtu_7094_Alarm_LN) ProtoMessage()    {}
func (*WlstRtu_7094_Alarm_LN) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{1, 0}
}
func (m *WlstRtu_7094_Alarm_LN) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtu_7094_Alarm_LN) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtu_7094_Alarm_LN.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtu_7094_Alarm_LN) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtu_7094_Alarm_LN.Merge(m, src)
}
func (m *WlstRtu_7094_Alarm_LN) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtu_7094_Alarm_LN) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtu_7094_Alarm_LN.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtu_7094_Alarm_LN proto.InternalMessageInfo

func (m *WlstRtu_7094_Alarm_LN) GetLoopNo() int32 {
	if m != nil {
		return m.LoopNo
	}
	return 0
}

func (m *WlstRtu_7094_Alarm_LN) GetAlarmStatus() int32 {
	if m != nil {
		return m.AlarmStatus
	}
	return 0
}

func (m *WlstRtu_7094_Alarm_LN) GetAlarmCurrent() float64 {
	if m != nil {
		return m.AlarmCurrent
	}
	return 0
}

// 设置/读取终端参数 （火零不平衡参数,1-24路周控制时间表）
type WlstRtu_7021 struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 参数类别，1-火零不平衡参数,2-1~24路周控制时间表
	DataType int32 `protobuf:"varint,2,opt,name=data_type,json=dataType,proto3" json:"data_type,omitempty"`
	// 火零不平衡参数
	Argsln []*WlstRtu_7021_Args_LN `protobuf:"bytes,3,rep,name=argsln,proto3" json:"argsln,omitempty"`
	// 设置应答状态码
	StatusCode int32 `protobuf:"varint,4,opt,name=status_code,json=statusCode,proto3" json:"status_code,omitempty"`
	// 回路代码 0-1~8回路,1-9~16回路,2-17~24回路
	LoopType int32 `protobuf:"varint,5,opt,name=loop_type,json=loopType,proto3" json:"loop_type,omitempty"`
	// 周日到周六 时间表参数(定长7)
	Argswc []*WlstRtu_7021_Args_WC `protobuf:"bytes,6,rep,name=argswc,proto3" json:"argswc,omitempty"`
}

func (m *WlstRtu_7021) Reset()         { *m = WlstRtu_7021{} }
func (m *WlstRtu_7021) String() string { return proto.CompactTextString(m) }
func (*WlstRtu_7021) ProtoMessage()    {}
func (*WlstRtu_7021) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{2}
}
func (m *WlstRtu_7021) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtu_7021) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtu_7021.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtu_7021) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtu_7021.Merge(m, src)
}
func (m *WlstRtu_7021) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtu_7021) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtu_7021.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtu_7021 proto.InternalMessageInfo

func (m *WlstRtu_7021) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *WlstRtu_7021) GetDataType() int32 {
	if m != nil {
		return m.DataType
	}
	return 0
}

func (m *WlstRtu_7021) GetArgsln() []*WlstRtu_7021_Args_LN {
	if m != nil {
		return m.Argsln
	}
	return nil
}

func (m *WlstRtu_7021) GetStatusCode() int32 {
	if m != nil {
		return m.StatusCode
	}
	return 0
}

func (m *WlstRtu_7021) GetLoopType() int32 {
	if m != nil {
		return m.LoopType
	}
	return 0
}

func (m *WlstRtu_7021) GetArgswc() []*WlstRtu_7021_Args_WC {
	if m != nil {
		return m.Argswc
	}
	return nil
}

type WlstRtu_7021_Args_LN struct {
	// 回路启用标识,1-12回路序号,填充回路号,超范围无视,不启用的回路不用填充
	LoopNo int32 `protobuf:"varint,1,opt,name=loop_no,json=loopNo,proto3" json:"loop_no,omitempty"`
	// 基础值(0-200)
	BaseValue int32 `protobuf:"varint,2,opt,name=base_value,json=baseValue,proto3" json:"base_value,omitempty"`
	// 报警阀值(0-200)
	AlarmValue int32 `protobuf:"varint,3,opt,name=alarm_value,json=alarmValue,proto3" json:"alarm_value,omitempty"`
	// 分闸阀值(0-200)
	BreakValue int32 `protobuf:"varint,4,opt,name=break_value,json=breakValue,proto3" json:"break_value,omitempty"`
}

func (m *WlstRtu_7021_Args_LN) Reset()         { *m = WlstRtu_7021_Args_LN{} }
func (m *WlstRtu_7021_Args_LN) String() string { return proto.CompactTextString(m) }
func (*WlstRtu_7021_Args_LN) ProtoMessage()    {}
func (*WlstRtu_7021_Args_LN) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{2, 0}
}
func (m *WlstRtu_7021_Args_LN) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtu_7021_Args_LN) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtu_7021_Args_LN.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtu_7021_Args_LN) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtu_7021_Args_LN.Merge(m, src)
}
func (m *WlstRtu_7021_Args_LN) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtu_7021_Args_LN) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtu_7021_Args_LN.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtu_7021_Args_LN proto.InternalMessageInfo

func (m *WlstRtu_7021_Args_LN) GetLoopNo() int32 {
	if m != nil {
		return m.LoopNo
	}
	return 0
}

func (m *WlstRtu_7021_Args_LN) GetBaseValue() int32 {
	if m != nil {
		return m.BaseValue
	}
	return 0
}

func (m *WlstRtu_7021_Args_LN) GetAlarmValue() int32 {
	if m != nil {
		return m.AlarmValue
	}
	return 0
}

func (m *WlstRtu_7021_Args_LN) GetBreakValue() int32 {
	if m != nil {
		return m.BreakValue
	}
	return 0
}

type WlstRtu_7021_Args_WC struct {
	// L1开灯时间(时*60+分钟,不操作填1500)
	L1On int32 `protobuf:"varint,1,opt,name=l1_on,json=l1On,proto3" json:"l1_on,omitempty"`
	// L1关灯时间
	L1Off int32 `protobuf:"varint,2,opt,name=l1_off,json=l1Off,proto3" json:"l1_off,omitempty"`
	// L2开灯时间
	L2On int32 `protobuf:"varint,3,opt,name=l2_on,json=l2On,proto3" json:"l2_on,omitempty"`
	// L2关灯时间
	L2Off int32 `protobuf:"varint,4,opt,name=l2_off,json=l2Off,proto3" json:"l2_off,omitempty"`
	// L3开灯时间
	L3On int32 `protobuf:"varint,5,opt,name=l3_on,json=l3On,proto3" json:"l3_on,omitempty"`
	// L3关灯时间
	L3Off int32 `protobuf:"varint,6,opt,name=l3_off,json=l3Off,proto3" json:"l3_off,omitempty"`
	// L4开灯时间
	L4On int32 `protobuf:"varint,7,opt,name=l4_on,json=l4On,proto3" json:"l4_on,omitempty"`
	// L4关灯时间
	L4Off int32 `protobuf:"varint,8,opt,name=l4_off,json=l4Off,proto3" json:"l4_off,omitempty"`
	// L5开灯时间
	L5On int32 `protobuf:"varint,9,opt,name=l5_on,json=l5On,proto3" json:"l5_on,omitempty"`
	// L5关灯时间
	L5Off int32 `protobuf:"varint,10,opt,name=l5_off,json=l5Off,proto3" json:"l5_off,omitempty"`
	// L6开灯时间
	L6On int32 `protobuf:"varint,11,opt,name=l6_on,json=l6On,proto3" json:"l6_on,omitempty"`
	// L6关灯时间
	L6Off int32 `protobuf:"varint,12,opt,name=l6_off,json=l6Off,proto3" json:"l6_off,omitempty"`
	// L7开灯时间
	L7On int32 `protobuf:"varint,13,opt,name=l7_on,json=l7On,proto3" json:"l7_on,omitempty"`
	// L7关灯时间
	L7Off int32 `protobuf:"varint,14,opt,name=l7_off,json=l7Off,proto3" json:"l7_off,omitempty"`
	// L8开灯时间
	L8On int32 `protobuf:"varint,15,opt,name=l8_on,json=l8On,proto3" json:"l8_on,omitempty"`
	// L8关灯时间
	L8Off int32 `protobuf:"varint,16,opt,name=l8_off,json=l8Off,proto3" json:"l8_off,omitempty"`
}

func (m *WlstRtu_7021_Args_WC) Reset()         { *m = WlstRtu_7021_Args_WC{} }
func (m *WlstRtu_7021_Args_WC) String() string { return proto.CompactTextString(m) }
func (*WlstRtu_7021_Args_WC) ProtoMessage()    {}
func (*WlstRtu_7021_Args_WC) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{2, 1}
}
func (m *WlstRtu_7021_Args_WC) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtu_7021_Args_WC) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtu_7021_Args_WC.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtu_7021_Args_WC) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtu_7021_Args_WC.Merge(m, src)
}
func (m *WlstRtu_7021_Args_WC) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtu_7021_Args_WC) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtu_7021_Args_WC.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtu_7021_Args_WC proto.InternalMessageInfo

func (m *WlstRtu_7021_Args_WC) GetL1On() int32 {
	if m != nil {
		return m.L1On
	}
	return 0
}

func (m *WlstRtu_7021_Args_WC) GetL1Off() int32 {
	if m != nil {
		return m.L1Off
	}
	return 0
}

func (m *WlstRtu_7021_Args_WC) GetL2On() int32 {
	if m != nil {
		return m.L2On
	}
	return 0
}

func (m *WlstRtu_7021_Args_WC) GetL2Off() int32 {
	if m != nil {
		return m.L2Off
	}
	return 0
}

func (m *WlstRtu_7021_Args_WC) GetL3On() int32 {
	if m != nil {
		return m.L3On
	}
	return 0
}

func (m *WlstRtu_7021_Args_WC) GetL3Off() int32 {
	if m != nil {
		return m.L3Off
	}
	return 0
}

func (m *WlstRtu_7021_Args_WC) GetL4On() int32 {
	if m != nil {
		return m.L4On
	}
	return 0
}

func (m *WlstRtu_7021_Args_WC) GetL4Off() int32 {
	if m != nil {
		return m.L4Off
	}
	return 0
}

func (m *WlstRtu_7021_Args_WC) GetL5On() int32 {
	if m != nil {
		return m.L5On
	}
	return 0
}

func (m *WlstRtu_7021_Args_WC) GetL5Off() int32 {
	if m != nil {
		return m.L5Off
	}
	return 0
}

func (m *WlstRtu_7021_Args_WC) GetL6On() int32 {
	if m != nil {
		return m.L6On
	}
	return 0
}

func (m *WlstRtu_7021_Args_WC) GetL6Off() int32 {
	if m != nil {
		return m.L6Off
	}
	return 0
}

func (m *WlstRtu_7021_Args_WC) GetL7On() int32 {
	if m != nil {
		return m.L7On
	}
	return 0
}

func (m *WlstRtu_7021_Args_WC) GetL7Off() int32 {
	if m != nil {
		return m.L7Off
	}
	return 0
}

func (m *WlstRtu_7021_Args_WC) GetL8On() int32 {
	if m != nil {
		return m.L8On
	}
	return 0
}

func (m *WlstRtu_7021_Args_WC) GetL8Off() int32 {
	if m != nil {
		return m.L8Off
	}
	return 0
}

// 遥控
type WlstRtu_7023 struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 参数类别，1-遥控
	DataType int32 `protobuf:"varint,2,opt,name=data_type,json=dataType,proto3" json:"data_type,omitempty"`
	// 控制参数
	Argscontrol []*WlstRtu_7023_Args_Control `protobuf:"bytes,3,rep,name=argscontrol,proto3" json:"argscontrol,omitempty"`
	// 应答状态码 0-成功
	StatusCode int32 `protobuf:"varint,4,opt,name=status_code,json=statusCode,proto3" json:"status_code,omitempty"`
}

func (m *WlstRtu_7023) Reset()         { *m = WlstRtu_7023{} }
func (m *WlstRtu_7023) String() string { return proto.CompactTextString(m) }
func (*WlstRtu_7023) ProtoMessage()    {}
func (*WlstRtu_7023) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{3}
}
func (m *WlstRtu_7023) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtu_7023) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtu_7023.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtu_7023) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtu_7023.Merge(m, src)
}
func (m *WlstRtu_7023) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtu_7023) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtu_7023.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtu_7023 proto.InternalMessageInfo

func (m *WlstRtu_7023) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *WlstRtu_7023) GetDataType() int32 {
	if m != nil {
		return m.DataType
	}
	return 0
}

func (m *WlstRtu_7023) GetArgscontrol() []*WlstRtu_7023_Args_Control {
	if m != nil {
		return m.Argscontrol
	}
	return nil
}

func (m *WlstRtu_7023) GetStatusCode() int32 {
	if m != nil {
		return m.StatusCode
	}
	return 0
}

type WlstRtu_7023_Args_Control struct {
	// 回路启用标识,1-24回路序号,填充回路号,超范围无视,不启用的回路不用填充
	LoopNo int32 `protobuf:"varint,1,opt,name=loop_no,json=loopNo,proto3" json:"loop_no,omitempty"`
	// 开关标识 0-关,1-开
	Operation int32 `protobuf:"varint,2,opt,name=operation,proto3" json:"operation,omitempty"`
}

func (m *WlstRtu_7023_Args_Control) Reset()         { *m = WlstRtu_7023_Args_Control{} }
func (m *WlstRtu_7023_Args_Control) String() string { return proto.CompactTextString(m) }
func (*WlstRtu_7023_Args_Control) ProtoMessage()    {}
func (*WlstRtu_7023_Args_Control) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{3, 0}
}
func (m *WlstRtu_7023_Args_Control) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtu_7023_Args_Control) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtu_7023_Args_Control.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtu_7023_Args_Control) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtu_7023_Args_Control.Merge(m, src)
}
func (m *WlstRtu_7023_Args_Control) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtu_7023_Args_Control) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtu_7023_Args_Control.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtu_7023_Args_Control proto.InternalMessageInfo

func (m *WlstRtu_7023_Args_Control) GetLoopNo() int32 {
	if m != nil {
		return m.LoopNo
	}
	return 0
}

func (m *WlstRtu_7023_Args_Control) GetOperation() int32 {
	if m != nil {
		return m.Operation
	}
	return 0
}

// 硬件相关参数招测
type WlstRtu_705B struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 数据类型，1-硬件版本信息
	CmdType int32 `protobuf:"varint,2,opt,name=cmd_type,json=cmdType,proto3" json:"cmd_type,omitempty"`
	// 硬件版本
	HardwareVer string `protobuf:"bytes,3,opt,name=hardware_ver,json=hardwareVer,proto3" json:"hardware_ver,omitempty"`
	// 生产批次,年周 如：1820
	ProductionBatch string `protobuf:"bytes,4,opt,name=production_batch,json=productionBatch,proto3" json:"production_batch,omitempty"`
	// 生产日期,年月日
	ProductionDate string `protobuf:"bytes,5,opt,name=production_date,json=productionDate,proto3" json:"production_date,omitempty"`
	// 安装日期，年月日
	InstallationDate string `protobuf:"bytes,6,opt,name=installation_date,json=installationDate,proto3" json:"installation_date,omitempty"`
}

func (m *WlstRtu_705B) Reset()         { *m = WlstRtu_705B{} }
func (m *WlstRtu_705B) String() string { return proto.CompactTextString(m) }
func (*WlstRtu_705B) ProtoMessage()    {}
func (*WlstRtu_705B) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{4}
}
func (m *WlstRtu_705B) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtu_705B) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtu_705B.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtu_705B) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtu_705B.Merge(m, src)
}
func (m *WlstRtu_705B) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtu_705B) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtu_705B.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtu_705B proto.InternalMessageInfo

func (m *WlstRtu_705B) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *WlstRtu_705B) GetCmdType() int32 {
	if m != nil {
		return m.CmdType
	}
	return 0
}

func (m *WlstRtu_705B) GetHardwareVer() string {
	if m != nil {
		return m.HardwareVer
	}
	return ""
}

func (m *WlstRtu_705B) GetProductionBatch() string {
	if m != nil {
		return m.ProductionBatch
	}
	return ""
}

func (m *WlstRtu_705B) GetProductionDate() string {
	if m != nil {
		return m.ProductionDate
	}
	return ""
}

func (m *WlstRtu_705B) GetInstallationDate() string {
	if m != nil {
		return m.InstallationDate
	}
	return ""
}

// 电能计量
type WlstRtu_70A0 struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 数据类型，1-电能计量，2-辅助数据+gps定位数据,3-24路输出选测数据
	CmdType int32 `protobuf:"varint,2,opt,name=cmd_type,json=cmdType,proto3" json:"cmd_type,omitempty"`
	// 频率，cmd_type==1时填
	Frequency float32 `protobuf:"fixed32,3,opt,name=frequency,proto3" json:"frequency,omitempty"`
	// 依次三相位电能数据
	Ee []*WlstRtu_70A0_ElectricEnergy `protobuf:"bytes,4,rep,name=ee,proto3" json:"ee,omitempty"`
	// 温度，-25-100，cmd_type==2,3时填
	Temperature int32 `protobuf:"varint,5,opt,name=temperature,proto3" json:"temperature,omitempty"`
	// 湿度，0-99%，cmd_type==2,3时填
	Humidity int32 `protobuf:"varint,6,opt,name=humidity,proto3" json:"humidity,omitempty"`
	// 主电源电压，cmd_type==2,3时填
	MainVoltage float64 `protobuf:"fixed64,7,opt,name=main_voltage,json=mainVoltage,proto3" json:"main_voltage,omitempty"`
	// 蓄电池电量，cmd_type==2时填
	BatteryPower int32 `protobuf:"varint,8,opt,name=battery_power,json=batteryPower,proto3" json:"battery_power,omitempty"`
	// 经度，cmd_type==2时填
	Longitude float64 `protobuf:"fixed64,9,opt,name=longitude,proto3" json:"longitude,omitempty"`
	// 纬度，cmd_type==2时填
	Latitude float64 `protobuf:"fixed64,10,opt,name=latitude,proto3" json:"latitude,omitempty"`
	// cmd_type==2时填
	Gpsargs *WlstRtu_70A0_GpsArgs `protobuf:"bytes,11,opt,name=gpsargs,proto3" json:"gpsargs,omitempty"`
	// 开关量输入状态 0-断,1-通，cmd_type==3时填
	SwitchInStPacked []int32 `protobuf:"varint,12,rep,packed,name=switch_in_st_packed,json=switchInStPacked,proto3" json:"switch_in_st_packed,omitempty"`
	// 开关量输出状态 0-断,1-通，cmd_type==3时填
	SwitchOutStPacked []int32 `protobuf:"varint,13,rep,packed,name=switch_out_st_packed,json=switchOutStPacked,proto3" json:"switch_out_st_packed,omitempty"`
	// 终端运行状态，cmd_type==3时填
	// [供电位0-有电,1-无电;开机申请位,0-无,1-开机;停运位,0-正常,1-停运;报警位,0-无警,1-告警;电压超限,0-正常,1-超限;电流超限,0-正常,1-超限;无电流报警,0-正常,1-报警;参数错误,0-正常,1-错误]
	TmlStPacked []int32 `protobuf:"varint,14,rep,packed,name=tml_st_packed,json=tmlStPacked,proto3" json:"tml_st_packed,omitempty"`
	// 终端复位次数[当前,昨天,前天,大前天]，cmd_type==3时填
	TmlReset []int32 `protobuf:"varint,15,rep,packed,name=tml_reset,json=tmlReset,proto3" json:"tml_reset,omitempty"`
	// 回路数量，cmd_type==3时填
	LoopCount int32 `protobuf:"varint,16,opt,name=loop_count,json=loopCount,proto3" json:"loop_count,omitempty"`
}

func (m *WlstRtu_70A0) Reset()         { *m = WlstRtu_70A0{} }
func (m *WlstRtu_70A0) String() string { return proto.CompactTextString(m) }
func (*WlstRtu_70A0) ProtoMessage()    {}
func (*WlstRtu_70A0) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{5}
}
func (m *WlstRtu_70A0) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtu_70A0) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtu_70A0.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtu_70A0) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtu_70A0.Merge(m, src)
}
func (m *WlstRtu_70A0) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtu_70A0) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtu_70A0.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtu_70A0 proto.InternalMessageInfo

func (m *WlstRtu_70A0) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *WlstRtu_70A0) GetCmdType() int32 {
	if m != nil {
		return m.CmdType
	}
	return 0
}

func (m *WlstRtu_70A0) GetFrequency() float32 {
	if m != nil {
		return m.Frequency
	}
	return 0
}

func (m *WlstRtu_70A0) GetEe() []*WlstRtu_70A0_ElectricEnergy {
	if m != nil {
		return m.Ee
	}
	return nil
}

func (m *WlstRtu_70A0) GetTemperature() int32 {
	if m != nil {
		return m.Temperature
	}
	return 0
}

func (m *WlstRtu_70A0) GetHumidity() int32 {
	if m != nil {
		return m.Humidity
	}
	return 0
}

func (m *WlstRtu_70A0) GetMainVoltage() float64 {
	if m != nil {
		return m.MainVoltage
	}
	return 0
}

func (m *WlstRtu_70A0) GetBatteryPower() int32 {
	if m != nil {
		return m.BatteryPower
	}
	return 0
}

func (m *WlstRtu_70A0) GetLongitude() float64 {
	if m != nil {
		return m.Longitude
	}
	return 0
}

func (m *WlstRtu_70A0) GetLatitude() float64 {
	if m != nil {
		return m.Latitude
	}
	return 0
}

func (m *WlstRtu_70A0) GetGpsargs() *WlstRtu_70A0_GpsArgs {
	if m != nil {
		return m.Gpsargs
	}
	return nil
}

func (m *WlstRtu_70A0) GetSwitchInStPacked() []int32 {
	if m != nil {
		return m.SwitchInStPacked
	}
	return nil
}

func (m *WlstRtu_70A0) GetSwitchOutStPacked() []int32 {
	if m != nil {
		return m.SwitchOutStPacked
	}
	return nil
}

func (m *WlstRtu_70A0) GetTmlStPacked() []int32 {
	if m != nil {
		return m.TmlStPacked
	}
	return nil
}

func (m *WlstRtu_70A0) GetTmlReset() []int32 {
	if m != nil {
		return m.TmlReset
	}
	return nil
}

func (m *WlstRtu_70A0) GetLoopCount() int32 {
	if m != nil {
		return m.LoopCount
	}
	return 0
}

type WlstRtu_70A0_ElectricEnergy struct {
	// 电压，cmd_type==1，3时填
	Voltage float32 `protobuf:"fixed32,1,opt,name=voltage,proto3" json:"voltage,omitempty"`
	// 电流，cmd_type==1，3时填
	Current float32 `protobuf:"fixed32,2,opt,name=current,proto3" json:"current,omitempty"`
	// 功率因素，cmd_type==1时填
	PowerFactor float32 `protobuf:"fixed32,3,opt,name=power_factor,json=powerFactor,proto3" json:"power_factor,omitempty"`
	// 有功功率，cmd_type==1，3时填
	ActivePower float32 `protobuf:"fixed32,4,opt,name=active_power,json=activePower,proto3" json:"active_power,omitempty"`
	// 无功功率，cmd_type==1时填
	ReactivePower float32 `protobuf:"fixed32,5,opt,name=reactive_power,json=reactivePower,proto3" json:"reactive_power,omitempty"`
	// 有功电能，cmd_type==1时填
	ActiveEnergy float32 `protobuf:"fixed32,6,opt,name=active_energy,json=activeEnergy,proto3" json:"active_energy,omitempty"`
	// 无功电能，cmd_type==1时填
	ReactiveEnergy float32 `protobuf:"fixed32,7,opt,name=reactive_energy,json=reactiveEnergy,proto3" json:"reactive_energy,omitempty"`
}

func (m *WlstRtu_70A0_ElectricEnergy) Reset()         { *m = WlstRtu_70A0_ElectricEnergy{} }
func (m *WlstRtu_70A0_ElectricEnergy) String() string { return proto.CompactTextString(m) }
func (*WlstRtu_70A0_ElectricEnergy) ProtoMessage()    {}
func (*WlstRtu_70A0_ElectricEnergy) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{5, 0}
}
func (m *WlstRtu_70A0_ElectricEnergy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtu_70A0_ElectricEnergy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtu_70A0_ElectricEnergy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtu_70A0_ElectricEnergy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtu_70A0_ElectricEnergy.Merge(m, src)
}
func (m *WlstRtu_70A0_ElectricEnergy) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtu_70A0_ElectricEnergy) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtu_70A0_ElectricEnergy.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtu_70A0_ElectricEnergy proto.InternalMessageInfo

func (m *WlstRtu_70A0_ElectricEnergy) GetVoltage() float32 {
	if m != nil {
		return m.Voltage
	}
	return 0
}

func (m *WlstRtu_70A0_ElectricEnergy) GetCurrent() float32 {
	if m != nil {
		return m.Current
	}
	return 0
}

func (m *WlstRtu_70A0_ElectricEnergy) GetPowerFactor() float32 {
	if m != nil {
		return m.PowerFactor
	}
	return 0
}

func (m *WlstRtu_70A0_ElectricEnergy) GetActivePower() float32 {
	if m != nil {
		return m.ActivePower
	}
	return 0
}

func (m *WlstRtu_70A0_ElectricEnergy) GetReactivePower() float32 {
	if m != nil {
		return m.ReactivePower
	}
	return 0
}

func (m *WlstRtu_70A0_ElectricEnergy) GetActiveEnergy() float32 {
	if m != nil {
		return m.ActiveEnergy
	}
	return 0
}

func (m *WlstRtu_70A0_ElectricEnergy) GetReactiveEnergy() float32 {
	if m != nil {
		return m.ReactiveEnergy
	}
	return 0
}

type WlstRtu_70A0_GpsArgs struct {
	// 定位方式:1—GPS定位,2—北斗定位,3—混合定位
	GpsType int32 `protobuf:"varint,1,opt,name=gps_type,json=gpsType,proto3" json:"gps_type,omitempty"`
	// 纬度类型：0-北纬,1-南纬
	LatType int32 `protobuf:"varint,2,opt,name=lat_type,json=latType,proto3" json:"lat_type,omitempty"`
	// 经度类型：0-东经，1-西经
	LonType int32 `protobuf:"varint,3,opt,name=lon_type,json=lonType,proto3" json:"lon_type,omitempty"`
	// 定位状态：0-未定位,1-已定位
	LocationStatus int32 `protobuf:"varint,4,opt,name=location_status,json=locationStatus,proto3" json:"location_status,omitempty"`
}

func (m *WlstRtu_70A0_GpsArgs) Reset()         { *m = WlstRtu_70A0_GpsArgs{} }
func (m *WlstRtu_70A0_GpsArgs) String() string { return proto.CompactTextString(m) }
func (*WlstRtu_70A0_GpsArgs) ProtoMessage()    {}
func (*WlstRtu_70A0_GpsArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{5, 1}
}
func (m *WlstRtu_70A0_GpsArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtu_70A0_GpsArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtu_70A0_GpsArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtu_70A0_GpsArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtu_70A0_GpsArgs.Merge(m, src)
}
func (m *WlstRtu_70A0_GpsArgs) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtu_70A0_GpsArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtu_70A0_GpsArgs.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtu_70A0_GpsArgs proto.InternalMessageInfo

func (m *WlstRtu_70A0_GpsArgs) GetGpsType() int32 {
	if m != nil {
		return m.GpsType
	}
	return 0
}

func (m *WlstRtu_70A0_GpsArgs) GetLatType() int32 {
	if m != nil {
		return m.LatType
	}
	return 0
}

func (m *WlstRtu_70A0_GpsArgs) GetLonType() int32 {
	if m != nil {
		return m.LonType
	}
	return 0
}

func (m *WlstRtu_70A0_GpsArgs) GetLocationStatus() int32 {
	if m != nil {
		return m.LocationStatus
	}
	return 0
}

// sd卡数据招测
type WlstRtu_7053 struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 记录类型 1-每天一条的最大电压电流数据,2-2s一条的普通选测数据
	RecordType int32 `protobuf:"varint,2,opt,name=record_type,json=recordType,proto3" json:"record_type,omitempty"`
	// 查询开始时间
	DtStart int64 `protobuf:"varint,3,opt,name=dt_start,json=dtStart,proto3" json:"dt_start,omitempty"`
	// 查询数据条数
	RecordCount int32 `protobuf:"varint,4,opt,name=record_count,json=recordCount,proto3" json:"record_count,omitempty"`
	// 查询时间间隔(单位秒)
	RecordDistance int64 `protobuf:"varint,5,opt,name=record_distance,json=recordDistance,proto3" json:"record_distance,omitempty"`
}

func (m *WlstRtu_7053) Reset()         { *m = WlstRtu_7053{} }
func (m *WlstRtu_7053) String() string { return proto.CompactTextString(m) }
func (*WlstRtu_7053) ProtoMessage()    {}
func (*WlstRtu_7053) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{6}
}
func (m *WlstRtu_7053) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtu_7053) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtu_7053.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtu_7053) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtu_7053.Merge(m, src)
}
func (m *WlstRtu_7053) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtu_7053) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtu_7053.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtu_7053 proto.InternalMessageInfo

func (m *WlstRtu_7053) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *WlstRtu_7053) GetRecordType() int32 {
	if m != nil {
		return m.RecordType
	}
	return 0
}

func (m *WlstRtu_7053) GetDtStart() int64 {
	if m != nil {
		return m.DtStart
	}
	return 0
}

func (m *WlstRtu_7053) GetRecordCount() int32 {
	if m != nil {
		return m.RecordCount
	}
	return 0
}

func (m *WlstRtu_7053) GetRecordDistance() int64 {
	if m != nil {
		return m.RecordDistance
	}
	return 0
}

// sd卡数据招测应答
type WlstRtu_70D3 struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 总包数
	RecordTotal int32 `protobuf:"varint,2,opt,name=record_total,json=recordTotal,proto3" json:"record_total,omitempty"`
	// 当前序号
	RecordIdx int32 `protobuf:"varint,3,opt,name=record_idx,json=recordIdx,proto3" json:"record_idx,omitempty"`
	// 当前数据包错误标志，0：正常,1-6：sd功能错误,7：无sd卡,8:记录时间错误,9：查询开始时间错误,10：查询截止时间错误,11：时间间隔错误,12：记录类型错误,13：记录数据错误
	RecordStatus int32 `protobuf:"varint,4,opt,name=record_status,json=recordStatus,proto3" json:"record_status,omitempty"`
	// 记录类型 1-2s一条的普通选测数据,2-每天一条的最大电压电流数据
	RecordType int32 `protobuf:"varint,5,opt,name=record_type,json=recordType,proto3" json:"record_type,omitempty"`
	// 查询开始时间
	DtStart int64 `protobuf:"varint,6,opt,name=dt_start,json=dtStart,proto3" json:"dt_start,omitempty"`
	// 查询数据条数
	RecordCount int32 `protobuf:"varint,7,opt,name=record_count,json=recordCount,proto3" json:"record_count,omitempty"`
	// 查询时间间隔(单位秒)
	RecordDistance int64 `protobuf:"varint,8,opt,name=record_distance,json=recordDistance,proto3" json:"record_distance,omitempty"`
	// 数据类型1
	Data_70D0 []*WlstRtu_70D0 `protobuf:"bytes,9,rep,name=data_70d0,json=data70d0,proto3" json:"data_70d0,omitempty"`
	// 数据类型2
	Data_70D0Max []*WlstRtu_70D0Max `protobuf:"bytes,10,rep,name=data_70d0_max,json=data70d0Max,proto3" json:"data_70d0_max,omitempty"`
}

func (m *WlstRtu_70D3) Reset()         { *m = WlstRtu_70D3{} }
func (m *WlstRtu_70D3) String() string { return proto.CompactTextString(m) }
func (*WlstRtu_70D3) ProtoMessage()    {}
func (*WlstRtu_70D3) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{7}
}
func (m *WlstRtu_70D3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtu_70D3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtu_70D3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtu_70D3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtu_70D3.Merge(m, src)
}
func (m *WlstRtu_70D3) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtu_70D3) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtu_70D3.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtu_70D3 proto.InternalMessageInfo

func (m *WlstRtu_70D3) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *WlstRtu_70D3) GetRecordTotal() int32 {
	if m != nil {
		return m.RecordTotal
	}
	return 0
}

func (m *WlstRtu_70D3) GetRecordIdx() int32 {
	if m != nil {
		return m.RecordIdx
	}
	return 0
}

func (m *WlstRtu_70D3) GetRecordStatus() int32 {
	if m != nil {
		return m.RecordStatus
	}
	return 0
}

func (m *WlstRtu_70D3) GetRecordType() int32 {
	if m != nil {
		return m.RecordType
	}
	return 0
}

func (m *WlstRtu_70D3) GetDtStart() int64 {
	if m != nil {
		return m.DtStart
	}
	return 0
}

func (m *WlstRtu_70D3) GetRecordCount() int32 {
	if m != nil {
		return m.RecordCount
	}
	return 0
}

func (m *WlstRtu_70D3) GetRecordDistance() int64 {
	if m != nil {
		return m.RecordDistance
	}
	return 0
}

func (m *WlstRtu_70D3) GetData_70D0() []*WlstRtu_70D0 {
	if m != nil {
		return m.Data_70D0
	}
	return nil
}

func (m *WlstRtu_70D3) GetData_70D0Max() []*WlstRtu_70D0Max {
	if m != nil {
		return m.Data_70D0Max
	}
	return nil
}

type WlstRtu_70D0Max struct {
	// 记录时间
	DtRecord int64 `protobuf:"varint,1,opt,name=dt_record,json=dtRecord,proto3" json:"dt_record,omitempty"`
	// 记录类型
	RecordType int32 `protobuf:"varint,2,opt,name=record_type,json=recordType,proto3" json:"record_type,omitempty"`
	// 回路数量
	LoopCount int32                      `protobuf:"varint,3,opt,name=loop_count,json=loopCount,proto3" json:"loop_count,omitempty"`
	MaxData   []*WlstRtu_70D0Max_MaxData `protobuf:"bytes,4,rep,name=max_data,json=maxData,proto3" json:"max_data,omitempty"`
}

func (m *WlstRtu_70D0Max) Reset()         { *m = WlstRtu_70D0Max{} }
func (m *WlstRtu_70D0Max) String() string { return proto.CompactTextString(m) }
func (*WlstRtu_70D0Max) ProtoMessage()    {}
func (*WlstRtu_70D0Max) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{8}
}
func (m *WlstRtu_70D0Max) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtu_70D0Max) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtu_70D0Max.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtu_70D0Max) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtu_70D0Max.Merge(m, src)
}
func (m *WlstRtu_70D0Max) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtu_70D0Max) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtu_70D0Max.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtu_70D0Max proto.InternalMessageInfo

func (m *WlstRtu_70D0Max) GetDtRecord() int64 {
	if m != nil {
		return m.DtRecord
	}
	return 0
}

func (m *WlstRtu_70D0Max) GetRecordType() int32 {
	if m != nil {
		return m.RecordType
	}
	return 0
}

func (m *WlstRtu_70D0Max) GetLoopCount() int32 {
	if m != nil {
		return m.LoopCount
	}
	return 0
}

func (m *WlstRtu_70D0Max) GetMaxData() []*WlstRtu_70D0Max_MaxData {
	if m != nil {
		return m.MaxData
	}
	return nil
}

type WlstRtu_70D0Max_MaxData struct {
	// 依次回路最大电流
	CurrentMax float64 `protobuf:"fixed64,1,opt,name=current_max,json=currentMax,proto3" json:"current_max,omitempty"`
	// 回路电流发生时间
	DtRecord int64 `protobuf:"varint,2,opt,name=dt_record,json=dtRecord,proto3" json:"dt_record,omitempty"`
}

func (m *WlstRtu_70D0Max_MaxData) Reset()         { *m = WlstRtu_70D0Max_MaxData{} }
func (m *WlstRtu_70D0Max_MaxData) String() string { return proto.CompactTextString(m) }
func (*WlstRtu_70D0Max_MaxData) ProtoMessage()    {}
func (*WlstRtu_70D0Max_MaxData) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{8, 0}
}
func (m *WlstRtu_70D0Max_MaxData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtu_70D0Max_MaxData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtu_70D0Max_MaxData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtu_70D0Max_MaxData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtu_70D0Max_MaxData.Merge(m, src)
}
func (m *WlstRtu_70D0Max_MaxData) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtu_70D0Max_MaxData) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtu_70D0Max_MaxData.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtu_70D0Max_MaxData proto.InternalMessageInfo

func (m *WlstRtu_70D0Max_MaxData) GetCurrentMax() float64 {
	if m != nil {
		return m.CurrentMax
	}
	return 0
}

func (m *WlstRtu_70D0Max_MaxData) GetDtRecord() int64 {
	if m != nil {
		return m.DtRecord
	}
	return 0
}

//事件招测
type WlstRtu_7800 struct {
	// 事件类型(上下行)
	EventType int32 `protobuf:"varint,1,opt,name=event_type,json=eventType,proto3" json:"event_type,omitempty"`
	// 分类标识(上下行)
	EventClass int32 `protobuf:"varint,2,opt,name=event_class,json=eventClass,proto3" json:"event_class,omitempty"`
	// 记录条数(上下行)
	DataNum int32 `protobuf:"varint,3,opt,name=data_num,json=dataNum,proto3" json:"data_num,omitempty"`
	// 开始时间(下行)
	DtStart int64 `protobuf:"varint,4,opt,name=dt_start,json=dtStart,proto3" json:"dt_start,omitempty"`
	// 结束时间(下行)
	DtEnd int64 `protobuf:"varint,5,opt,name=dt_end,json=dtEnd,proto3" json:"dt_end,omitempty"`
	// 总包数(上行)
	AllNum int32 `protobuf:"varint,6,opt,name=all_num,json=allNum,proto3" json:"all_num,omitempty"`
	// 当前包(上行)
	CurNum int32 `protobuf:"varint,7,opt,name=cur_num,json=curNum,proto3" json:"cur_num,omitempty"`
	// 原始数据(上行)
	RawData string `protobuf:"bytes,8,opt,name=raw_data,json=rawData,proto3" json:"raw_data,omitempty"`
}

func (m *WlstRtu_7800) Reset()         { *m = WlstRtu_7800{} }
func (m *WlstRtu_7800) String() string { return proto.CompactTextString(m) }
func (*WlstRtu_7800) ProtoMessage()    {}
func (*WlstRtu_7800) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{9}
}
func (m *WlstRtu_7800) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtu_7800) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtu_7800.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtu_7800) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtu_7800.Merge(m, src)
}
func (m *WlstRtu_7800) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtu_7800) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtu_7800.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtu_7800 proto.InternalMessageInfo

func (m *WlstRtu_7800) GetEventType() int32 {
	if m != nil {
		return m.EventType
	}
	return 0
}

func (m *WlstRtu_7800) GetEventClass() int32 {
	if m != nil {
		return m.EventClass
	}
	return 0
}

func (m *WlstRtu_7800) GetDataNum() int32 {
	if m != nil {
		return m.DataNum
	}
	return 0
}

func (m *WlstRtu_7800) GetDtStart() int64 {
	if m != nil {
		return m.DtStart
	}
	return 0
}

func (m *WlstRtu_7800) GetDtEnd() int64 {
	if m != nil {
		return m.DtEnd
	}
	return 0
}

func (m *WlstRtu_7800) GetAllNum() int32 {
	if m != nil {
		return m.AllNum
	}
	return 0
}

func (m *WlstRtu_7800) GetCurNum() int32 {
	if m != nil {
		return m.CurNum
	}
	return 0
}

func (m *WlstRtu_7800) GetRawData() string {
	if m != nil {
		return m.RawData
	}
	return ""
}

//新版选测
type WlstRtu_7050 struct {
	CmdIdx   int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	DataMark int32 `protobuf:"varint,2,opt,name=data_mark,json=dataMark,proto3" json:"data_mark,omitempty"`
}

func (m *WlstRtu_7050) Reset()         { *m = WlstRtu_7050{} }
func (m *WlstRtu_7050) String() string { return proto.CompactTextString(m) }
func (*WlstRtu_7050) ProtoMessage()    {}
func (*WlstRtu_7050) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{10}
}
func (m *WlstRtu_7050) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtu_7050) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtu_7050.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtu_7050) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtu_7050.Merge(m, src)
}
func (m *WlstRtu_7050) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtu_7050) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtu_7050.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtu_7050 proto.InternalMessageInfo

func (m *WlstRtu_7050) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *WlstRtu_7050) GetDataMark() int32 {
	if m != nil {
		return m.DataMark
	}
	return 0
}

type WlstRtu_70D0 struct {
	// 序号
	// (老版选测也将升级为该结构,若idx==-1表示为老版数据,idx>=0表示新版，idx==-2表示sd卡数据)
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 数据标示
	DataMark *WlstRtu_70D0_DataMark `protobuf:"bytes,2,opt,name=data_mark,json=dataMark,proto3" json:"data_mark,omitempty"`
	// 开关量输入状态,0-断,1-通
	SwitchInStPacked []int32 `protobuf:"varint,3,rep,packed,name=switch_in_st_packed,json=switchInStPacked,proto3" json:"switch_in_st_packed,omitempty"`
	// 开关量输出状态 0-断,1-通
	SwitchOutStPacked []int32 `protobuf:"varint,4,rep,packed,name=switch_out_st_packed,json=switchOutStPacked,proto3" json:"switch_out_st_packed,omitempty"`
	// 终端运行状态
	// [供电位0-有电,1-无电;开机申请位,0-无,1-开机;停运位,0-正常,1-停运;报警位,0-无警,1-告警;电压超限,0-正常,1-超限;电流超限,0-正常,1-超限;无电流报警,0-正常,1-报警;参数错误,0-正常,1-错误]
	TmlStPacked []int32 `protobuf:"varint,5,rep,packed,name=tml_st_packed,json=tmlStPacked,proto3" json:"tml_st_packed,omitempty"`
	// 温度
	Temperature int32 `protobuf:"varint,6,opt,name=temperature,proto3" json:"temperature,omitempty"`
	// gprs掉线次数
	GprsReset int32 `protobuf:"varint,7,opt,name=gprs_reset,json=gprsReset,proto3" json:"gprs_reset,omitempty"`
	// gprs信号强度
	GprsSignal int32 `protobuf:"varint,8,opt,name=gprs_signal,json=gprsSignal,proto3" json:"gprs_signal,omitempty"`
	// 终端复位次数[当前,昨天,前天,大前天]
	TmlReset []int32 `protobuf:"varint,9,rep,packed,name=tml_reset,json=tmlReset,proto3" json:"tml_reset,omitempty"`
	// 终端参数状态,0-正常,1-错误[状态和地址;工作参数;模拟量显示参数;开关量输入路数和跳变报警;开关量输出路数;开关量输入矢量;开关量输出矢量;模拟量上下限;
	//                            时空光控选择标志;1-3继电器开关灯时间;4-6继电器开关灯时间;7-8继电器开关灯时间;组地址;经纬度计算时间;经纬度和偏移;收费时间;
	//                            1-4端节假日;5-8端节假日;最后时限开关灯时间;模拟量相位;模拟量输入矢量;模拟量校准/线路检测参数;线路状态;终端参数错误]
	TmlArgsStatus []int32 `protobuf:"varint,10,rep,packed,name=tml_args_status,json=tmlArgsStatus,proto3" json:"tml_args_status,omitempty"`
	// 供电电压
	PowerSupply float64 `protobuf:"fixed64,11,opt,name=power_supply,json=powerSupply,proto3" json:"power_supply,omitempty"`
	// 采样板电压(数组长度即表示有多少采样板)
	SamplingVoltage []*WlstRtu_70D0_SamplingVoltage `protobuf:"bytes,12,rep,name=sampling_voltage,json=samplingVoltage,proto3" json:"sampling_voltage,omitempty"`
	// 回路数据(数组长度即表示有多少回路)
	AnalogData []*WlstRtu_70D0_AnalogData `protobuf:"bytes,13,rep,name=analog_data,json=analogData,proto3" json:"analog_data,omitempty"`
	// int型赋值
	SwitchInSt  int64 `protobuf:"varint,14,opt,name=switch_in_st,json=switchInSt,proto3" json:"switch_in_st,omitempty"`
	SwitchOutSt int32 `protobuf:"varint,15,opt,name=switch_out_st,json=switchOutSt,proto3" json:"switch_out_st,omitempty"`
	TmlSt       int32 `protobuf:"varint,16,opt,name=tml_st,json=tmlSt,proto3" json:"tml_st,omitempty"`
	// 满量程
	FullRange int32 `protobuf:"varint,17,opt,name=full_range,json=fullRange,proto3" json:"full_range,omitempty"`
	// 记录时间
	DtRecord int64 `protobuf:"varint,18,opt,name=dt_record,json=dtRecord,proto3" json:"dt_record,omitempty"`
	// 最后一次开关量输出状态变化原因，8个回路8个元素，0-时控，1-光控，2-主台，3-面板，4-最后时限，5-年设置
	SwitchOutReason []int32 `protobuf:"varint,19,rep,packed,name=switch_out_reason,json=switchOutReason,proto3" json:"switch_out_reason,omitempty"`
}

func (m *WlstRtu_70D0) Reset()         { *m = WlstRtu_70D0{} }
func (m *WlstRtu_70D0) String() string { return proto.CompactTextString(m) }
func (*WlstRtu_70D0) ProtoMessage()    {}
func (*WlstRtu_70D0) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{11}
}
func (m *WlstRtu_70D0) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtu_70D0) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtu_70D0.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtu_70D0) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtu_70D0.Merge(m, src)
}
func (m *WlstRtu_70D0) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtu_70D0) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtu_70D0.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtu_70D0 proto.InternalMessageInfo

func (m *WlstRtu_70D0) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *WlstRtu_70D0) GetDataMark() *WlstRtu_70D0_DataMark {
	if m != nil {
		return m.DataMark
	}
	return nil
}

func (m *WlstRtu_70D0) GetSwitchInStPacked() []int32 {
	if m != nil {
		return m.SwitchInStPacked
	}
	return nil
}

func (m *WlstRtu_70D0) GetSwitchOutStPacked() []int32 {
	if m != nil {
		return m.SwitchOutStPacked
	}
	return nil
}

func (m *WlstRtu_70D0) GetTmlStPacked() []int32 {
	if m != nil {
		return m.TmlStPacked
	}
	return nil
}

func (m *WlstRtu_70D0) GetTemperature() int32 {
	if m != nil {
		return m.Temperature
	}
	return 0
}

func (m *WlstRtu_70D0) GetGprsReset() int32 {
	if m != nil {
		return m.GprsReset
	}
	return 0
}

func (m *WlstRtu_70D0) GetGprsSignal() int32 {
	if m != nil {
		return m.GprsSignal
	}
	return 0
}

func (m *WlstRtu_70D0) GetTmlReset() []int32 {
	if m != nil {
		return m.TmlReset
	}
	return nil
}

func (m *WlstRtu_70D0) GetTmlArgsStatus() []int32 {
	if m != nil {
		return m.TmlArgsStatus
	}
	return nil
}

func (m *WlstRtu_70D0) GetPowerSupply() float64 {
	if m != nil {
		return m.PowerSupply
	}
	return 0
}

func (m *WlstRtu_70D0) GetSamplingVoltage() []*WlstRtu_70D0_SamplingVoltage {
	if m != nil {
		return m.SamplingVoltage
	}
	return nil
}

func (m *WlstRtu_70D0) GetAnalogData() []*WlstRtu_70D0_AnalogData {
	if m != nil {
		return m.AnalogData
	}
	return nil
}

func (m *WlstRtu_70D0) GetSwitchInSt() int64 {
	if m != nil {
		return m.SwitchInSt
	}
	return 0
}

func (m *WlstRtu_70D0) GetSwitchOutSt() int32 {
	if m != nil {
		return m.SwitchOutSt
	}
	return 0
}

func (m *WlstRtu_70D0) GetTmlSt() int32 {
	if m != nil {
		return m.TmlSt
	}
	return 0
}

func (m *WlstRtu_70D0) GetFullRange() int32 {
	if m != nil {
		return m.FullRange
	}
	return 0
}

func (m *WlstRtu_70D0) GetDtRecord() int64 {
	if m != nil {
		return m.DtRecord
	}
	return 0
}

func (m *WlstRtu_70D0) GetSwitchOutReason() []int32 {
	if m != nil {
		return m.SwitchOutReason
	}
	return nil
}

type WlstRtu_70D0_DataMark struct {
	// 即时选测
	GetRunData int32 `protobuf:"varint,1,opt,name=get_run_data,json=getRunData,proto3" json:"get_run_data,omitempty"`
	// 开关量输出变化原因
	GetSwitchoutReason int32 `protobuf:"varint,2,opt,name=get_switchout_reason,json=getSwitchoutReason,proto3" json:"get_switchout_reason,omitempty"`
}

func (m *WlstRtu_70D0_DataMark) Reset()         { *m = WlstRtu_70D0_DataMark{} }
func (m *WlstRtu_70D0_DataMark) String() string { return proto.CompactTextString(m) }
func (*WlstRtu_70D0_DataMark) ProtoMessage()    {}
func (*WlstRtu_70D0_DataMark) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{11, 0}
}
func (m *WlstRtu_70D0_DataMark) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtu_70D0_DataMark) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtu_70D0_DataMark.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtu_70D0_DataMark) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtu_70D0_DataMark.Merge(m, src)
}
func (m *WlstRtu_70D0_DataMark) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtu_70D0_DataMark) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtu_70D0_DataMark.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtu_70D0_DataMark proto.InternalMessageInfo

func (m *WlstRtu_70D0_DataMark) GetGetRunData() int32 {
	if m != nil {
		return m.GetRunData
	}
	return 0
}

func (m *WlstRtu_70D0_DataMark) GetGetSwitchoutReason() int32 {
	if m != nil {
		return m.GetSwitchoutReason
	}
	return 0
}

// 采样板电压
type WlstRtu_70D0_SamplingVoltage struct {
	VolA float64 `protobuf:"fixed64,1,opt,name=vol_a,json=volA,proto3" json:"vol_a,omitempty"`
	VolB float64 `protobuf:"fixed64,2,opt,name=vol_b,json=volB,proto3" json:"vol_b,omitempty"`
	VolC float64 `protobuf:"fixed64,3,opt,name=vol_c,json=volC,proto3" json:"vol_c,omitempty"`
}

func (m *WlstRtu_70D0_SamplingVoltage) Reset()         { *m = WlstRtu_70D0_SamplingVoltage{} }
func (m *WlstRtu_70D0_SamplingVoltage) String() string { return proto.CompactTextString(m) }
func (*WlstRtu_70D0_SamplingVoltage) ProtoMessage()    {}
func (*WlstRtu_70D0_SamplingVoltage) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{11, 1}
}
func (m *WlstRtu_70D0_SamplingVoltage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtu_70D0_SamplingVoltage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtu_70D0_SamplingVoltage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtu_70D0_SamplingVoltage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtu_70D0_SamplingVoltage.Merge(m, src)
}
func (m *WlstRtu_70D0_SamplingVoltage) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtu_70D0_SamplingVoltage) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtu_70D0_SamplingVoltage.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtu_70D0_SamplingVoltage proto.InternalMessageInfo

func (m *WlstRtu_70D0_SamplingVoltage) GetVolA() float64 {
	if m != nil {
		return m.VolA
	}
	return 0
}

func (m *WlstRtu_70D0_SamplingVoltage) GetVolB() float64 {
	if m != nil {
		return m.VolB
	}
	return 0
}

func (m *WlstRtu_70D0_SamplingVoltage) GetVolC() float64 {
	if m != nil {
		return m.VolC
	}
	return 0
}

type WlstRtu_70D0_AnalogData struct {
	Voltage float64 `protobuf:"fixed64,1,opt,name=voltage,proto3" json:"voltage,omitempty"`
	Current float64 `protobuf:"fixed64,2,opt,name=current,proto3" json:"current,omitempty"`
	Power   float64 `protobuf:"fixed64,3,opt,name=power,proto3" json:"power,omitempty"`
	// 电压越限0-正常，3-满量程，当idx=-1时有效
	VoltageStatus int32 `protobuf:"varint,4,opt,name=voltage_status,json=voltageStatus,proto3" json:"voltage_status,omitempty"`
	// 电压越限0-正常，3-满量程，当idx=-1时有效
	CurrentStatus int32 `protobuf:"varint,5,opt,name=current_status,json=currentStatus,proto3" json:"current_status,omitempty"`
}

func (m *WlstRtu_70D0_AnalogData) Reset()         { *m = WlstRtu_70D0_AnalogData{} }
func (m *WlstRtu_70D0_AnalogData) String() string { return proto.CompactTextString(m) }
func (*WlstRtu_70D0_AnalogData) ProtoMessage()    {}
func (*WlstRtu_70D0_AnalogData) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{11, 2}
}
func (m *WlstRtu_70D0_AnalogData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtu_70D0_AnalogData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtu_70D0_AnalogData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtu_70D0_AnalogData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtu_70D0_AnalogData.Merge(m, src)
}
func (m *WlstRtu_70D0_AnalogData) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtu_70D0_AnalogData) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtu_70D0_AnalogData.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtu_70D0_AnalogData proto.InternalMessageInfo

func (m *WlstRtu_70D0_AnalogData) GetVoltage() float64 {
	if m != nil {
		return m.Voltage
	}
	return 0
}

func (m *WlstRtu_70D0_AnalogData) GetCurrent() float64 {
	if m != nil {
		return m.Current
	}
	return 0
}

func (m *WlstRtu_70D0_AnalogData) GetPower() float64 {
	if m != nil {
		return m.Power
	}
	return 0
}

func (m *WlstRtu_70D0_AnalogData) GetVoltageStatus() int32 {
	if m != nil {
		return m.VoltageStatus
	}
	return 0
}

func (m *WlstRtu_70D0_AnalogData) GetCurrentStatus() int32 {
	if m != nil {
		return m.CurrentStatus
	}
	return 0
}

// 召测终端参数(旧版召测协议也将升级为该结构)
type WlstRtu_705A struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 指令类型，1-招测基础参数，2-招测互感比值
	CmdType int32 `protobuf:"varint,2,opt,name=cmd_type,json=cmdType,proto3" json:"cmd_type,omitempty"`
}

func (m *WlstRtu_705A) Reset()         { *m = WlstRtu_705A{} }
func (m *WlstRtu_705A) String() string { return proto.CompactTextString(m) }
func (*WlstRtu_705A) ProtoMessage()    {}
func (*WlstRtu_705A) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{12}
}
func (m *WlstRtu_705A) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtu_705A) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtu_705A.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtu_705A) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtu_705A.Merge(m, src)
}
func (m *WlstRtu_705A) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtu_705A) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtu_705A.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtu_705A proto.InternalMessageInfo

func (m *WlstRtu_705A) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *WlstRtu_705A) GetCmdType() int32 {
	if m != nil {
		return m.CmdType
	}
	return 0
}

type WlstRtu_70Da struct {
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	//心跳周期
	KeepAlive int32 `protobuf:"varint,2,opt,name=keep_alive,json=keepAlive,proto3" json:"keep_alive,omitempty"`
	//主报周期
	AlarmCycle int32 `protobuf:"varint,3,opt,name=alarm_cycle,json=alarmCycle,proto3" json:"alarm_cycle,omitempty"`
	//报警延时
	AlarmDelay int32 `protobuf:"varint,4,opt,name=alarm_delay,json=alarmDelay,proto3" json:"alarm_delay,omitempty"`
	//开关量输出路数
	SwitchOutSum int32 `protobuf:"varint,5,opt,name=switch_out_sum,json=switchOutSum,proto3" json:"switch_out_sum,omitempty"`
	//开关量输入路数
	SwitchInSum int32 `protobuf:"varint,6,opt,name=switch_in_sum,json=switchInSum,proto3" json:"switch_in_sum,omitempty"`
	//模拟量输入路数
	AnalogSum int32 `protobuf:"varint,7,opt,name=analog_sum,json=analogSum,proto3" json:"analog_sum,omitempty"`
	//开关量输出开关时间 hhmm-hhmm
	XSwitchingTime []string `protobuf:"bytes,8,rep,name=x_switching_time,json=xSwitchingTime,proto3" json:"x_switching_time,omitempty"`
	//市付费启用时分，hhmm
	CityPayTime string `protobuf:"bytes,9,opt,name=city_pay_time,json=cityPayTime,proto3" json:"city_pay_time,omitempty"`
	//自付费启用时分，hhmm
	SelfPayTime string `protobuf:"bytes,10,opt,name=self_pay_time,json=selfPayTime,proto3" json:"self_pay_time,omitempty"`
	//各个开关量输出路数
	XSwitchOutCount []int32 `protobuf:"varint,11,rep,packed,name=x_switch_out_count,json=xSwitchOutCount,proto3" json:"x_switch_out_count,omitempty"`
	//开关量输入1-16跳变
	SwitchInHopping []int32 `protobuf:"varint,12,rep,packed,name=switch_in_hopping,json=switchInHopping,proto3" json:"switch_in_hopping,omitempty"`
	//电压量程
	VoltageRange int32 `protobuf:"varint,13,opt,name=voltage_range,json=voltageRange,proto3" json:"voltage_range,omitempty"`
	//模拟量回路x电流量程
	XCurrentRange []int32 `protobuf:"varint,14,rep,packed,name=x_current_range,json=xCurrentRange,proto3" json:"x_current_range,omitempty"`
	//开关量输出x矢量
	XSwitchOutVector []int32 `protobuf:"varint,15,rep,packed,name=x_switch_out_vector,json=xSwitchOutVector,proto3" json:"x_switch_out_vector,omitempty"`
	//开关量输入x矢量
	XSwitchInVector []int32 `protobuf:"varint,16,rep,packed,name=x_switch_in_vector,json=xSwitchInVector,proto3" json:"x_switch_in_vector,omitempty"`
	//模拟量x失量
	XAnalogVector []int32 `protobuf:"varint,17,rep,packed,name=x_analog_vector,json=xAnalogVector,proto3" json:"x_analog_vector,omitempty"`
	//电压上限
	UpperVoltageLimit int32 `protobuf:"varint,18,opt,name=upper_voltage_limit,json=upperVoltageLimit,proto3" json:"upper_voltage_limit,omitempty"`
	//电压下限
	LowerVoltageLimit int32 `protobuf:"varint,19,opt,name=lower_voltage_limit,json=lowerVoltageLimit,proto3" json:"lower_voltage_limit,omitempty"`
	//模拟量回路x电流上限
	XUpperCurrentLimit []int32 `protobuf:"varint,20,rep,packed,name=x_upper_current_limit,json=xUpperCurrentLimit,proto3" json:"x_upper_current_limit,omitempty"`
	//模拟量回路x电流下限
	XLowerCurrentLimit []int32 `protobuf:"varint,21,rep,packed,name=x_lower_current_limit,json=xLowerCurrentLimit,proto3" json:"x_lower_current_limit,omitempty"`
	//优先组地址
	GroupId int32 `protobuf:"varint,22,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	// 指令类型，1-招测基础参数，2-招测互感比值
	CmdType int32 `protobuf:"varint,23,opt,name=cmd_type,json=cmdType,proto3" json:"cmd_type,omitempty"`
	// ABC三项电能板互感比
	Transformers []int32 `protobuf:"varint,24,rep,packed,name=transformers,proto3" json:"transformers,omitempty"`
}

func (m *WlstRtu_70Da) Reset()         { *m = WlstRtu_70Da{} }
func (m *WlstRtu_70Da) String() string { return proto.CompactTextString(m) }
func (*WlstRtu_70Da) ProtoMessage()    {}
func (*WlstRtu_70Da) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{13}
}
func (m *WlstRtu_70Da) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtu_70Da) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtu_70Da.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtu_70Da) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtu_70Da.Merge(m, src)
}
func (m *WlstRtu_70Da) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtu_70Da) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtu_70Da.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtu_70Da proto.InternalMessageInfo

func (m *WlstRtu_70Da) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *WlstRtu_70Da) GetKeepAlive() int32 {
	if m != nil {
		return m.KeepAlive
	}
	return 0
}

func (m *WlstRtu_70Da) GetAlarmCycle() int32 {
	if m != nil {
		return m.AlarmCycle
	}
	return 0
}

func (m *WlstRtu_70Da) GetAlarmDelay() int32 {
	if m != nil {
		return m.AlarmDelay
	}
	return 0
}

func (m *WlstRtu_70Da) GetSwitchOutSum() int32 {
	if m != nil {
		return m.SwitchOutSum
	}
	return 0
}

func (m *WlstRtu_70Da) GetSwitchInSum() int32 {
	if m != nil {
		return m.SwitchInSum
	}
	return 0
}

func (m *WlstRtu_70Da) GetAnalogSum() int32 {
	if m != nil {
		return m.AnalogSum
	}
	return 0
}

func (m *WlstRtu_70Da) GetXSwitchingTime() []string {
	if m != nil {
		return m.XSwitchingTime
	}
	return nil
}

func (m *WlstRtu_70Da) GetCityPayTime() string {
	if m != nil {
		return m.CityPayTime
	}
	return ""
}

func (m *WlstRtu_70Da) GetSelfPayTime() string {
	if m != nil {
		return m.SelfPayTime
	}
	return ""
}

func (m *WlstRtu_70Da) GetXSwitchOutCount() []int32 {
	if m != nil {
		return m.XSwitchOutCount
	}
	return nil
}

func (m *WlstRtu_70Da) GetSwitchInHopping() []int32 {
	if m != nil {
		return m.SwitchInHopping
	}
	return nil
}

func (m *WlstRtu_70Da) GetVoltageRange() int32 {
	if m != nil {
		return m.VoltageRange
	}
	return 0
}

func (m *WlstRtu_70Da) GetXCurrentRange() []int32 {
	if m != nil {
		return m.XCurrentRange
	}
	return nil
}

func (m *WlstRtu_70Da) GetXSwitchOutVector() []int32 {
	if m != nil {
		return m.XSwitchOutVector
	}
	return nil
}

func (m *WlstRtu_70Da) GetXSwitchInVector() []int32 {
	if m != nil {
		return m.XSwitchInVector
	}
	return nil
}

func (m *WlstRtu_70Da) GetXAnalogVector() []int32 {
	if m != nil {
		return m.XAnalogVector
	}
	return nil
}

func (m *WlstRtu_70Da) GetUpperVoltageLimit() int32 {
	if m != nil {
		return m.UpperVoltageLimit
	}
	return 0
}

func (m *WlstRtu_70Da) GetLowerVoltageLimit() int32 {
	if m != nil {
		return m.LowerVoltageLimit
	}
	return 0
}

func (m *WlstRtu_70Da) GetXUpperCurrentLimit() []int32 {
	if m != nil {
		return m.XUpperCurrentLimit
	}
	return nil
}

func (m *WlstRtu_70Da) GetXLowerCurrentLimit() []int32 {
	if m != nil {
		return m.XLowerCurrentLimit
	}
	return nil
}

func (m *WlstRtu_70Da) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *WlstRtu_70Da) GetCmdType() int32 {
	if m != nil {
		return m.CmdType
	}
	return 0
}

func (m *WlstRtu_70Da) GetTransformers() []int32 {
	if m != nil {
		return m.Transformers
	}
	return nil
}

//远程修改主板通讯参数
type WlstRtu_700A struct {
	ComArgv []int32 `protobuf:"varint,1,rep,packed,name=com_argv,json=comArgv,proto3" json:"com_argv,omitempty"`
}

func (m *WlstRtu_700A) Reset()         { *m = WlstRtu_700A{} }
func (m *WlstRtu_700A) String() string { return proto.CompactTextString(m) }
func (*WlstRtu_700A) ProtoMessage()    {}
func (*WlstRtu_700A) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{14}
}
func (m *WlstRtu_700A) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtu_700A) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtu_700A.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtu_700A) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtu_700A.Merge(m, src)
}
func (m *WlstRtu_700A) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtu_700A) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtu_700A.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtu_700A proto.InternalMessageInfo

func (m *WlstRtu_700A) GetComArgv() []int32 {
	if m != nil {
		return m.ComArgv
	}
	return nil
}

//模块ftp升级
type WlstRtu_7010 struct {
	// 复位类型，1-复位终端，2-恢复出厂参数，3-复位通信模块，4-火零不平衡复位
	DataMark int32 `protobuf:"varint,1,opt,name=data_mark,json=dataMark,proto3" json:"data_mark,omitempty"`
	//序号
	CmdIdx int32 `protobuf:"varint,2,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 应答
	Status int32 `protobuf:"varint,3,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *WlstRtu_7010) Reset()         { *m = WlstRtu_7010{} }
func (m *WlstRtu_7010) String() string { return proto.CompactTextString(m) }
func (*WlstRtu_7010) ProtoMessage()    {}
func (*WlstRtu_7010) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{15}
}
func (m *WlstRtu_7010) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtu_7010) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtu_7010.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtu_7010) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtu_7010.Merge(m, src)
}
func (m *WlstRtu_7010) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtu_7010) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtu_7010.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtu_7010 proto.InternalMessageInfo

func (m *WlstRtu_7010) GetDataMark() int32 {
	if m != nil {
		return m.DataMark
	}
	return 0
}

func (m *WlstRtu_7010) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *WlstRtu_7010) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

//模块ftp升级
type WlstRtu_7003 struct {
	//序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// ftp升级命令数据
	FtpData []int32 `protobuf:"varint,2,rep,packed,name=ftp_data,json=ftpData,proto3" json:"ftp_data,omitempty"`
}

func (m *WlstRtu_7003) Reset()         { *m = WlstRtu_7003{} }
func (m *WlstRtu_7003) String() string { return proto.CompactTextString(m) }
func (*WlstRtu_7003) ProtoMessage()    {}
func (*WlstRtu_7003) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{16}
}
func (m *WlstRtu_7003) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtu_7003) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtu_7003.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtu_7003) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtu_7003.Merge(m, src)
}
func (m *WlstRtu_7003) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtu_7003) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtu_7003.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtu_7003 proto.InternalMessageInfo

func (m *WlstRtu_7003) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *WlstRtu_7003) GetFtpData() []int32 {
	if m != nil {
		return m.FtpData
	}
	return nil
}

// 3006终端升级准备
type WlstRtu_7006 struct {
	//序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	//总数
	AllCount int32 `protobuf:"varint,2,opt,name=all_count,json=allCount,proto3" json:"all_count,omitempty"`
	// cache文件名
	CacheName string `protobuf:"bytes,3,opt,name=cache_name,json=cacheName,proto3" json:"cache_name,omitempty"`
}

func (m *WlstRtu_7006) Reset()         { *m = WlstRtu_7006{} }
func (m *WlstRtu_7006) String() string { return proto.CompactTextString(m) }
func (*WlstRtu_7006) ProtoMessage()    {}
func (*WlstRtu_7006) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{17}
}
func (m *WlstRtu_7006) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtu_7006) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtu_7006.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtu_7006) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtu_7006.Merge(m, src)
}
func (m *WlstRtu_7006) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtu_7006) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtu_7006.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtu_7006 proto.InternalMessageInfo

func (m *WlstRtu_7006) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *WlstRtu_7006) GetAllCount() int32 {
	if m != nil {
		return m.AllCount
	}
	return 0
}

func (m *WlstRtu_7006) GetCacheName() string {
	if m != nil {
		return m.CacheName
	}
	return ""
}

// 3006终端升级数据包发送状态查询
type WlstRtu_7007 struct {
	//序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
}

func (m *WlstRtu_7007) Reset()         { *m = WlstRtu_7007{} }
func (m *WlstRtu_7007) String() string { return proto.CompactTextString(m) }
func (*WlstRtu_7007) ProtoMessage()    {}
func (*WlstRtu_7007) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{18}
}
func (m *WlstRtu_7007) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtu_7007) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtu_7007.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtu_7007) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtu_7007.Merge(m, src)
}
func (m *WlstRtu_7007) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtu_7007) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtu_7007.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtu_7007 proto.InternalMessageInfo

func (m *WlstRtu_7007) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

// 3006终端数据包状态查询应答
// Wlst_rtu_7083
type WlstRtu_7087 struct {
	//序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	//状态 0-数据包正常，>0数据包异常
	Status int32 `protobuf:"varint,2,opt,name=status,proto3" json:"status,omitempty"`
	//失败的数据包编号
	FailedPackages []int32 `protobuf:"varint,3,rep,packed,name=failed_packages,json=failedPackages,proto3" json:"failed_packages,omitempty"`
	//设备传回的失败标识字节数
	BytesCount int32 `protobuf:"varint,4,opt,name=bytes_count,json=bytesCount,proto3" json:"bytes_count,omitempty"`
}

func (m *WlstRtu_7087) Reset()         { *m = WlstRtu_7087{} }
func (m *WlstRtu_7087) String() string { return proto.CompactTextString(m) }
func (*WlstRtu_7087) ProtoMessage()    {}
func (*WlstRtu_7087) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{19}
}
func (m *WlstRtu_7087) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtu_7087) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtu_7087.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtu_7087) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtu_7087.Merge(m, src)
}
func (m *WlstRtu_7087) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtu_7087) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtu_7087.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtu_7087 proto.InternalMessageInfo

func (m *WlstRtu_7087) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *WlstRtu_7087) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *WlstRtu_7087) GetFailedPackages() []int32 {
	if m != nil {
		return m.FailedPackages
	}
	return nil
}

func (m *WlstRtu_7087) GetBytesCount() int32 {
	if m != nil {
		return m.BytesCount
	}
	return 0
}

// 终端升级上报
type WlstRtu_7081 struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 状态
	Status int32 `protobuf:"varint,2,opt,name=status,proto3" json:"status,omitempty"`
	// 旧版本
	OldVer string `protobuf:"bytes,3,opt,name=old_ver,json=oldVer,proto3" json:"old_ver,omitempty"`
	// 新版本
	NewVer string `protobuf:"bytes,4,opt,name=new_ver,json=newVer,proto3" json:"new_ver,omitempty"`
	// 位置关系
	DataLocation int32 `protobuf:"varint,5,opt,name=data_location,json=dataLocation,proto3" json:"data_location,omitempty"`
}

func (m *WlstRtu_7081) Reset()         { *m = WlstRtu_7081{} }
func (m *WlstRtu_7081) String() string { return proto.CompactTextString(m) }
func (*WlstRtu_7081) ProtoMessage()    {}
func (*WlstRtu_7081) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{20}
}
func (m *WlstRtu_7081) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtu_7081) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtu_7081.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtu_7081) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtu_7081.Merge(m, src)
}
func (m *WlstRtu_7081) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtu_7081) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtu_7081.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtu_7081 proto.InternalMessageInfo

func (m *WlstRtu_7081) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *WlstRtu_7081) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *WlstRtu_7081) GetOldVer() string {
	if m != nil {
		return m.OldVer
	}
	return ""
}

func (m *WlstRtu_7081) GetNewVer() string {
	if m != nil {
		return m.NewVer
	}
	return ""
}

func (m *WlstRtu_7081) GetDataLocation() int32 {
	if m != nil {
		return m.DataLocation
	}
	return 0
}

// 3006终端升级发送数据包
type WlstRtu_7008 struct {
	//序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	//数据
	UpdData []string `protobuf:"bytes,2,rep,name=upd_data,json=updData,proto3" json:"upd_data,omitempty"`
	// cache文件名
	CacheName string `protobuf:"bytes,3,opt,name=cache_name,json=cacheName,proto3" json:"cache_name,omitempty"`
	// 0-写缓存，1-清缓存
	Clean      int32   `protobuf:"varint,4,opt,name=clean,proto3" json:"clean,omitempty"`
	IntUpdData []int32 `protobuf:"varint,5,rep,packed,name=int_upd_data,json=intUpdData,proto3" json:"int_upd_data,omitempty"`
}

func (m *WlstRtu_7008) Reset()         { *m = WlstRtu_7008{} }
func (m *WlstRtu_7008) String() string { return proto.CompactTextString(m) }
func (*WlstRtu_7008) ProtoMessage()    {}
func (*WlstRtu_7008) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{21}
}
func (m *WlstRtu_7008) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtu_7008) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtu_7008.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtu_7008) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtu_7008.Merge(m, src)
}
func (m *WlstRtu_7008) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtu_7008) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtu_7008.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtu_7008 proto.InternalMessageInfo

func (m *WlstRtu_7008) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *WlstRtu_7008) GetUpdData() []string {
	if m != nil {
		return m.UpdData
	}
	return nil
}

func (m *WlstRtu_7008) GetCacheName() string {
	if m != nil {
		return m.CacheName
	}
	return ""
}

func (m *WlstRtu_7008) GetClean() int32 {
	if m != nil {
		return m.Clean
	}
	return 0
}

func (m *WlstRtu_7008) GetIntUpdData() []int32 {
	if m != nil {
		return m.IntUpdData
	}
	return nil
}

// wlst_rtu_70e1
type WlstRtu_7060 struct {
	//序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 起始时间,提取月,日
	DtStart int64 `protobuf:"varint,2,opt,name=dt_start,json=dtStart,proto3" json:"dt_start,omitempty"`
	// 天数
	Days     int32                    `protobuf:"varint,3,opt,name=days,proto3" json:"days,omitempty"`
	YearCtrl []*WlstRtu_7060_YearCtrl `protobuf:"bytes,4,rep,name=year_ctrl,json=yearCtrl,proto3" json:"year_ctrl,omitempty"`
}

func (m *WlstRtu_7060) Reset()         { *m = WlstRtu_7060{} }
func (m *WlstRtu_7060) String() string { return proto.CompactTextString(m) }
func (*WlstRtu_7060) ProtoMessage()    {}
func (*WlstRtu_7060) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{22}
}
func (m *WlstRtu_7060) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtu_7060) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtu_7060.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtu_7060) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtu_7060.Merge(m, src)
}
func (m *WlstRtu_7060) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtu_7060) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtu_7060.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtu_7060 proto.InternalMessageInfo

func (m *WlstRtu_7060) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *WlstRtu_7060) GetDtStart() int64 {
	if m != nil {
		return m.DtStart
	}
	return 0
}

func (m *WlstRtu_7060) GetDays() int32 {
	if m != nil {
		return m.Days
	}
	return 0
}

func (m *WlstRtu_7060) GetYearCtrl() []*WlstRtu_7060_YearCtrl {
	if m != nil {
		return m.YearCtrl
	}
	return nil
}

type WlstRtu_7060_YearCtrl struct {
	// 回路编号
	LoopNo int32 `protobuf:"varint,1,opt,name=loop_no,json=loopNo,proto3" json:"loop_no,omitempty"`
	// 回路时段数
	TimeCount int32 `protobuf:"varint,2,opt,name=time_count,json=timeCount,proto3" json:"time_count,omitempty"`
	// 每段开关灯时间，[第一段开,第一段关,第二段开,第二段关...], 格式:hh*60+mm
	OptTime []int32 `protobuf:"varint,3,rep,packed,name=opt_time,json=optTime,proto3" json:"opt_time,omitempty"`
}

func (m *WlstRtu_7060_YearCtrl) Reset()         { *m = WlstRtu_7060_YearCtrl{} }
func (m *WlstRtu_7060_YearCtrl) String() string { return proto.CompactTextString(m) }
func (*WlstRtu_7060_YearCtrl) ProtoMessage()    {}
func (*WlstRtu_7060_YearCtrl) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{22, 0}
}
func (m *WlstRtu_7060_YearCtrl) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtu_7060_YearCtrl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtu_7060_YearCtrl.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtu_7060_YearCtrl) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtu_7060_YearCtrl.Merge(m, src)
}
func (m *WlstRtu_7060_YearCtrl) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtu_7060_YearCtrl) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtu_7060_YearCtrl.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtu_7060_YearCtrl proto.InternalMessageInfo

func (m *WlstRtu_7060_YearCtrl) GetLoopNo() int32 {
	if m != nil {
		return m.LoopNo
	}
	return 0
}

func (m *WlstRtu_7060_YearCtrl) GetTimeCount() int32 {
	if m != nil {
		return m.TimeCount
	}
	return 0
}

func (m *WlstRtu_7060_YearCtrl) GetOptTime() []int32 {
	if m != nil {
		return m.OptTime
	}
	return nil
}

type WlstRtu_7061 struct {
	//序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 起始时间,提取月,日
	DtStart int64 `protobuf:"varint,2,opt,name=dt_start,json=dtStart,proto3" json:"dt_start,omitempty"`
	// 天数
	Days int32 `protobuf:"varint,3,opt,name=days,proto3" json:"days,omitempty"`
	// 回路标示
	LoopNo []int32 `protobuf:"varint,4,rep,packed,name=loop_no,json=loopNo,proto3" json:"loop_no,omitempty"`
}

func (m *WlstRtu_7061) Reset()         { *m = WlstRtu_7061{} }
func (m *WlstRtu_7061) String() string { return proto.CompactTextString(m) }
func (*WlstRtu_7061) ProtoMessage()    {}
func (*WlstRtu_7061) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{23}
}
func (m *WlstRtu_7061) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtu_7061) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtu_7061.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtu_7061) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtu_7061.Merge(m, src)
}
func (m *WlstRtu_7061) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtu_7061) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtu_7061.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtu_7061 proto.InternalMessageInfo

func (m *WlstRtu_7061) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *WlstRtu_7061) GetDtStart() int64 {
	if m != nil {
		return m.DtStart
	}
	return 0
}

func (m *WlstRtu_7061) GetDays() int32 {
	if m != nil {
		return m.Days
	}
	return 0
}

func (m *WlstRtu_7061) GetLoopNo() []int32 {
	if m != nil {
		return m.LoopNo
	}
	return nil
}

type WlstRtu_70E0 struct {
	//序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	//状态
	Status int32 `protobuf:"varint,2,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *WlstRtu_70E0) Reset()         { *m = WlstRtu_70E0{} }
func (m *WlstRtu_70E0) String() string { return proto.CompactTextString(m) }
func (*WlstRtu_70E0) ProtoMessage()    {}
func (*WlstRtu_70E0) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{24}
}
func (m *WlstRtu_70E0) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtu_70E0) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtu_70E0.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtu_70E0) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtu_70E0.Merge(m, src)
}
func (m *WlstRtu_70E0) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtu_70E0) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtu_70E0.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtu_70E0 proto.InternalMessageInfo

func (m *WlstRtu_70E0) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *WlstRtu_70E0) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

type WlstRtu_7B00 struct {
	// sim卡号码
	Sim string `protobuf:"bytes,1,opt,name=sim,proto3" json:"sim,omitempty"`
	//信号强度
	Signal int32 `protobuf:"varint,2,opt,name=signal,proto3" json:"signal,omitempty"`
}

func (m *WlstRtu_7B00) Reset()         { *m = WlstRtu_7B00{} }
func (m *WlstRtu_7B00) String() string { return proto.CompactTextString(m) }
func (*WlstRtu_7B00) ProtoMessage()    {}
func (*WlstRtu_7B00) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{25}
}
func (m *WlstRtu_7B00) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtu_7B00) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtu_7B00.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtu_7B00) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtu_7B00.Merge(m, src)
}
func (m *WlstRtu_7B00) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtu_7B00) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtu_7B00.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtu_7B00 proto.InternalMessageInfo

func (m *WlstRtu_7B00) GetSim() string {
	if m != nil {
		return m.Sim
	}
	return ""
}

func (m *WlstRtu_7B00) GetSignal() int32 {
	if m != nil {
		return m.Signal
	}
	return 0
}

type WlstRtu_1900 struct {
	//终端地址
	Addr int32 `protobuf:"varint,1,opt,name=addr,proto3" json:"addr,omitempty"`
	//终端ip
	TmlIp int64 `protobuf:"varint,2,opt,name=tml_ip,json=tmlIp,proto3" json:"tml_ip,omitempty"`
}

func (m *WlstRtu_1900) Reset()         { *m = WlstRtu_1900{} }
func (m *WlstRtu_1900) String() string { return proto.CompactTextString(m) }
func (*WlstRtu_1900) ProtoMessage()    {}
func (*WlstRtu_1900) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{26}
}
func (m *WlstRtu_1900) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtu_1900) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtu_1900.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtu_1900) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtu_1900.Merge(m, src)
}
func (m *WlstRtu_1900) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtu_1900) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtu_1900.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtu_1900 proto.InternalMessageInfo

func (m *WlstRtu_1900) GetAddr() int32 {
	if m != nil {
		return m.Addr
	}
	return 0
}

func (m *WlstRtu_1900) GetTmlIp() int64 {
	if m != nil {
		return m.TmlIp
	}
	return 0
}

type WlstRtu_4000 struct {
	//工作标识
	WorkMark int32 `protobuf:"varint,1,opt,name=work_mark,json=workMark,proto3" json:"work_mark,omitempty"`
	//心跳周期
	KeepAlive int32 `protobuf:"varint,2,opt,name=keep_alive,json=keepAlive,proto3" json:"keep_alive,omitempty"`
	//主报周期
	AlarmCycle int32 `protobuf:"varint,3,opt,name=alarm_cycle,json=alarmCycle,proto3" json:"alarm_cycle,omitempty"`
	//报警延时
	AlarmDelay int32 `protobuf:"varint,4,opt,name=alarm_delay,json=alarmDelay,proto3" json:"alarm_delay,omitempty"`
	//回路x数量
	XLoopCount []int32 `protobuf:"varint,5,rep,packed,name=x_loop_count,json=xLoopCount,proto3" json:"x_loop_count,omitempty"`
}

func (m *WlstRtu_4000) Reset()         { *m = WlstRtu_4000{} }
func (m *WlstRtu_4000) String() string { return proto.CompactTextString(m) }
func (*WlstRtu_4000) ProtoMessage()    {}
func (*WlstRtu_4000) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{27}
}
func (m *WlstRtu_4000) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtu_4000) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtu_4000.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtu_4000) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtu_4000.Merge(m, src)
}
func (m *WlstRtu_4000) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtu_4000) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtu_4000.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtu_4000 proto.InternalMessageInfo

func (m *WlstRtu_4000) GetWorkMark() int32 {
	if m != nil {
		return m.WorkMark
	}
	return 0
}

func (m *WlstRtu_4000) GetKeepAlive() int32 {
	if m != nil {
		return m.KeepAlive
	}
	return 0
}

func (m *WlstRtu_4000) GetAlarmCycle() int32 {
	if m != nil {
		return m.AlarmCycle
	}
	return 0
}

func (m *WlstRtu_4000) GetAlarmDelay() int32 {
	if m != nil {
		return m.AlarmDelay
	}
	return 0
}

func (m *WlstRtu_4000) GetXLoopCount() []int32 {
	if m != nil {
		return m.XLoopCount
	}
	return nil
}

type WlstRtu_4101 struct {
	//模拟量输入路数总数
	AnalogSum int32 `protobuf:"varint,1,opt,name=analog_sum,json=analogSum,proto3" json:"analog_sum,omitempty"`
	//电压量程
	VoltageRange int32 `protobuf:"varint,2,opt,name=voltage_range,json=voltageRange,proto3" json:"voltage_range,omitempty"`
	//回路x电流量程
	XCurrentRange []int32 `protobuf:"varint,3,rep,packed,name=x_current_range,json=xCurrentRange,proto3" json:"x_current_range,omitempty"`
}

func (m *WlstRtu_4101) Reset()         { *m = WlstRtu_4101{} }
func (m *WlstRtu_4101) String() string { return proto.CompactTextString(m) }
func (*WlstRtu_4101) ProtoMessage()    {}
func (*WlstRtu_4101) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{28}
}
func (m *WlstRtu_4101) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtu_4101) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtu_4101.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtu_4101) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtu_4101.Merge(m, src)
}
func (m *WlstRtu_4101) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtu_4101) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtu_4101.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtu_4101 proto.InternalMessageInfo

func (m *WlstRtu_4101) GetAnalogSum() int32 {
	if m != nil {
		return m.AnalogSum
	}
	return 0
}

func (m *WlstRtu_4101) GetVoltageRange() int32 {
	if m != nil {
		return m.VoltageRange
	}
	return 0
}

func (m *WlstRtu_4101) GetXCurrentRange() []int32 {
	if m != nil {
		return m.XCurrentRange
	}
	return nil
}

type WlstRtu_4104 struct {
	//开关量输入路数总数
	SwitchinSum int32 `protobuf:"varint,1,opt,name=switchin_sum,json=switchinSum,proto3" json:"switchin_sum,omitempty"`
	//开关量输入x矢量
	XSwitchVector []int32 `protobuf:"varint,2,rep,packed,name=x_switch_vector,json=xSwitchVector,proto3" json:"x_switch_vector,omitempty"`
	//开关量输入x跳变
	XSwitchHopping []int32 `protobuf:"varint,3,rep,packed,name=x_switch_hopping,json=xSwitchHopping,proto3" json:"x_switch_hopping,omitempty"`
}

func (m *WlstRtu_4104) Reset()         { *m = WlstRtu_4104{} }
func (m *WlstRtu_4104) String() string { return proto.CompactTextString(m) }
func (*WlstRtu_4104) ProtoMessage()    {}
func (*WlstRtu_4104) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{29}
}
func (m *WlstRtu_4104) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtu_4104) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtu_4104.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtu_4104) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtu_4104.Merge(m, src)
}
func (m *WlstRtu_4104) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtu_4104) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtu_4104.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtu_4104 proto.InternalMessageInfo

func (m *WlstRtu_4104) GetSwitchinSum() int32 {
	if m != nil {
		return m.SwitchinSum
	}
	return 0
}

func (m *WlstRtu_4104) GetXSwitchVector() []int32 {
	if m != nil {
		return m.XSwitchVector
	}
	return nil
}

func (m *WlstRtu_4104) GetXSwitchHopping() []int32 {
	if m != nil {
		return m.XSwitchHopping
	}
	return nil
}

type WlstRtu_4110 struct {
	//开关量输出路数总数
	SwitchInSum int32 `protobuf:"varint,1,opt,name=switch_in_sum,json=switchInSum,proto3" json:"switch_in_sum,omitempty"`
}

func (m *WlstRtu_4110) Reset()         { *m = WlstRtu_4110{} }
func (m *WlstRtu_4110) String() string { return proto.CompactTextString(m) }
func (*WlstRtu_4110) ProtoMessage()    {}
func (*WlstRtu_4110) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{30}
}
func (m *WlstRtu_4110) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtu_4110) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtu_4110.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtu_4110) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtu_4110.Merge(m, src)
}
func (m *WlstRtu_4110) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtu_4110) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtu_4110.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtu_4110 proto.InternalMessageInfo

func (m *WlstRtu_4110) GetSwitchInSum() int32 {
	if m != nil {
		return m.SwitchInSum
	}
	return 0
}

// 设置电能采集版电流互感器比值
type WlstRtu_4111 struct {
	// A,B,C三项互感比，下行不需要/5,如100：5的填充100即可
	Transformers []int32 `protobuf:"varint,1,rep,packed,name=transformers,proto3" json:"transformers,omitempty"`
	// 设置状态，0-失败，1-成功
	Status int32 `protobuf:"varint,2,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *WlstRtu_4111) Reset()         { *m = WlstRtu_4111{} }
func (m *WlstRtu_4111) String() string { return proto.CompactTextString(m) }
func (*WlstRtu_4111) ProtoMessage()    {}
func (*WlstRtu_4111) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{31}
}
func (m *WlstRtu_4111) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtu_4111) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtu_4111.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtu_4111) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtu_4111.Merge(m, src)
}
func (m *WlstRtu_4111) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtu_4111) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtu_4111.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtu_4111 proto.InternalMessageInfo

func (m *WlstRtu_4111) GetTransformers() []int32 {
	if m != nil {
		return m.Transformers
	}
	return nil
}

func (m *WlstRtu_4111) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

type WlstRtu_4200 struct {
	//模拟量x失量
	XAnalogVector []int32 `protobuf:"varint,1,rep,packed,name=x_analog_vector,json=xAnalogVector,proto3" json:"x_analog_vector,omitempty"`
	//开关量输入x矢量
	XSwitchInVector []int32 `protobuf:"varint,2,rep,packed,name=x_switch_in_vector,json=xSwitchInVector,proto3" json:"x_switch_in_vector,omitempty"`
	//开关量输出x矢量
	XSwitchOutVector []int32 `protobuf:"varint,3,rep,packed,name=x_switch_out_vector,json=xSwitchOutVector,proto3" json:"x_switch_out_vector,omitempty"`
	//模拟量输入路数总数
	AnalogSum int32 `protobuf:"varint,4,opt,name=analog_sum,json=analogSum,proto3" json:"analog_sum,omitempty"`
	//开关量输入路数总数
	SwitchInSum int32 `protobuf:"varint,5,opt,name=switch_in_sum,json=switchInSum,proto3" json:"switch_in_sum,omitempty"`
	//开关量输出数量
	SwitchOutSum int32 `protobuf:"varint,6,opt,name=switch_out_sum,json=switchOutSum,proto3" json:"switch_out_sum,omitempty"`
}

func (m *WlstRtu_4200) Reset()         { *m = WlstRtu_4200{} }
func (m *WlstRtu_4200) String() string { return proto.CompactTextString(m) }
func (*WlstRtu_4200) ProtoMessage()    {}
func (*WlstRtu_4200) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{32}
}
func (m *WlstRtu_4200) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtu_4200) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtu_4200.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtu_4200) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtu_4200.Merge(m, src)
}
func (m *WlstRtu_4200) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtu_4200) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtu_4200.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtu_4200 proto.InternalMessageInfo

func (m *WlstRtu_4200) GetXAnalogVector() []int32 {
	if m != nil {
		return m.XAnalogVector
	}
	return nil
}

func (m *WlstRtu_4200) GetXSwitchInVector() []int32 {
	if m != nil {
		return m.XSwitchInVector
	}
	return nil
}

func (m *WlstRtu_4200) GetXSwitchOutVector() []int32 {
	if m != nil {
		return m.XSwitchOutVector
	}
	return nil
}

func (m *WlstRtu_4200) GetAnalogSum() int32 {
	if m != nil {
		return m.AnalogSum
	}
	return 0
}

func (m *WlstRtu_4200) GetSwitchInSum() int32 {
	if m != nil {
		return m.SwitchInSum
	}
	return 0
}

func (m *WlstRtu_4200) GetSwitchOutSum() int32 {
	if m != nil {
		return m.SwitchOutSum
	}
	return 0
}

type WlstRtu_4401 struct {
	//模拟量输入路数总数
	AnalogSum int32 `protobuf:"varint,1,opt,name=analog_sum,json=analogSum,proto3" json:"analog_sum,omitempty"`
	//电压上限
	UpperVoltageLimit int32 `protobuf:"varint,2,opt,name=upper_voltage_limit,json=upperVoltageLimit,proto3" json:"upper_voltage_limit,omitempty"`
	//电压下限
	LowerVoltageLimit int32 `protobuf:"varint,3,opt,name=lower_voltage_limit,json=lowerVoltageLimit,proto3" json:"lower_voltage_limit,omitempty"`
	//模拟量回路x电流上限
	XUpperCurrentLimit []int32 `protobuf:"varint,4,rep,packed,name=x_upper_current_limit,json=xUpperCurrentLimit,proto3" json:"x_upper_current_limit,omitempty"`
	//模拟量回路x电流下限
	XLowerCurrentLimit []int32 `protobuf:"varint,5,rep,packed,name=x_lower_current_limit,json=xLowerCurrentLimit,proto3" json:"x_lower_current_limit,omitempty"`
	//电压量程
	VoltageRange int32 `protobuf:"varint,6,opt,name=voltage_range,json=voltageRange,proto3" json:"voltage_range,omitempty"`
	//模拟量回路x电流量程
	XCurrentRange []int32 `protobuf:"varint,7,rep,packed,name=x_current_range,json=xCurrentRange,proto3" json:"x_current_range,omitempty"`
}

func (m *WlstRtu_4401) Reset()         { *m = WlstRtu_4401{} }
func (m *WlstRtu_4401) String() string { return proto.CompactTextString(m) }
func (*WlstRtu_4401) ProtoMessage()    {}
func (*WlstRtu_4401) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{33}
}
func (m *WlstRtu_4401) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtu_4401) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtu_4401.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtu_4401) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtu_4401.Merge(m, src)
}
func (m *WlstRtu_4401) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtu_4401) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtu_4401.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtu_4401 proto.InternalMessageInfo

func (m *WlstRtu_4401) GetAnalogSum() int32 {
	if m != nil {
		return m.AnalogSum
	}
	return 0
}

func (m *WlstRtu_4401) GetUpperVoltageLimit() int32 {
	if m != nil {
		return m.UpperVoltageLimit
	}
	return 0
}

func (m *WlstRtu_4401) GetLowerVoltageLimit() int32 {
	if m != nil {
		return m.LowerVoltageLimit
	}
	return 0
}

func (m *WlstRtu_4401) GetXUpperCurrentLimit() []int32 {
	if m != nil {
		return m.XUpperCurrentLimit
	}
	return nil
}

func (m *WlstRtu_4401) GetXLowerCurrentLimit() []int32 {
	if m != nil {
		return m.XLowerCurrentLimit
	}
	return nil
}

func (m *WlstRtu_4401) GetVoltageRange() int32 {
	if m != nil {
		return m.VoltageRange
	}
	return 0
}

func (m *WlstRtu_4401) GetXCurrentRange() []int32 {
	if m != nil {
		return m.XCurrentRange
	}
	return nil
}

type WlstRtuDa00 struct {
	//心跳周期
	KeepAlive int32 `protobuf:"varint,1,opt,name=keep_alive,json=keepAlive,proto3" json:"keep_alive,omitempty"`
	//主报周期
	AlarmCycle int32 `protobuf:"varint,2,opt,name=alarm_cycle,json=alarmCycle,proto3" json:"alarm_cycle,omitempty"`
	//报警延时
	AlarmDelay int32 `protobuf:"varint,3,opt,name=alarm_delay,json=alarmDelay,proto3" json:"alarm_delay,omitempty"`
	//终端地址
	Addr int32 `protobuf:"varint,4,opt,name=addr,proto3" json:"addr,omitempty"`
	//开关量输出路数
	SwitchOutSum int32 `protobuf:"varint,5,opt,name=switch_out_sum,json=switchOutSum,proto3" json:"switch_out_sum,omitempty"`
	//开关量输入路数
	SwitchInSum int32 `protobuf:"varint,6,opt,name=switch_in_sum,json=switchInSum,proto3" json:"switch_in_sum,omitempty"`
	//模拟量输入路数
	AnalogSum int32 `protobuf:"varint,7,opt,name=analog_sum,json=analogSum,proto3" json:"analog_sum,omitempty"`
	//开关量输出开关时间 hhmm-hhmm
	XSwitchingTime []string `protobuf:"bytes,8,rep,name=x_switching_time,json=xSwitchingTime,proto3" json:"x_switching_time,omitempty"`
	//市付费启用时分，hhmm
	CityPayTime string `protobuf:"bytes,9,opt,name=city_pay_time,json=cityPayTime,proto3" json:"city_pay_time,omitempty"`
	//自付费启用时分，hhmm
	SelfPayTime string `protobuf:"bytes,10,opt,name=self_pay_time,json=selfPayTime,proto3" json:"self_pay_time,omitempty"`
	//各个开关量输出路数
	XSwitchOutCount []int32 `protobuf:"varint,11,rep,packed,name=x_switch_out_count,json=xSwitchOutCount,proto3" json:"x_switch_out_count,omitempty"`
	//开关量输入1-16跳变
	SwitchInHopping int32 `protobuf:"varint,12,opt,name=switch_in_hopping,json=switchInHopping,proto3" json:"switch_in_hopping,omitempty"`
	//电压量程
	VoltageRange int32 `protobuf:"varint,13,opt,name=voltage_range,json=voltageRange,proto3" json:"voltage_range,omitempty"`
	//模拟量回路x电流量程
	XCurrentRange []int32 `protobuf:"varint,14,rep,packed,name=x_current_range,json=xCurrentRange,proto3" json:"x_current_range,omitempty"`
	//开关量输出x矢量
	XSwitchOutVector []int32 `protobuf:"varint,15,rep,packed,name=x_switch_out_vector,json=xSwitchOutVector,proto3" json:"x_switch_out_vector,omitempty"`
	//开关量输入x矢量
	XSwitchInVector []int32 `protobuf:"varint,16,rep,packed,name=x_switch_in_vector,json=xSwitchInVector,proto3" json:"x_switch_in_vector,omitempty"`
	//模拟量x失量
	XAnalogVector []int32 `protobuf:"varint,17,rep,packed,name=x_analog_vector,json=xAnalogVector,proto3" json:"x_analog_vector,omitempty"`
	//电压上限
	UpperVoltageLimit int32 `protobuf:"varint,18,opt,name=upper_voltage_limit,json=upperVoltageLimit,proto3" json:"upper_voltage_limit,omitempty"`
	//电压下限
	LowerVoltageLimit int32 `protobuf:"varint,19,opt,name=lower_voltage_limit,json=lowerVoltageLimit,proto3" json:"lower_voltage_limit,omitempty"`
	//模拟量回路x电流上限
	XUpperCurrentLimit []int32 `protobuf:"varint,20,rep,packed,name=x_upper_current_limit,json=xUpperCurrentLimit,proto3" json:"x_upper_current_limit,omitempty"`
	//模拟量回路x电流下限
	XLowerCurrentLimit []int32 `protobuf:"varint,21,rep,packed,name=x_lower_current_limit,json=xLowerCurrentLimit,proto3" json:"x_lower_current_limit,omitempty"`
	//优先组地址
	GroupId int32 `protobuf:"varint,22,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
}

func (m *WlstRtuDa00) Reset()         { *m = WlstRtuDa00{} }
func (m *WlstRtuDa00) String() string { return proto.CompactTextString(m) }
func (*WlstRtuDa00) ProtoMessage()    {}
func (*WlstRtuDa00) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{34}
}
func (m *WlstRtuDa00) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtuDa00) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtuDa00.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtuDa00) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtuDa00.Merge(m, src)
}
func (m *WlstRtuDa00) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtuDa00) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtuDa00.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtuDa00 proto.InternalMessageInfo

func (m *WlstRtuDa00) GetKeepAlive() int32 {
	if m != nil {
		return m.KeepAlive
	}
	return 0
}

func (m *WlstRtuDa00) GetAlarmCycle() int32 {
	if m != nil {
		return m.AlarmCycle
	}
	return 0
}

func (m *WlstRtuDa00) GetAlarmDelay() int32 {
	if m != nil {
		return m.AlarmDelay
	}
	return 0
}

func (m *WlstRtuDa00) GetAddr() int32 {
	if m != nil {
		return m.Addr
	}
	return 0
}

func (m *WlstRtuDa00) GetSwitchOutSum() int32 {
	if m != nil {
		return m.SwitchOutSum
	}
	return 0
}

func (m *WlstRtuDa00) GetSwitchInSum() int32 {
	if m != nil {
		return m.SwitchInSum
	}
	return 0
}

func (m *WlstRtuDa00) GetAnalogSum() int32 {
	if m != nil {
		return m.AnalogSum
	}
	return 0
}

func (m *WlstRtuDa00) GetXSwitchingTime() []string {
	if m != nil {
		return m.XSwitchingTime
	}
	return nil
}

func (m *WlstRtuDa00) GetCityPayTime() string {
	if m != nil {
		return m.CityPayTime
	}
	return ""
}

func (m *WlstRtuDa00) GetSelfPayTime() string {
	if m != nil {
		return m.SelfPayTime
	}
	return ""
}

func (m *WlstRtuDa00) GetXSwitchOutCount() []int32 {
	if m != nil {
		return m.XSwitchOutCount
	}
	return nil
}

func (m *WlstRtuDa00) GetSwitchInHopping() int32 {
	if m != nil {
		return m.SwitchInHopping
	}
	return 0
}

func (m *WlstRtuDa00) GetVoltageRange() int32 {
	if m != nil {
		return m.VoltageRange
	}
	return 0
}

func (m *WlstRtuDa00) GetXCurrentRange() []int32 {
	if m != nil {
		return m.XCurrentRange
	}
	return nil
}

func (m *WlstRtuDa00) GetXSwitchOutVector() []int32 {
	if m != nil {
		return m.XSwitchOutVector
	}
	return nil
}

func (m *WlstRtuDa00) GetXSwitchInVector() []int32 {
	if m != nil {
		return m.XSwitchInVector
	}
	return nil
}

func (m *WlstRtuDa00) GetXAnalogVector() []int32 {
	if m != nil {
		return m.XAnalogVector
	}
	return nil
}

func (m *WlstRtuDa00) GetUpperVoltageLimit() int32 {
	if m != nil {
		return m.UpperVoltageLimit
	}
	return 0
}

func (m *WlstRtuDa00) GetLowerVoltageLimit() int32 {
	if m != nil {
		return m.LowerVoltageLimit
	}
	return 0
}

func (m *WlstRtuDa00) GetXUpperCurrentLimit() []int32 {
	if m != nil {
		return m.XUpperCurrentLimit
	}
	return nil
}

func (m *WlstRtuDa00) GetXLowerCurrentLimit() []int32 {
	if m != nil {
		return m.XLowerCurrentLimit
	}
	return nil
}

func (m *WlstRtuDa00) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

type WlstRtuDf00 struct {
	//开关量输出开关时间 hhmm-hhmm
	XSwitchingTime []string `protobuf:"bytes,8,rep,name=x_switching_time,json=xSwitchingTime,proto3" json:"x_switching_time,omitempty"`
	//各个开关量输出路数
	XSwitchOutCount []int32 `protobuf:"varint,11,rep,packed,name=x_switch_out_count,json=xSwitchOutCount,proto3" json:"x_switch_out_count,omitempty"`
	//开关量输出x矢量
	XSwitchOutVector []int32 `protobuf:"varint,15,rep,packed,name=x_switch_out_vector,json=xSwitchOutVector,proto3" json:"x_switch_out_vector,omitempty"`
}

func (m *WlstRtuDf00) Reset()         { *m = WlstRtuDf00{} }
func (m *WlstRtuDf00) String() string { return proto.CompactTextString(m) }
func (*WlstRtuDf00) ProtoMessage()    {}
func (*WlstRtuDf00) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{35}
}
func (m *WlstRtuDf00) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtuDf00) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtuDf00.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtuDf00) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtuDf00.Merge(m, src)
}
func (m *WlstRtuDf00) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtuDf00) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtuDf00.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtuDf00 proto.InternalMessageInfo

func (m *WlstRtuDf00) GetXSwitchingTime() []string {
	if m != nil {
		return m.XSwitchingTime
	}
	return nil
}

func (m *WlstRtuDf00) GetXSwitchOutCount() []int32 {
	if m != nil {
		return m.XSwitchOutCount
	}
	return nil
}

func (m *WlstRtuDf00) GetXSwitchOutVector() []int32 {
	if m != nil {
		return m.XSwitchOutVector
	}
	return nil
}

type WlstRtu_6100 struct {
	//模拟量x电压矢量
	XVoltagePhase []int32 `protobuf:"varint,1,rep,packed,name=x_voltage_phase,json=xVoltagePhase,proto3" json:"x_voltage_phase,omitempty"`
}

func (m *WlstRtu_6100) Reset()         { *m = WlstRtu_6100{} }
func (m *WlstRtu_6100) String() string { return proto.CompactTextString(m) }
func (*WlstRtu_6100) ProtoMessage()    {}
func (*WlstRtu_6100) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{36}
}
func (m *WlstRtu_6100) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtu_6100) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtu_6100.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtu_6100) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtu_6100.Merge(m, src)
}
func (m *WlstRtu_6100) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtu_6100) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtu_6100.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtu_6100 proto.InternalMessageInfo

func (m *WlstRtu_6100) GetXVoltagePhase() []int32 {
	if m != nil {
		return m.XVoltagePhase
	}
	return nil
}

// Wlst_rtu_af00
type WlstRtuA000 struct {
	//模拟量回路x电压  需要*电压量程
	XAnalogVoltage []float64 `protobuf:"fixed64,1,rep,packed,name=x_analog_voltage,json=xAnalogVoltage,proto3" json:"x_analog_voltage,omitempty"`
	//模拟量回路x电流  需要*电流量程
	XAnalogCurrent []float64 `protobuf:"fixed64,2,rep,packed,name=x_analog_current,json=xAnalogCurrent,proto3" json:"x_analog_current,omitempty"`
	//模拟量回路x功率  需要 *电压量程*电流量程
	XAnalogPower []float64 `protobuf:"fixed64,3,rep,packed,name=x_analog_power,json=xAnalogPower,proto3" json:"x_analog_power,omitempty"`
	//开关量输入x状态
	SwitchInSt int64 `protobuf:"varint,4,opt,name=switch_in_st,json=switchInSt,proto3" json:"switch_in_st,omitempty"`
	//开关量输出状态
	SwitchOutSt int32 `protobuf:"varint,5,opt,name=switch_out_st,json=switchOutSt,proto3" json:"switch_out_st,omitempty"`
	//终端状态
	TmlSt int32 `protobuf:"varint,6,opt,name=tml_st,json=tmlSt,proto3" json:"tml_st,omitempty"`
	//模拟量回路x电流越限状态
	XCurrentStatus []int32 `protobuf:"varint,7,rep,packed,name=x_current_status,json=xCurrentStatus,proto3" json:"x_current_status,omitempty"`
	//模拟量回路x电压越限状态
	XVoltageStatus []int32 `protobuf:"varint,8,rep,packed,name=x_voltage_status,json=xVoltageStatus,proto3" json:"x_voltage_status,omitempty"`
	FullRange      int32   `protobuf:"varint,9,opt,name=full_range,json=fullRange,proto3" json:"full_range,omitempty"`
	Temperature    int32   `protobuf:"varint,10,opt,name=temperature,proto3" json:"temperature,omitempty"`
}

func (m *WlstRtuA000) Reset()         { *m = WlstRtuA000{} }
func (m *WlstRtuA000) String() string { return proto.CompactTextString(m) }
func (*WlstRtuA000) ProtoMessage()    {}
func (*WlstRtuA000) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{37}
}
func (m *WlstRtuA000) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtuA000) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtuA000.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtuA000) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtuA000.Merge(m, src)
}
func (m *WlstRtuA000) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtuA000) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtuA000.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtuA000 proto.InternalMessageInfo

func (m *WlstRtuA000) GetXAnalogVoltage() []float64 {
	if m != nil {
		return m.XAnalogVoltage
	}
	return nil
}

func (m *WlstRtuA000) GetXAnalogCurrent() []float64 {
	if m != nil {
		return m.XAnalogCurrent
	}
	return nil
}

func (m *WlstRtuA000) GetXAnalogPower() []float64 {
	if m != nil {
		return m.XAnalogPower
	}
	return nil
}

func (m *WlstRtuA000) GetSwitchInSt() int64 {
	if m != nil {
		return m.SwitchInSt
	}
	return 0
}

func (m *WlstRtuA000) GetSwitchOutSt() int32 {
	if m != nil {
		return m.SwitchOutSt
	}
	return 0
}

func (m *WlstRtuA000) GetTmlSt() int32 {
	if m != nil {
		return m.TmlSt
	}
	return 0
}

func (m *WlstRtuA000) GetXCurrentStatus() []int32 {
	if m != nil {
		return m.XCurrentStatus
	}
	return nil
}

func (m *WlstRtuA000) GetXVoltageStatus() []int32 {
	if m != nil {
		return m.XVoltageStatus
	}
	return nil
}

func (m *WlstRtuA000) GetFullRange() int32 {
	if m != nil {
		return m.FullRange
	}
	return 0
}

func (m *WlstRtuA000) GetTemperature() int32 {
	if m != nil {
		return m.Temperature
	}
	return 0
}

// Wlst_rtu_2210
type WlstRtuA200 struct {
	//开关量输出
	KNo int32 `protobuf:"varint,1,opt,name=k_no,json=kNo,proto3" json:"k_no,omitempty"`
	//操作
	Operation int32 `protobuf:"varint,2,opt,name=operation,proto3" json:"operation,omitempty"`
}

func (m *WlstRtuA200) Reset()         { *m = WlstRtuA200{} }
func (m *WlstRtuA200) String() string { return proto.CompactTextString(m) }
func (*WlstRtuA200) ProtoMessage()    {}
func (*WlstRtuA200) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{38}
}
func (m *WlstRtuA200) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtuA200) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtuA200.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtuA200) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtuA200.Merge(m, src)
}
func (m *WlstRtuA200) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtuA200) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtuA200.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtuA200 proto.InternalMessageInfo

func (m *WlstRtuA200) GetKNo() int32 {
	if m != nil {
		return m.KNo
	}
	return 0
}

func (m *WlstRtuA200) GetOperation() int32 {
	if m != nil {
		return m.Operation
	}
	return 0
}

type WlstRtu_4B00 struct {
	// kx操作，0-关，1-开，2-不变
	Operation []int32 `protobuf:"varint,1,rep,packed,name=operation,proto3" json:"operation,omitempty"`
}

func (m *WlstRtu_4B00) Reset()         { *m = WlstRtu_4B00{} }
func (m *WlstRtu_4B00) String() string { return proto.CompactTextString(m) }
func (*WlstRtu_4B00) ProtoMessage()    {}
func (*WlstRtu_4B00) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{39}
}
func (m *WlstRtu_4B00) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtu_4B00) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtu_4B00.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtu_4B00) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtu_4B00.Merge(m, src)
}
func (m *WlstRtu_4B00) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtu_4B00) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtu_4B00.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtu_4B00 proto.InternalMessageInfo

func (m *WlstRtu_4B00) GetOperation() []int32 {
	if m != nil {
		return m.Operation
	}
	return nil
}

// Wlst_rtu_1200
type WlstRtu_9300 struct {
	// yyyy-mm-dd hh:mm:ss w 格式
	TmlDate string `protobuf:"bytes,1,opt,name=tml_date,json=tmlDate,proto3" json:"tml_date,omitempty"`
}

func (m *WlstRtu_9300) Reset()         { *m = WlstRtu_9300{} }
func (m *WlstRtu_9300) String() string { return proto.CompactTextString(m) }
func (*WlstRtu_9300) ProtoMessage()    {}
func (*WlstRtu_9300) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{40}
}
func (m *WlstRtu_9300) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtu_9300) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtu_9300.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtu_9300) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtu_9300.Merge(m, src)
}
func (m *WlstRtu_9300) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtu_9300) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtu_9300.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtu_9300 proto.InternalMessageInfo

func (m *WlstRtu_9300) GetTmlDate() string {
	if m != nil {
		return m.TmlDate
	}
	return ""
}

// Wlst_rtu_3100_5800_6800_d900_e900
type WlstRtuB200 struct {
	//周日~周六k1开关时间 hhmm-hhmm
	XK1OptTime []string `protobuf:"bytes,1,rep,name=x_k1_opt_time,json=xK1OptTime,proto3" json:"x_k1_opt_time,omitempty"`
	//周日~周六k3开关时间 hhmm-hhmm
	XK2OptTime []string `protobuf:"bytes,2,rep,name=x_k2_opt_time,json=xK2OptTime,proto3" json:"x_k2_opt_time,omitempty"`
	//周日~周六k3开关时间 hhmm-hhmm
	XK3OptTime []string `protobuf:"bytes,3,rep,name=x_k3_opt_time,json=xK3OptTime,proto3" json:"x_k3_opt_time,omitempty"`
	//周日~周六市付费启用时分，hhmm
	XCityPayTime []string `protobuf:"bytes,4,rep,name=x_city_pay_time,json=xCityPayTime,proto3" json:"x_city_pay_time,omitempty"`
	//周日~周六自付费启用时分，hhmm
	XSelfPayTime []string `protobuf:"bytes,5,rep,name=x_self_pay_time,json=xSelfPayTime,proto3" json:"x_self_pay_time,omitempty"`
	//周日~周六k4开关时间 hhmm-hhmm
	XK4OptTime []string `protobuf:"bytes,6,rep,name=x_k4_opt_time,json=xK4OptTime,proto3" json:"x_k4_opt_time,omitempty"`
	//周日~周六k5开关时间 hhmm-hhmm
	XK5OptTime []string `protobuf:"bytes,7,rep,name=x_k5_opt_time,json=xK5OptTime,proto3" json:"x_k5_opt_time,omitempty"`
	//周日~周六k6开关时间 hhmm-hhmm
	XK6OptTime []string `protobuf:"bytes,8,rep,name=x_k6_opt_time,json=xK6OptTime,proto3" json:"x_k6_opt_time,omitempty"`
	//周日~周六k7开关时间 hhmm-hhmm
	XK7OptTime []string `protobuf:"bytes,9,rep,name=x_k7_opt_time,json=xK7OptTime,proto3" json:"x_k7_opt_time,omitempty"`
	//周日~周六k8开关时间 hhmm-hhmm
	XK8OptTime []string `protobuf:"bytes,10,rep,name=x_k8_opt_time,json=xK8OptTime,proto3" json:"x_k8_opt_time,omitempty"`
}

func (m *WlstRtuB200) Reset()         { *m = WlstRtuB200{} }
func (m *WlstRtuB200) String() string { return proto.CompactTextString(m) }
func (*WlstRtuB200) ProtoMessage()    {}
func (*WlstRtuB200) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{41}
}
func (m *WlstRtuB200) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtuB200) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtuB200.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtuB200) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtuB200.Merge(m, src)
}
func (m *WlstRtuB200) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtuB200) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtuB200.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtuB200 proto.InternalMessageInfo

func (m *WlstRtuB200) GetXK1OptTime() []string {
	if m != nil {
		return m.XK1OptTime
	}
	return nil
}

func (m *WlstRtuB200) GetXK2OptTime() []string {
	if m != nil {
		return m.XK2OptTime
	}
	return nil
}

func (m *WlstRtuB200) GetXK3OptTime() []string {
	if m != nil {
		return m.XK3OptTime
	}
	return nil
}

func (m *WlstRtuB200) GetXCityPayTime() []string {
	if m != nil {
		return m.XCityPayTime
	}
	return nil
}

func (m *WlstRtuB200) GetXSelfPayTime() []string {
	if m != nil {
		return m.XSelfPayTime
	}
	return nil
}

func (m *WlstRtuB200) GetXK4OptTime() []string {
	if m != nil {
		return m.XK4OptTime
	}
	return nil
}

func (m *WlstRtuB200) GetXK5OptTime() []string {
	if m != nil {
		return m.XK5OptTime
	}
	return nil
}

func (m *WlstRtuB200) GetXK6OptTime() []string {
	if m != nil {
		return m.XK6OptTime
	}
	return nil
}

func (m *WlstRtuB200) GetXK7OptTime() []string {
	if m != nil {
		return m.XK7OptTime
	}
	return nil
}

func (m *WlstRtuB200) GetXK8OptTime() []string {
	if m != nil {
		return m.XK8OptTime
	}
	return nil
}

// Wlst_rtu_4600_6500_c700
type WlstRtuE600 struct {
	//时间段1-4(或5-8)起始日期 mmdd-mmdd
	XHolidays []string `protobuf:"bytes,1,rep,name=x_holidays,json=xHolidays,proto3" json:"x_holidays,omitempty"`
	// K1时间段1-4(或5-8)开关时间 hhmm-hhmm
	XK1Time []string `protobuf:"bytes,2,rep,name=x_k1_time,json=xK1Time,proto3" json:"x_k1_time,omitempty"`
	// K2时间段1-4(或5-8)开关时间 hhmm-hhmm
	XK2Time []string `protobuf:"bytes,3,rep,name=x_k2_time,json=xK2Time,proto3" json:"x_k2_time,omitempty"`
	// K3时间段1-4(或5-8)开关时间 hhmm-hhmm
	XK3Time []string `protobuf:"bytes,4,rep,name=x_k3_time,json=xK3Time,proto3" json:"x_k3_time,omitempty"`
	// K4时间段1-4(或5-8)开关时间 hhmm-hhmm
	XK4Time []string `protobuf:"bytes,5,rep,name=x_k4_time,json=xK4Time,proto3" json:"x_k4_time,omitempty"`
	// K5时间段1-4(或5-8)开关时间 hhmm-hhmm
	XK5Time []string `protobuf:"bytes,6,rep,name=x_k5_time,json=xK5Time,proto3" json:"x_k5_time,omitempty"`
	// K6时间段1-4(或5-8)开关时间 hhmm-hhmm
	XK6Time []string `protobuf:"bytes,7,rep,name=x_k6_time,json=xK6Time,proto3" json:"x_k6_time,omitempty"`
	// K7时间段1-4(或5-8)开关时间 hhmm-hhmm
	XK7Time []string `protobuf:"bytes,10,rep,name=x_k7_time,json=xK7Time,proto3" json:"x_k7_time,omitempty"`
	// K8时间段1-4(或5-8)开关时间 hhmm-hhmm
	XK8Time []string `protobuf:"bytes,11,rep,name=x_k8_time,json=xK8Time,proto3" json:"x_k8_time,omitempty"`
	//时间段1-4(或5-8)市付
	XCityPayTime []string `protobuf:"bytes,8,rep,name=x_city_pay_time,json=xCityPayTime,proto3" json:"x_city_pay_time,omitempty"`
	//时间段1-4(或5-8)自付
	XSelfPayTime []string `protobuf:"bytes,9,rep,name=x_self_pay_time,json=xSelfPayTime,proto3" json:"x_self_pay_time,omitempty"`
}

func (m *WlstRtuE600) Reset()         { *m = WlstRtuE600{} }
func (m *WlstRtuE600) String() string { return proto.CompactTextString(m) }
func (*WlstRtuE600) ProtoMessage()    {}
func (*WlstRtuE600) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{42}
}
func (m *WlstRtuE600) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtuE600) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtuE600.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtuE600) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtuE600.Merge(m, src)
}
func (m *WlstRtuE600) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtuE600) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtuE600.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtuE600 proto.InternalMessageInfo

func (m *WlstRtuE600) GetXHolidays() []string {
	if m != nil {
		return m.XHolidays
	}
	return nil
}

func (m *WlstRtuE600) GetXK1Time() []string {
	if m != nil {
		return m.XK1Time
	}
	return nil
}

func (m *WlstRtuE600) GetXK2Time() []string {
	if m != nil {
		return m.XK2Time
	}
	return nil
}

func (m *WlstRtuE600) GetXK3Time() []string {
	if m != nil {
		return m.XK3Time
	}
	return nil
}

func (m *WlstRtuE600) GetXK4Time() []string {
	if m != nil {
		return m.XK4Time
	}
	return nil
}

func (m *WlstRtuE600) GetXK5Time() []string {
	if m != nil {
		return m.XK5Time
	}
	return nil
}

func (m *WlstRtuE600) GetXK6Time() []string {
	if m != nil {
		return m.XK6Time
	}
	return nil
}

func (m *WlstRtuE600) GetXK7Time() []string {
	if m != nil {
		return m.XK7Time
	}
	return nil
}

func (m *WlstRtuE600) GetXK8Time() []string {
	if m != nil {
		return m.XK8Time
	}
	return nil
}

func (m *WlstRtuE600) GetXCityPayTime() []string {
	if m != nil {
		return m.XCityPayTime
	}
	return nil
}

func (m *WlstRtuE600) GetXSelfPayTime() []string {
	if m != nil {
		return m.XSelfPayTime
	}
	return nil
}

// Wlst_rtu_4c00_cc00
type WlstRtu_9800 struct {
	// 4c00和cc00时表示：设置档位，1-1档，2-2档，3-3档，4-旁路，5-返回状态。9800时表示：终端开机申请状态1-参数正常，0-参数错误，2-时钟错误
	Status int32 `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *WlstRtu_9800) Reset()         { *m = WlstRtu_9800{} }
func (m *WlstRtu_9800) String() string { return proto.CompactTextString(m) }
func (*WlstRtu_9800) ProtoMessage()    {}
func (*WlstRtu_9800) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{43}
}
func (m *WlstRtu_9800) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtu_9800) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtu_9800.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtu_9800) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtu_9800.Merge(m, src)
}
func (m *WlstRtu_9800) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtu_9800) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtu_9800.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtu_9800 proto.InternalMessageInfo

func (m *WlstRtu_9800) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

// Wlst_rtu_ab00
type WlstRtuDc00 struct {
	// ab00-》序列号,dc00-》版本字符串
	Ver string `protobuf:"bytes,1,opt,name=ver,proto3" json:"ver,omitempty"`
}

func (m *WlstRtuDc00) Reset()         { *m = WlstRtuDc00{} }
func (m *WlstRtuDc00) String() string { return proto.CompactTextString(m) }
func (*WlstRtuDc00) ProtoMessage()    {}
func (*WlstRtuDc00) Descriptor() ([]byte, []int) {
	return fileDescriptor_25d30f1c467c939f, []int{44}
}
func (m *WlstRtuDc00) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstRtuDc00) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstRtuDc00.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstRtuDc00) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstRtuDc00.Merge(m, src)
}
func (m *WlstRtuDc00) XXX_Size() int {
	return m.Size()
}
func (m *WlstRtuDc00) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstRtuDc00.DiscardUnknown(m)
}

var xxx_messageInfo_WlstRtuDc00 proto.InternalMessageInfo

func (m *WlstRtuDc00) GetVer() string {
	if m != nil {
		return m.Ver
	}
	return ""
}

func init() {
	proto.RegisterType((*WlstRtuAns)(nil), "wlst.pb2.Wlst_rtu_ans")
	proto.RegisterType((*WlstRtu_7094)(nil), "wlst.pb2.Wlst_rtu_7094")
	proto.RegisterType((*WlstRtu_7094_Alarm_LN)(nil), "wlst.pb2.Wlst_rtu_7094.Alarm_LN")
	proto.RegisterType((*WlstRtu_7021)(nil), "wlst.pb2.Wlst_rtu_7021")
	proto.RegisterType((*WlstRtu_7021_Args_LN)(nil), "wlst.pb2.Wlst_rtu_7021.Args_LN")
	proto.RegisterType((*WlstRtu_7021_Args_WC)(nil), "wlst.pb2.Wlst_rtu_7021.Args_WC")
	proto.RegisterType((*WlstRtu_7023)(nil), "wlst.pb2.Wlst_rtu_7023")
	proto.RegisterType((*WlstRtu_7023_Args_Control)(nil), "wlst.pb2.Wlst_rtu_7023.Args_Control")
	proto.RegisterType((*WlstRtu_705B)(nil), "wlst.pb2.Wlst_rtu_705b")
	proto.RegisterType((*WlstRtu_70A0)(nil), "wlst.pb2.Wlst_rtu_70a0")
	proto.RegisterType((*WlstRtu_70A0_ElectricEnergy)(nil), "wlst.pb2.Wlst_rtu_70a0.Electric_energy")
	proto.RegisterType((*WlstRtu_70A0_GpsArgs)(nil), "wlst.pb2.Wlst_rtu_70a0.Gps_args")
	proto.RegisterType((*WlstRtu_7053)(nil), "wlst.pb2.Wlst_rtu_7053")
	proto.RegisterType((*WlstRtu_70D3)(nil), "wlst.pb2.Wlst_rtu_70d3")
	proto.RegisterType((*WlstRtu_70D0Max)(nil), "wlst.pb2.Wlst_rtu_70d0_max")
	proto.RegisterType((*WlstRtu_70D0Max_MaxData)(nil), "wlst.pb2.Wlst_rtu_70d0_max.Max_data")
	proto.RegisterType((*WlstRtu_7800)(nil), "wlst.pb2.Wlst_rtu_7800")
	proto.RegisterType((*WlstRtu_7050)(nil), "wlst.pb2.Wlst_rtu_7050")
	proto.RegisterType((*WlstRtu_70D0)(nil), "wlst.pb2.Wlst_rtu_70d0")
	proto.RegisterType((*WlstRtu_70D0_DataMark)(nil), "wlst.pb2.Wlst_rtu_70d0.Data_mark")
	proto.RegisterType((*WlstRtu_70D0_SamplingVoltage)(nil), "wlst.pb2.Wlst_rtu_70d0.Sampling_voltage")
	proto.RegisterType((*WlstRtu_70D0_AnalogData)(nil), "wlst.pb2.Wlst_rtu_70d0.Analog_data")
	proto.RegisterType((*WlstRtu_705A)(nil), "wlst.pb2.Wlst_rtu_705a")
	proto.RegisterType((*WlstRtu_70Da)(nil), "wlst.pb2.Wlst_rtu_70da")
	proto.RegisterType((*WlstRtu_700A)(nil), "wlst.pb2.Wlst_rtu_700a")
	proto.RegisterType((*WlstRtu_7010)(nil), "wlst.pb2.Wlst_rtu_7010")
	proto.RegisterType((*WlstRtu_7003)(nil), "wlst.pb2.Wlst_rtu_7003")
	proto.RegisterType((*WlstRtu_7006)(nil), "wlst.pb2.Wlst_rtu_7006")
	proto.RegisterType((*WlstRtu_7007)(nil), "wlst.pb2.Wlst_rtu_7007")
	proto.RegisterType((*WlstRtu_7087)(nil), "wlst.pb2.Wlst_rtu_7087")
	proto.RegisterType((*WlstRtu_7081)(nil), "wlst.pb2.Wlst_rtu_7081")
	proto.RegisterType((*WlstRtu_7008)(nil), "wlst.pb2.Wlst_rtu_7008")
	proto.RegisterType((*WlstRtu_7060)(nil), "wlst.pb2.Wlst_rtu_7060")
	proto.RegisterType((*WlstRtu_7060_YearCtrl)(nil), "wlst.pb2.Wlst_rtu_7060.YearCtrl")
	proto.RegisterType((*WlstRtu_7061)(nil), "wlst.pb2.Wlst_rtu_7061")
	proto.RegisterType((*WlstRtu_70E0)(nil), "wlst.pb2.Wlst_rtu_70e0")
	proto.RegisterType((*WlstRtu_7B00)(nil), "wlst.pb2.Wlst_rtu_7b00")
	proto.RegisterType((*WlstRtu_1900)(nil), "wlst.pb2.Wlst_rtu_1900")
	proto.RegisterType((*WlstRtu_4000)(nil), "wlst.pb2.Wlst_rtu_4000")
	proto.RegisterType((*WlstRtu_4101)(nil), "wlst.pb2.Wlst_rtu_4101")
	proto.RegisterType((*WlstRtu_4104)(nil), "wlst.pb2.Wlst_rtu_4104")
	proto.RegisterType((*WlstRtu_4110)(nil), "wlst.pb2.Wlst_rtu_4110")
	proto.RegisterType((*WlstRtu_4111)(nil), "wlst.pb2.Wlst_rtu_4111")
	proto.RegisterType((*WlstRtu_4200)(nil), "wlst.pb2.Wlst_rtu_4200")
	proto.RegisterType((*WlstRtu_4401)(nil), "wlst.pb2.Wlst_rtu_4401")
	proto.RegisterType((*WlstRtuDa00)(nil), "wlst.pb2.Wlst_rtu_da00")
	proto.RegisterType((*WlstRtuDf00)(nil), "wlst.pb2.Wlst_rtu_df00")
	proto.RegisterType((*WlstRtu_6100)(nil), "wlst.pb2.Wlst_rtu_6100")
	proto.RegisterType((*WlstRtuA000)(nil), "wlst.pb2.Wlst_rtu_a000")
	proto.RegisterType((*WlstRtuA200)(nil), "wlst.pb2.Wlst_rtu_a200")
	proto.RegisterType((*WlstRtu_4B00)(nil), "wlst.pb2.Wlst_rtu_4b00")
	proto.RegisterType((*WlstRtu_9300)(nil), "wlst.pb2.Wlst_rtu_9300")
	proto.RegisterType((*WlstRtuB200)(nil), "wlst.pb2.Wlst_rtu_b200")
	proto.RegisterType((*WlstRtuE600)(nil), "wlst.pb2.Wlst_rtu_e600")
	proto.RegisterType((*WlstRtu_9800)(nil), "wlst.pb2.Wlst_rtu_9800")
	proto.RegisterType((*WlstRtuDc00)(nil), "wlst.pb2.Wlst_rtu_dc00")
}

func init() { proto.RegisterFile("protocol_rtu.proto", fileDescriptor_25d30f1c467c939f) }

var fileDescriptor_25d30f1c467c939f = []byte{
	// 3389 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5a, 0xcb, 0x6f, 0x23, 0xc7,
	0x99, 0x77, 0x93, 0xe2, 0xab, 0x48, 0xbd, 0x7a, 0x66, 0x3c, 0xb4, 0xec, 0x79, 0xb5, 0xc7, 0x1e,
	0xed, 0xec, 0x42, 0xdb, 0x24, 0xf5, 0x1a, 0x2f, 0x76, 0xbd, 0x33, 0x9a, 0x71, 0x66, 0xa0, 0x79,
	0xa5, 0x65, 0x8f, 0x91, 0x43, 0xd0, 0x28, 0x75, 0x97, 0x28, 0x42, 0xcd, 0xee, 0x4e, 0x77, 0x51,
	0x22, 0x4f, 0x09, 0x90, 0x20, 0x08, 0x8c, 0x20, 0xc9, 0x2d, 0xa7, 0xe4, 0x66, 0x20, 0xc7, 0x00,
	0xf9, 0x27, 0x72, 0x09, 0x60, 0xe4, 0x94, 0x43, 0x0e, 0x81, 0x7d, 0x30, 0x7c, 0xcb, 0xc5, 0x87,
	0x20, 0x97, 0xe0, 0xab, 0x47, 0x77, 0x15, 0x29, 0x52, 0xa3, 0x41, 0x90, 0x43, 0xe0, 0x9b, 0xfa,
	0xfb, 0x7e, 0x55, 0xf5, 0xd5, 0x57, 0xdf, 0x9b, 0x42, 0x66, 0x9c, 0x44, 0x34, 0xf2, 0xa2, 0xc0,
	0x4d, 0xe8, 0x60, 0x8d, 0x7d, 0x98, 0xd5, 0x93, 0x20, 0xa5, 0x6b, 0xf1, 0x7e, 0xdb, 0xfa, 0x8d,
	0x81, 0x1a, 0x1f, 0x07, 0x29, 0x05, 0xa6, 0x8b, 0xc3, 0xd4, 0xbc, 0x8c, 0x2a, 0x5e, 0xdf, 0x77,
	0x7b, 0xfe, 0xb0, 0x69, 0x5c, 0x37, 0x56, 0x4b, 0x4e, 0xd9, 0xeb, 0xfb, 0x8f, 0xfc, 0xa1, 0x79,
	0x0d, 0xd5, 0x7c, 0x4c, 0xb1, 0xdb, 0xc7, 0xc9, 0x51, 0xb3, 0x70, 0xbd, 0xb8, 0x5a, 0xba, 0x57,
	0x58, 0x32, 0x9c, 0x2a, 0x10, 0x9f, 0xe0, 0xe4, 0xc8, 0xbc, 0x81, 0x10, 0x03, 0xc4, 0x51, 0x2f,
	0xa4, 0xcd, 0x62, 0x86, 0x60, 0xcb, 0x9e, 0x03, 0xd1, 0x5c, 0x41, 0xe5, 0x94, 0x62, 0x3a, 0x48,
	0x9b, 0x73, 0x19, 0x5b, 0x50, 0xcc, 0x6b, 0xa8, 0xce, 0xff, 0x72, 0xbd, 0xc8, 0x27, 0xcd, 0x12,
	0x3b, 0x1c, 0x71, 0xd2, 0x4e, 0xe4, 0x13, 0xeb, 0xd3, 0x02, 0x9a, 0xcf, 0x44, 0xdd, 0xb2, 0xef,
	0xac, 0x4f, 0x97, 0xf5, 0x0a, 0x42, 0x38, 0xc0, 0x49, 0xdf, 0xa5, 0xa3, 0x98, 0x34, 0x0b, 0x8c,
	0x57, 0x63, 0x94, 0x0f, 0x47, 0x31, 0x31, 0xdf, 0x43, 0x15, 0xf6, 0x11, 0x84, 0xcd, 0xe2, 0x75,
	0x63, 0xb5, 0xde, 0xbe, 0xbe, 0x26, 0x15, 0xb2, 0xa6, 0x9d, 0xb0, 0x76, 0x97, 0xed, 0xf2, 0xf8,
	0xa9, 0x23, 0x17, 0x98, 0x1d, 0x74, 0x31, 0x3d, 0xe9, 0x51, 0xef, 0xd0, 0x8d, 0x06, 0xd4, 0x4d,
	0xa9, 0x1b, 0x63, 0xef, 0x88, 0xf8, 0xca, 0x85, 0x96, 0x39, 0xff, 0xd9, 0x80, 0xee, 0xd1, 0xe7,
	0x8c, 0xb9, 0x72, 0x84, 0xaa, 0x72, 0x27, 0x10, 0x3a, 0x88, 0xa2, 0xd8, 0x0d, 0x23, 0x29, 0x34,
	0x7c, 0x3e, 0x8d, 0xcc, 0x1b, 0xa8, 0xc1, 0x85, 0x16, 0x2a, 0xe2, 0x62, 0xd7, 0x19, 0x6d, 0x8f,
	0xeb, 0xe8, 0x6d, 0x34, 0xcf, 0x21, 0xde, 0x20, 0x49, 0x08, 0xd3, 0xb2, 0xb1, 0x6a, 0x38, 0x7c,
	0xdd, 0x0e, 0xa7, 0x59, 0x5f, 0x96, 0x34, 0x3d, 0xb5, 0x5b, 0xd3, 0xf5, 0xf4, 0xa6, 0x78, 0x53,
	0x45, 0x4d, 0xec, 0x3d, 0x99, 0x96, 0xb6, 0x50, 0x19, 0x27, 0xdd, 0x94, 0x29, 0xa9, 0xb8, 0x5a,
	0x6f, 0x5f, 0x3b, 0x55, 0x49, 0xed, 0xd6, 0xda, 0xdd, 0xa4, 0x9b, 0x82, 0x8e, 0x04, 0x7c, 0xfc,
	0x25, 0xe7, 0xc6, 0x5f, 0x12, 0x8e, 0x65, 0x2a, 0x60, 0xc7, 0xf2, 0x87, 0xae, 0x02, 0x41, 0x3d,
	0xf6, 0xc4, 0x6b, 0x96, 0x5f, 0xe2, 0xd8, 0x8f, 0x77, 0x1c, 0x01, 0x5f, 0xf9, 0xa1, 0x81, 0x2a,
	0x42, 0x94, 0xe9, 0x4a, 0xbe, 0x82, 0xd0, 0x3e, 0x4e, 0x89, 0x7b, 0x8c, 0x83, 0x41, 0x66, 0x19,
	0x40, 0x79, 0x01, 0x04, 0x10, 0x9d, 0x2b, 0x98, 0xf3, 0x8b, 0x5c, 0x74, 0x46, 0xca, 0x00, 0xfb,
	0x09, 0xc1, 0x47, 0x02, 0x20, 0xee, 0xc6, 0x48, 0x0c, 0xb0, 0xf2, 0x55, 0x41, 0x48, 0xf1, 0xf1,
	0x8e, 0x79, 0x01, 0x95, 0x82, 0x96, 0x1b, 0x85, 0x42, 0x86, 0xb9, 0xa0, 0xf5, 0x2c, 0x34, 0x2f,
	0xa1, 0x32, 0x10, 0x0f, 0x0e, 0xc4, 0xe9, 0xa5, 0xa0, 0xf5, 0xec, 0xe0, 0x80, 0x61, 0xdb, 0x80,
	0x2d, 0x0a, 0x6c, 0x5b, 0x60, 0xdb, 0x0c, 0x3b, 0x27, 0xb0, 0x6d, 0x89, 0xed, 0x00, 0xb6, 0x24,
	0xb0, 0x1d, 0x81, 0xed, 0x30, 0x6c, 0x59, 0x60, 0x3b, 0x12, 0xbb, 0x0e, 0xd8, 0x8a, 0xc0, 0xae,
	0x0b, 0xec, 0x3a, 0xc3, 0x56, 0x05, 0x76, 0x5d, 0x62, 0x37, 0x00, 0x5b, 0x13, 0xd8, 0x0d, 0x81,
	0xdd, 0x60, 0x58, 0x24, 0xb0, 0x1b, 0x12, 0xbb, 0x09, 0xd8, 0xba, 0xc0, 0x6e, 0x0a, 0xec, 0x26,
	0xc3, 0x36, 0x04, 0x76, 0x53, 0x62, 0xb7, 0x00, 0x3b, 0x2f, 0xb0, 0x5b, 0x02, 0xbb, 0xc5, 0xb0,
	0x0b, 0x02, 0xbb, 0x25, 0xb1, 0xdb, 0x80, 0x5d, 0x14, 0xd8, 0x6d, 0x81, 0xdd, 0x66, 0xd8, 0x25,
	0x81, 0xdd, 0x7e, 0x76, 0x70, 0x60, 0x7d, 0x6d, 0xe8, 0x96, 0xde, 0x79, 0x45, 0x4b, 0xff, 0x00,
	0xd5, 0xc1, 0x86, 0xbc, 0x28, 0xa4, 0x49, 0x14, 0x08, 0x73, 0xbf, 0x79, 0xba, 0xdd, 0x75, 0xb8,
	0xdd, 0xed, 0x70, 0xac, 0xa3, 0x2e, 0x3c, 0xd3, 0xf0, 0x57, 0x1e, 0xa0, 0x86, 0xba, 0x7a, 0xba,
	0x99, 0xbe, 0x85, 0x6a, 0x51, 0x4c, 0x12, 0x4c, 0x7b, 0x51, 0x28, 0xad, 0x34, 0x23, 0x58, 0x5f,
	0xea, 0xf7, 0xde, 0xd8, 0x9f, 0x7e, 0xef, 0x37, 0x50, 0x15, 0x18, 0xca, 0xb5, 0x01, 0xc8, 0x6e,
	0x7d, 0x03, 0x35, 0x0e, 0x71, 0xe2, 0x9f, 0xe0, 0x84, 0xb8, 0xc7, 0x24, 0x61, 0x86, 0x57, 0x73,
	0xea, 0x92, 0xf6, 0x82, 0x24, 0xe6, 0x7f, 0xa0, 0xa5, 0x38, 0x89, 0xfc, 0x81, 0x07, 0xc7, 0xba,
	0xfb, 0x98, 0x7a, 0x87, 0xec, 0x56, 0x35, 0x67, 0x31, 0xa7, 0xdf, 0x03, 0xb2, 0x79, 0x0b, 0x29,
	0x24, 0xd7, 0xc7, 0x94, 0x7b, 0x76, 0xcd, 0x59, 0xc8, 0xc9, 0xf7, 0x31, 0x25, 0xe6, 0x7f, 0xa2,
	0xe5, 0x5e, 0x98, 0x52, 0x1c, 0x04, 0x38, 0x87, 0x96, 0x19, 0x74, 0x49, 0x65, 0x00, 0xd8, 0xfa,
	0x6b, 0x45, 0xbb, 0x29, 0xb6, 0x5f, 0xe9, 0xa6, 0x6f, 0xa1, 0xda, 0x41, 0x42, 0xbe, 0x37, 0x20,
	0xa1, 0x37, 0x62, 0xd7, 0x2c, 0x38, 0x39, 0xc1, 0xdc, 0x42, 0x05, 0x42, 0x58, 0xfc, 0xae, 0xb7,
	0x6f, 0x9d, 0xfa, 0xe8, 0xd8, 0x5e, 0x7b, 0x10, 0x10, 0x8f, 0x26, 0x3d, 0xcf, 0x25, 0x21, 0x49,
	0xba, 0x23, 0xa7, 0x40, 0x88, 0x79, 0x1d, 0xd5, 0x29, 0xe9, 0xb3, 0x57, 0x19, 0x24, 0x32, 0x90,
	0xa9, 0x24, 0x73, 0x05, 0x55, 0x0f, 0x07, 0xfd, 0x9e, 0xdf, 0xa3, 0x23, 0xe1, 0x95, 0xd9, 0x37,
	0xa8, 0xbf, 0x8f, 0x7b, 0xa1, 0x7b, 0x1c, 0x05, 0x14, 0x77, 0x09, 0xf3, 0x4f, 0xc3, 0xa9, 0x03,
	0xed, 0x05, 0x27, 0x41, 0xb8, 0xdf, 0xc7, 0x94, 0x92, 0x64, 0xe4, 0xc6, 0xd1, 0x09, 0x49, 0x84,
	0xb7, 0x36, 0x04, 0xf1, 0x39, 0xd0, 0xe0, 0x72, 0x41, 0x14, 0x76, 0x7b, 0x74, 0xe0, 0x13, 0xe6,
	0xb8, 0x86, 0x93, 0x13, 0x40, 0x02, 0x50, 0x27, 0x63, 0x22, 0xc6, 0xcc, 0xbe, 0x21, 0x0d, 0x76,
	0xe3, 0x14, 0x0c, 0x98, 0x39, 0xf1, 0xb4, 0x34, 0x88, 0xed, 0xb5, 0x6f, 0xc5, 0xa9, 0x0b, 0x38,
	0x47, 0x2e, 0x30, 0x5b, 0xe8, 0x82, 0x48, 0x83, 0xbd, 0x50, 0xc9, 0x82, 0x8d, 0x2c, 0x0b, 0x2e,
	0x71, 0xf6, 0xa3, 0x50, 0x26, 0xc1, 0xa9, 0x99, 0x73, 0x7e, 0x46, 0xe6, 0x34, 0xdf, 0x45, 0xf3,
	0xb4, 0x1f, 0x28, 0xe8, 0x85, 0x0c, 0x5d, 0xa7, 0xfd, 0x20, 0xc3, 0x5d, 0x43, 0x35, 0xc0, 0x25,
	0x24, 0x25, 0xb4, 0xb9, 0x98, 0x57, 0x27, 0xb4, 0x1f, 0x38, 0x40, 0x83, 0xc0, 0xcf, 0x5c, 0xcd,
	0x8b, 0x06, 0x21, 0x15, 0x61, 0x84, 0x65, 0xa1, 0x1d, 0x20, 0xac, 0xfc, 0xa0, 0x80, 0x16, 0xc7,
	0xde, 0xd8, 0x6c, 0xa2, 0x8a, 0x7c, 0x1c, 0x83, 0x19, 0x8d, 0xfc, 0x04, 0x8e, 0xcc, 0xc0, 0x05,
	0xce, 0x11, 0x9f, 0xf0, 0xaa, 0xec, 0xa9, 0xdc, 0x03, 0xec, 0xd1, 0x28, 0x11, 0xd6, 0x56, 0x67,
	0xb4, 0x0f, 0x18, 0x89, 0xe5, 0x79, 0x8f, 0xf6, 0x8e, 0x89, 0x78, 0xd4, 0x39, 0x0e, 0xe1, 0x34,
	0xfe, 0xa6, 0xef, 0xa0, 0x85, 0x84, 0x68, 0xa0, 0x12, 0x03, 0xcd, 0x4b, 0x2a, 0x87, 0x41, 0x39,
	0xc0, 0x41, 0x5c, 0x62, 0x66, 0x63, 0x05, 0x47, 0x6c, 0xff, 0x80, 0xdf, 0xe2, 0x16, 0x5a, 0xcc,
	0xf6, 0x12, 0xb0, 0x0a, 0x83, 0x65, 0x47, 0x70, 0xe0, 0xca, 0x8f, 0x0c, 0x54, 0x95, 0x0f, 0x0d,
	0xde, 0xd4, 0x8d, 0x53, 0xee, 0x4d, 0xdc, 0xcf, 0xe0, 0xe9, 0x99, 0x37, 0xbd, 0xc1, 0x4c, 0x4a,
	0x73, 0xb4, 0x00, 0xd3, 0x8c, 0x15, 0x85, 0x9c, 0x55, 0x14, 0xac, 0x28, 0x64, 0xac, 0x5b, 0x68,
	0x31, 0x88, 0x3c, 0xee, 0xf2, 0x59, 0x0d, 0x08, 0x88, 0x05, 0x49, 0xe6, 0x35, 0x8e, 0xf5, 0xdb,
	0xb1, 0xe0, 0xd6, 0x99, 0x55, 0x92, 0xd6, 0x13, 0xe2, 0x45, 0x89, 0xe6, 0xf5, 0x88, 0x93, 0xa4,
	0x3c, 0x3e, 0x98, 0x1a, 0x4e, 0x78, 0xa9, 0x54, 0x74, 0x2a, 0x3e, 0xdd, 0x83, 0x4f, 0x78, 0x05,
	0xb1, 0x96, 0x5b, 0x04, 0x17, 0x46, 0xec, 0xc7, 0x6c, 0x82, 0x6b, 0x8e, 0x41, 0xfc, 0x5e, 0x4a,
	0x71, 0xe8, 0x71, 0x1f, 0x2f, 0x82, 0xe6, 0x80, 0x7c, 0x5f, 0x50, 0xad, 0x9f, 0x15, 0x35, 0x91,
	0xfd, 0x19, 0x22, 0xe7, 0xc7, 0xd2, 0x88, 0xe2, 0x40, 0x16, 0x79, 0x42, 0x66, 0x20, 0x81, 0xa5,
	0x0a, 0x08, 0x2c, 0xe7, 0x6a, 0xac, 0x71, 0x0a, 0xec, 0xf0, 0x36, 0x9a, 0x17, 0x6c, 0x4d, 0x8d,
	0x62, 0xdb, 0xbd, 0xac, 0x98, 0x56, 0x35, 0x53, 0x9a, 0xa9, 0x99, 0xf2, 0x6c, 0xcd, 0x54, 0x5e,
	0x4a, 0x33, 0xd5, 0xd3, 0x34, 0x63, 0xae, 0x8b, 0xb4, 0xbb, 0x65, 0xfb, 0x76, 0xb3, 0xc6, 0x42,
	0xec, 0xe5, 0x53, 0x83, 0x8c, 0x6f, 0xf3, 0x7c, 0x0c, 0x7f, 0x99, 0xef, 0xa3, 0xf9, 0x6c, 0x95,
	0xdb, 0xc7, 0xc3, 0x26, 0x62, 0x2b, 0xdf, 0x9c, 0xb2, 0x12, 0x20, 0x4e, 0x5d, 0xae, 0x7e, 0x82,
	0x87, 0xd6, 0xdf, 0x0d, 0xb4, 0x3c, 0x01, 0x61, 0x35, 0x00, 0x75, 0xb9, 0x84, 0xec, 0x59, 0x8a,
	0x4e, 0xd5, 0xa7, 0x0e, 0xfb, 0x3e, 0xdb, 0x96, 0xf4, 0x00, 0x52, 0x1c, 0x0b, 0x20, 0xe6, 0xfb,
	0xa8, 0xda, 0xc7, 0x43, 0xc8, 0x66, 0x58, 0xe4, 0x92, 0x9b, 0x33, 0xc4, 0x5d, 0x7b, 0x22, 0xb0,
	0x4e, 0xa5, 0x8f, 0x87, 0xf7, 0x31, 0xc5, 0x2b, 0x0f, 0x51, 0x55, 0x12, 0x41, 0x18, 0x11, 0x50,
	0xd8, 0xf5, 0x0d, 0x16, 0xb8, 0x91, 0x20, 0x3d, 0x19, 0xbf, 0x4a, 0x41, 0xbf, 0x8a, 0xf5, 0x95,
	0xe6, 0x41, 0xdb, 0xb6, 0x0d, 0xb2, 0x93, 0x63, 0xd8, 0x4d, 0xf1, 0xe7, 0x1a, 0xa3, 0xb0, 0xab,
	0x5d, 0x43, 0x75, 0xce, 0xf6, 0x02, 0x9c, 0xca, 0xc6, 0x83, 0xaf, 0xd8, 0x01, 0x0a, 0xb3, 0x16,
	0x78, 0x90, 0x70, 0xd0, 0x97, 0x7e, 0x0d, 0xdf, 0x4f, 0x07, 0x7d, 0xcd, 0x90, 0xe6, 0x74, 0x43,
	0xba, 0x84, 0xca, 0x3e, 0x75, 0x49, 0xe8, 0x0b, 0xb7, 0x29, 0xf9, 0xf4, 0x41, 0xe8, 0x83, 0x6f,
	0xe0, 0x20, 0x60, 0x7b, 0xf1, 0x9c, 0x58, 0xc6, 0x41, 0x00, 0x5b, 0x5d, 0x66, 0x51, 0x95, 0x31,
	0x2a, 0xc2, 0x69, 0x06, 0x89, 0x38, 0x23, 0xc1, 0x27, 0x5c, 0xb7, 0x55, 0x56, 0x29, 0x54, 0x12,
	0x7c, 0x02, 0x5a, 0xb3, 0x1e, 0xe8, 0xc1, 0xc2, 0x3e, 0xbb, 0x02, 0x14, 0xfd, 0x6b, 0x56, 0x01,
	0x42, 0xef, 0x6a, 0x7d, 0x52, 0xd3, 0x3d, 0x78, 0xc6, 0x3e, 0xff, 0x37, 0xbe, 0x4f, 0xbd, 0x7d,
	0x63, 0xca, 0x4b, 0xaf, 0xdd, 0x97, 0x40, 0xa5, 0x4d, 0x9e, 0x92, 0x39, 0x8b, 0xaf, 0x90, 0x39,
	0xe7, 0xce, 0x95, 0x39, 0x4b, 0xa7, 0x67, 0xce, 0xb1, 0x2a, 0xa6, 0x3c, 0x59, 0xc5, 0x5c, 0x41,
	0xa8, 0x1b, 0x27, 0xa9, 0x48, 0xae, 0xfc, 0x69, 0x6a, 0x40, 0xe1, 0x99, 0xf5, 0x1a, 0xaa, 0x33,
	0x76, 0xda, 0xeb, 0x86, 0x38, 0x10, 0x35, 0x0a, 0x5b, 0xb1, 0xc7, 0x28, 0x7a, 0x6e, 0xae, 0x9d,
	0x92, 0x9b, 0x6f, 0xa3, 0x45, 0x00, 0x40, 0xe2, 0x91, 0x41, 0x0d, 0x65, 0x30, 0xb8, 0x05, 0x14,
	0xcd, 0x22, 0xb2, 0x65, 0x09, 0x36, 0x1d, 0xc4, 0x71, 0x30, 0x62, 0x95, 0x8b, 0x21, 0x12, 0xec,
	0x1e, 0x23, 0x99, 0x7b, 0x68, 0x29, 0xc5, 0xfd, 0x38, 0xe8, 0x85, 0xdd, 0xac, 0xba, 0x6a, 0x30,
	0x97, 0x5c, 0x9d, 0xf6, 0x50, 0x7b, 0x63, 0x78, 0x67, 0x51, 0xee, 0x20, 0x6b, 0xb1, 0xfb, 0xa8,
	0x8e, 0x43, 0x1c, 0x44, 0x5d, 0x6e, 0x86, 0xf3, 0x6c, 0xbf, 0xb7, 0xa7, 0xed, 0x77, 0x37, 0x87,
	0x3a, 0x88, 0xaf, 0x03, 0x5b, 0x30, 0xaf, 0xa3, 0x86, 0xfa, 0xf8, 0xac, 0xf5, 0x29, 0x3a, 0x28,
	0x7f, 0x71, 0xd3, 0x42, 0xf3, 0xda, 0x5b, 0x8b, 0x3e, 0xa8, 0xae, 0x3c, 0x30, 0x38, 0x16, 0x7f,
	0x5a, 0xd9, 0x0e, 0xb1, 0xf7, 0x84, 0x77, 0x3a, 0x18, 0x04, 0x81, 0x9b, 0xe0, 0xb0, 0x4b, 0x9a,
	0xcb, 0xfc, 0x9d, 0x80, 0xe2, 0x00, 0x41, 0x8f, 0x19, 0xe6, 0x58, 0xf8, 0x5b, 0x43, 0xcb, 0xca,
	0xb1, 0x09, 0xc1, 0x69, 0x14, 0x36, 0x2f, 0x64, 0x8f, 0xb0, 0x98, 0x1d, 0xef, 0x30, 0xd6, 0x8a,
	0x8b, 0x6a, 0x99, 0x71, 0xc3, 0xad, 0xba, 0x84, 0xba, 0xc9, 0x20, 0xe4, 0xca, 0x31, 0x84, 0x09,
	0x10, 0xea, 0x0c, 0x42, 0x76, 0x6f, 0x1b, 0x5d, 0x04, 0x04, 0xdf, 0x45, 0x39, 0x81, 0xfb, 0xa1,
	0xd9, 0x25, 0x74, 0x4f, 0xb2, 0xc4, 0x01, 0xdf, 0x46, 0x4b, 0xe3, 0x8f, 0x02, 0xbd, 0xe1, 0x71,
	0x14, 0xb8, 0x58, 0x04, 0xc4, 0xb9, 0xe3, 0x28, 0xb8, 0x2b, 0x89, 0xfb, 0x6c, 0x2f, 0x4e, 0xbc,
	0x27, 0x89, 0x9e, 0x18, 0x90, 0x00, 0x71, 0x67, 0xe5, 0x53, 0x03, 0xd5, 0x95, 0x87, 0x19, 0xaf,
	0xef, 0x8c, 0xa9, 0xf5, 0x9d, 0x91, 0xd7, 0x77, 0x17, 0x51, 0x89, 0x17, 0x64, 0x7c, 0x63, 0xfe,
	0x01, 0xf5, 0x9a, 0x58, 0xaa, 0x27, 0xe5, 0x79, 0x41, 0x15, 0xb6, 0xfb, 0x0e, 0x5a, 0x90, 0x61,
	0x5d, 0xc0, 0x78, 0x62, 0x9e, 0x17, 0x54, 0x51, 0x01, 0xed, 0xe8, 0x31, 0x0d, 0xbf, 0x4a, 0xcf,
	0x63, 0xfd, 0x51, 0xef, 0x9c, 0x7c, 0x3c, 0x73, 0x5a, 0x76, 0x44, 0x48, 0xec, 0xe2, 0xa0, 0x77,
	0x9c, 0xcd, 0x44, 0x80, 0x72, 0x17, 0x08, 0xf9, 0x4c, 0xc4, 0x1b, 0x79, 0x81, 0x3e, 0x13, 0xd9,
	0x01, 0x4a, 0x0e, 0xf0, 0x49, 0x80, 0x47, 0xb2, 0xed, 0x65, 0xa4, 0xfb, 0x40, 0x31, 0x6f, 0xa2,
	0x05, 0xd5, 0xa6, 0x07, 0x7d, 0x71, 0xef, 0x46, 0x6e, 0xd4, 0x83, 0xbe, 0x62, 0xf9, 0xe0, 0x1b,
	0x59, 0x76, 0xa8, 0x67, 0xce, 0x31, 0xe8, 0xb3, 0xc1, 0x1e, 0x7f, 0xc1, 0x34, 0xcb, 0x12, 0x35,
	0x4e, 0x01, 0xf6, 0x2a, 0x5a, 0x1a, 0x0a, 0x23, 0x03, 0xbb, 0xa1, 0xbd, 0x3e, 0x14, 0x26, 0x45,
	0xe8, 0x42, 0x87, 0x7b, 0x92, 0xfc, 0x61, 0xaf, 0x4f, 0xe0, 0x30, 0xaf, 0x47, 0x47, 0x6e, 0x8c,
	0x47, 0x1c, 0x56, 0xe3, 0xdd, 0x2f, 0x10, 0x9f, 0xe3, 0x91, 0xc4, 0xa4, 0x24, 0x38, 0xc8, 0x31,
	0x88, 0x63, 0x80, 0x28, 0x31, 0xff, 0x8d, 0x4c, 0x79, 0x22, 0xbb, 0x1c, 0xaf, 0x0e, 0xea, 0xb9,
	0xe3, 0x88, 0x73, 0x9f, 0x0d, 0x28, 0xaf, 0x13, 0x72, 0x47, 0xeb, 0x85, 0xee, 0x61, 0x14, 0xc7,
	0xbd, 0xb0, 0xab, 0xb4, 0x4d, 0x8b, 0xf2, 0xb6, 0x0f, 0x39, 0x0b, 0xca, 0x3d, 0x69, 0x5a, 0xdc,
	0xaf, 0xf9, 0x0c, 0xa5, 0x21, 0x03, 0x15, 0x73, 0xed, 0xdb, 0x68, 0x71, 0x28, 0x67, 0x82, 0x02,
	0x96, 0xf7, 0x49, 0xf3, 0x43, 0x31, 0x19, 0xe4, 0xd8, 0x16, 0xba, 0xa0, 0x49, 0x7c, 0x4c, 0x58,
	0xa3, 0x92, 0xf7, 0x4c, 0x4b, 0xb9, 0xc8, 0x2f, 0x18, 0x4f, 0xbb, 0x24, 0x74, 0xac, 0x7c, 0xc5,
	0xd2, 0xc4, 0x25, 0x1f, 0x85, 0x62, 0x01, 0x93, 0x47, 0x3c, 0x94, 0x40, 0x2f, 0x2b, 0xf2, 0x70,
	0x27, 0x14, 0xd8, 0x35, 0x74, 0x61, 0x10, 0xc7, 0x24, 0x91, 0x5e, 0xee, 0x06, 0xbd, 0x7e, 0x8f,
	0xb2, 0x00, 0x55, 0x72, 0x96, 0x19, 0x4b, 0xc4, 0xe0, 0xc7, 0xc0, 0x00, 0x7c, 0xc0, 0x12, 0x80,
	0x8e, 0xbf, 0xc0, 0xf1, 0x8c, 0xa5, 0xe1, 0x37, 0xd0, 0xa5, 0xa1, 0xcb, 0x4f, 0x90, 0x1a, 0xe2,
	0x2b, 0x2e, 0x66, 0x12, 0x99, 0xc3, 0x8f, 0x80, 0x2f, 0xd4, 0xa4, 0x2c, 0xe3, 0x07, 0xe9, 0xcb,
	0x2e, 0x29, 0xcb, 0x1e, 0x03, 0x5f, 0x5b, 0x06, 0x7d, 0x53, 0x12, 0x0d, 0x62, 0xb7, 0xe7, 0x37,
	0x5f, 0x17, 0x7d, 0x13, 0x7c, 0x3f, 0xf2, 0x35, 0x67, 0xbd, 0xac, 0x0f, 0x28, 0xde, 0x45, 0x0d,
	0x9a, 0xe0, 0x30, 0x3d, 0x88, 0x92, 0x3e, 0x49, 0xd2, 0x66, 0x33, 0x3b, 0x43, 0xa3, 0x5b, 0xb7,
	0x35, 0x9f, 0xb6, 0x31, 0xdb, 0x33, 0xea, 0x43, 0xe6, 0x3c, 0x6e, 0x1a, 0xb0, 0xc8, 0xa9, 0x78,
	0x51, 0xff, 0x6e, 0xd2, 0x3d, 0xb6, 0xbe, 0xab, 0x61, 0x5b, 0xb6, 0x5e, 0x00, 0x19, 0x7a, 0x01,
	0xa4, 0x06, 0x87, 0x82, 0x16, 0x1c, 0x5e, 0xcf, 0x46, 0xf6, 0xdc, 0xf1, 0xc5, 0xd7, 0x58, 0x90,
	0xb2, 0x3b, 0x33, 0x83, 0xd4, 0x01, 0x8d, 0x79, 0x66, 0x28, 0x70, 0x19, 0x0f, 0x68, 0xcc, 0xaa,
	0x37, 0x5f, 0xdf, 0x64, 0x73, 0x66, 0xf5, 0x06, 0x45, 0x23, 0x77, 0x2f, 0x51, 0xbd, 0xe1, 0x20,
	0xe0, 0x3e, 0x75, 0x05, 0x21, 0x0f, 0x7b, 0x87, 0xc4, 0x0d, 0x71, 0x9f, 0x88, 0x39, 0x56, 0x8d,
	0x51, 0x9e, 0xe2, 0x3e, 0xb1, 0x56, 0xf5, 0x53, 0xb6, 0xa6, 0x9e, 0x62, 0x7d, 0xa2, 0xf7, 0x9e,
	0xdb, 0xd3, 0xa1, 0x8a, 0x5e, 0x0a, 0xaa, 0x5e, 0xa0, 0x35, 0x3a, 0xc0, 0xbd, 0x80, 0xf8, 0xac,
	0xec, 0xc2, 0x5d, 0x92, 0xf2, 0xd2, 0xce, 0x59, 0xe0, 0xe4, 0xe7, 0x82, 0xca, 0x26, 0xc9, 0x23,
	0x4a, 0x52, 0xad, 0xff, 0x44, 0x8c, 0xc4, 0x6e, 0x65, 0xfd, 0x72, 0x4c, 0x98, 0xd6, 0xf9, 0x85,
	0xb9, 0x8c, 0x2a, 0x51, 0xe0, 0x2b, 0xd3, 0xbd, 0x72, 0x14, 0xf8, 0x2f, 0x48, 0x02, 0x8c, 0x90,
	0x9c, 0x30, 0x06, 0x9f, 0xe7, 0x95, 0x43, 0x72, 0xf2, 0x82, 0x8f, 0x14, 0x98, 0x91, 0xc8, 0xa6,
	0x5c, 0x46, 0x6a, 0x20, 0x3e, 0x16, 0x34, 0xeb, 0xd7, 0xba, 0x64, 0xf6, 0xf6, 0xcc, 0xc7, 0x1f,
	0xc4, 0x7e, 0xfe, 0xf8, 0x35, 0xa7, 0x32, 0x88, 0x7d, 0x56, 0x13, 0xcc, 0x7e, 0x35, 0xc8, 0xb4,
	0x5e, 0x40, 0x70, 0x28, 0x47, 0xdf, 0xec, 0xc3, 0xbc, 0x89, 0x1a, 0xbd, 0x90, 0xba, 0xd9, 0x9e,
	0x79, 0x51, 0x8b, 0x7a, 0x21, 0xfd, 0x88, 0x6f, 0x6d, 0xfd, 0x4d, 0x17, 0x70, 0x73, 0xf6, 0xd8,
	0x30, 0xeb, 0x5f, 0x0a, 0x7a, 0xff, 0x62, 0xa2, 0x39, 0x1f, 0x8f, 0xa4, 0xe1, 0xb3, 0xbf, 0xcd,
	0xff, 0x45, 0xb5, 0x11, 0xc1, 0x89, 0xeb, 0xd1, 0x24, 0x10, 0x7d, 0xde, 0xe9, 0x53, 0xb3, 0x4d,
	0x7b, 0xed, 0x3b, 0x04, 0x27, 0x3b, 0x34, 0x09, 0x9c, 0xea, 0x48, 0xfc, 0xb5, 0x82, 0x51, 0x55,
	0x52, 0x67, 0xfe, 0x46, 0x01, 0xe9, 0x46, 0x33, 0xf6, 0x1a, 0x50, 0xa4, 0xb5, 0x57, 0xa3, 0x98,
	0xf2, 0x8c, 0x94, 0x77, 0x0d, 0x95, 0x28, 0xa6, 0x90, 0x91, 0x2c, 0xaa, 0x5f, 0xbd, 0xf5, 0x4f,
	0xbb, 0xfa, 0x9b, 0xb9, 0xbc, 0xca, 0xaf, 0x77, 0x5c, 0x66, 0xeb, 0xff, 0xb5, 0x53, 0x89, 0x7d,
	0x6e, 0x5b, 0xb5, 0xee, 0xa8, 0x3b, 0xec, 0xdb, 0xb6, 0xb9, 0x84, 0x8a, 0x69, 0xaf, 0xcf, 0x56,
	0xd7, 0x1c, 0xf8, 0x93, 0x2d, 0xe5, 0x4d, 0x86, 0x5c, 0xca, 0xbe, 0xac, 0xf7, 0x94, 0xa5, 0xad,
	0x3b, 0xb6, 0x0d, 0xe2, 0x63, 0xdf, 0x4f, 0xe4, 0xef, 0x2e, 0xf0, 0xb7, 0x2c, 0x9a, 0x7b, 0xb1,
	0xb8, 0x2b, 0x14, 0xcd, 0x8f, 0x62, 0xeb, 0x77, 0xaa, 0xa9, 0xac, 0xdb, 0x36, 0x8b, 0x93, 0x27,
	0x51, 0x72, 0xa4, 0xc5, 0x49, 0x20, 0xb0, 0x38, 0xf9, 0x2f, 0xa8, 0x95, 0x1a, 0x90, 0x77, 0xb2,
	0x41, 0x83, 0x62, 0xe0, 0xc3, 0xc7, 0x72, 0xda, 0x60, 0x7d, 0x5f, 0x15, 0xba, 0x65, 0xb7, 0xc6,
	0x0a, 0x23, 0x63, 0xbc, 0x30, 0x9a, 0xa8, 0x22, 0x0a, 0x2f, 0x57, 0x45, 0x14, 0xa7, 0x54, 0x11,
	0xd6, 0x4f, 0x0d, 0x5d, 0x82, 0x75, 0x68, 0xcc, 0x64, 0xe5, 0xa5, 0xc8, 0x50, 0x97, 0x34, 0x90,
	0x82, 0x1d, 0x20, 0xea, 0x08, 0x51, 0x16, 0x14, 0x94, 0x03, 0x78, 0x11, 0x21, 0xca, 0x82, 0xff,
	0xca, 0x4b, 0xb9, 0xac, 0x4c, 0xca, 0xa5, 0x91, 0xe5, 0x9c, 0xa8, 0x92, 0xac, 0x8e, 0x26, 0x4d,
	0xcb, 0x9e, 0x2c, 0x26, 0x8d, 0x89, 0x62, 0xd2, 0x7a, 0xa6, 0x2f, 0x6a, 0x4d, 0xa4, 0x61, 0xe3,
	0xf4, 0x34, 0x3c, 0xd5, 0x84, 0x7f, 0xa2, 0xfe, 0x42, 0xbd, 0xde, 0xb6, 0xed, 0xd3, 0x0a, 0x21,
	0x63, 0x5a, 0x21, 0x74, 0x7a, 0x95, 0x55, 0x98, 0x5e, 0x65, 0x4d, 0xa9, 0xe4, 0x8a, 0x33, 0x2a,
	0x39, 0xdd, 0x4c, 0xe6, 0xc6, 0xcd, 0x64, 0x42, 0x6b, 0xa5, 0xc9, 0x12, 0x7c, 0xb2, 0x98, 0x2f,
	0x4f, 0x16, 0xf3, 0xd6, 0x1f, 0x34, 0x55, 0xac, 0x9f, 0x6d, 0xa1, 0x53, 0xca, 0xc0, 0xc2, 0x39,
	0xcb, 0xc0, 0xe2, 0xb9, 0xcb, 0xc0, 0xb9, 0x57, 0x2b, 0x03, 0x4b, 0x33, 0xcb, 0xc0, 0x09, 0x7f,
	0x2b, 0xbf, 0x9c, 0xbf, 0x55, 0xa6, 0xf9, 0xdb, 0x8f, 0xd5, 0x76, 0xce, 0xc7, 0x7c, 0xa6, 0xa7,
	0x44, 0x22, 0xe3, 0x8c, 0x48, 0x54, 0x38, 0x2b, 0x12, 0x15, 0x27, 0x22, 0x91, 0x0c, 0xa2, 0x73,
	0x4a, 0x10, 0xfd, 0xa6, 0x93, 0xcb, 0x3b, 0xb9, 0xdb, 0xa7, 0x77, 0x72, 0x70, 0x91, 0x6f, 0xba,
	0xb8, 0x7f, 0xd7, 0x2e, 0xce, 0xfa, 0x95, 0x9a, 0xf8, 0xfc, 0x03, 0xdb, 0x3e, 0x87, 0xa9, 0x9e,
	0xdb, 0xc4, 0xce, 0xff, 0xca, 0xd6, 0xff, 0x28, 0xe2, 0x6d, 0xb6, 0x64, 0x0a, 0x92, 0x5a, 0x8e,
	0x0f, 0x71, 0x4a, 0xb4, 0x14, 0x24, 0xb4, 0xfc, 0x1c, 0x18, 0xd6, 0xcf, 0xd5, 0x1f, 0xb2, 0x30,
	0x14, 0x43, 0x2c, 0x0d, 0x4b, 0x1b, 0xc8, 0x86, 0x65, 0xc5, 0x55, 0x43, 0xa4, 0x61, 0x61, 0x04,
	0x62, 0x6e, 0xa6, 0xa2, 0xf3, 0x01, 0xda, 0x38, 0x5a, 0xa8, 0xda, 0x5c, 0x45, 0x0b, 0x19, 0x5a,
	0x0e, 0xd5, 0x24, 0xb6, 0x21, 0xb0, 0xfc, 0x87, 0xce, 0xf1, 0xb1, 0xe9, 0xdc, 0xd9, 0x63, 0xd3,
	0xd2, 0xac, 0xb1, 0x69, 0x59, 0x1d, 0x9b, 0x32, 0xa1, 0xc7, 0xe6, 0x72, 0x15, 0xa5, 0xd2, 0xd8,
	0x51, 0x87, 0x73, 0x1c, 0x3d, 0x36, 0xec, 0xab, 0x2a, 0xe8, 0x17, 0xda, 0xc4, 0x4f, 0x1f, 0xc9,
	0xd6, 0xc6, 0x47, 0xb2, 0x63, 0xb3, 0x77, 0x34, 0x31, 0x7b, 0xd7, 0xea, 0x6a, 0x0c, 0x15, 0xc5,
	0x32, 0x9a, 0x3b, 0xca, 0x5b, 0x86, 0xe2, 0xd1, 0x99, 0xff, 0x2c, 0xd2, 0x52, 0x13, 0x31, 0xd4,
	0xd5, 0xd7, 0x55, 0x78, 0x6e, 0x0a, 0xca, 0x12, 0x75, 0xcc, 0x70, 0xa7, 0x63, 0xdb, 0xe0, 0x0f,
	0xa0, 0x39, 0xf6, 0xaf, 0x1a, 0xbc, 0x1e, 0xaf, 0xd0, 0x7e, 0xc0, 0xfe, 0x43, 0xe3, 0x6b, 0x35,
	0xd1, 0xef, 0x83, 0x84, 0x37, 0xd0, 0xfc, 0xd0, 0x3d, 0x6a, 0xb9, 0x59, 0x93, 0x62, 0x30, 0x67,
	0x40, 0xc3, 0xdd, 0xd6, 0x33, 0xde, 0xa3, 0x08, 0x48, 0x3b, 0x87, 0x14, 0x24, 0xa4, 0xad, 0x43,
	0x3a, 0xae, 0xd6, 0xea, 0x30, 0x48, 0x47, 0x42, 0xde, 0x61, 0xf1, 0x52, 0x8b, 0xfd, 0x73, 0x0c,
	0xd4, 0x18, 0xee, 0x28, 0xc1, 0x9f, 0xc1, 0xf4, 0xf0, 0x5f, 0x12, 0xb0, 0x3d, 0x25, 0xfe, 0xf3,
	0x03, 0xd7, 0xf3, 0x03, 0xcb, 0xf2, 0xc0, 0x75, 0x5d, 0xa6, 0x8d, 0x1c, 0x52, 0x91, 0x90, 0x0d,
	0x1d, 0xb2, 0x99, 0x43, 0xaa, 0x12, 0xb2, 0xa9, 0x43, 0xb6, 0x72, 0x48, 0x4d, 0x42, 0xb6, 0x74,
	0xc8, 0x76, 0x0e, 0x41, 0x12, 0xb2, 0x2d, 0x20, 0xd6, 0x9f, 0x55, 0xbd, 0x93, 0x4d, 0x5e, 0x10,
	0x0c, 0xdd, 0xc3, 0x28, 0xe8, 0xb1, 0xce, 0x8d, 0x2b, 0xbd, 0x36, 0x7c, 0x28, 0x08, 0xe6, 0x0a,
	0xaa, 0xb1, 0x67, 0x51, 0xf4, 0x5d, 0x19, 0xee, 0xb6, 0xd8, 0x79, 0x9c, 0xd7, 0x56, 0x15, 0x5d,
	0x19, 0xee, 0xb6, 0x15, 0x5e, 0x47, 0xd5, 0x6f, 0x65, 0xb8, 0xdb, 0x51, 0x78, 0xeb, 0xaa, 0x52,
	0x2b, 0xc3, 0xdd, 0x75, 0x85, 0xb7, 0xa1, 0xea, 0xb2, 0x32, 0xdc, 0xdd, 0x50, 0x78, 0x9b, 0xaa,
	0x12, 0x2b, 0xc3, 0xdd, 0x4d, 0x85, 0xb7, 0xa5, 0xde, 0xbb, 0x32, 0xdc, 0xdd, 0x52, 0x78, 0xdb,
	0x9c, 0x57, 0x97, 0xbc, 0xed, 0x69, 0xd6, 0x50, 0x7d, 0x39, 0x6b, 0xa8, 0x4d, 0x5a, 0x83, 0x75,
	0x4b, 0x75, 0x81, 0x6d, 0xdb, 0x56, 0x6a, 0x7e, 0x43, 0xab, 0xf9, 0x6f, 0xa8, 0xe9, 0xc0, 0xe3,
	0x6d, 0xeb, 0x31, 0x49, 0x64, 0xdb, 0x7a, 0x4c, 0x92, 0x7b, 0x2b, 0xbf, 0xff, 0xfc, 0xaa, 0xf1,
	0xd9, 0xe7, 0x57, 0x8d, 0xbf, 0x7c, 0x7e, 0xd5, 0xf8, 0xc5, 0x17, 0x57, 0x5f, 0xfb, 0xec, 0x8b,
	0xab, 0xaf, 0xfd, 0xe9, 0x8b, 0xab, 0xaf, 0x3d, 0x34, 0xf6, 0xcb, 0xec, 0x1f, 0x72, 0x3b, 0xff,
	0x08, 0x00, 0x00, 0xff, 0xff, 0xfc, 0x30, 0x92, 0x7a, 0xa6, 0x2b, 0x00, 0x00,
}

func (m *WlstRtuAns) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtuAns) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtuAns) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StatusCode != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.StatusCode))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Status) > 0 {
		dAtA2 := make([]byte, len(m.Status)*10)
		var j1 int
		for _, num1 := range m.Status {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x22
	}
	if len(m.DataPoint) > 0 {
		dAtA4 := make([]byte, len(m.DataPoint)*10)
		var j3 int
		for _, num1 := range m.DataPoint {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DataMark) > 0 {
		dAtA6 := make([]byte, len(m.DataMark)*10)
		var j5 int
		for _, num1 := range m.DataMark {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0x12
	}
	if m.CmdIdx != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtu_7094) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtu_7094) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtu_7094) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SwitchOutStPacked) > 0 {
		dAtA8 := make([]byte, len(m.SwitchOutStPacked)*10)
		var j7 int
		for _, num1 := range m.SwitchOutStPacked {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		i -= j7
		copy(dAtA[i:], dAtA8[:j7])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j7))
		i--
		dAtA[i] = 0x22
	}
	if m.Alarmln != nil {
		{
			size, err := m.Alarmln.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocolRtu(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.AlarmType != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.AlarmType))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtu_7094_Alarm_LN) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtu_7094_Alarm_LN) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtu_7094_Alarm_LN) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AlarmCurrent != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.AlarmCurrent))))
		i--
		dAtA[i] = 0x19
	}
	if m.AlarmStatus != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.AlarmStatus))
		i--
		dAtA[i] = 0x10
	}
	if m.LoopNo != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.LoopNo))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtu_7021) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtu_7021) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtu_7021) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Argswc) > 0 {
		for iNdEx := len(m.Argswc) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Argswc[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProtocolRtu(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.LoopType != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.LoopType))
		i--
		dAtA[i] = 0x28
	}
	if m.StatusCode != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.StatusCode))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Argsln) > 0 {
		for iNdEx := len(m.Argsln) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Argsln[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProtocolRtu(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.DataType != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.DataType))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtu_7021_Args_LN) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtu_7021_Args_LN) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtu_7021_Args_LN) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BreakValue != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.BreakValue))
		i--
		dAtA[i] = 0x20
	}
	if m.AlarmValue != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.AlarmValue))
		i--
		dAtA[i] = 0x18
	}
	if m.BaseValue != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.BaseValue))
		i--
		dAtA[i] = 0x10
	}
	if m.LoopNo != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.LoopNo))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtu_7021_Args_WC) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtu_7021_Args_WC) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtu_7021_Args_WC) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.L8Off != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.L8Off))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.L8On != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.L8On))
		i--
		dAtA[i] = 0x78
	}
	if m.L7Off != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.L7Off))
		i--
		dAtA[i] = 0x70
	}
	if m.L7On != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.L7On))
		i--
		dAtA[i] = 0x68
	}
	if m.L6Off != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.L6Off))
		i--
		dAtA[i] = 0x60
	}
	if m.L6On != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.L6On))
		i--
		dAtA[i] = 0x58
	}
	if m.L5Off != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.L5Off))
		i--
		dAtA[i] = 0x50
	}
	if m.L5On != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.L5On))
		i--
		dAtA[i] = 0x48
	}
	if m.L4Off != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.L4Off))
		i--
		dAtA[i] = 0x40
	}
	if m.L4On != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.L4On))
		i--
		dAtA[i] = 0x38
	}
	if m.L3Off != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.L3Off))
		i--
		dAtA[i] = 0x30
	}
	if m.L3On != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.L3On))
		i--
		dAtA[i] = 0x28
	}
	if m.L2Off != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.L2Off))
		i--
		dAtA[i] = 0x20
	}
	if m.L2On != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.L2On))
		i--
		dAtA[i] = 0x18
	}
	if m.L1Off != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.L1Off))
		i--
		dAtA[i] = 0x10
	}
	if m.L1On != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.L1On))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtu_7023) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtu_7023) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtu_7023) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StatusCode != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.StatusCode))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Argscontrol) > 0 {
		for iNdEx := len(m.Argscontrol) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Argscontrol[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProtocolRtu(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.DataType != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.DataType))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtu_7023_Args_Control) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtu_7023_Args_Control) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtu_7023_Args_Control) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Operation != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.Operation))
		i--
		dAtA[i] = 0x10
	}
	if m.LoopNo != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.LoopNo))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtu_705B) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtu_705B) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtu_705B) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InstallationDate) > 0 {
		i -= len(m.InstallationDate)
		copy(dAtA[i:], m.InstallationDate)
		i = encodeVarintProtocolRtu(dAtA, i, uint64(len(m.InstallationDate)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ProductionDate) > 0 {
		i -= len(m.ProductionDate)
		copy(dAtA[i:], m.ProductionDate)
		i = encodeVarintProtocolRtu(dAtA, i, uint64(len(m.ProductionDate)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ProductionBatch) > 0 {
		i -= len(m.ProductionBatch)
		copy(dAtA[i:], m.ProductionBatch)
		i = encodeVarintProtocolRtu(dAtA, i, uint64(len(m.ProductionBatch)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.HardwareVer) > 0 {
		i -= len(m.HardwareVer)
		copy(dAtA[i:], m.HardwareVer)
		i = encodeVarintProtocolRtu(dAtA, i, uint64(len(m.HardwareVer)))
		i--
		dAtA[i] = 0x1a
	}
	if m.CmdType != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.CmdType))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtu_70A0) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtu_70A0) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtu_70A0) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LoopCount != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.LoopCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if len(m.TmlReset) > 0 {
		dAtA11 := make([]byte, len(m.TmlReset)*10)
		var j10 int
		for _, num1 := range m.TmlReset {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		i -= j10
		copy(dAtA[i:], dAtA11[:j10])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j10))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.TmlStPacked) > 0 {
		dAtA13 := make([]byte, len(m.TmlStPacked)*10)
		var j12 int
		for _, num1 := range m.TmlStPacked {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA13[j12] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j12++
			}
			dAtA13[j12] = uint8(num)
			j12++
		}
		i -= j12
		copy(dAtA[i:], dAtA13[:j12])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j12))
		i--
		dAtA[i] = 0x72
	}
	if len(m.SwitchOutStPacked) > 0 {
		dAtA15 := make([]byte, len(m.SwitchOutStPacked)*10)
		var j14 int
		for _, num1 := range m.SwitchOutStPacked {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA15[j14] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j14++
			}
			dAtA15[j14] = uint8(num)
			j14++
		}
		i -= j14
		copy(dAtA[i:], dAtA15[:j14])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j14))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.SwitchInStPacked) > 0 {
		dAtA17 := make([]byte, len(m.SwitchInStPacked)*10)
		var j16 int
		for _, num1 := range m.SwitchInStPacked {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA17[j16] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j16++
			}
			dAtA17[j16] = uint8(num)
			j16++
		}
		i -= j16
		copy(dAtA[i:], dAtA17[:j16])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j16))
		i--
		dAtA[i] = 0x62
	}
	if m.Gpsargs != nil {
		{
			size, err := m.Gpsargs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocolRtu(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.Latitude != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Latitude))))
		i--
		dAtA[i] = 0x51
	}
	if m.Longitude != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Longitude))))
		i--
		dAtA[i] = 0x49
	}
	if m.BatteryPower != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.BatteryPower))
		i--
		dAtA[i] = 0x40
	}
	if m.MainVoltage != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MainVoltage))))
		i--
		dAtA[i] = 0x39
	}
	if m.Humidity != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.Humidity))
		i--
		dAtA[i] = 0x30
	}
	if m.Temperature != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.Temperature))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Ee) > 0 {
		for iNdEx := len(m.Ee) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ee[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProtocolRtu(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Frequency != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Frequency))))
		i--
		dAtA[i] = 0x1d
	}
	if m.CmdType != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.CmdType))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtu_70A0_ElectricEnergy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtu_70A0_ElectricEnergy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtu_70A0_ElectricEnergy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReactiveEnergy != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ReactiveEnergy))))
		i--
		dAtA[i] = 0x3d
	}
	if m.ActiveEnergy != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ActiveEnergy))))
		i--
		dAtA[i] = 0x35
	}
	if m.ReactivePower != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ReactivePower))))
		i--
		dAtA[i] = 0x2d
	}
	if m.ActivePower != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ActivePower))))
		i--
		dAtA[i] = 0x25
	}
	if m.PowerFactor != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PowerFactor))))
		i--
		dAtA[i] = 0x1d
	}
	if m.Current != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Current))))
		i--
		dAtA[i] = 0x15
	}
	if m.Voltage != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Voltage))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtu_70A0_GpsArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtu_70A0_GpsArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtu_70A0_GpsArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LocationStatus != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.LocationStatus))
		i--
		dAtA[i] = 0x20
	}
	if m.LonType != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.LonType))
		i--
		dAtA[i] = 0x18
	}
	if m.LatType != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.LatType))
		i--
		dAtA[i] = 0x10
	}
	if m.GpsType != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.GpsType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtu_7053) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtu_7053) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtu_7053) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RecordDistance != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.RecordDistance))
		i--
		dAtA[i] = 0x28
	}
	if m.RecordCount != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.RecordCount))
		i--
		dAtA[i] = 0x20
	}
	if m.DtStart != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.DtStart))
		i--
		dAtA[i] = 0x18
	}
	if m.RecordType != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.RecordType))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtu_70D3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtu_70D3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtu_70D3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data_70D0Max) > 0 {
		for iNdEx := len(m.Data_70D0Max) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Data_70D0Max[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProtocolRtu(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.Data_70D0) > 0 {
		for iNdEx := len(m.Data_70D0) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Data_70D0[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProtocolRtu(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.RecordDistance != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.RecordDistance))
		i--
		dAtA[i] = 0x40
	}
	if m.RecordCount != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.RecordCount))
		i--
		dAtA[i] = 0x38
	}
	if m.DtStart != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.DtStart))
		i--
		dAtA[i] = 0x30
	}
	if m.RecordType != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.RecordType))
		i--
		dAtA[i] = 0x28
	}
	if m.RecordStatus != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.RecordStatus))
		i--
		dAtA[i] = 0x20
	}
	if m.RecordIdx != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.RecordIdx))
		i--
		dAtA[i] = 0x18
	}
	if m.RecordTotal != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.RecordTotal))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtu_70D0Max) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtu_70D0Max) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtu_70D0Max) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MaxData) > 0 {
		for iNdEx := len(m.MaxData) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MaxData[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProtocolRtu(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.LoopCount != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.LoopCount))
		i--
		dAtA[i] = 0x18
	}
	if m.RecordType != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.RecordType))
		i--
		dAtA[i] = 0x10
	}
	if m.DtRecord != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.DtRecord))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtu_70D0Max_MaxData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtu_70D0Max_MaxData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtu_70D0Max_MaxData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DtRecord != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.DtRecord))
		i--
		dAtA[i] = 0x10
	}
	if m.CurrentMax != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CurrentMax))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtu_7800) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtu_7800) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtu_7800) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RawData) > 0 {
		i -= len(m.RawData)
		copy(dAtA[i:], m.RawData)
		i = encodeVarintProtocolRtu(dAtA, i, uint64(len(m.RawData)))
		i--
		dAtA[i] = 0x42
	}
	if m.CurNum != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.CurNum))
		i--
		dAtA[i] = 0x38
	}
	if m.AllNum != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.AllNum))
		i--
		dAtA[i] = 0x30
	}
	if m.DtEnd != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.DtEnd))
		i--
		dAtA[i] = 0x28
	}
	if m.DtStart != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.DtStart))
		i--
		dAtA[i] = 0x20
	}
	if m.DataNum != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.DataNum))
		i--
		dAtA[i] = 0x18
	}
	if m.EventClass != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.EventClass))
		i--
		dAtA[i] = 0x10
	}
	if m.EventType != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.EventType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtu_7050) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtu_7050) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtu_7050) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DataMark != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.DataMark))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtu_70D0) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtu_70D0) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtu_70D0) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SwitchOutReason) > 0 {
		dAtA20 := make([]byte, len(m.SwitchOutReason)*10)
		var j19 int
		for _, num1 := range m.SwitchOutReason {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA20[j19] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j19++
			}
			dAtA20[j19] = uint8(num)
			j19++
		}
		i -= j19
		copy(dAtA[i:], dAtA20[:j19])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j19))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.DtRecord != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.DtRecord))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.FullRange != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.FullRange))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.TmlSt != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.TmlSt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.SwitchOutSt != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.SwitchOutSt))
		i--
		dAtA[i] = 0x78
	}
	if m.SwitchInSt != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.SwitchInSt))
		i--
		dAtA[i] = 0x70
	}
	if len(m.AnalogData) > 0 {
		for iNdEx := len(m.AnalogData) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AnalogData[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProtocolRtu(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.SamplingVoltage) > 0 {
		for iNdEx := len(m.SamplingVoltage) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SamplingVoltage[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProtocolRtu(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if m.PowerSupply != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PowerSupply))))
		i--
		dAtA[i] = 0x59
	}
	if len(m.TmlArgsStatus) > 0 {
		dAtA22 := make([]byte, len(m.TmlArgsStatus)*10)
		var j21 int
		for _, num1 := range m.TmlArgsStatus {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA22[j21] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j21++
			}
			dAtA22[j21] = uint8(num)
			j21++
		}
		i -= j21
		copy(dAtA[i:], dAtA22[:j21])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j21))
		i--
		dAtA[i] = 0x52
	}
	if len(m.TmlReset) > 0 {
		dAtA24 := make([]byte, len(m.TmlReset)*10)
		var j23 int
		for _, num1 := range m.TmlReset {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA24[j23] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j23++
			}
			dAtA24[j23] = uint8(num)
			j23++
		}
		i -= j23
		copy(dAtA[i:], dAtA24[:j23])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j23))
		i--
		dAtA[i] = 0x4a
	}
	if m.GprsSignal != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.GprsSignal))
		i--
		dAtA[i] = 0x40
	}
	if m.GprsReset != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.GprsReset))
		i--
		dAtA[i] = 0x38
	}
	if m.Temperature != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.Temperature))
		i--
		dAtA[i] = 0x30
	}
	if len(m.TmlStPacked) > 0 {
		dAtA26 := make([]byte, len(m.TmlStPacked)*10)
		var j25 int
		for _, num1 := range m.TmlStPacked {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA26[j25] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j25++
			}
			dAtA26[j25] = uint8(num)
			j25++
		}
		i -= j25
		copy(dAtA[i:], dAtA26[:j25])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j25))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SwitchOutStPacked) > 0 {
		dAtA28 := make([]byte, len(m.SwitchOutStPacked)*10)
		var j27 int
		for _, num1 := range m.SwitchOutStPacked {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA28[j27] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j27++
			}
			dAtA28[j27] = uint8(num)
			j27++
		}
		i -= j27
		copy(dAtA[i:], dAtA28[:j27])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j27))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SwitchInStPacked) > 0 {
		dAtA30 := make([]byte, len(m.SwitchInStPacked)*10)
		var j29 int
		for _, num1 := range m.SwitchInStPacked {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA30[j29] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j29++
			}
			dAtA30[j29] = uint8(num)
			j29++
		}
		i -= j29
		copy(dAtA[i:], dAtA30[:j29])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j29))
		i--
		dAtA[i] = 0x1a
	}
	if m.DataMark != nil {
		{
			size, err := m.DataMark.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocolRtu(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.CmdIdx != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtu_70D0_DataMark) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtu_70D0_DataMark) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtu_70D0_DataMark) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GetSwitchoutReason != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.GetSwitchoutReason))
		i--
		dAtA[i] = 0x10
	}
	if m.GetRunData != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.GetRunData))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtu_70D0_SamplingVoltage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtu_70D0_SamplingVoltage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtu_70D0_SamplingVoltage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VolC != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.VolC))))
		i--
		dAtA[i] = 0x19
	}
	if m.VolB != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.VolB))))
		i--
		dAtA[i] = 0x11
	}
	if m.VolA != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.VolA))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtu_70D0_AnalogData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtu_70D0_AnalogData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtu_70D0_AnalogData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CurrentStatus != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.CurrentStatus))
		i--
		dAtA[i] = 0x28
	}
	if m.VoltageStatus != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.VoltageStatus))
		i--
		dAtA[i] = 0x20
	}
	if m.Power != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Power))))
		i--
		dAtA[i] = 0x19
	}
	if m.Current != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Current))))
		i--
		dAtA[i] = 0x11
	}
	if m.Voltage != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Voltage))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtu_705A) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtu_705A) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtu_705A) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CmdType != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.CmdType))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtu_70Da) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtu_70Da) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtu_70Da) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Transformers) > 0 {
		dAtA33 := make([]byte, len(m.Transformers)*10)
		var j32 int
		for _, num1 := range m.Transformers {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA33[j32] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j32++
			}
			dAtA33[j32] = uint8(num)
			j32++
		}
		i -= j32
		copy(dAtA[i:], dAtA33[:j32])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j32))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.CmdType != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.CmdType))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.GroupId != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if len(m.XLowerCurrentLimit) > 0 {
		dAtA35 := make([]byte, len(m.XLowerCurrentLimit)*10)
		var j34 int
		for _, num1 := range m.XLowerCurrentLimit {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA35[j34] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j34++
			}
			dAtA35[j34] = uint8(num)
			j34++
		}
		i -= j34
		copy(dAtA[i:], dAtA35[:j34])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j34))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if len(m.XUpperCurrentLimit) > 0 {
		dAtA37 := make([]byte, len(m.XUpperCurrentLimit)*10)
		var j36 int
		for _, num1 := range m.XUpperCurrentLimit {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA37[j36] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j36++
			}
			dAtA37[j36] = uint8(num)
			j36++
		}
		i -= j36
		copy(dAtA[i:], dAtA37[:j36])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j36))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.LowerVoltageLimit != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.LowerVoltageLimit))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.UpperVoltageLimit != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.UpperVoltageLimit))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if len(m.XAnalogVector) > 0 {
		dAtA39 := make([]byte, len(m.XAnalogVector)*10)
		var j38 int
		for _, num1 := range m.XAnalogVector {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA39[j38] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j38++
			}
			dAtA39[j38] = uint8(num)
			j38++
		}
		i -= j38
		copy(dAtA[i:], dAtA39[:j38])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j38))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.XSwitchInVector) > 0 {
		dAtA41 := make([]byte, len(m.XSwitchInVector)*10)
		var j40 int
		for _, num1 := range m.XSwitchInVector {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA41[j40] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j40++
			}
			dAtA41[j40] = uint8(num)
			j40++
		}
		i -= j40
		copy(dAtA[i:], dAtA41[:j40])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j40))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.XSwitchOutVector) > 0 {
		dAtA43 := make([]byte, len(m.XSwitchOutVector)*10)
		var j42 int
		for _, num1 := range m.XSwitchOutVector {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA43[j42] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j42++
			}
			dAtA43[j42] = uint8(num)
			j42++
		}
		i -= j42
		copy(dAtA[i:], dAtA43[:j42])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j42))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.XCurrentRange) > 0 {
		dAtA45 := make([]byte, len(m.XCurrentRange)*10)
		var j44 int
		for _, num1 := range m.XCurrentRange {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA45[j44] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j44++
			}
			dAtA45[j44] = uint8(num)
			j44++
		}
		i -= j44
		copy(dAtA[i:], dAtA45[:j44])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j44))
		i--
		dAtA[i] = 0x72
	}
	if m.VoltageRange != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.VoltageRange))
		i--
		dAtA[i] = 0x68
	}
	if len(m.SwitchInHopping) > 0 {
		dAtA47 := make([]byte, len(m.SwitchInHopping)*10)
		var j46 int
		for _, num1 := range m.SwitchInHopping {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA47[j46] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j46++
			}
			dAtA47[j46] = uint8(num)
			j46++
		}
		i -= j46
		copy(dAtA[i:], dAtA47[:j46])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j46))
		i--
		dAtA[i] = 0x62
	}
	if len(m.XSwitchOutCount) > 0 {
		dAtA49 := make([]byte, len(m.XSwitchOutCount)*10)
		var j48 int
		for _, num1 := range m.XSwitchOutCount {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA49[j48] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j48++
			}
			dAtA49[j48] = uint8(num)
			j48++
		}
		i -= j48
		copy(dAtA[i:], dAtA49[:j48])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j48))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.SelfPayTime) > 0 {
		i -= len(m.SelfPayTime)
		copy(dAtA[i:], m.SelfPayTime)
		i = encodeVarintProtocolRtu(dAtA, i, uint64(len(m.SelfPayTime)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.CityPayTime) > 0 {
		i -= len(m.CityPayTime)
		copy(dAtA[i:], m.CityPayTime)
		i = encodeVarintProtocolRtu(dAtA, i, uint64(len(m.CityPayTime)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.XSwitchingTime) > 0 {
		for iNdEx := len(m.XSwitchingTime) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.XSwitchingTime[iNdEx])
			copy(dAtA[i:], m.XSwitchingTime[iNdEx])
			i = encodeVarintProtocolRtu(dAtA, i, uint64(len(m.XSwitchingTime[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.AnalogSum != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.AnalogSum))
		i--
		dAtA[i] = 0x38
	}
	if m.SwitchInSum != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.SwitchInSum))
		i--
		dAtA[i] = 0x30
	}
	if m.SwitchOutSum != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.SwitchOutSum))
		i--
		dAtA[i] = 0x28
	}
	if m.AlarmDelay != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.AlarmDelay))
		i--
		dAtA[i] = 0x20
	}
	if m.AlarmCycle != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.AlarmCycle))
		i--
		dAtA[i] = 0x18
	}
	if m.KeepAlive != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.KeepAlive))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtu_700A) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtu_700A) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtu_700A) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ComArgv) > 0 {
		dAtA51 := make([]byte, len(m.ComArgv)*10)
		var j50 int
		for _, num1 := range m.ComArgv {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA51[j50] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j50++
			}
			dAtA51[j50] = uint8(num)
			j50++
		}
		i -= j50
		copy(dAtA[i:], dAtA51[:j50])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j50))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtu_7010) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtu_7010) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtu_7010) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if m.CmdIdx != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x10
	}
	if m.DataMark != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.DataMark))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtu_7003) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtu_7003) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtu_7003) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FtpData) > 0 {
		dAtA53 := make([]byte, len(m.FtpData)*10)
		var j52 int
		for _, num1 := range m.FtpData {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA53[j52] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j52++
			}
			dAtA53[j52] = uint8(num)
			j52++
		}
		i -= j52
		copy(dAtA[i:], dAtA53[:j52])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j52))
		i--
		dAtA[i] = 0x12
	}
	if m.CmdIdx != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtu_7006) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtu_7006) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtu_7006) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CacheName) > 0 {
		i -= len(m.CacheName)
		copy(dAtA[i:], m.CacheName)
		i = encodeVarintProtocolRtu(dAtA, i, uint64(len(m.CacheName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.AllCount != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.AllCount))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtu_7007) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtu_7007) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtu_7007) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CmdIdx != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtu_7087) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtu_7087) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtu_7087) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BytesCount != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.BytesCount))
		i--
		dAtA[i] = 0x20
	}
	if len(m.FailedPackages) > 0 {
		dAtA55 := make([]byte, len(m.FailedPackages)*10)
		var j54 int
		for _, num1 := range m.FailedPackages {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA55[j54] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j54++
			}
			dAtA55[j54] = uint8(num)
			j54++
		}
		i -= j54
		copy(dAtA[i:], dAtA55[:j54])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j54))
		i--
		dAtA[i] = 0x1a
	}
	if m.Status != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtu_7081) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtu_7081) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtu_7081) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DataLocation != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.DataLocation))
		i--
		dAtA[i] = 0x28
	}
	if len(m.NewVer) > 0 {
		i -= len(m.NewVer)
		copy(dAtA[i:], m.NewVer)
		i = encodeVarintProtocolRtu(dAtA, i, uint64(len(m.NewVer)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.OldVer) > 0 {
		i -= len(m.OldVer)
		copy(dAtA[i:], m.OldVer)
		i = encodeVarintProtocolRtu(dAtA, i, uint64(len(m.OldVer)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Status != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtu_7008) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtu_7008) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtu_7008) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.IntUpdData) > 0 {
		dAtA57 := make([]byte, len(m.IntUpdData)*10)
		var j56 int
		for _, num1 := range m.IntUpdData {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA57[j56] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j56++
			}
			dAtA57[j56] = uint8(num)
			j56++
		}
		i -= j56
		copy(dAtA[i:], dAtA57[:j56])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j56))
		i--
		dAtA[i] = 0x2a
	}
	if m.Clean != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.Clean))
		i--
		dAtA[i] = 0x20
	}
	if len(m.CacheName) > 0 {
		i -= len(m.CacheName)
		copy(dAtA[i:], m.CacheName)
		i = encodeVarintProtocolRtu(dAtA, i, uint64(len(m.CacheName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.UpdData) > 0 {
		for iNdEx := len(m.UpdData) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.UpdData[iNdEx])
			copy(dAtA[i:], m.UpdData[iNdEx])
			i = encodeVarintProtocolRtu(dAtA, i, uint64(len(m.UpdData[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.CmdIdx != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtu_7060) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtu_7060) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtu_7060) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.YearCtrl) > 0 {
		for iNdEx := len(m.YearCtrl) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.YearCtrl[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProtocolRtu(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Days != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.Days))
		i--
		dAtA[i] = 0x18
	}
	if m.DtStart != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.DtStart))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtu_7060_YearCtrl) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtu_7060_YearCtrl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtu_7060_YearCtrl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OptTime) > 0 {
		dAtA59 := make([]byte, len(m.OptTime)*10)
		var j58 int
		for _, num1 := range m.OptTime {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA59[j58] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j58++
			}
			dAtA59[j58] = uint8(num)
			j58++
		}
		i -= j58
		copy(dAtA[i:], dAtA59[:j58])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j58))
		i--
		dAtA[i] = 0x1a
	}
	if m.TimeCount != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.TimeCount))
		i--
		dAtA[i] = 0x10
	}
	if m.LoopNo != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.LoopNo))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtu_7061) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtu_7061) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtu_7061) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LoopNo) > 0 {
		dAtA61 := make([]byte, len(m.LoopNo)*10)
		var j60 int
		for _, num1 := range m.LoopNo {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA61[j60] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j60++
			}
			dAtA61[j60] = uint8(num)
			j60++
		}
		i -= j60
		copy(dAtA[i:], dAtA61[:j60])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j60))
		i--
		dAtA[i] = 0x22
	}
	if m.Days != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.Days))
		i--
		dAtA[i] = 0x18
	}
	if m.DtStart != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.DtStart))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtu_70E0) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtu_70E0) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtu_70E0) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtu_7B00) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtu_7B00) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtu_7B00) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Signal != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.Signal))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Sim) > 0 {
		i -= len(m.Sim)
		copy(dAtA[i:], m.Sim)
		i = encodeVarintProtocolRtu(dAtA, i, uint64(len(m.Sim)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtu_1900) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtu_1900) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtu_1900) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TmlIp != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.TmlIp))
		i--
		dAtA[i] = 0x10
	}
	if m.Addr != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.Addr))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtu_4000) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtu_4000) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtu_4000) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.XLoopCount) > 0 {
		dAtA63 := make([]byte, len(m.XLoopCount)*10)
		var j62 int
		for _, num1 := range m.XLoopCount {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA63[j62] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j62++
			}
			dAtA63[j62] = uint8(num)
			j62++
		}
		i -= j62
		copy(dAtA[i:], dAtA63[:j62])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j62))
		i--
		dAtA[i] = 0x2a
	}
	if m.AlarmDelay != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.AlarmDelay))
		i--
		dAtA[i] = 0x20
	}
	if m.AlarmCycle != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.AlarmCycle))
		i--
		dAtA[i] = 0x18
	}
	if m.KeepAlive != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.KeepAlive))
		i--
		dAtA[i] = 0x10
	}
	if m.WorkMark != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.WorkMark))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtu_4101) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtu_4101) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtu_4101) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.XCurrentRange) > 0 {
		dAtA65 := make([]byte, len(m.XCurrentRange)*10)
		var j64 int
		for _, num1 := range m.XCurrentRange {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA65[j64] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j64++
			}
			dAtA65[j64] = uint8(num)
			j64++
		}
		i -= j64
		copy(dAtA[i:], dAtA65[:j64])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j64))
		i--
		dAtA[i] = 0x1a
	}
	if m.VoltageRange != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.VoltageRange))
		i--
		dAtA[i] = 0x10
	}
	if m.AnalogSum != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.AnalogSum))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtu_4104) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtu_4104) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtu_4104) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.XSwitchHopping) > 0 {
		dAtA67 := make([]byte, len(m.XSwitchHopping)*10)
		var j66 int
		for _, num1 := range m.XSwitchHopping {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA67[j66] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j66++
			}
			dAtA67[j66] = uint8(num)
			j66++
		}
		i -= j66
		copy(dAtA[i:], dAtA67[:j66])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j66))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.XSwitchVector) > 0 {
		dAtA69 := make([]byte, len(m.XSwitchVector)*10)
		var j68 int
		for _, num1 := range m.XSwitchVector {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA69[j68] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j68++
			}
			dAtA69[j68] = uint8(num)
			j68++
		}
		i -= j68
		copy(dAtA[i:], dAtA69[:j68])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j68))
		i--
		dAtA[i] = 0x12
	}
	if m.SwitchinSum != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.SwitchinSum))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtu_4110) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtu_4110) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtu_4110) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SwitchInSum != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.SwitchInSum))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtu_4111) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtu_4111) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtu_4111) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Transformers) > 0 {
		dAtA71 := make([]byte, len(m.Transformers)*10)
		var j70 int
		for _, num1 := range m.Transformers {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA71[j70] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j70++
			}
			dAtA71[j70] = uint8(num)
			j70++
		}
		i -= j70
		copy(dAtA[i:], dAtA71[:j70])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j70))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtu_4200) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtu_4200) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtu_4200) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SwitchOutSum != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.SwitchOutSum))
		i--
		dAtA[i] = 0x30
	}
	if m.SwitchInSum != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.SwitchInSum))
		i--
		dAtA[i] = 0x28
	}
	if m.AnalogSum != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.AnalogSum))
		i--
		dAtA[i] = 0x20
	}
	if len(m.XSwitchOutVector) > 0 {
		dAtA73 := make([]byte, len(m.XSwitchOutVector)*10)
		var j72 int
		for _, num1 := range m.XSwitchOutVector {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA73[j72] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j72++
			}
			dAtA73[j72] = uint8(num)
			j72++
		}
		i -= j72
		copy(dAtA[i:], dAtA73[:j72])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j72))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.XSwitchInVector) > 0 {
		dAtA75 := make([]byte, len(m.XSwitchInVector)*10)
		var j74 int
		for _, num1 := range m.XSwitchInVector {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA75[j74] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j74++
			}
			dAtA75[j74] = uint8(num)
			j74++
		}
		i -= j74
		copy(dAtA[i:], dAtA75[:j74])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j74))
		i--
		dAtA[i] = 0x12
	}
	if len(m.XAnalogVector) > 0 {
		dAtA77 := make([]byte, len(m.XAnalogVector)*10)
		var j76 int
		for _, num1 := range m.XAnalogVector {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA77[j76] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j76++
			}
			dAtA77[j76] = uint8(num)
			j76++
		}
		i -= j76
		copy(dAtA[i:], dAtA77[:j76])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j76))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtu_4401) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtu_4401) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtu_4401) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.XCurrentRange) > 0 {
		dAtA79 := make([]byte, len(m.XCurrentRange)*10)
		var j78 int
		for _, num1 := range m.XCurrentRange {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA79[j78] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j78++
			}
			dAtA79[j78] = uint8(num)
			j78++
		}
		i -= j78
		copy(dAtA[i:], dAtA79[:j78])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j78))
		i--
		dAtA[i] = 0x3a
	}
	if m.VoltageRange != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.VoltageRange))
		i--
		dAtA[i] = 0x30
	}
	if len(m.XLowerCurrentLimit) > 0 {
		dAtA81 := make([]byte, len(m.XLowerCurrentLimit)*10)
		var j80 int
		for _, num1 := range m.XLowerCurrentLimit {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA81[j80] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j80++
			}
			dAtA81[j80] = uint8(num)
			j80++
		}
		i -= j80
		copy(dAtA[i:], dAtA81[:j80])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j80))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.XUpperCurrentLimit) > 0 {
		dAtA83 := make([]byte, len(m.XUpperCurrentLimit)*10)
		var j82 int
		for _, num1 := range m.XUpperCurrentLimit {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA83[j82] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j82++
			}
			dAtA83[j82] = uint8(num)
			j82++
		}
		i -= j82
		copy(dAtA[i:], dAtA83[:j82])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j82))
		i--
		dAtA[i] = 0x22
	}
	if m.LowerVoltageLimit != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.LowerVoltageLimit))
		i--
		dAtA[i] = 0x18
	}
	if m.UpperVoltageLimit != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.UpperVoltageLimit))
		i--
		dAtA[i] = 0x10
	}
	if m.AnalogSum != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.AnalogSum))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtuDa00) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtuDa00) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtuDa00) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GroupId != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if len(m.XLowerCurrentLimit) > 0 {
		dAtA85 := make([]byte, len(m.XLowerCurrentLimit)*10)
		var j84 int
		for _, num1 := range m.XLowerCurrentLimit {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA85[j84] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j84++
			}
			dAtA85[j84] = uint8(num)
			j84++
		}
		i -= j84
		copy(dAtA[i:], dAtA85[:j84])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j84))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if len(m.XUpperCurrentLimit) > 0 {
		dAtA87 := make([]byte, len(m.XUpperCurrentLimit)*10)
		var j86 int
		for _, num1 := range m.XUpperCurrentLimit {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA87[j86] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j86++
			}
			dAtA87[j86] = uint8(num)
			j86++
		}
		i -= j86
		copy(dAtA[i:], dAtA87[:j86])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j86))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.LowerVoltageLimit != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.LowerVoltageLimit))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.UpperVoltageLimit != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.UpperVoltageLimit))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if len(m.XAnalogVector) > 0 {
		dAtA89 := make([]byte, len(m.XAnalogVector)*10)
		var j88 int
		for _, num1 := range m.XAnalogVector {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA89[j88] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j88++
			}
			dAtA89[j88] = uint8(num)
			j88++
		}
		i -= j88
		copy(dAtA[i:], dAtA89[:j88])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j88))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.XSwitchInVector) > 0 {
		dAtA91 := make([]byte, len(m.XSwitchInVector)*10)
		var j90 int
		for _, num1 := range m.XSwitchInVector {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA91[j90] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j90++
			}
			dAtA91[j90] = uint8(num)
			j90++
		}
		i -= j90
		copy(dAtA[i:], dAtA91[:j90])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j90))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.XSwitchOutVector) > 0 {
		dAtA93 := make([]byte, len(m.XSwitchOutVector)*10)
		var j92 int
		for _, num1 := range m.XSwitchOutVector {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA93[j92] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j92++
			}
			dAtA93[j92] = uint8(num)
			j92++
		}
		i -= j92
		copy(dAtA[i:], dAtA93[:j92])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j92))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.XCurrentRange) > 0 {
		dAtA95 := make([]byte, len(m.XCurrentRange)*10)
		var j94 int
		for _, num1 := range m.XCurrentRange {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA95[j94] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j94++
			}
			dAtA95[j94] = uint8(num)
			j94++
		}
		i -= j94
		copy(dAtA[i:], dAtA95[:j94])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j94))
		i--
		dAtA[i] = 0x72
	}
	if m.VoltageRange != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.VoltageRange))
		i--
		dAtA[i] = 0x68
	}
	if m.SwitchInHopping != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.SwitchInHopping))
		i--
		dAtA[i] = 0x60
	}
	if len(m.XSwitchOutCount) > 0 {
		dAtA97 := make([]byte, len(m.XSwitchOutCount)*10)
		var j96 int
		for _, num1 := range m.XSwitchOutCount {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA97[j96] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j96++
			}
			dAtA97[j96] = uint8(num)
			j96++
		}
		i -= j96
		copy(dAtA[i:], dAtA97[:j96])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j96))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.SelfPayTime) > 0 {
		i -= len(m.SelfPayTime)
		copy(dAtA[i:], m.SelfPayTime)
		i = encodeVarintProtocolRtu(dAtA, i, uint64(len(m.SelfPayTime)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.CityPayTime) > 0 {
		i -= len(m.CityPayTime)
		copy(dAtA[i:], m.CityPayTime)
		i = encodeVarintProtocolRtu(dAtA, i, uint64(len(m.CityPayTime)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.XSwitchingTime) > 0 {
		for iNdEx := len(m.XSwitchingTime) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.XSwitchingTime[iNdEx])
			copy(dAtA[i:], m.XSwitchingTime[iNdEx])
			i = encodeVarintProtocolRtu(dAtA, i, uint64(len(m.XSwitchingTime[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.AnalogSum != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.AnalogSum))
		i--
		dAtA[i] = 0x38
	}
	if m.SwitchInSum != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.SwitchInSum))
		i--
		dAtA[i] = 0x30
	}
	if m.SwitchOutSum != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.SwitchOutSum))
		i--
		dAtA[i] = 0x28
	}
	if m.Addr != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.Addr))
		i--
		dAtA[i] = 0x20
	}
	if m.AlarmDelay != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.AlarmDelay))
		i--
		dAtA[i] = 0x18
	}
	if m.AlarmCycle != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.AlarmCycle))
		i--
		dAtA[i] = 0x10
	}
	if m.KeepAlive != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.KeepAlive))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtuDf00) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtuDf00) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtuDf00) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.XSwitchOutVector) > 0 {
		dAtA99 := make([]byte, len(m.XSwitchOutVector)*10)
		var j98 int
		for _, num1 := range m.XSwitchOutVector {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA99[j98] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j98++
			}
			dAtA99[j98] = uint8(num)
			j98++
		}
		i -= j98
		copy(dAtA[i:], dAtA99[:j98])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j98))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.XSwitchOutCount) > 0 {
		dAtA101 := make([]byte, len(m.XSwitchOutCount)*10)
		var j100 int
		for _, num1 := range m.XSwitchOutCount {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA101[j100] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j100++
			}
			dAtA101[j100] = uint8(num)
			j100++
		}
		i -= j100
		copy(dAtA[i:], dAtA101[:j100])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j100))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.XSwitchingTime) > 0 {
		for iNdEx := len(m.XSwitchingTime) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.XSwitchingTime[iNdEx])
			copy(dAtA[i:], m.XSwitchingTime[iNdEx])
			i = encodeVarintProtocolRtu(dAtA, i, uint64(len(m.XSwitchingTime[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtu_6100) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtu_6100) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtu_6100) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.XVoltagePhase) > 0 {
		dAtA103 := make([]byte, len(m.XVoltagePhase)*10)
		var j102 int
		for _, num1 := range m.XVoltagePhase {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA103[j102] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j102++
			}
			dAtA103[j102] = uint8(num)
			j102++
		}
		i -= j102
		copy(dAtA[i:], dAtA103[:j102])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j102))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtuA000) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtuA000) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtuA000) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Temperature != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.Temperature))
		i--
		dAtA[i] = 0x50
	}
	if m.FullRange != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.FullRange))
		i--
		dAtA[i] = 0x48
	}
	if len(m.XVoltageStatus) > 0 {
		dAtA105 := make([]byte, len(m.XVoltageStatus)*10)
		var j104 int
		for _, num1 := range m.XVoltageStatus {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA105[j104] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j104++
			}
			dAtA105[j104] = uint8(num)
			j104++
		}
		i -= j104
		copy(dAtA[i:], dAtA105[:j104])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j104))
		i--
		dAtA[i] = 0x42
	}
	if len(m.XCurrentStatus) > 0 {
		dAtA107 := make([]byte, len(m.XCurrentStatus)*10)
		var j106 int
		for _, num1 := range m.XCurrentStatus {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA107[j106] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j106++
			}
			dAtA107[j106] = uint8(num)
			j106++
		}
		i -= j106
		copy(dAtA[i:], dAtA107[:j106])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j106))
		i--
		dAtA[i] = 0x3a
	}
	if m.TmlSt != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.TmlSt))
		i--
		dAtA[i] = 0x30
	}
	if m.SwitchOutSt != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.SwitchOutSt))
		i--
		dAtA[i] = 0x28
	}
	if m.SwitchInSt != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.SwitchInSt))
		i--
		dAtA[i] = 0x20
	}
	if len(m.XAnalogPower) > 0 {
		for iNdEx := len(m.XAnalogPower) - 1; iNdEx >= 0; iNdEx-- {
			f108 := math.Float64bits(float64(m.XAnalogPower[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f108))
		}
		i = encodeVarintProtocolRtu(dAtA, i, uint64(len(m.XAnalogPower)*8))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.XAnalogCurrent) > 0 {
		for iNdEx := len(m.XAnalogCurrent) - 1; iNdEx >= 0; iNdEx-- {
			f109 := math.Float64bits(float64(m.XAnalogCurrent[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f109))
		}
		i = encodeVarintProtocolRtu(dAtA, i, uint64(len(m.XAnalogCurrent)*8))
		i--
		dAtA[i] = 0x12
	}
	if len(m.XAnalogVoltage) > 0 {
		for iNdEx := len(m.XAnalogVoltage) - 1; iNdEx >= 0; iNdEx-- {
			f110 := math.Float64bits(float64(m.XAnalogVoltage[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f110))
		}
		i = encodeVarintProtocolRtu(dAtA, i, uint64(len(m.XAnalogVoltage)*8))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtuA200) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtuA200) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtuA200) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Operation != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.Operation))
		i--
		dAtA[i] = 0x10
	}
	if m.KNo != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.KNo))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtu_4B00) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtu_4B00) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtu_4B00) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Operation) > 0 {
		dAtA112 := make([]byte, len(m.Operation)*10)
		var j111 int
		for _, num1 := range m.Operation {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA112[j111] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j111++
			}
			dAtA112[j111] = uint8(num)
			j111++
		}
		i -= j111
		copy(dAtA[i:], dAtA112[:j111])
		i = encodeVarintProtocolRtu(dAtA, i, uint64(j111))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtu_9300) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtu_9300) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtu_9300) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TmlDate) > 0 {
		i -= len(m.TmlDate)
		copy(dAtA[i:], m.TmlDate)
		i = encodeVarintProtocolRtu(dAtA, i, uint64(len(m.TmlDate)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtuB200) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtuB200) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtuB200) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.XK8OptTime) > 0 {
		for iNdEx := len(m.XK8OptTime) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.XK8OptTime[iNdEx])
			copy(dAtA[i:], m.XK8OptTime[iNdEx])
			i = encodeVarintProtocolRtu(dAtA, i, uint64(len(m.XK8OptTime[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.XK7OptTime) > 0 {
		for iNdEx := len(m.XK7OptTime) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.XK7OptTime[iNdEx])
			copy(dAtA[i:], m.XK7OptTime[iNdEx])
			i = encodeVarintProtocolRtu(dAtA, i, uint64(len(m.XK7OptTime[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.XK6OptTime) > 0 {
		for iNdEx := len(m.XK6OptTime) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.XK6OptTime[iNdEx])
			copy(dAtA[i:], m.XK6OptTime[iNdEx])
			i = encodeVarintProtocolRtu(dAtA, i, uint64(len(m.XK6OptTime[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.XK5OptTime) > 0 {
		for iNdEx := len(m.XK5OptTime) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.XK5OptTime[iNdEx])
			copy(dAtA[i:], m.XK5OptTime[iNdEx])
			i = encodeVarintProtocolRtu(dAtA, i, uint64(len(m.XK5OptTime[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.XK4OptTime) > 0 {
		for iNdEx := len(m.XK4OptTime) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.XK4OptTime[iNdEx])
			copy(dAtA[i:], m.XK4OptTime[iNdEx])
			i = encodeVarintProtocolRtu(dAtA, i, uint64(len(m.XK4OptTime[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.XSelfPayTime) > 0 {
		for iNdEx := len(m.XSelfPayTime) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.XSelfPayTime[iNdEx])
			copy(dAtA[i:], m.XSelfPayTime[iNdEx])
			i = encodeVarintProtocolRtu(dAtA, i, uint64(len(m.XSelfPayTime[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.XCityPayTime) > 0 {
		for iNdEx := len(m.XCityPayTime) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.XCityPayTime[iNdEx])
			copy(dAtA[i:], m.XCityPayTime[iNdEx])
			i = encodeVarintProtocolRtu(dAtA, i, uint64(len(m.XCityPayTime[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.XK3OptTime) > 0 {
		for iNdEx := len(m.XK3OptTime) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.XK3OptTime[iNdEx])
			copy(dAtA[i:], m.XK3OptTime[iNdEx])
			i = encodeVarintProtocolRtu(dAtA, i, uint64(len(m.XK3OptTime[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.XK2OptTime) > 0 {
		for iNdEx := len(m.XK2OptTime) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.XK2OptTime[iNdEx])
			copy(dAtA[i:], m.XK2OptTime[iNdEx])
			i = encodeVarintProtocolRtu(dAtA, i, uint64(len(m.XK2OptTime[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.XK1OptTime) > 0 {
		for iNdEx := len(m.XK1OptTime) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.XK1OptTime[iNdEx])
			copy(dAtA[i:], m.XK1OptTime[iNdEx])
			i = encodeVarintProtocolRtu(dAtA, i, uint64(len(m.XK1OptTime[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtuE600) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtuE600) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtuE600) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.XK8Time) > 0 {
		for iNdEx := len(m.XK8Time) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.XK8Time[iNdEx])
			copy(dAtA[i:], m.XK8Time[iNdEx])
			i = encodeVarintProtocolRtu(dAtA, i, uint64(len(m.XK8Time[iNdEx])))
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.XK7Time) > 0 {
		for iNdEx := len(m.XK7Time) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.XK7Time[iNdEx])
			copy(dAtA[i:], m.XK7Time[iNdEx])
			i = encodeVarintProtocolRtu(dAtA, i, uint64(len(m.XK7Time[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.XSelfPayTime) > 0 {
		for iNdEx := len(m.XSelfPayTime) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.XSelfPayTime[iNdEx])
			copy(dAtA[i:], m.XSelfPayTime[iNdEx])
			i = encodeVarintProtocolRtu(dAtA, i, uint64(len(m.XSelfPayTime[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.XCityPayTime) > 0 {
		for iNdEx := len(m.XCityPayTime) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.XCityPayTime[iNdEx])
			copy(dAtA[i:], m.XCityPayTime[iNdEx])
			i = encodeVarintProtocolRtu(dAtA, i, uint64(len(m.XCityPayTime[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.XK6Time) > 0 {
		for iNdEx := len(m.XK6Time) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.XK6Time[iNdEx])
			copy(dAtA[i:], m.XK6Time[iNdEx])
			i = encodeVarintProtocolRtu(dAtA, i, uint64(len(m.XK6Time[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.XK5Time) > 0 {
		for iNdEx := len(m.XK5Time) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.XK5Time[iNdEx])
			copy(dAtA[i:], m.XK5Time[iNdEx])
			i = encodeVarintProtocolRtu(dAtA, i, uint64(len(m.XK5Time[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.XK4Time) > 0 {
		for iNdEx := len(m.XK4Time) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.XK4Time[iNdEx])
			copy(dAtA[i:], m.XK4Time[iNdEx])
			i = encodeVarintProtocolRtu(dAtA, i, uint64(len(m.XK4Time[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.XK3Time) > 0 {
		for iNdEx := len(m.XK3Time) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.XK3Time[iNdEx])
			copy(dAtA[i:], m.XK3Time[iNdEx])
			i = encodeVarintProtocolRtu(dAtA, i, uint64(len(m.XK3Time[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.XK2Time) > 0 {
		for iNdEx := len(m.XK2Time) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.XK2Time[iNdEx])
			copy(dAtA[i:], m.XK2Time[iNdEx])
			i = encodeVarintProtocolRtu(dAtA, i, uint64(len(m.XK2Time[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.XK1Time) > 0 {
		for iNdEx := len(m.XK1Time) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.XK1Time[iNdEx])
			copy(dAtA[i:], m.XK1Time[iNdEx])
			i = encodeVarintProtocolRtu(dAtA, i, uint64(len(m.XK1Time[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.XHolidays) > 0 {
		for iNdEx := len(m.XHolidays) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.XHolidays[iNdEx])
			copy(dAtA[i:], m.XHolidays[iNdEx])
			i = encodeVarintProtocolRtu(dAtA, i, uint64(len(m.XHolidays[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtu_9800) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtu_9800) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtu_9800) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintProtocolRtu(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstRtuDc00) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstRtuDc00) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstRtuDc00) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ver) > 0 {
		i -= len(m.Ver)
		copy(dAtA[i:], m.Ver)
		i = encodeVarintProtocolRtu(dAtA, i, uint64(len(m.Ver)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintProtocolRtu(dAtA []byte, offset int, v uint64) int {
	offset -= sovProtocolRtu(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *WlstRtuAns) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovProtocolRtu(uint64(m.CmdIdx))
	}
	if len(m.DataMark) > 0 {
		l = 0
		for _, e := range m.DataMark {
			l += sovProtocolRtu(uint64(e))
		}
		n += 1 + sovProtocolRtu(uint64(l)) + l
	}
	if len(m.DataPoint) > 0 {
		l = 0
		for _, e := range m.DataPoint {
			l += sovProtocolRtu(uint64(e))
		}
		n += 1 + sovProtocolRtu(uint64(l)) + l
	}
	if len(m.Status) > 0 {
		l = 0
		for _, e := range m.Status {
			l += sovProtocolRtu(uint64(e))
		}
		n += 1 + sovProtocolRtu(uint64(l)) + l
	}
	if m.StatusCode != 0 {
		n += 1 + sovProtocolRtu(uint64(m.StatusCode))
	}
	return n
}

func (m *WlstRtu_7094) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovProtocolRtu(uint64(m.CmdIdx))
	}
	if m.AlarmType != 0 {
		n += 1 + sovProtocolRtu(uint64(m.AlarmType))
	}
	if m.Alarmln != nil {
		l = m.Alarmln.Size()
		n += 1 + l + sovProtocolRtu(uint64(l))
	}
	if len(m.SwitchOutStPacked) > 0 {
		l = 0
		for _, e := range m.SwitchOutStPacked {
			l += sovProtocolRtu(uint64(e))
		}
		n += 1 + sovProtocolRtu(uint64(l)) + l
	}
	return n
}

func (m *WlstRtu_7094_Alarm_LN) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LoopNo != 0 {
		n += 1 + sovProtocolRtu(uint64(m.LoopNo))
	}
	if m.AlarmStatus != 0 {
		n += 1 + sovProtocolRtu(uint64(m.AlarmStatus))
	}
	if m.AlarmCurrent != 0 {
		n += 9
	}
	return n
}

func (m *WlstRtu_7021) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovProtocolRtu(uint64(m.CmdIdx))
	}
	if m.DataType != 0 {
		n += 1 + sovProtocolRtu(uint64(m.DataType))
	}
	if len(m.Argsln) > 0 {
		for _, e := range m.Argsln {
			l = e.Size()
			n += 1 + l + sovProtocolRtu(uint64(l))
		}
	}
	if m.StatusCode != 0 {
		n += 1 + sovProtocolRtu(uint64(m.StatusCode))
	}
	if m.LoopType != 0 {
		n += 1 + sovProtocolRtu(uint64(m.LoopType))
	}
	if len(m.Argswc) > 0 {
		for _, e := range m.Argswc {
			l = e.Size()
			n += 1 + l + sovProtocolRtu(uint64(l))
		}
	}
	return n
}

func (m *WlstRtu_7021_Args_LN) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LoopNo != 0 {
		n += 1 + sovProtocolRtu(uint64(m.LoopNo))
	}
	if m.BaseValue != 0 {
		n += 1 + sovProtocolRtu(uint64(m.BaseValue))
	}
	if m.AlarmValue != 0 {
		n += 1 + sovProtocolRtu(uint64(m.AlarmValue))
	}
	if m.BreakValue != 0 {
		n += 1 + sovProtocolRtu(uint64(m.BreakValue))
	}
	return n
}

func (m *WlstRtu_7021_Args_WC) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.L1On != 0 {
		n += 1 + sovProtocolRtu(uint64(m.L1On))
	}
	if m.L1Off != 0 {
		n += 1 + sovProtocolRtu(uint64(m.L1Off))
	}
	if m.L2On != 0 {
		n += 1 + sovProtocolRtu(uint64(m.L2On))
	}
	if m.L2Off != 0 {
		n += 1 + sovProtocolRtu(uint64(m.L2Off))
	}
	if m.L3On != 0 {
		n += 1 + sovProtocolRtu(uint64(m.L3On))
	}
	if m.L3Off != 0 {
		n += 1 + sovProtocolRtu(uint64(m.L3Off))
	}
	if m.L4On != 0 {
		n += 1 + sovProtocolRtu(uint64(m.L4On))
	}
	if m.L4Off != 0 {
		n += 1 + sovProtocolRtu(uint64(m.L4Off))
	}
	if m.L5On != 0 {
		n += 1 + sovProtocolRtu(uint64(m.L5On))
	}
	if m.L5Off != 0 {
		n += 1 + sovProtocolRtu(uint64(m.L5Off))
	}
	if m.L6On != 0 {
		n += 1 + sovProtocolRtu(uint64(m.L6On))
	}
	if m.L6Off != 0 {
		n += 1 + sovProtocolRtu(uint64(m.L6Off))
	}
	if m.L7On != 0 {
		n += 1 + sovProtocolRtu(uint64(m.L7On))
	}
	if m.L7Off != 0 {
		n += 1 + sovProtocolRtu(uint64(m.L7Off))
	}
	if m.L8On != 0 {
		n += 1 + sovProtocolRtu(uint64(m.L8On))
	}
	if m.L8Off != 0 {
		n += 2 + sovProtocolRtu(uint64(m.L8Off))
	}
	return n
}

func (m *WlstRtu_7023) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovProtocolRtu(uint64(m.CmdIdx))
	}
	if m.DataType != 0 {
		n += 1 + sovProtocolRtu(uint64(m.DataType))
	}
	if len(m.Argscontrol) > 0 {
		for _, e := range m.Argscontrol {
			l = e.Size()
			n += 1 + l + sovProtocolRtu(uint64(l))
		}
	}
	if m.StatusCode != 0 {
		n += 1 + sovProtocolRtu(uint64(m.StatusCode))
	}
	return n
}

func (m *WlstRtu_7023_Args_Control) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LoopNo != 0 {
		n += 1 + sovProtocolRtu(uint64(m.LoopNo))
	}
	if m.Operation != 0 {
		n += 1 + sovProtocolRtu(uint64(m.Operation))
	}
	return n
}

func (m *WlstRtu_705B) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovProtocolRtu(uint64(m.CmdIdx))
	}
	if m.CmdType != 0 {
		n += 1 + sovProtocolRtu(uint64(m.CmdType))
	}
	l = len(m.HardwareVer)
	if l > 0 {
		n += 1 + l + sovProtocolRtu(uint64(l))
	}
	l = len(m.ProductionBatch)
	if l > 0 {
		n += 1 + l + sovProtocolRtu(uint64(l))
	}
	l = len(m.ProductionDate)
	if l > 0 {
		n += 1 + l + sovProtocolRtu(uint64(l))
	}
	l = len(m.InstallationDate)
	if l > 0 {
		n += 1 + l + sovProtocolRtu(uint64(l))
	}
	return n
}

func (m *WlstRtu_70A0) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovProtocolRtu(uint64(m.CmdIdx))
	}
	if m.CmdType != 0 {
		n += 1 + sovProtocolRtu(uint64(m.CmdType))
	}
	if m.Frequency != 0 {
		n += 5
	}
	if len(m.Ee) > 0 {
		for _, e := range m.Ee {
			l = e.Size()
			n += 1 + l + sovProtocolRtu(uint64(l))
		}
	}
	if m.Temperature != 0 {
		n += 1 + sovProtocolRtu(uint64(m.Temperature))
	}
	if m.Humidity != 0 {
		n += 1 + sovProtocolRtu(uint64(m.Humidity))
	}
	if m.MainVoltage != 0 {
		n += 9
	}
	if m.BatteryPower != 0 {
		n += 1 + sovProtocolRtu(uint64(m.BatteryPower))
	}
	if m.Longitude != 0 {
		n += 9
	}
	if m.Latitude != 0 {
		n += 9
	}
	if m.Gpsargs != nil {
		l = m.Gpsargs.Size()
		n += 1 + l + sovProtocolRtu(uint64(l))
	}
	if len(m.SwitchInStPacked) > 0 {
		l = 0
		for _, e := range m.SwitchInStPacked {
			l += sovProtocolRtu(uint64(e))
		}
		n += 1 + sovProtocolRtu(uint64(l)) + l
	}
	if len(m.SwitchOutStPacked) > 0 {
		l = 0
		for _, e := range m.SwitchOutStPacked {
			l += sovProtocolRtu(uint64(e))
		}
		n += 1 + sovProtocolRtu(uint64(l)) + l
	}
	if len(m.TmlStPacked) > 0 {
		l = 0
		for _, e := range m.TmlStPacked {
			l += sovProtocolRtu(uint64(e))
		}
		n += 1 + sovProtocolRtu(uint64(l)) + l
	}
	if len(m.TmlReset) > 0 {
		l = 0
		for _, e := range m.TmlReset {
			l += sovProtocolRtu(uint64(e))
		}
		n += 1 + sovProtocolRtu(uint64(l)) + l
	}
	if m.LoopCount != 0 {
		n += 2 + sovProtocolRtu(uint64(m.LoopCount))
	}
	return n
}

func (m *WlstRtu_70A0_ElectricEnergy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Voltage != 0 {
		n += 5
	}
	if m.Current != 0 {
		n += 5
	}
	if m.PowerFactor != 0 {
		n += 5
	}
	if m.ActivePower != 0 {
		n += 5
	}
	if m.ReactivePower != 0 {
		n += 5
	}
	if m.ActiveEnergy != 0 {
		n += 5
	}
	if m.ReactiveEnergy != 0 {
		n += 5
	}
	return n
}

func (m *WlstRtu_70A0_GpsArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GpsType != 0 {
		n += 1 + sovProtocolRtu(uint64(m.GpsType))
	}
	if m.LatType != 0 {
		n += 1 + sovProtocolRtu(uint64(m.LatType))
	}
	if m.LonType != 0 {
		n += 1 + sovProtocolRtu(uint64(m.LonType))
	}
	if m.LocationStatus != 0 {
		n += 1 + sovProtocolRtu(uint64(m.LocationStatus))
	}
	return n
}

func (m *WlstRtu_7053) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovProtocolRtu(uint64(m.CmdIdx))
	}
	if m.RecordType != 0 {
		n += 1 + sovProtocolRtu(uint64(m.RecordType))
	}
	if m.DtStart != 0 {
		n += 1 + sovProtocolRtu(uint64(m.DtStart))
	}
	if m.RecordCount != 0 {
		n += 1 + sovProtocolRtu(uint64(m.RecordCount))
	}
	if m.RecordDistance != 0 {
		n += 1 + sovProtocolRtu(uint64(m.RecordDistance))
	}
	return n
}

func (m *WlstRtu_70D3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovProtocolRtu(uint64(m.CmdIdx))
	}
	if m.RecordTotal != 0 {
		n += 1 + sovProtocolRtu(uint64(m.RecordTotal))
	}
	if m.RecordIdx != 0 {
		n += 1 + sovProtocolRtu(uint64(m.RecordIdx))
	}
	if m.RecordStatus != 0 {
		n += 1 + sovProtocolRtu(uint64(m.RecordStatus))
	}
	if m.RecordType != 0 {
		n += 1 + sovProtocolRtu(uint64(m.RecordType))
	}
	if m.DtStart != 0 {
		n += 1 + sovProtocolRtu(uint64(m.DtStart))
	}
	if m.RecordCount != 0 {
		n += 1 + sovProtocolRtu(uint64(m.RecordCount))
	}
	if m.RecordDistance != 0 {
		n += 1 + sovProtocolRtu(uint64(m.RecordDistance))
	}
	if len(m.Data_70D0) > 0 {
		for _, e := range m.Data_70D0 {
			l = e.Size()
			n += 1 + l + sovProtocolRtu(uint64(l))
		}
	}
	if len(m.Data_70D0Max) > 0 {
		for _, e := range m.Data_70D0Max {
			l = e.Size()
			n += 1 + l + sovProtocolRtu(uint64(l))
		}
	}
	return n
}

func (m *WlstRtu_70D0Max) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DtRecord != 0 {
		n += 1 + sovProtocolRtu(uint64(m.DtRecord))
	}
	if m.RecordType != 0 {
		n += 1 + sovProtocolRtu(uint64(m.RecordType))
	}
	if m.LoopCount != 0 {
		n += 1 + sovProtocolRtu(uint64(m.LoopCount))
	}
	if len(m.MaxData) > 0 {
		for _, e := range m.MaxData {
			l = e.Size()
			n += 1 + l + sovProtocolRtu(uint64(l))
		}
	}
	return n
}

func (m *WlstRtu_70D0Max_MaxData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CurrentMax != 0 {
		n += 9
	}
	if m.DtRecord != 0 {
		n += 1 + sovProtocolRtu(uint64(m.DtRecord))
	}
	return n
}

func (m *WlstRtu_7800) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EventType != 0 {
		n += 1 + sovProtocolRtu(uint64(m.EventType))
	}
	if m.EventClass != 0 {
		n += 1 + sovProtocolRtu(uint64(m.EventClass))
	}
	if m.DataNum != 0 {
		n += 1 + sovProtocolRtu(uint64(m.DataNum))
	}
	if m.DtStart != 0 {
		n += 1 + sovProtocolRtu(uint64(m.DtStart))
	}
	if m.DtEnd != 0 {
		n += 1 + sovProtocolRtu(uint64(m.DtEnd))
	}
	if m.AllNum != 0 {
		n += 1 + sovProtocolRtu(uint64(m.AllNum))
	}
	if m.CurNum != 0 {
		n += 1 + sovProtocolRtu(uint64(m.CurNum))
	}
	l = len(m.RawData)
	if l > 0 {
		n += 1 + l + sovProtocolRtu(uint64(l))
	}
	return n
}

func (m *WlstRtu_7050) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovProtocolRtu(uint64(m.CmdIdx))
	}
	if m.DataMark != 0 {
		n += 1 + sovProtocolRtu(uint64(m.DataMark))
	}
	return n
}

func (m *WlstRtu_70D0) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovProtocolRtu(uint64(m.CmdIdx))
	}
	if m.DataMark != nil {
		l = m.DataMark.Size()
		n += 1 + l + sovProtocolRtu(uint64(l))
	}
	if len(m.SwitchInStPacked) > 0 {
		l = 0
		for _, e := range m.SwitchInStPacked {
			l += sovProtocolRtu(uint64(e))
		}
		n += 1 + sovProtocolRtu(uint64(l)) + l
	}
	if len(m.SwitchOutStPacked) > 0 {
		l = 0
		for _, e := range m.SwitchOutStPacked {
			l += sovProtocolRtu(uint64(e))
		}
		n += 1 + sovProtocolRtu(uint64(l)) + l
	}
	if len(m.TmlStPacked) > 0 {
		l = 0
		for _, e := range m.TmlStPacked {
			l += sovProtocolRtu(uint64(e))
		}
		n += 1 + sovProtocolRtu(uint64(l)) + l
	}
	if m.Temperature != 0 {
		n += 1 + sovProtocolRtu(uint64(m.Temperature))
	}
	if m.GprsReset != 0 {
		n += 1 + sovProtocolRtu(uint64(m.GprsReset))
	}
	if m.GprsSignal != 0 {
		n += 1 + sovProtocolRtu(uint64(m.GprsSignal))
	}
	if len(m.TmlReset) > 0 {
		l = 0
		for _, e := range m.TmlReset {
			l += sovProtocolRtu(uint64(e))
		}
		n += 1 + sovProtocolRtu(uint64(l)) + l
	}
	if len(m.TmlArgsStatus) > 0 {
		l = 0
		for _, e := range m.TmlArgsStatus {
			l += sovProtocolRtu(uint64(e))
		}
		n += 1 + sovProtocolRtu(uint64(l)) + l
	}
	if m.PowerSupply != 0 {
		n += 9
	}
	if len(m.SamplingVoltage) > 0 {
		for _, e := range m.SamplingVoltage {
			l = e.Size()
			n += 1 + l + sovProtocolRtu(uint64(l))
		}
	}
	if len(m.AnalogData) > 0 {
		for _, e := range m.AnalogData {
			l = e.Size()
			n += 1 + l + sovProtocolRtu(uint64(l))
		}
	}
	if m.SwitchInSt != 0 {
		n += 1 + sovProtocolRtu(uint64(m.SwitchInSt))
	}
	if m.SwitchOutSt != 0 {
		n += 1 + sovProtocolRtu(uint64(m.SwitchOutSt))
	}
	if m.TmlSt != 0 {
		n += 2 + sovProtocolRtu(uint64(m.TmlSt))
	}
	if m.FullRange != 0 {
		n += 2 + sovProtocolRtu(uint64(m.FullRange))
	}
	if m.DtRecord != 0 {
		n += 2 + sovProtocolRtu(uint64(m.DtRecord))
	}
	if len(m.SwitchOutReason) > 0 {
		l = 0
		for _, e := range m.SwitchOutReason {
			l += sovProtocolRtu(uint64(e))
		}
		n += 2 + sovProtocolRtu(uint64(l)) + l
	}
	return n
}

func (m *WlstRtu_70D0_DataMark) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GetRunData != 0 {
		n += 1 + sovProtocolRtu(uint64(m.GetRunData))
	}
	if m.GetSwitchoutReason != 0 {
		n += 1 + sovProtocolRtu(uint64(m.GetSwitchoutReason))
	}
	return n
}

func (m *WlstRtu_70D0_SamplingVoltage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VolA != 0 {
		n += 9
	}
	if m.VolB != 0 {
		n += 9
	}
	if m.VolC != 0 {
		n += 9
	}
	return n
}

func (m *WlstRtu_70D0_AnalogData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Voltage != 0 {
		n += 9
	}
	if m.Current != 0 {
		n += 9
	}
	if m.Power != 0 {
		n += 9
	}
	if m.VoltageStatus != 0 {
		n += 1 + sovProtocolRtu(uint64(m.VoltageStatus))
	}
	if m.CurrentStatus != 0 {
		n += 1 + sovProtocolRtu(uint64(m.CurrentStatus))
	}
	return n
}

func (m *WlstRtu_705A) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovProtocolRtu(uint64(m.CmdIdx))
	}
	if m.CmdType != 0 {
		n += 1 + sovProtocolRtu(uint64(m.CmdType))
	}
	return n
}

func (m *WlstRtu_70Da) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovProtocolRtu(uint64(m.CmdIdx))
	}
	if m.KeepAlive != 0 {
		n += 1 + sovProtocolRtu(uint64(m.KeepAlive))
	}
	if m.AlarmCycle != 0 {
		n += 1 + sovProtocolRtu(uint64(m.AlarmCycle))
	}
	if m.AlarmDelay != 0 {
		n += 1 + sovProtocolRtu(uint64(m.AlarmDelay))
	}
	if m.SwitchOutSum != 0 {
		n += 1 + sovProtocolRtu(uint64(m.SwitchOutSum))
	}
	if m.SwitchInSum != 0 {
		n += 1 + sovProtocolRtu(uint64(m.SwitchInSum))
	}
	if m.AnalogSum != 0 {
		n += 1 + sovProtocolRtu(uint64(m.AnalogSum))
	}
	if len(m.XSwitchingTime) > 0 {
		for _, s := range m.XSwitchingTime {
			l = len(s)
			n += 1 + l + sovProtocolRtu(uint64(l))
		}
	}
	l = len(m.CityPayTime)
	if l > 0 {
		n += 1 + l + sovProtocolRtu(uint64(l))
	}
	l = len(m.SelfPayTime)
	if l > 0 {
		n += 1 + l + sovProtocolRtu(uint64(l))
	}
	if len(m.XSwitchOutCount) > 0 {
		l = 0
		for _, e := range m.XSwitchOutCount {
			l += sovProtocolRtu(uint64(e))
		}
		n += 1 + sovProtocolRtu(uint64(l)) + l
	}
	if len(m.SwitchInHopping) > 0 {
		l = 0
		for _, e := range m.SwitchInHopping {
			l += sovProtocolRtu(uint64(e))
		}
		n += 1 + sovProtocolRtu(uint64(l)) + l
	}
	if m.VoltageRange != 0 {
		n += 1 + sovProtocolRtu(uint64(m.VoltageRange))
	}
	if len(m.XCurrentRange) > 0 {
		l = 0
		for _, e := range m.XCurrentRange {
			l += sovProtocolRtu(uint64(e))
		}
		n += 1 + sovProtocolRtu(uint64(l)) + l
	}
	if len(m.XSwitchOutVector) > 0 {
		l = 0
		for _, e := range m.XSwitchOutVector {
			l += sovProtocolRtu(uint64(e))
		}
		n += 1 + sovProtocolRtu(uint64(l)) + l
	}
	if len(m.XSwitchInVector) > 0 {
		l = 0
		for _, e := range m.XSwitchInVector {
			l += sovProtocolRtu(uint64(e))
		}
		n += 2 + sovProtocolRtu(uint64(l)) + l
	}
	if len(m.XAnalogVector) > 0 {
		l = 0
		for _, e := range m.XAnalogVector {
			l += sovProtocolRtu(uint64(e))
		}
		n += 2 + sovProtocolRtu(uint64(l)) + l
	}
	if m.UpperVoltageLimit != 0 {
		n += 2 + sovProtocolRtu(uint64(m.UpperVoltageLimit))
	}
	if m.LowerVoltageLimit != 0 {
		n += 2 + sovProtocolRtu(uint64(m.LowerVoltageLimit))
	}
	if len(m.XUpperCurrentLimit) > 0 {
		l = 0
		for _, e := range m.XUpperCurrentLimit {
			l += sovProtocolRtu(uint64(e))
		}
		n += 2 + sovProtocolRtu(uint64(l)) + l
	}
	if len(m.XLowerCurrentLimit) > 0 {
		l = 0
		for _, e := range m.XLowerCurrentLimit {
			l += sovProtocolRtu(uint64(e))
		}
		n += 2 + sovProtocolRtu(uint64(l)) + l
	}
	if m.GroupId != 0 {
		n += 2 + sovProtocolRtu(uint64(m.GroupId))
	}
	if m.CmdType != 0 {
		n += 2 + sovProtocolRtu(uint64(m.CmdType))
	}
	if len(m.Transformers) > 0 {
		l = 0
		for _, e := range m.Transformers {
			l += sovProtocolRtu(uint64(e))
		}
		n += 2 + sovProtocolRtu(uint64(l)) + l
	}
	return n
}

func (m *WlstRtu_700A) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ComArgv) > 0 {
		l = 0
		for _, e := range m.ComArgv {
			l += sovProtocolRtu(uint64(e))
		}
		n += 1 + sovProtocolRtu(uint64(l)) + l
	}
	return n
}

func (m *WlstRtu_7010) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DataMark != 0 {
		n += 1 + sovProtocolRtu(uint64(m.DataMark))
	}
	if m.CmdIdx != 0 {
		n += 1 + sovProtocolRtu(uint64(m.CmdIdx))
	}
	if m.Status != 0 {
		n += 1 + sovProtocolRtu(uint64(m.Status))
	}
	return n
}

func (m *WlstRtu_7003) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovProtocolRtu(uint64(m.CmdIdx))
	}
	if len(m.FtpData) > 0 {
		l = 0
		for _, e := range m.FtpData {
			l += sovProtocolRtu(uint64(e))
		}
		n += 1 + sovProtocolRtu(uint64(l)) + l
	}
	return n
}

func (m *WlstRtu_7006) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovProtocolRtu(uint64(m.CmdIdx))
	}
	if m.AllCount != 0 {
		n += 1 + sovProtocolRtu(uint64(m.AllCount))
	}
	l = len(m.CacheName)
	if l > 0 {
		n += 1 + l + sovProtocolRtu(uint64(l))
	}
	return n
}

func (m *WlstRtu_7007) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovProtocolRtu(uint64(m.CmdIdx))
	}
	return n
}

func (m *WlstRtu_7087) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovProtocolRtu(uint64(m.CmdIdx))
	}
	if m.Status != 0 {
		n += 1 + sovProtocolRtu(uint64(m.Status))
	}
	if len(m.FailedPackages) > 0 {
		l = 0
		for _, e := range m.FailedPackages {
			l += sovProtocolRtu(uint64(e))
		}
		n += 1 + sovProtocolRtu(uint64(l)) + l
	}
	if m.BytesCount != 0 {
		n += 1 + sovProtocolRtu(uint64(m.BytesCount))
	}
	return n
}

func (m *WlstRtu_7081) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovProtocolRtu(uint64(m.CmdIdx))
	}
	if m.Status != 0 {
		n += 1 + sovProtocolRtu(uint64(m.Status))
	}
	l = len(m.OldVer)
	if l > 0 {
		n += 1 + l + sovProtocolRtu(uint64(l))
	}
	l = len(m.NewVer)
	if l > 0 {
		n += 1 + l + sovProtocolRtu(uint64(l))
	}
	if m.DataLocation != 0 {
		n += 1 + sovProtocolRtu(uint64(m.DataLocation))
	}
	return n
}

func (m *WlstRtu_7008) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovProtocolRtu(uint64(m.CmdIdx))
	}
	if len(m.UpdData) > 0 {
		for _, s := range m.UpdData {
			l = len(s)
			n += 1 + l + sovProtocolRtu(uint64(l))
		}
	}
	l = len(m.CacheName)
	if l > 0 {
		n += 1 + l + sovProtocolRtu(uint64(l))
	}
	if m.Clean != 0 {
		n += 1 + sovProtocolRtu(uint64(m.Clean))
	}
	if len(m.IntUpdData) > 0 {
		l = 0
		for _, e := range m.IntUpdData {
			l += sovProtocolRtu(uint64(e))
		}
		n += 1 + sovProtocolRtu(uint64(l)) + l
	}
	return n
}

func (m *WlstRtu_7060) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovProtocolRtu(uint64(m.CmdIdx))
	}
	if m.DtStart != 0 {
		n += 1 + sovProtocolRtu(uint64(m.DtStart))
	}
	if m.Days != 0 {
		n += 1 + sovProtocolRtu(uint64(m.Days))
	}
	if len(m.YearCtrl) > 0 {
		for _, e := range m.YearCtrl {
			l = e.Size()
			n += 1 + l + sovProtocolRtu(uint64(l))
		}
	}
	return n
}

func (m *WlstRtu_7060_YearCtrl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LoopNo != 0 {
		n += 1 + sovProtocolRtu(uint64(m.LoopNo))
	}
	if m.TimeCount != 0 {
		n += 1 + sovProtocolRtu(uint64(m.TimeCount))
	}
	if len(m.OptTime) > 0 {
		l = 0
		for _, e := range m.OptTime {
			l += sovProtocolRtu(uint64(e))
		}
		n += 1 + sovProtocolRtu(uint64(l)) + l
	}
	return n
}

func (m *WlstRtu_7061) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovProtocolRtu(uint64(m.CmdIdx))
	}
	if m.DtStart != 0 {
		n += 1 + sovProtocolRtu(uint64(m.DtStart))
	}
	if m.Days != 0 {
		n += 1 + sovProtocolRtu(uint64(m.Days))
	}
	if len(m.LoopNo) > 0 {
		l = 0
		for _, e := range m.LoopNo {
			l += sovProtocolRtu(uint64(e))
		}
		n += 1 + sovProtocolRtu(uint64(l)) + l
	}
	return n
}

func (m *WlstRtu_70E0) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovProtocolRtu(uint64(m.CmdIdx))
	}
	if m.Status != 0 {
		n += 1 + sovProtocolRtu(uint64(m.Status))
	}
	return n
}

func (m *WlstRtu_7B00) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sim)
	if l > 0 {
		n += 1 + l + sovProtocolRtu(uint64(l))
	}
	if m.Signal != 0 {
		n += 1 + sovProtocolRtu(uint64(m.Signal))
	}
	return n
}

func (m *WlstRtu_1900) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Addr != 0 {
		n += 1 + sovProtocolRtu(uint64(m.Addr))
	}
	if m.TmlIp != 0 {
		n += 1 + sovProtocolRtu(uint64(m.TmlIp))
	}
	return n
}

func (m *WlstRtu_4000) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WorkMark != 0 {
		n += 1 + sovProtocolRtu(uint64(m.WorkMark))
	}
	if m.KeepAlive != 0 {
		n += 1 + sovProtocolRtu(uint64(m.KeepAlive))
	}
	if m.AlarmCycle != 0 {
		n += 1 + sovProtocolRtu(uint64(m.AlarmCycle))
	}
	if m.AlarmDelay != 0 {
		n += 1 + sovProtocolRtu(uint64(m.AlarmDelay))
	}
	if len(m.XLoopCount) > 0 {
		l = 0
		for _, e := range m.XLoopCount {
			l += sovProtocolRtu(uint64(e))
		}
		n += 1 + sovProtocolRtu(uint64(l)) + l
	}
	return n
}

func (m *WlstRtu_4101) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnalogSum != 0 {
		n += 1 + sovProtocolRtu(uint64(m.AnalogSum))
	}
	if m.VoltageRange != 0 {
		n += 1 + sovProtocolRtu(uint64(m.VoltageRange))
	}
	if len(m.XCurrentRange) > 0 {
		l = 0
		for _, e := range m.XCurrentRange {
			l += sovProtocolRtu(uint64(e))
		}
		n += 1 + sovProtocolRtu(uint64(l)) + l
	}
	return n
}

func (m *WlstRtu_4104) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SwitchinSum != 0 {
		n += 1 + sovProtocolRtu(uint64(m.SwitchinSum))
	}
	if len(m.XSwitchVector) > 0 {
		l = 0
		for _, e := range m.XSwitchVector {
			l += sovProtocolRtu(uint64(e))
		}
		n += 1 + sovProtocolRtu(uint64(l)) + l
	}
	if len(m.XSwitchHopping) > 0 {
		l = 0
		for _, e := range m.XSwitchHopping {
			l += sovProtocolRtu(uint64(e))
		}
		n += 1 + sovProtocolRtu(uint64(l)) + l
	}
	return n
}

func (m *WlstRtu_4110) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SwitchInSum != 0 {
		n += 1 + sovProtocolRtu(uint64(m.SwitchInSum))
	}
	return n
}

func (m *WlstRtu_4111) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Transformers) > 0 {
		l = 0
		for _, e := range m.Transformers {
			l += sovProtocolRtu(uint64(e))
		}
		n += 1 + sovProtocolRtu(uint64(l)) + l
	}
	if m.Status != 0 {
		n += 1 + sovProtocolRtu(uint64(m.Status))
	}
	return n
}

func (m *WlstRtu_4200) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.XAnalogVector) > 0 {
		l = 0
		for _, e := range m.XAnalogVector {
			l += sovProtocolRtu(uint64(e))
		}
		n += 1 + sovProtocolRtu(uint64(l)) + l
	}
	if len(m.XSwitchInVector) > 0 {
		l = 0
		for _, e := range m.XSwitchInVector {
			l += sovProtocolRtu(uint64(e))
		}
		n += 1 + sovProtocolRtu(uint64(l)) + l
	}
	if len(m.XSwitchOutVector) > 0 {
		l = 0
		for _, e := range m.XSwitchOutVector {
			l += sovProtocolRtu(uint64(e))
		}
		n += 1 + sovProtocolRtu(uint64(l)) + l
	}
	if m.AnalogSum != 0 {
		n += 1 + sovProtocolRtu(uint64(m.AnalogSum))
	}
	if m.SwitchInSum != 0 {
		n += 1 + sovProtocolRtu(uint64(m.SwitchInSum))
	}
	if m.SwitchOutSum != 0 {
		n += 1 + sovProtocolRtu(uint64(m.SwitchOutSum))
	}
	return n
}

func (m *WlstRtu_4401) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnalogSum != 0 {
		n += 1 + sovProtocolRtu(uint64(m.AnalogSum))
	}
	if m.UpperVoltageLimit != 0 {
		n += 1 + sovProtocolRtu(uint64(m.UpperVoltageLimit))
	}
	if m.LowerVoltageLimit != 0 {
		n += 1 + sovProtocolRtu(uint64(m.LowerVoltageLimit))
	}
	if len(m.XUpperCurrentLimit) > 0 {
		l = 0
		for _, e := range m.XUpperCurrentLimit {
			l += sovProtocolRtu(uint64(e))
		}
		n += 1 + sovProtocolRtu(uint64(l)) + l
	}
	if len(m.XLowerCurrentLimit) > 0 {
		l = 0
		for _, e := range m.XLowerCurrentLimit {
			l += sovProtocolRtu(uint64(e))
		}
		n += 1 + sovProtocolRtu(uint64(l)) + l
	}
	if m.VoltageRange != 0 {
		n += 1 + sovProtocolRtu(uint64(m.VoltageRange))
	}
	if len(m.XCurrentRange) > 0 {
		l = 0
		for _, e := range m.XCurrentRange {
			l += sovProtocolRtu(uint64(e))
		}
		n += 1 + sovProtocolRtu(uint64(l)) + l
	}
	return n
}

func (m *WlstRtuDa00) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.KeepAlive != 0 {
		n += 1 + sovProtocolRtu(uint64(m.KeepAlive))
	}
	if m.AlarmCycle != 0 {
		n += 1 + sovProtocolRtu(uint64(m.AlarmCycle))
	}
	if m.AlarmDelay != 0 {
		n += 1 + sovProtocolRtu(uint64(m.AlarmDelay))
	}
	if m.Addr != 0 {
		n += 1 + sovProtocolRtu(uint64(m.Addr))
	}
	if m.SwitchOutSum != 0 {
		n += 1 + sovProtocolRtu(uint64(m.SwitchOutSum))
	}
	if m.SwitchInSum != 0 {
		n += 1 + sovProtocolRtu(uint64(m.SwitchInSum))
	}
	if m.AnalogSum != 0 {
		n += 1 + sovProtocolRtu(uint64(m.AnalogSum))
	}
	if len(m.XSwitchingTime) > 0 {
		for _, s := range m.XSwitchingTime {
			l = len(s)
			n += 1 + l + sovProtocolRtu(uint64(l))
		}
	}
	l = len(m.CityPayTime)
	if l > 0 {
		n += 1 + l + sovProtocolRtu(uint64(l))
	}
	l = len(m.SelfPayTime)
	if l > 0 {
		n += 1 + l + sovProtocolRtu(uint64(l))
	}
	if len(m.XSwitchOutCount) > 0 {
		l = 0
		for _, e := range m.XSwitchOutCount {
			l += sovProtocolRtu(uint64(e))
		}
		n += 1 + sovProtocolRtu(uint64(l)) + l
	}
	if m.SwitchInHopping != 0 {
		n += 1 + sovProtocolRtu(uint64(m.SwitchInHopping))
	}
	if m.VoltageRange != 0 {
		n += 1 + sovProtocolRtu(uint64(m.VoltageRange))
	}
	if len(m.XCurrentRange) > 0 {
		l = 0
		for _, e := range m.XCurrentRange {
			l += sovProtocolRtu(uint64(e))
		}
		n += 1 + sovProtocolRtu(uint64(l)) + l
	}
	if len(m.XSwitchOutVector) > 0 {
		l = 0
		for _, e := range m.XSwitchOutVector {
			l += sovProtocolRtu(uint64(e))
		}
		n += 1 + sovProtocolRtu(uint64(l)) + l
	}
	if len(m.XSwitchInVector) > 0 {
		l = 0
		for _, e := range m.XSwitchInVector {
			l += sovProtocolRtu(uint64(e))
		}
		n += 2 + sovProtocolRtu(uint64(l)) + l
	}
	if len(m.XAnalogVector) > 0 {
		l = 0
		for _, e := range m.XAnalogVector {
			l += sovProtocolRtu(uint64(e))
		}
		n += 2 + sovProtocolRtu(uint64(l)) + l
	}
	if m.UpperVoltageLimit != 0 {
		n += 2 + sovProtocolRtu(uint64(m.UpperVoltageLimit))
	}
	if m.LowerVoltageLimit != 0 {
		n += 2 + sovProtocolRtu(uint64(m.LowerVoltageLimit))
	}
	if len(m.XUpperCurrentLimit) > 0 {
		l = 0
		for _, e := range m.XUpperCurrentLimit {
			l += sovProtocolRtu(uint64(e))
		}
		n += 2 + sovProtocolRtu(uint64(l)) + l
	}
	if len(m.XLowerCurrentLimit) > 0 {
		l = 0
		for _, e := range m.XLowerCurrentLimit {
			l += sovProtocolRtu(uint64(e))
		}
		n += 2 + sovProtocolRtu(uint64(l)) + l
	}
	if m.GroupId != 0 {
		n += 2 + sovProtocolRtu(uint64(m.GroupId))
	}
	return n
}

func (m *WlstRtuDf00) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.XSwitchingTime) > 0 {
		for _, s := range m.XSwitchingTime {
			l = len(s)
			n += 1 + l + sovProtocolRtu(uint64(l))
		}
	}
	if len(m.XSwitchOutCount) > 0 {
		l = 0
		for _, e := range m.XSwitchOutCount {
			l += sovProtocolRtu(uint64(e))
		}
		n += 1 + sovProtocolRtu(uint64(l)) + l
	}
	if len(m.XSwitchOutVector) > 0 {
		l = 0
		for _, e := range m.XSwitchOutVector {
			l += sovProtocolRtu(uint64(e))
		}
		n += 1 + sovProtocolRtu(uint64(l)) + l
	}
	return n
}

func (m *WlstRtu_6100) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.XVoltagePhase) > 0 {
		l = 0
		for _, e := range m.XVoltagePhase {
			l += sovProtocolRtu(uint64(e))
		}
		n += 1 + sovProtocolRtu(uint64(l)) + l
	}
	return n
}

func (m *WlstRtuA000) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.XAnalogVoltage) > 0 {
		n += 1 + sovProtocolRtu(uint64(len(m.XAnalogVoltage)*8)) + len(m.XAnalogVoltage)*8
	}
	if len(m.XAnalogCurrent) > 0 {
		n += 1 + sovProtocolRtu(uint64(len(m.XAnalogCurrent)*8)) + len(m.XAnalogCurrent)*8
	}
	if len(m.XAnalogPower) > 0 {
		n += 1 + sovProtocolRtu(uint64(len(m.XAnalogPower)*8)) + len(m.XAnalogPower)*8
	}
	if m.SwitchInSt != 0 {
		n += 1 + sovProtocolRtu(uint64(m.SwitchInSt))
	}
	if m.SwitchOutSt != 0 {
		n += 1 + sovProtocolRtu(uint64(m.SwitchOutSt))
	}
	if m.TmlSt != 0 {
		n += 1 + sovProtocolRtu(uint64(m.TmlSt))
	}
	if len(m.XCurrentStatus) > 0 {
		l = 0
		for _, e := range m.XCurrentStatus {
			l += sovProtocolRtu(uint64(e))
		}
		n += 1 + sovProtocolRtu(uint64(l)) + l
	}
	if len(m.XVoltageStatus) > 0 {
		l = 0
		for _, e := range m.XVoltageStatus {
			l += sovProtocolRtu(uint64(e))
		}
		n += 1 + sovProtocolRtu(uint64(l)) + l
	}
	if m.FullRange != 0 {
		n += 1 + sovProtocolRtu(uint64(m.FullRange))
	}
	if m.Temperature != 0 {
		n += 1 + sovProtocolRtu(uint64(m.Temperature))
	}
	return n
}

func (m *WlstRtuA200) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.KNo != 0 {
		n += 1 + sovProtocolRtu(uint64(m.KNo))
	}
	if m.Operation != 0 {
		n += 1 + sovProtocolRtu(uint64(m.Operation))
	}
	return n
}

func (m *WlstRtu_4B00) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Operation) > 0 {
		l = 0
		for _, e := range m.Operation {
			l += sovProtocolRtu(uint64(e))
		}
		n += 1 + sovProtocolRtu(uint64(l)) + l
	}
	return n
}

func (m *WlstRtu_9300) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TmlDate)
	if l > 0 {
		n += 1 + l + sovProtocolRtu(uint64(l))
	}
	return n
}

func (m *WlstRtuB200) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.XK1OptTime) > 0 {
		for _, s := range m.XK1OptTime {
			l = len(s)
			n += 1 + l + sovProtocolRtu(uint64(l))
		}
	}
	if len(m.XK2OptTime) > 0 {
		for _, s := range m.XK2OptTime {
			l = len(s)
			n += 1 + l + sovProtocolRtu(uint64(l))
		}
	}
	if len(m.XK3OptTime) > 0 {
		for _, s := range m.XK3OptTime {
			l = len(s)
			n += 1 + l + sovProtocolRtu(uint64(l))
		}
	}
	if len(m.XCityPayTime) > 0 {
		for _, s := range m.XCityPayTime {
			l = len(s)
			n += 1 + l + sovProtocolRtu(uint64(l))
		}
	}
	if len(m.XSelfPayTime) > 0 {
		for _, s := range m.XSelfPayTime {
			l = len(s)
			n += 1 + l + sovProtocolRtu(uint64(l))
		}
	}
	if len(m.XK4OptTime) > 0 {
		for _, s := range m.XK4OptTime {
			l = len(s)
			n += 1 + l + sovProtocolRtu(uint64(l))
		}
	}
	if len(m.XK5OptTime) > 0 {
		for _, s := range m.XK5OptTime {
			l = len(s)
			n += 1 + l + sovProtocolRtu(uint64(l))
		}
	}
	if len(m.XK6OptTime) > 0 {
		for _, s := range m.XK6OptTime {
			l = len(s)
			n += 1 + l + sovProtocolRtu(uint64(l))
		}
	}
	if len(m.XK7OptTime) > 0 {
		for _, s := range m.XK7OptTime {
			l = len(s)
			n += 1 + l + sovProtocolRtu(uint64(l))
		}
	}
	if len(m.XK8OptTime) > 0 {
		for _, s := range m.XK8OptTime {
			l = len(s)
			n += 1 + l + sovProtocolRtu(uint64(l))
		}
	}
	return n
}

func (m *WlstRtuE600) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.XHolidays) > 0 {
		for _, s := range m.XHolidays {
			l = len(s)
			n += 1 + l + sovProtocolRtu(uint64(l))
		}
	}
	if len(m.XK1Time) > 0 {
		for _, s := range m.XK1Time {
			l = len(s)
			n += 1 + l + sovProtocolRtu(uint64(l))
		}
	}
	if len(m.XK2Time) > 0 {
		for _, s := range m.XK2Time {
			l = len(s)
			n += 1 + l + sovProtocolRtu(uint64(l))
		}
	}
	if len(m.XK3Time) > 0 {
		for _, s := range m.XK3Time {
			l = len(s)
			n += 1 + l + sovProtocolRtu(uint64(l))
		}
	}
	if len(m.XK4Time) > 0 {
		for _, s := range m.XK4Time {
			l = len(s)
			n += 1 + l + sovProtocolRtu(uint64(l))
		}
	}
	if len(m.XK5Time) > 0 {
		for _, s := range m.XK5Time {
			l = len(s)
			n += 1 + l + sovProtocolRtu(uint64(l))
		}
	}
	if len(m.XK6Time) > 0 {
		for _, s := range m.XK6Time {
			l = len(s)
			n += 1 + l + sovProtocolRtu(uint64(l))
		}
	}
	if len(m.XCityPayTime) > 0 {
		for _, s := range m.XCityPayTime {
			l = len(s)
			n += 1 + l + sovProtocolRtu(uint64(l))
		}
	}
	if len(m.XSelfPayTime) > 0 {
		for _, s := range m.XSelfPayTime {
			l = len(s)
			n += 1 + l + sovProtocolRtu(uint64(l))
		}
	}
	if len(m.XK7Time) > 0 {
		for _, s := range m.XK7Time {
			l = len(s)
			n += 1 + l + sovProtocolRtu(uint64(l))
		}
	}
	if len(m.XK8Time) > 0 {
		for _, s := range m.XK8Time {
			l = len(s)
			n += 1 + l + sovProtocolRtu(uint64(l))
		}
	}
	return n
}

func (m *WlstRtu_9800) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovProtocolRtu(uint64(m.Status))
	}
	return n
}

func (m *WlstRtuDc00) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Ver)
	if l > 0 {
		n += 1 + l + sovProtocolRtu(uint64(l))
	}
	return n
}

func sovProtocolRtu(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozProtocolRtu(x uint64) (n int) {
	return sovProtocolRtu(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *WlstRtuAns) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_rtu_ans: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_rtu_ans: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DataMark = append(m.DataMark, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DataMark) == 0 {
					m.DataMark = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DataMark = append(m.DataMark, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DataMark", wireType)
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DataPoint = append(m.DataPoint, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DataPoint) == 0 {
					m.DataPoint = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DataPoint = append(m.DataPoint, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DataPoint", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Status = append(m.Status, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Status) == 0 {
					m.Status = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Status = append(m.Status, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusCode", wireType)
			}
			m.StatusCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtu_7094) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_rtu_7094: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_rtu_7094: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlarmType", wireType)
			}
			m.AlarmType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlarmType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alarmln", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Alarmln == nil {
				m.Alarmln = &WlstRtu_7094_Alarm_LN{}
			}
			if err := m.Alarmln.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SwitchOutStPacked = append(m.SwitchOutStPacked, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SwitchOutStPacked) == 0 {
					m.SwitchOutStPacked = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SwitchOutStPacked = append(m.SwitchOutStPacked, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchOutStPacked", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtu_7094_Alarm_LN) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Alarm_LN: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Alarm_LN: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoopNo", wireType)
			}
			m.LoopNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoopNo |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlarmStatus", wireType)
			}
			m.AlarmStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlarmStatus |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlarmCurrent", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.AlarmCurrent = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtu_7021) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_rtu_7021: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_rtu_7021: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataType", wireType)
			}
			m.DataType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Argsln", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Argsln = append(m.Argsln, &WlstRtu_7021_Args_LN{})
			if err := m.Argsln[len(m.Argsln)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusCode", wireType)
			}
			m.StatusCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoopType", wireType)
			}
			m.LoopType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoopType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Argswc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Argswc = append(m.Argswc, &WlstRtu_7021_Args_WC{})
			if err := m.Argswc[len(m.Argswc)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtu_7021_Args_LN) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Args_LN: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Args_LN: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoopNo", wireType)
			}
			m.LoopNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoopNo |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseValue", wireType)
			}
			m.BaseValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseValue |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlarmValue", wireType)
			}
			m.AlarmValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlarmValue |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BreakValue", wireType)
			}
			m.BreakValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BreakValue |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtu_7021_Args_WC) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Args_WC: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Args_WC: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L1On", wireType)
			}
			m.L1On = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L1On |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L1Off", wireType)
			}
			m.L1Off = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L1Off |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L2On", wireType)
			}
			m.L2On = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L2On |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L2Off", wireType)
			}
			m.L2Off = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L2Off |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L3On", wireType)
			}
			m.L3On = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L3On |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L3Off", wireType)
			}
			m.L3Off = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L3Off |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L4On", wireType)
			}
			m.L4On = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L4On |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L4Off", wireType)
			}
			m.L4Off = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L4Off |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L5On", wireType)
			}
			m.L5On = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L5On |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L5Off", wireType)
			}
			m.L5Off = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L5Off |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L6On", wireType)
			}
			m.L6On = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L6On |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L6Off", wireType)
			}
			m.L6Off = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L6Off |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L7On", wireType)
			}
			m.L7On = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L7On |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L7Off", wireType)
			}
			m.L7Off = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L7Off |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L8On", wireType)
			}
			m.L8On = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L8On |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L8Off", wireType)
			}
			m.L8Off = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L8Off |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtu_7023) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_rtu_7023: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_rtu_7023: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataType", wireType)
			}
			m.DataType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Argscontrol", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Argscontrol = append(m.Argscontrol, &WlstRtu_7023_Args_Control{})
			if err := m.Argscontrol[len(m.Argscontrol)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusCode", wireType)
			}
			m.StatusCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtu_7023_Args_Control) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Args_Control: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Args_Control: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoopNo", wireType)
			}
			m.LoopNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoopNo |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			m.Operation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Operation |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtu_705B) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_rtu_705b: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_rtu_705b: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdType", wireType)
			}
			m.CmdType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HardwareVer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HardwareVer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductionBatch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductionBatch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductionDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductionDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstallationDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstallationDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtu_70A0) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_rtu_70a0: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_rtu_70a0: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdType", wireType)
			}
			m.CmdType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Frequency", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Frequency = float32(math.Float32frombits(v))
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ee = append(m.Ee, &WlstRtu_70A0_ElectricEnergy{})
			if err := m.Ee[len(m.Ee)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Temperature", wireType)
			}
			m.Temperature = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Temperature |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Humidity", wireType)
			}
			m.Humidity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Humidity |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MainVoltage", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MainVoltage = float64(math.Float64frombits(v))
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatteryPower", wireType)
			}
			m.BatteryPower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatteryPower |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longitude", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Longitude = float64(math.Float64frombits(v))
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latitude", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Latitude = float64(math.Float64frombits(v))
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gpsargs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gpsargs == nil {
				m.Gpsargs = &WlstRtu_70A0_GpsArgs{}
			}
			if err := m.Gpsargs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SwitchInStPacked = append(m.SwitchInStPacked, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SwitchInStPacked) == 0 {
					m.SwitchInStPacked = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SwitchInStPacked = append(m.SwitchInStPacked, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchInStPacked", wireType)
			}
		case 13:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SwitchOutStPacked = append(m.SwitchOutStPacked, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SwitchOutStPacked) == 0 {
					m.SwitchOutStPacked = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SwitchOutStPacked = append(m.SwitchOutStPacked, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchOutStPacked", wireType)
			}
		case 14:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TmlStPacked = append(m.TmlStPacked, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.TmlStPacked) == 0 {
					m.TmlStPacked = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TmlStPacked = append(m.TmlStPacked, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TmlStPacked", wireType)
			}
		case 15:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TmlReset = append(m.TmlReset, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.TmlReset) == 0 {
					m.TmlReset = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TmlReset = append(m.TmlReset, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TmlReset", wireType)
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoopCount", wireType)
			}
			m.LoopCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoopCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtu_70A0_ElectricEnergy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Electric_energy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Electric_energy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voltage", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Voltage = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Current", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Current = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PowerFactor", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PowerFactor = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivePower", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ActivePower = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReactivePower", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ReactivePower = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveEnergy", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ActiveEnergy = float32(math.Float32frombits(v))
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReactiveEnergy", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ReactiveEnergy = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtu_70A0_GpsArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Gps_args: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Gps_args: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpsType", wireType)
			}
			m.GpsType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GpsType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatType", wireType)
			}
			m.LatType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LatType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LonType", wireType)
			}
			m.LonType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LonType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocationStatus", wireType)
			}
			m.LocationStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocationStatus |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtu_7053) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_rtu_7053: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_rtu_7053: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordType", wireType)
			}
			m.RecordType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecordType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DtStart", wireType)
			}
			m.DtStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DtStart |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordCount", wireType)
			}
			m.RecordCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecordCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordDistance", wireType)
			}
			m.RecordDistance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecordDistance |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtu_70D3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_rtu_70d3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_rtu_70d3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordTotal", wireType)
			}
			m.RecordTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecordTotal |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordIdx", wireType)
			}
			m.RecordIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecordIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordStatus", wireType)
			}
			m.RecordStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecordStatus |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordType", wireType)
			}
			m.RecordType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecordType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DtStart", wireType)
			}
			m.DtStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DtStart |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordCount", wireType)
			}
			m.RecordCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecordCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordDistance", wireType)
			}
			m.RecordDistance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecordDistance |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data_70D0", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data_70D0 = append(m.Data_70D0, &WlstRtu_70D0{})
			if err := m.Data_70D0[len(m.Data_70D0)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data_70D0Max", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data_70D0Max = append(m.Data_70D0Max, &WlstRtu_70D0Max{})
			if err := m.Data_70D0Max[len(m.Data_70D0Max)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtu_70D0Max) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_rtu_70d0_max: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_rtu_70d0_max: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DtRecord", wireType)
			}
			m.DtRecord = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DtRecord |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordType", wireType)
			}
			m.RecordType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecordType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoopCount", wireType)
			}
			m.LoopCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoopCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaxData = append(m.MaxData, &WlstRtu_70D0Max_MaxData{})
			if err := m.MaxData[len(m.MaxData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtu_70D0Max_MaxData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Max_data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Max_data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentMax", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CurrentMax = float64(math.Float64frombits(v))
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DtRecord", wireType)
			}
			m.DtRecord = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DtRecord |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtu_7800) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_rtu_7800: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_rtu_7800: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventClass", wireType)
			}
			m.EventClass = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventClass |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataNum", wireType)
			}
			m.DataNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DtStart", wireType)
			}
			m.DtStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DtStart |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DtEnd", wireType)
			}
			m.DtEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DtEnd |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllNum", wireType)
			}
			m.AllNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AllNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurNum", wireType)
			}
			m.CurNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtu_7050) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_rtu_7050: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_rtu_7050: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataMark", wireType)
			}
			m.DataMark = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataMark |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtu_70D0) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_rtu_70d0: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_rtu_70d0: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataMark", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DataMark == nil {
				m.DataMark = &WlstRtu_70D0_DataMark{}
			}
			if err := m.DataMark.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SwitchInStPacked = append(m.SwitchInStPacked, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SwitchInStPacked) == 0 {
					m.SwitchInStPacked = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SwitchInStPacked = append(m.SwitchInStPacked, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchInStPacked", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SwitchOutStPacked = append(m.SwitchOutStPacked, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SwitchOutStPacked) == 0 {
					m.SwitchOutStPacked = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SwitchOutStPacked = append(m.SwitchOutStPacked, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchOutStPacked", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TmlStPacked = append(m.TmlStPacked, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.TmlStPacked) == 0 {
					m.TmlStPacked = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TmlStPacked = append(m.TmlStPacked, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TmlStPacked", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Temperature", wireType)
			}
			m.Temperature = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Temperature |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GprsReset", wireType)
			}
			m.GprsReset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GprsReset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GprsSignal", wireType)
			}
			m.GprsSignal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GprsSignal |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TmlReset = append(m.TmlReset, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.TmlReset) == 0 {
					m.TmlReset = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TmlReset = append(m.TmlReset, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TmlReset", wireType)
			}
		case 10:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TmlArgsStatus = append(m.TmlArgsStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.TmlArgsStatus) == 0 {
					m.TmlArgsStatus = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TmlArgsStatus = append(m.TmlArgsStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TmlArgsStatus", wireType)
			}
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PowerSupply", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PowerSupply = float64(math.Float64frombits(v))
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SamplingVoltage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SamplingVoltage = append(m.SamplingVoltage, &WlstRtu_70D0_SamplingVoltage{})
			if err := m.SamplingVoltage[len(m.SamplingVoltage)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnalogData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AnalogData = append(m.AnalogData, &WlstRtu_70D0_AnalogData{})
			if err := m.AnalogData[len(m.AnalogData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchInSt", wireType)
			}
			m.SwitchInSt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SwitchInSt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchOutSt", wireType)
			}
			m.SwitchOutSt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SwitchOutSt |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TmlSt", wireType)
			}
			m.TmlSt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TmlSt |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullRange", wireType)
			}
			m.FullRange = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FullRange |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DtRecord", wireType)
			}
			m.DtRecord = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DtRecord |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SwitchOutReason = append(m.SwitchOutReason, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SwitchOutReason) == 0 {
					m.SwitchOutReason = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SwitchOutReason = append(m.SwitchOutReason, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchOutReason", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtu_70D0_DataMark) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Data_mark: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Data_mark: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetRunData", wireType)
			}
			m.GetRunData = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GetRunData |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetSwitchoutReason", wireType)
			}
			m.GetSwitchoutReason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GetSwitchoutReason |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtu_70D0_SamplingVoltage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sampling_voltage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sampling_voltage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolA", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.VolA = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolB", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.VolB = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolC", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.VolC = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtu_70D0_AnalogData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Analog_data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Analog_data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voltage", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Voltage = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Current", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Current = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Power", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Power = float64(math.Float64frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoltageStatus", wireType)
			}
			m.VoltageStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VoltageStatus |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentStatus", wireType)
			}
			m.CurrentStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentStatus |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtu_705A) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_rtu_705a: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_rtu_705a: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdType", wireType)
			}
			m.CmdType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtu_70Da) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_rtu_70da: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_rtu_70da: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeepAlive", wireType)
			}
			m.KeepAlive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeepAlive |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlarmCycle", wireType)
			}
			m.AlarmCycle = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlarmCycle |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlarmDelay", wireType)
			}
			m.AlarmDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlarmDelay |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchOutSum", wireType)
			}
			m.SwitchOutSum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SwitchOutSum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchInSum", wireType)
			}
			m.SwitchInSum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SwitchInSum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnalogSum", wireType)
			}
			m.AnalogSum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnalogSum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field XSwitchingTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.XSwitchingTime = append(m.XSwitchingTime, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CityPayTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CityPayTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfPayTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SelfPayTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.XSwitchOutCount = append(m.XSwitchOutCount, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.XSwitchOutCount) == 0 {
					m.XSwitchOutCount = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.XSwitchOutCount = append(m.XSwitchOutCount, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field XSwitchOutCount", wireType)
			}
		case 12:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SwitchInHopping = append(m.SwitchInHopping, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SwitchInHopping) == 0 {
					m.SwitchInHopping = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SwitchInHopping = append(m.SwitchInHopping, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchInHopping", wireType)
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoltageRange", wireType)
			}
			m.VoltageRange = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VoltageRange |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.XCurrentRange = append(m.XCurrentRange, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.XCurrentRange) == 0 {
					m.XCurrentRange = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.XCurrentRange = append(m.XCurrentRange, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field XCurrentRange", wireType)
			}
		case 15:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.XSwitchOutVector = append(m.XSwitchOutVector, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.XSwitchOutVector) == 0 {
					m.XSwitchOutVector = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.XSwitchOutVector = append(m.XSwitchOutVector, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field XSwitchOutVector", wireType)
			}
		case 16:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.XSwitchInVector = append(m.XSwitchInVector, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.XSwitchInVector) == 0 {
					m.XSwitchInVector = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.XSwitchInVector = append(m.XSwitchInVector, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field XSwitchInVector", wireType)
			}
		case 17:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.XAnalogVector = append(m.XAnalogVector, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.XAnalogVector) == 0 {
					m.XAnalogVector = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.XAnalogVector = append(m.XAnalogVector, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field XAnalogVector", wireType)
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpperVoltageLimit", wireType)
			}
			m.UpperVoltageLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpperVoltageLimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowerVoltageLimit", wireType)
			}
			m.LowerVoltageLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LowerVoltageLimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.XUpperCurrentLimit = append(m.XUpperCurrentLimit, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.XUpperCurrentLimit) == 0 {
					m.XUpperCurrentLimit = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.XUpperCurrentLimit = append(m.XUpperCurrentLimit, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field XUpperCurrentLimit", wireType)
			}
		case 21:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.XLowerCurrentLimit = append(m.XLowerCurrentLimit, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.XLowerCurrentLimit) == 0 {
					m.XLowerCurrentLimit = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.XLowerCurrentLimit = append(m.XLowerCurrentLimit, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field XLowerCurrentLimit", wireType)
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdType", wireType)
			}
			m.CmdType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Transformers = append(m.Transformers, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Transformers) == 0 {
					m.Transformers = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Transformers = append(m.Transformers, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Transformers", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtu_700A) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_rtu_700a: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_rtu_700a: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ComArgv = append(m.ComArgv, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ComArgv) == 0 {
					m.ComArgv = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ComArgv = append(m.ComArgv, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ComArgv", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtu_7010) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_rtu_7010: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_rtu_7010: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataMark", wireType)
			}
			m.DataMark = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataMark |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtu_7003) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_rtu_7003: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_rtu_7003: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.FtpData = append(m.FtpData, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.FtpData) == 0 {
					m.FtpData = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.FtpData = append(m.FtpData, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field FtpData", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtu_7006) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_rtu_7006: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_rtu_7006: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllCount", wireType)
			}
			m.AllCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AllCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtu_7007) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_rtu_7007: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_rtu_7007: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtu_7087) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_rtu_7087: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_rtu_7087: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.FailedPackages = append(m.FailedPackages, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.FailedPackages) == 0 {
					m.FailedPackages = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.FailedPackages = append(m.FailedPackages, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field FailedPackages", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesCount", wireType)
			}
			m.BytesCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtu_7081) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_rtu_7081: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_rtu_7081: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldVer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OldVer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewVer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewVer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataLocation", wireType)
			}
			m.DataLocation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataLocation |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtu_7008) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_rtu_7008: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_rtu_7008: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdData = append(m.UpdData, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clean", wireType)
			}
			m.Clean = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Clean |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IntUpdData = append(m.IntUpdData, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.IntUpdData) == 0 {
					m.IntUpdData = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IntUpdData = append(m.IntUpdData, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IntUpdData", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtu_7060) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_rtu_7060: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_rtu_7060: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DtStart", wireType)
			}
			m.DtStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DtStart |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Days", wireType)
			}
			m.Days = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Days |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field YearCtrl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.YearCtrl = append(m.YearCtrl, &WlstRtu_7060_YearCtrl{})
			if err := m.YearCtrl[len(m.YearCtrl)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtu_7060_YearCtrl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: YearCtrl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: YearCtrl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoopNo", wireType)
			}
			m.LoopNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoopNo |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeCount", wireType)
			}
			m.TimeCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OptTime = append(m.OptTime, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OptTime) == 0 {
					m.OptTime = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OptTime = append(m.OptTime, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OptTime", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtu_7061) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_rtu_7061: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_rtu_7061: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DtStart", wireType)
			}
			m.DtStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DtStart |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Days", wireType)
			}
			m.Days = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Days |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.LoopNo = append(m.LoopNo, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.LoopNo) == 0 {
					m.LoopNo = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.LoopNo = append(m.LoopNo, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field LoopNo", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtu_70E0) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_rtu_70e0: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_rtu_70e0: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtu_7B00) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_rtu_7b00: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_rtu_7b00: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sim", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sim = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signal", wireType)
			}
			m.Signal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Signal |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtu_1900) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_rtu_1900: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_rtu_1900: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			m.Addr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Addr |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TmlIp", wireType)
			}
			m.TmlIp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TmlIp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtu_4000) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_rtu_4000: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_rtu_4000: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkMark", wireType)
			}
			m.WorkMark = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkMark |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeepAlive", wireType)
			}
			m.KeepAlive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeepAlive |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlarmCycle", wireType)
			}
			m.AlarmCycle = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlarmCycle |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlarmDelay", wireType)
			}
			m.AlarmDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlarmDelay |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.XLoopCount = append(m.XLoopCount, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.XLoopCount) == 0 {
					m.XLoopCount = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.XLoopCount = append(m.XLoopCount, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field XLoopCount", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtu_4101) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_rtu_4101: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_rtu_4101: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnalogSum", wireType)
			}
			m.AnalogSum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnalogSum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoltageRange", wireType)
			}
			m.VoltageRange = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VoltageRange |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.XCurrentRange = append(m.XCurrentRange, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.XCurrentRange) == 0 {
					m.XCurrentRange = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.XCurrentRange = append(m.XCurrentRange, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field XCurrentRange", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtu_4104) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_rtu_4104: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_rtu_4104: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchinSum", wireType)
			}
			m.SwitchinSum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SwitchinSum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.XSwitchVector = append(m.XSwitchVector, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.XSwitchVector) == 0 {
					m.XSwitchVector = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.XSwitchVector = append(m.XSwitchVector, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field XSwitchVector", wireType)
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.XSwitchHopping = append(m.XSwitchHopping, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.XSwitchHopping) == 0 {
					m.XSwitchHopping = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.XSwitchHopping = append(m.XSwitchHopping, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field XSwitchHopping", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtu_4110) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_rtu_4110: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_rtu_4110: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchInSum", wireType)
			}
			m.SwitchInSum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SwitchInSum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtu_4111) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_rtu_4111: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_rtu_4111: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Transformers = append(m.Transformers, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Transformers) == 0 {
					m.Transformers = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Transformers = append(m.Transformers, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Transformers", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtu_4200) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_rtu_4200: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_rtu_4200: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.XAnalogVector = append(m.XAnalogVector, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.XAnalogVector) == 0 {
					m.XAnalogVector = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.XAnalogVector = append(m.XAnalogVector, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field XAnalogVector", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.XSwitchInVector = append(m.XSwitchInVector, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.XSwitchInVector) == 0 {
					m.XSwitchInVector = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.XSwitchInVector = append(m.XSwitchInVector, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field XSwitchInVector", wireType)
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.XSwitchOutVector = append(m.XSwitchOutVector, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.XSwitchOutVector) == 0 {
					m.XSwitchOutVector = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.XSwitchOutVector = append(m.XSwitchOutVector, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field XSwitchOutVector", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnalogSum", wireType)
			}
			m.AnalogSum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnalogSum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchInSum", wireType)
			}
			m.SwitchInSum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SwitchInSum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchOutSum", wireType)
			}
			m.SwitchOutSum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SwitchOutSum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtu_4401) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_rtu_4401: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_rtu_4401: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnalogSum", wireType)
			}
			m.AnalogSum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnalogSum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpperVoltageLimit", wireType)
			}
			m.UpperVoltageLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpperVoltageLimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowerVoltageLimit", wireType)
			}
			m.LowerVoltageLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LowerVoltageLimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.XUpperCurrentLimit = append(m.XUpperCurrentLimit, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.XUpperCurrentLimit) == 0 {
					m.XUpperCurrentLimit = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.XUpperCurrentLimit = append(m.XUpperCurrentLimit, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field XUpperCurrentLimit", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.XLowerCurrentLimit = append(m.XLowerCurrentLimit, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.XLowerCurrentLimit) == 0 {
					m.XLowerCurrentLimit = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.XLowerCurrentLimit = append(m.XLowerCurrentLimit, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field XLowerCurrentLimit", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoltageRange", wireType)
			}
			m.VoltageRange = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VoltageRange |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.XCurrentRange = append(m.XCurrentRange, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.XCurrentRange) == 0 {
					m.XCurrentRange = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.XCurrentRange = append(m.XCurrentRange, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field XCurrentRange", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtuDa00) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_rtu_da00: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_rtu_da00: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeepAlive", wireType)
			}
			m.KeepAlive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeepAlive |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlarmCycle", wireType)
			}
			m.AlarmCycle = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlarmCycle |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlarmDelay", wireType)
			}
			m.AlarmDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlarmDelay |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			m.Addr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Addr |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchOutSum", wireType)
			}
			m.SwitchOutSum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SwitchOutSum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchInSum", wireType)
			}
			m.SwitchInSum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SwitchInSum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnalogSum", wireType)
			}
			m.AnalogSum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnalogSum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field XSwitchingTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.XSwitchingTime = append(m.XSwitchingTime, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CityPayTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CityPayTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfPayTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SelfPayTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.XSwitchOutCount = append(m.XSwitchOutCount, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.XSwitchOutCount) == 0 {
					m.XSwitchOutCount = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.XSwitchOutCount = append(m.XSwitchOutCount, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field XSwitchOutCount", wireType)
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchInHopping", wireType)
			}
			m.SwitchInHopping = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SwitchInHopping |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoltageRange", wireType)
			}
			m.VoltageRange = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VoltageRange |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.XCurrentRange = append(m.XCurrentRange, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.XCurrentRange) == 0 {
					m.XCurrentRange = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.XCurrentRange = append(m.XCurrentRange, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field XCurrentRange", wireType)
			}
		case 15:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.XSwitchOutVector = append(m.XSwitchOutVector, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.XSwitchOutVector) == 0 {
					m.XSwitchOutVector = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.XSwitchOutVector = append(m.XSwitchOutVector, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field XSwitchOutVector", wireType)
			}
		case 16:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.XSwitchInVector = append(m.XSwitchInVector, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.XSwitchInVector) == 0 {
					m.XSwitchInVector = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.XSwitchInVector = append(m.XSwitchInVector, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field XSwitchInVector", wireType)
			}
		case 17:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.XAnalogVector = append(m.XAnalogVector, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.XAnalogVector) == 0 {
					m.XAnalogVector = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.XAnalogVector = append(m.XAnalogVector, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field XAnalogVector", wireType)
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpperVoltageLimit", wireType)
			}
			m.UpperVoltageLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpperVoltageLimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowerVoltageLimit", wireType)
			}
			m.LowerVoltageLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LowerVoltageLimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.XUpperCurrentLimit = append(m.XUpperCurrentLimit, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.XUpperCurrentLimit) == 0 {
					m.XUpperCurrentLimit = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.XUpperCurrentLimit = append(m.XUpperCurrentLimit, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field XUpperCurrentLimit", wireType)
			}
		case 21:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.XLowerCurrentLimit = append(m.XLowerCurrentLimit, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.XLowerCurrentLimit) == 0 {
					m.XLowerCurrentLimit = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.XLowerCurrentLimit = append(m.XLowerCurrentLimit, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field XLowerCurrentLimit", wireType)
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtuDf00) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_rtu_df00: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_rtu_df00: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field XSwitchingTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.XSwitchingTime = append(m.XSwitchingTime, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.XSwitchOutCount = append(m.XSwitchOutCount, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.XSwitchOutCount) == 0 {
					m.XSwitchOutCount = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.XSwitchOutCount = append(m.XSwitchOutCount, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field XSwitchOutCount", wireType)
			}
		case 15:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.XSwitchOutVector = append(m.XSwitchOutVector, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.XSwitchOutVector) == 0 {
					m.XSwitchOutVector = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.XSwitchOutVector = append(m.XSwitchOutVector, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field XSwitchOutVector", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtu_6100) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_rtu_6100: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_rtu_6100: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.XVoltagePhase = append(m.XVoltagePhase, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.XVoltagePhase) == 0 {
					m.XVoltagePhase = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.XVoltagePhase = append(m.XVoltagePhase, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field XVoltagePhase", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtuA000) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_rtu_a000: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_rtu_a000: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.XAnalogVoltage = append(m.XAnalogVoltage, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.XAnalogVoltage) == 0 {
					m.XAnalogVoltage = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.XAnalogVoltage = append(m.XAnalogVoltage, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field XAnalogVoltage", wireType)
			}
		case 2:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.XAnalogCurrent = append(m.XAnalogCurrent, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.XAnalogCurrent) == 0 {
					m.XAnalogCurrent = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.XAnalogCurrent = append(m.XAnalogCurrent, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field XAnalogCurrent", wireType)
			}
		case 3:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.XAnalogPower = append(m.XAnalogPower, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.XAnalogPower) == 0 {
					m.XAnalogPower = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.XAnalogPower = append(m.XAnalogPower, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field XAnalogPower", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchInSt", wireType)
			}
			m.SwitchInSt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SwitchInSt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchOutSt", wireType)
			}
			m.SwitchOutSt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SwitchOutSt |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TmlSt", wireType)
			}
			m.TmlSt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TmlSt |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.XCurrentStatus = append(m.XCurrentStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.XCurrentStatus) == 0 {
					m.XCurrentStatus = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.XCurrentStatus = append(m.XCurrentStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field XCurrentStatus", wireType)
			}
		case 8:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.XVoltageStatus = append(m.XVoltageStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.XVoltageStatus) == 0 {
					m.XVoltageStatus = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.XVoltageStatus = append(m.XVoltageStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field XVoltageStatus", wireType)
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullRange", wireType)
			}
			m.FullRange = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FullRange |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Temperature", wireType)
			}
			m.Temperature = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Temperature |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtuA200) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_rtu_a200: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_rtu_a200: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KNo", wireType)
			}
			m.KNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KNo |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			m.Operation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Operation |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtu_4B00) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_rtu_4b00: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_rtu_4b00: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Operation = append(m.Operation, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolRtu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolRtu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Operation) == 0 {
					m.Operation = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolRtu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Operation = append(m.Operation, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtu_9300) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_rtu_9300: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_rtu_9300: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TmlDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TmlDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtuB200) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_rtu_b200: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_rtu_b200: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field XK1OptTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.XK1OptTime = append(m.XK1OptTime, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field XK2OptTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.XK2OptTime = append(m.XK2OptTime, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field XK3OptTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.XK3OptTime = append(m.XK3OptTime, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field XCityPayTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.XCityPayTime = append(m.XCityPayTime, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field XSelfPayTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.XSelfPayTime = append(m.XSelfPayTime, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field XK4OptTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.XK4OptTime = append(m.XK4OptTime, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field XK5OptTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.XK5OptTime = append(m.XK5OptTime, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field XK6OptTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.XK6OptTime = append(m.XK6OptTime, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field XK7OptTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.XK7OptTime = append(m.XK7OptTime, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field XK8OptTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.XK8OptTime = append(m.XK8OptTime, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtuE600) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_rtu_e600: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_rtu_e600: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field XHolidays", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.XHolidays = append(m.XHolidays, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field XK1Time", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.XK1Time = append(m.XK1Time, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field XK2Time", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.XK2Time = append(m.XK2Time, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field XK3Time", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.XK3Time = append(m.XK3Time, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field XK4Time", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.XK4Time = append(m.XK4Time, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field XK5Time", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.XK5Time = append(m.XK5Time, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field XK6Time", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.XK6Time = append(m.XK6Time, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field XCityPayTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.XCityPayTime = append(m.XCityPayTime, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field XSelfPayTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.XSelfPayTime = append(m.XSelfPayTime, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field XK7Time", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.XK7Time = append(m.XK7Time, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field XK8Time", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.XK8Time = append(m.XK8Time, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtu_9800) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_rtu_9800: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_rtu_9800: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstRtuDc00) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_rtu_dc00: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_rtu_dc00: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolRtu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolRtu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipProtocolRtu(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProtocolRtu
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProtocolRtu
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthProtocolRtu
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupProtocolRtu
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthProtocolRtu
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthProtocolRtu        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProtocolRtu          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupProtocolRtu = fmt.Errorf("proto: unexpected end of group")
)
