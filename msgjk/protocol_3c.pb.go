// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: protocol_3c.proto

package wlst_pb2

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// 3c协议模块基本修改
type WlstCom_0000 struct {
	ServerIp   string `protobuf:"bytes,1,opt,name=server_ip,json=serverIp,proto3" json:"server_ip,omitempty"`
	ServerPort string `protobuf:"bytes,2,opt,name=server_port,json=serverPort,proto3" json:"server_port,omitempty"`
	Apn        string `protobuf:"bytes,3,opt,name=apn,proto3" json:"apn,omitempty"`
	KeepAlive  string `protobuf:"bytes,4,opt,name=keep_alive,json=keepAlive,proto3" json:"keep_alive,omitempty"`
	//通讯类型1-tcp，0-udp
	Type         string `protobuf:"bytes,5,opt,name=type,proto3" json:"type,omitempty"`
	Sim          string `protobuf:"bytes,6,opt,name=sim,proto3" json:"sim,omitempty"`
	CdmaUsername string `protobuf:"bytes,7,opt,name=cdma_username,json=cdmaUsername,proto3" json:"cdma_username,omitempty"`
	CdmaPassword string `protobuf:"bytes,8,opt,name=cdma_password,json=cdmaPassword,proto3" json:"cdma_password,omitempty"`
}

func (m *WlstCom_0000) Reset()         { *m = WlstCom_0000{} }
func (m *WlstCom_0000) String() string { return proto.CompactTextString(m) }
func (*WlstCom_0000) ProtoMessage()    {}
func (*WlstCom_0000) Descriptor() ([]byte, []int) {
	return fileDescriptor_800322016269ce4e, []int{0}
}
func (m *WlstCom_0000) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstCom_0000) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstCom_0000.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstCom_0000) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstCom_0000.Merge(m, src)
}
func (m *WlstCom_0000) XXX_Size() int {
	return m.Size()
}
func (m *WlstCom_0000) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstCom_0000.DiscardUnknown(m)
}

var xxx_messageInfo_WlstCom_0000 proto.InternalMessageInfo

func (m *WlstCom_0000) GetServerIp() string {
	if m != nil {
		return m.ServerIp
	}
	return ""
}

func (m *WlstCom_0000) GetServerPort() string {
	if m != nil {
		return m.ServerPort
	}
	return ""
}

func (m *WlstCom_0000) GetApn() string {
	if m != nil {
		return m.Apn
	}
	return ""
}

func (m *WlstCom_0000) GetKeepAlive() string {
	if m != nil {
		return m.KeepAlive
	}
	return ""
}

func (m *WlstCom_0000) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *WlstCom_0000) GetSim() string {
	if m != nil {
		return m.Sim
	}
	return ""
}

func (m *WlstCom_0000) GetCdmaUsername() string {
	if m != nil {
		return m.CdmaUsername
	}
	return ""
}

func (m *WlstCom_0000) GetCdmaPassword() string {
	if m != nil {
		return m.CdmaPassword
	}
	return ""
}

type WlstCom_3E01 struct {
	// 11位地址，默认”00000000000“
	Addr string `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
	//组号
	GroupMark int32 `protobuf:"varint,2,opt,name=group_mark,json=groupMark,proto3" json:"group_mark,omitempty"`
	//位号，依据组号排序
	ArgsMark []int32 `protobuf:"varint,3,rep,packed,name=args_mark,json=argsMark,proto3" json:"args_mark,omitempty"`
}

func (m *WlstCom_3E01) Reset()         { *m = WlstCom_3E01{} }
func (m *WlstCom_3E01) String() string { return proto.CompactTextString(m) }
func (*WlstCom_3E01) ProtoMessage()    {}
func (*WlstCom_3E01) Descriptor() ([]byte, []int) {
	return fileDescriptor_800322016269ce4e, []int{1}
}
func (m *WlstCom_3E01) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstCom_3E01) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstCom_3E01.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstCom_3E01) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstCom_3E01.Merge(m, src)
}
func (m *WlstCom_3E01) XXX_Size() int {
	return m.Size()
}
func (m *WlstCom_3E01) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstCom_3E01.DiscardUnknown(m)
}

var xxx_messageInfo_WlstCom_3E01 proto.InternalMessageInfo

func (m *WlstCom_3E01) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *WlstCom_3E01) GetGroupMark() int32 {
	if m != nil {
		return m.GroupMark
	}
	return 0
}

func (m *WlstCom_3E01) GetArgsMark() []int32 {
	if m != nil {
		return m.ArgsMark
	}
	return nil
}

type WlstCom_3E02 struct {
	// 11位地址，默认”00000000000“
	Addr string `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
	//组号
	GroupMark int32 `protobuf:"varint,2,opt,name=group_mark,json=groupMark,proto3" json:"group_mark,omitempty"`
	//位号，依据组号排序
	ArgsMark  []int32               `protobuf:"varint,3,rep,packed,name=args_mark,json=argsMark,proto3" json:"args_mark,omitempty"`
	Operators *WlstCom_3E02_Group01 `protobuf:"bytes,4,opt,name=operators,proto3" json:"operators,omitempty"`
	Channel   *WlstCom_3E02_Group02 `protobuf:"bytes,5,opt,name=channel,proto3" json:"channel,omitempty"`
	Interface *WlstCom_3E02_Group03 `protobuf:"bytes,6,opt,name=interface,proto3" json:"interface,omitempty"`
	Sms       *WlstCom_3E02_Group04 `protobuf:"bytes,7,opt,name=sms,proto3" json:"sms,omitempty"`
	Address   *WlstCom_3E02_Group05 `protobuf:"bytes,8,opt,name=address,proto3" json:"address,omitempty"`
	Status    *WlstCom_3E02_Group06 `protobuf:"bytes,9,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *WlstCom_3E02) Reset()         { *m = WlstCom_3E02{} }
func (m *WlstCom_3E02) String() string { return proto.CompactTextString(m) }
func (*WlstCom_3E02) ProtoMessage()    {}
func (*WlstCom_3E02) Descriptor() ([]byte, []int) {
	return fileDescriptor_800322016269ce4e, []int{2}
}
func (m *WlstCom_3E02) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstCom_3E02) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstCom_3E02.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstCom_3E02) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstCom_3E02.Merge(m, src)
}
func (m *WlstCom_3E02) XXX_Size() int {
	return m.Size()
}
func (m *WlstCom_3E02) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstCom_3E02.DiscardUnknown(m)
}

var xxx_messageInfo_WlstCom_3E02 proto.InternalMessageInfo

func (m *WlstCom_3E02) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *WlstCom_3E02) GetGroupMark() int32 {
	if m != nil {
		return m.GroupMark
	}
	return 0
}

func (m *WlstCom_3E02) GetArgsMark() []int32 {
	if m != nil {
		return m.ArgsMark
	}
	return nil
}

func (m *WlstCom_3E02) GetOperators() *WlstCom_3E02_Group01 {
	if m != nil {
		return m.Operators
	}
	return nil
}

func (m *WlstCom_3E02) GetChannel() *WlstCom_3E02_Group02 {
	if m != nil {
		return m.Channel
	}
	return nil
}

func (m *WlstCom_3E02) GetInterface() *WlstCom_3E02_Group03 {
	if m != nil {
		return m.Interface
	}
	return nil
}

func (m *WlstCom_3E02) GetSms() *WlstCom_3E02_Group04 {
	if m != nil {
		return m.Sms
	}
	return nil
}

func (m *WlstCom_3E02) GetAddress() *WlstCom_3E02_Group05 {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *WlstCom_3E02) GetStatus() *WlstCom_3E02_Group06 {
	if m != nil {
		return m.Status
	}
	return nil
}

type WlstCom_3E02_Group01 struct {
	Apn  string `protobuf:"bytes,1,opt,name=apn,proto3" json:"apn,omitempty"`
	User string `protobuf:"bytes,2,opt,name=user,proto3" json:"user,omitempty"`
	Pwd  string `protobuf:"bytes,3,opt,name=pwd,proto3" json:"pwd,omitempty"`
}

func (m *WlstCom_3E02_Group01) Reset()         { *m = WlstCom_3E02_Group01{} }
func (m *WlstCom_3E02_Group01) String() string { return proto.CompactTextString(m) }
func (*WlstCom_3E02_Group01) ProtoMessage()    {}
func (*WlstCom_3E02_Group01) Descriptor() ([]byte, []int) {
	return fileDescriptor_800322016269ce4e, []int{2, 0}
}
func (m *WlstCom_3E02_Group01) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstCom_3E02_Group01) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstCom_3E02_Group01.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstCom_3E02_Group01) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstCom_3E02_Group01.Merge(m, src)
}
func (m *WlstCom_3E02_Group01) XXX_Size() int {
	return m.Size()
}
func (m *WlstCom_3E02_Group01) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstCom_3E02_Group01.DiscardUnknown(m)
}

var xxx_messageInfo_WlstCom_3E02_Group01 proto.InternalMessageInfo

func (m *WlstCom_3E02_Group01) GetApn() string {
	if m != nil {
		return m.Apn
	}
	return ""
}

func (m *WlstCom_3E02_Group01) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *WlstCom_3E02_Group01) GetPwd() string {
	if m != nil {
		return m.Pwd
	}
	return ""
}

type WlstCom_3E02_Group02 struct {
	Channel1Type      int32   `protobuf:"varint,1,opt,name=channel1_type,json=channel1Type,proto3" json:"channel1_type,omitempty"`
	Channel1Ip        []int32 `protobuf:"varint,2,rep,packed,name=channel1_ip,json=channel1Ip,proto3" json:"channel1_ip,omitempty"`
	Channel1Port      int32   `protobuf:"varint,3,opt,name=channel1_port,json=channel1Port,proto3" json:"channel1_port,omitempty"`
	Channel1LocalPort int32   `protobuf:"varint,4,opt,name=channel1_local_port,json=channel1LocalPort,proto3" json:"channel1_local_port,omitempty"`
	Channel2Type      int32   `protobuf:"varint,5,opt,name=channel2_type,json=channel2Type,proto3" json:"channel2_type,omitempty"`
	Channel2Ip        []int32 `protobuf:"varint,6,rep,packed,name=channel2_ip,json=channel2Ip,proto3" json:"channel2_ip,omitempty"`
	Channel2Port      int32   `protobuf:"varint,7,opt,name=channel2_port,json=channel2Port,proto3" json:"channel2_port,omitempty"`
	Channel2LocalPort int32   `protobuf:"varint,8,opt,name=channel2_local_port,json=channel2LocalPort,proto3" json:"channel2_local_port,omitempty"`
	KeepAlive         int32   `protobuf:"varint,9,opt,name=keep_alive,json=keepAlive,proto3" json:"keep_alive,omitempty"`
	Idle              int32   `protobuf:"varint,10,opt,name=idle,proto3" json:"idle,omitempty"`
}

func (m *WlstCom_3E02_Group02) Reset()         { *m = WlstCom_3E02_Group02{} }
func (m *WlstCom_3E02_Group02) String() string { return proto.CompactTextString(m) }
func (*WlstCom_3E02_Group02) ProtoMessage()    {}
func (*WlstCom_3E02_Group02) Descriptor() ([]byte, []int) {
	return fileDescriptor_800322016269ce4e, []int{2, 1}
}
func (m *WlstCom_3E02_Group02) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstCom_3E02_Group02) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstCom_3E02_Group02.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstCom_3E02_Group02) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstCom_3E02_Group02.Merge(m, src)
}
func (m *WlstCom_3E02_Group02) XXX_Size() int {
	return m.Size()
}
func (m *WlstCom_3E02_Group02) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstCom_3E02_Group02.DiscardUnknown(m)
}

var xxx_messageInfo_WlstCom_3E02_Group02 proto.InternalMessageInfo

func (m *WlstCom_3E02_Group02) GetChannel1Type() int32 {
	if m != nil {
		return m.Channel1Type
	}
	return 0
}

func (m *WlstCom_3E02_Group02) GetChannel1Ip() []int32 {
	if m != nil {
		return m.Channel1Ip
	}
	return nil
}

func (m *WlstCom_3E02_Group02) GetChannel1Port() int32 {
	if m != nil {
		return m.Channel1Port
	}
	return 0
}

func (m *WlstCom_3E02_Group02) GetChannel1LocalPort() int32 {
	if m != nil {
		return m.Channel1LocalPort
	}
	return 0
}

func (m *WlstCom_3E02_Group02) GetChannel2Type() int32 {
	if m != nil {
		return m.Channel2Type
	}
	return 0
}

func (m *WlstCom_3E02_Group02) GetChannel2Ip() []int32 {
	if m != nil {
		return m.Channel2Ip
	}
	return nil
}

func (m *WlstCom_3E02_Group02) GetChannel2Port() int32 {
	if m != nil {
		return m.Channel2Port
	}
	return 0
}

func (m *WlstCom_3E02_Group02) GetChannel2LocalPort() int32 {
	if m != nil {
		return m.Channel2LocalPort
	}
	return 0
}

func (m *WlstCom_3E02_Group02) GetKeepAlive() int32 {
	if m != nil {
		return m.KeepAlive
	}
	return 0
}

func (m *WlstCom_3E02_Group02) GetIdle() int32 {
	if m != nil {
		return m.Idle
	}
	return 0
}

type WlstCom_3E02_Group03 struct {
	Port1Br  int32 `protobuf:"varint,1,opt,name=port1_br,json=port1Br,proto3" json:"port1_br,omitempty"`
	Port1Rc  int32 `protobuf:"varint,2,opt,name=port1_rc,json=port1Rc,proto3" json:"port1_rc,omitempty"`
	Port2Br  int32 `protobuf:"varint,3,opt,name=port2_br,json=port2Br,proto3" json:"port2_br,omitempty"`
	Port2Rc  int32 `protobuf:"varint,4,opt,name=port2_rc,json=port2Rc,proto3" json:"port2_rc,omitempty"`
	WorkMode int32 `protobuf:"varint,5,opt,name=work_mode,json=workMode,proto3" json:"work_mode,omitempty"`
}

func (m *WlstCom_3E02_Group03) Reset()         { *m = WlstCom_3E02_Group03{} }
func (m *WlstCom_3E02_Group03) String() string { return proto.CompactTextString(m) }
func (*WlstCom_3E02_Group03) ProtoMessage()    {}
func (*WlstCom_3E02_Group03) Descriptor() ([]byte, []int) {
	return fileDescriptor_800322016269ce4e, []int{2, 2}
}
func (m *WlstCom_3E02_Group03) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstCom_3E02_Group03) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstCom_3E02_Group03.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstCom_3E02_Group03) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstCom_3E02_Group03.Merge(m, src)
}
func (m *WlstCom_3E02_Group03) XXX_Size() int {
	return m.Size()
}
func (m *WlstCom_3E02_Group03) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstCom_3E02_Group03.DiscardUnknown(m)
}

var xxx_messageInfo_WlstCom_3E02_Group03 proto.InternalMessageInfo

func (m *WlstCom_3E02_Group03) GetPort1Br() int32 {
	if m != nil {
		return m.Port1Br
	}
	return 0
}

func (m *WlstCom_3E02_Group03) GetPort1Rc() int32 {
	if m != nil {
		return m.Port1Rc
	}
	return 0
}

func (m *WlstCom_3E02_Group03) GetPort2Br() int32 {
	if m != nil {
		return m.Port2Br
	}
	return 0
}

func (m *WlstCom_3E02_Group03) GetPort2Rc() int32 {
	if m != nil {
		return m.Port2Rc
	}
	return 0
}

func (m *WlstCom_3E02_Group03) GetWorkMode() int32 {
	if m != nil {
		return m.WorkMode
	}
	return 0
}

type WlstCom_3E02_Group04 struct {
	ValidCount int32 `protobuf:"varint,1,opt,name=valid_count,json=validCount,proto3" json:"valid_count,omitempty"`
	// sim号码列表，最大10，ascii,不足补“0”（0x30）
	Sim []string `protobuf:"bytes,2,rep,name=sim,proto3" json:"sim,omitempty"`
	//最大16个字符，不足补0
	Yecx string `protobuf:"bytes,3,opt,name=yecx,proto3" json:"yecx,omitempty"`
}

func (m *WlstCom_3E02_Group04) Reset()         { *m = WlstCom_3E02_Group04{} }
func (m *WlstCom_3E02_Group04) String() string { return proto.CompactTextString(m) }
func (*WlstCom_3E02_Group04) ProtoMessage()    {}
func (*WlstCom_3E02_Group04) Descriptor() ([]byte, []int) {
	return fileDescriptor_800322016269ce4e, []int{2, 3}
}
func (m *WlstCom_3E02_Group04) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstCom_3E02_Group04) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstCom_3E02_Group04.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstCom_3E02_Group04) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstCom_3E02_Group04.Merge(m, src)
}
func (m *WlstCom_3E02_Group04) XXX_Size() int {
	return m.Size()
}
func (m *WlstCom_3E02_Group04) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstCom_3E02_Group04.DiscardUnknown(m)
}

var xxx_messageInfo_WlstCom_3E02_Group04 proto.InternalMessageInfo

func (m *WlstCom_3E02_Group04) GetValidCount() int32 {
	if m != nil {
		return m.ValidCount
	}
	return 0
}

func (m *WlstCom_3E02_Group04) GetSim() []string {
	if m != nil {
		return m.Sim
	}
	return nil
}

func (m *WlstCom_3E02_Group04) GetYecx() string {
	if m != nil {
		return m.Yecx
	}
	return ""
}

type WlstCom_3E02_Group05 struct {
	// 11位bcd，不足补“0”（0x30）
	Addr string `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
	// 32位unicode，最大16个中文字符
	Street string `protobuf:"bytes,2,opt,name=street,proto3" json:"street,omitempty"`
	//批号，20个ascII字符
	BatchNumber string `protobuf:"bytes,3,opt,name=batch_number,json=batchNumber,proto3" json:"batch_number,omitempty"`
}

func (m *WlstCom_3E02_Group05) Reset()         { *m = WlstCom_3E02_Group05{} }
func (m *WlstCom_3E02_Group05) String() string { return proto.CompactTextString(m) }
func (*WlstCom_3E02_Group05) ProtoMessage()    {}
func (*WlstCom_3E02_Group05) Descriptor() ([]byte, []int) {
	return fileDescriptor_800322016269ce4e, []int{2, 4}
}
func (m *WlstCom_3E02_Group05) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstCom_3E02_Group05) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstCom_3E02_Group05.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstCom_3E02_Group05) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstCom_3E02_Group05.Merge(m, src)
}
func (m *WlstCom_3E02_Group05) XXX_Size() int {
	return m.Size()
}
func (m *WlstCom_3E02_Group05) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstCom_3E02_Group05.DiscardUnknown(m)
}

var xxx_messageInfo_WlstCom_3E02_Group05 proto.InternalMessageInfo

func (m *WlstCom_3E02_Group05) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *WlstCom_3E02_Group05) GetStreet() string {
	if m != nil {
		return m.Street
	}
	return ""
}

func (m *WlstCom_3E02_Group05) GetBatchNumber() string {
	if m != nil {
		return m.BatchNumber
	}
	return ""
}

type WlstCom_3E02_Group06 struct {
	// 状态
	State string `protobuf:"bytes,1,opt,name=state,proto3" json:"state,omitempty"`
	// 15位imei号码
	Imei int64 `protobuf:"varint,2,opt,name=imei,proto3" json:"imei,omitempty"`
	// 模块版本
	Ver string `protobuf:"bytes,3,opt,name=ver,proto3" json:"ver,omitempty"`
	// iccid
	Iccid string `protobuf:"bytes,4,opt,name=iccid,proto3" json:"iccid,omitempty"`
}

func (m *WlstCom_3E02_Group06) Reset()         { *m = WlstCom_3E02_Group06{} }
func (m *WlstCom_3E02_Group06) String() string { return proto.CompactTextString(m) }
func (*WlstCom_3E02_Group06) ProtoMessage()    {}
func (*WlstCom_3E02_Group06) Descriptor() ([]byte, []int) {
	return fileDescriptor_800322016269ce4e, []int{2, 5}
}
func (m *WlstCom_3E02_Group06) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstCom_3E02_Group06) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstCom_3E02_Group06.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstCom_3E02_Group06) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstCom_3E02_Group06.Merge(m, src)
}
func (m *WlstCom_3E02_Group06) XXX_Size() int {
	return m.Size()
}
func (m *WlstCom_3E02_Group06) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstCom_3E02_Group06.DiscardUnknown(m)
}

var xxx_messageInfo_WlstCom_3E02_Group06 proto.InternalMessageInfo

func (m *WlstCom_3E02_Group06) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func (m *WlstCom_3E02_Group06) GetImei() int64 {
	if m != nil {
		return m.Imei
	}
	return 0
}

func (m *WlstCom_3E02_Group06) GetVer() string {
	if m != nil {
		return m.Ver
	}
	return ""
}

func (m *WlstCom_3E02_Group06) GetIccid() string {
	if m != nil {
		return m.Iccid
	}
	return ""
}

type WlstCom_3E82 struct {
	//状态0-失败，1-正常
	Status int32 `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
	//组号
	GroupMark int32 `protobuf:"varint,2,opt,name=group_mark,json=groupMark,proto3" json:"group_mark,omitempty"`
	//位号，依据组号排序
	ArgsMark []int32 `protobuf:"varint,3,rep,packed,name=args_mark,json=argsMark,proto3" json:"args_mark,omitempty"`
}

func (m *WlstCom_3E82) Reset()         { *m = WlstCom_3E82{} }
func (m *WlstCom_3E82) String() string { return proto.CompactTextString(m) }
func (*WlstCom_3E82) ProtoMessage()    {}
func (*WlstCom_3E82) Descriptor() ([]byte, []int) {
	return fileDescriptor_800322016269ce4e, []int{3}
}
func (m *WlstCom_3E82) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstCom_3E82) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstCom_3E82.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstCom_3E82) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstCom_3E82.Merge(m, src)
}
func (m *WlstCom_3E82) XXX_Size() int {
	return m.Size()
}
func (m *WlstCom_3E82) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstCom_3E82.DiscardUnknown(m)
}

var xxx_messageInfo_WlstCom_3E82 proto.InternalMessageInfo

func (m *WlstCom_3E82) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *WlstCom_3E82) GetGroupMark() int32 {
	if m != nil {
		return m.GroupMark
	}
	return 0
}

func (m *WlstCom_3E82) GetArgsMark() []int32 {
	if m != nil {
		return m.ArgsMark
	}
	return nil
}

type WlstCom_3E84 struct {
	// 11位地址，默认”00000000000“
	Addr string `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
	// 信号强度
	Signal int32 `protobuf:"varint,2,opt,name=signal,proto3" json:"signal,omitempty"`
	// 网络模式，4-4g，2-2/3g
	NetType int32 `protobuf:"varint,3,opt,name=net_type,json=netType,proto3" json:"net_type,omitempty"`
	// 掉线次数
	DisconnCount int32 `protobuf:"varint,4,opt,name=disconn_count,json=disconnCount,proto3" json:"disconn_count,omitempty"`
	// 重启次数
	ResetCount int32 `protobuf:"varint,5,opt,name=reset_count,json=resetCount,proto3" json:"reset_count,omitempty"`
}

func (m *WlstCom_3E84) Reset()         { *m = WlstCom_3E84{} }
func (m *WlstCom_3E84) String() string { return proto.CompactTextString(m) }
func (*WlstCom_3E84) ProtoMessage()    {}
func (*WlstCom_3E84) Descriptor() ([]byte, []int) {
	return fileDescriptor_800322016269ce4e, []int{4}
}
func (m *WlstCom_3E84) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstCom_3E84) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstCom_3E84.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstCom_3E84) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstCom_3E84.Merge(m, src)
}
func (m *WlstCom_3E84) XXX_Size() int {
	return m.Size()
}
func (m *WlstCom_3E84) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstCom_3E84.DiscardUnknown(m)
}

var xxx_messageInfo_WlstCom_3E84 proto.InternalMessageInfo

func (m *WlstCom_3E84) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *WlstCom_3E84) GetSignal() int32 {
	if m != nil {
		return m.Signal
	}
	return 0
}

func (m *WlstCom_3E84) GetNetType() int32 {
	if m != nil {
		return m.NetType
	}
	return 0
}

func (m *WlstCom_3E84) GetDisconnCount() int32 {
	if m != nil {
		return m.DisconnCount
	}
	return 0
}

func (m *WlstCom_3E84) GetResetCount() int32 {
	if m != nil {
		return m.ResetCount
	}
	return 0
}

type WlstFtp_0000 struct {
	// 升级目标，rtu，com，slu，gb
	Target string `protobuf:"bytes,1,opt,name=target,proto3" json:"target,omitempty"`
	// ftp 地址
	FtpIp string `protobuf:"bytes,2,opt,name=ftp_ip,json=ftpIp,proto3" json:"ftp_ip,omitempty"`
	// ftp 端口
	FtpPort int32 `protobuf:"varint,3,opt,name=ftp_port,json=ftpPort,proto3" json:"ftp_port,omitempty"`
	// ftp 用户名
	FtpUser string `protobuf:"bytes,4,opt,name=ftp_user,json=ftpUser,proto3" json:"ftp_user,omitempty"`
	// ftp 密码
	FtpPwd string `protobuf:"bytes,5,opt,name=ftp_pwd,json=ftpPwd,proto3" json:"ftp_pwd,omitempty"`
	// ftp 文件名
	FtpFile string `protobuf:"bytes,6,opt,name=ftp_file,json=ftpFile,proto3" json:"ftp_file,omitempty"`
	// ftp 路径
	FtpDir string `protobuf:"bytes,7,opt,name=ftp_dir,json=ftpDir,proto3" json:"ftp_dir,omitempty"`
}

func (m *WlstFtp_0000) Reset()         { *m = WlstFtp_0000{} }
func (m *WlstFtp_0000) String() string { return proto.CompactTextString(m) }
func (*WlstFtp_0000) ProtoMessage()    {}
func (*WlstFtp_0000) Descriptor() ([]byte, []int) {
	return fileDescriptor_800322016269ce4e, []int{5}
}
func (m *WlstFtp_0000) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstFtp_0000) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstFtp_0000.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstFtp_0000) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstFtp_0000.Merge(m, src)
}
func (m *WlstFtp_0000) XXX_Size() int {
	return m.Size()
}
func (m *WlstFtp_0000) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstFtp_0000.DiscardUnknown(m)
}

var xxx_messageInfo_WlstFtp_0000 proto.InternalMessageInfo

func (m *WlstFtp_0000) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func (m *WlstFtp_0000) GetFtpIp() string {
	if m != nil {
		return m.FtpIp
	}
	return ""
}

func (m *WlstFtp_0000) GetFtpPort() int32 {
	if m != nil {
		return m.FtpPort
	}
	return 0
}

func (m *WlstFtp_0000) GetFtpUser() string {
	if m != nil {
		return m.FtpUser
	}
	return ""
}

func (m *WlstFtp_0000) GetFtpPwd() string {
	if m != nil {
		return m.FtpPwd
	}
	return ""
}

func (m *WlstFtp_0000) GetFtpFile() string {
	if m != nil {
		return m.FtpFile
	}
	return ""
}

func (m *WlstFtp_0000) GetFtpDir() string {
	if m != nil {
		return m.FtpDir
	}
	return ""
}

func init() {
	proto.RegisterType((*WlstCom_0000)(nil), "wlst.pb2.Wlst_com_0000")
	proto.RegisterType((*WlstCom_3E01)(nil), "wlst.pb2.Wlst_com_3e01")
	proto.RegisterType((*WlstCom_3E02)(nil), "wlst.pb2.Wlst_com_3e02")
	proto.RegisterType((*WlstCom_3E02_Group01)(nil), "wlst.pb2.Wlst_com_3e02.Group01")
	proto.RegisterType((*WlstCom_3E02_Group02)(nil), "wlst.pb2.Wlst_com_3e02.Group02")
	proto.RegisterType((*WlstCom_3E02_Group03)(nil), "wlst.pb2.Wlst_com_3e02.Group03")
	proto.RegisterType((*WlstCom_3E02_Group04)(nil), "wlst.pb2.Wlst_com_3e02.Group04")
	proto.RegisterType((*WlstCom_3E02_Group05)(nil), "wlst.pb2.Wlst_com_3e02.Group05")
	proto.RegisterType((*WlstCom_3E02_Group06)(nil), "wlst.pb2.Wlst_com_3e02.Group06")
	proto.RegisterType((*WlstCom_3E82)(nil), "wlst.pb2.Wlst_com_3e82")
	proto.RegisterType((*WlstCom_3E84)(nil), "wlst.pb2.Wlst_com_3e84")
	proto.RegisterType((*WlstFtp_0000)(nil), "wlst.pb2.Wlst_ftp_0000")
}

func init() { proto.RegisterFile("protocol_3c.proto", fileDescriptor_800322016269ce4e) }

var fileDescriptor_800322016269ce4e = []byte{
	// 911 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0x4f, 0x6f, 0x23, 0x35,
	0x14, 0xef, 0x34, 0x69, 0xfe, 0x38, 0xad, 0xc4, 0x1a, 0x58, 0x86, 0x20, 0xd2, 0x25, 0x7b, 0xd9,
	0x53, 0x94, 0x4c, 0xba, 0x0b, 0x1c, 0x38, 0xec, 0x82, 0x80, 0x4a, 0x2c, 0xaa, 0x46, 0x20, 0x90,
	0x38, 0x8c, 0x1c, 0x8f, 0xd3, 0xb5, 0x3a, 0x7f, 0x2c, 0xdb, 0x69, 0xd8, 0x6f, 0x81, 0x90, 0xb8,
	0xf1, 0x65, 0xb8, 0x71, 0xdc, 0x23, 0x47, 0xd4, 0xde, 0x39, 0xf0, 0x09, 0xd0, 0x7b, 0xb6, 0x33,
	0x9d, 0x0a, 0x54, 0x24, 0xb8, 0xd9, 0xbf, 0xf7, 0xde, 0xcf, 0xbf, 0xbc, 0x7f, 0x13, 0x72, 0x4f,
	0xe9, 0xda, 0xd6, 0xbc, 0x2e, 0xb2, 0x25, 0x9f, 0xe1, 0x99, 0x0e, 0xb6, 0x85, 0xb1, 0x33, 0xb5,
	0x4a, 0xa6, 0x7f, 0x44, 0xe4, 0xe8, 0x9b, 0xc2, 0xd8, 0x8c, 0xd7, 0x65, 0x36, 0x9f, 0xcf, 0xe7,
	0xf4, 0x1d, 0x32, 0x34, 0x42, 0x5f, 0x0a, 0x9d, 0x49, 0x15, 0x47, 0x0f, 0xa2, 0x47, 0xc3, 0x74,
	0xe0, 0x80, 0x53, 0x45, 0x8f, 0xc9, 0xc8, 0x1b, 0x55, 0xad, 0x6d, 0xbc, 0x8f, 0x66, 0xe2, 0xa0,
	0xb3, 0x5a, 0x5b, 0xfa, 0x1a, 0xe9, 0x30, 0x55, 0xc5, 0x1d, 0x34, 0xc0, 0x91, 0xbe, 0x4b, 0xc8,
	0x85, 0x10, 0x2a, 0x63, 0x85, 0xbc, 0x14, 0x71, 0x17, 0x0d, 0x43, 0x40, 0x9e, 0x02, 0x40, 0x29,
	0xe9, 0xda, 0x97, 0x4a, 0xc4, 0x07, 0x68, 0xc0, 0x33, 0x90, 0x18, 0x59, 0xc6, 0x3d, 0x47, 0x62,
	0x64, 0x49, 0x1f, 0x92, 0x23, 0x9e, 0x97, 0x2c, 0xdb, 0x18, 0xa1, 0x2b, 0x56, 0x8a, 0xb8, 0x8f,
	0xb6, 0x43, 0x00, 0xbf, 0xf6, 0xd8, 0xce, 0x49, 0x31, 0x63, 0xb6, 0xb5, 0xce, 0xe3, 0x41, 0xe3,
	0x74, 0xe6, 0xb1, 0x69, 0x76, 0xe3, 0xf7, 0x2e, 0xc5, 0x7c, 0x01, 0x02, 0x58, 0x9e, 0x6b, 0xff,
	0x53, 0xf1, 0x0c, 0x9a, 0xcf, 0x75, 0xbd, 0x51, 0x59, 0xc9, 0xf4, 0x05, 0xfe, 0xca, 0x83, 0x74,
	0x88, 0xc8, 0x73, 0xa6, 0x2f, 0x20, 0x45, 0x4c, 0x9f, 0x1b, 0x67, 0xed, 0x3c, 0xe8, 0x3c, 0x3a,
	0x48, 0x07, 0x00, 0x80, 0x71, 0xfa, 0x13, 0x69, 0xbf, 0x90, 0xfc, 0xdf, 0x2f, 0xd0, 0x8f, 0xc8,
	0xb0, 0x56, 0x42, 0x33, 0x5b, 0x6b, 0x83, 0x09, 0x1d, 0x25, 0xc7, 0xb3, 0x50, 0xd1, 0x59, 0xeb,
	0xed, 0xd9, 0x67, 0x40, 0x39, 0x5f, 0xa4, 0x4d, 0x04, 0xfd, 0x90, 0xf4, 0xf9, 0x0b, 0x56, 0x55,
	0xa2, 0xc0, 0xa4, 0xdf, 0x19, 0x9c, 0xa4, 0xc1, 0x1f, 0x5e, 0x96, 0x95, 0x15, 0x7a, 0xcd, 0xb8,
	0xc0, 0xf2, 0xdc, 0x19, 0xbc, 0x4c, 0x9b, 0x08, 0xba, 0x20, 0x1d, 0x53, 0x1a, 0xac, 0xdd, 0x9d,
	0x81, 0x27, 0x29, 0xf8, 0x82, 0x58, 0xc8, 0x97, 0x30, 0x06, 0xab, 0x79, 0x67, 0xd8, 0xe3, 0x34,
	0xf8, 0xd3, 0xf7, 0x49, 0xcf, 0x58, 0x66, 0x37, 0x26, 0x1e, 0xfe, 0x9b, 0xc8, 0x27, 0xa9, 0x77,
	0x1f, 0x3f, 0x25, 0x7d, 0x9f, 0xb6, 0xd0, 0xce, 0x51, 0xd3, 0xce, 0x94, 0x74, 0xa1, 0x09, 0x7d,
	0xeb, 0xe3, 0x19, 0xbc, 0xd4, 0x36, 0x0f, 0x4d, 0xaf, 0xb6, 0xf9, 0xf8, 0xcf, 0xfd, 0xc0, 0x91,
	0x60, 0x5b, 0xba, 0xfc, 0x2d, 0x32, 0x6c, 0xf5, 0x08, 0xab, 0x7d, 0x18, 0xc0, 0xaf, 0xa0, 0xe5,
	0x8f, 0xc9, 0x68, 0xe7, 0x24, 0x55, 0xbc, 0x8f, 0x25, 0x27, 0x01, 0x3a, 0x55, 0x2d, 0x16, 0x9c,
	0xbd, 0x4e, 0x9b, 0x05, 0xa7, 0x6f, 0x46, 0x5e, 0xdf, 0x39, 0x15, 0x35, 0x67, 0x85, 0x73, 0xed,
	0xa2, 0xeb, 0xbd, 0x60, 0xfa, 0x02, 0x2c, 0xe8, 0xdf, 0x90, 0x26, 0xd9, 0x6e, 0x0a, 0x1b, 0xd2,
	0xe4, 0x96, 0xb4, 0x04, 0xa4, 0xf5, 0x5a, 0xd2, 0x92, 0x96, 0xb4, 0xc4, 0xbd, 0xd7, 0x6f, 0xb3,
	0xdc, 0x92, 0x96, 0xdc, 0x94, 0x36, 0x68, 0x49, 0x4b, 0x1a, 0x69, 0xed, 0xb5, 0x31, 0x74, 0x03,
	0xd2, 0x5a, 0x1b, 0x32, 0x2f, 0x44, 0x4c, 0xd0, 0x80, 0xe7, 0xf1, 0x8f, 0x51, 0x48, 0xfa, 0x92,
	0xbe, 0x4d, 0x06, 0xc0, 0xbf, 0xc8, 0x56, 0xda, 0xe7, 0xbb, 0x8f, 0xf7, 0x67, 0xba, 0x31, 0x69,
	0xee, 0x07, 0xcf, 0x99, 0x52, 0x1e, 0x4c, 0x09, 0x44, 0x75, 0x1a, 0x53, 0xd2, 0x44, 0x25, 0x10,
	0xd5, 0xbd, 0x61, 0x4a, 0x39, 0x0c, 0xeb, 0xb6, 0xd6, 0x17, 0x59, 0x59, 0xe7, 0x21, 0x83, 0x03,
	0x00, 0x9e, 0xd7, 0xb9, 0x18, 0x9f, 0x05, 0x4d, 0x27, 0x90, 0xc8, 0x4b, 0x56, 0xc8, 0x3c, 0xe3,
	0xf5, 0xa6, 0xb2, 0x5e, 0x16, 0x41, 0xe8, 0x63, 0x40, 0xc2, 0xde, 0x83, 0xe2, 0xfb, 0xbd, 0x47,
	0x49, 0xf7, 0xa5, 0xe0, 0xdf, 0xfb, 0xd6, 0xc2, 0xf3, 0xf8, 0xdb, 0xc0, 0xf8, 0xf8, 0x6f, 0x37,
	0xcb, 0x7d, 0x68, 0x7b, 0x2d, 0x44, 0xd8, 0xce, 0xfe, 0x46, 0xdf, 0x23, 0x87, 0x2b, 0x66, 0xf9,
	0x8b, 0xac, 0xda, 0x94, 0x2b, 0xa1, 0x3d, 0xe5, 0x08, 0xb1, 0x2f, 0x11, 0x1a, 0x7f, 0x17, 0x98,
	0x9f, 0xd0, 0x37, 0xc8, 0x01, 0x4c, 0x83, 0xf0, 0xd4, 0xee, 0x82, 0x59, 0x2f, 0x85, 0x44, 0xe6,
	0x4e, 0x8a, 0x67, 0x10, 0x7d, 0xb9, 0xa3, 0x83, 0x23, 0xc4, 0x4a, 0xce, 0x65, 0xee, 0x97, 0xbd,
	0xbb, 0x4c, 0x79, 0x6b, 0x2d, 0x7e, 0x90, 0x38, 0xa1, 0x38, 0x9f, 0x2e, 0x13, 0xfe, 0xf6, 0x9f,
	0x96, 0xef, 0xcf, 0x51, 0xfb, 0x95, 0x93, 0x7f, 0x4c, 0x91, 0x3c, 0xaf, 0x58, 0xe1, 0xd9, 0xfd,
	0x0d, 0x6a, 0x5c, 0x09, 0xeb, 0x26, 0xc1, 0x97, 0xbf, 0x12, 0x16, 0x87, 0xe0, 0x21, 0x39, 0xca,
	0xa5, 0xe1, 0x75, 0x55, 0xf9, 0xea, 0xb9, 0x1e, 0x38, 0xf4, 0xa0, 0xab, 0xdf, 0x31, 0x19, 0x69,
	0x61, 0x84, 0xf5, 0x2e, 0xae, 0x15, 0x08, 0x42, 0xe8, 0x30, 0xfd, 0x25, 0xc8, 0x5b, 0x5b, 0xe5,
	0xbe, 0xb6, 0xf7, 0x49, 0xcf, 0x32, 0x7d, 0x2e, 0xac, 0x17, 0xe8, 0x6f, 0xf4, 0x4d, 0xd2, 0x03,
	0x1f, 0x5c, 0x05, 0x98, 0xc4, 0xb5, 0x55, 0xa7, 0x0a, 0x14, 0x02, 0x7c, 0x63, 0x01, 0xf4, 0xd7,
	0x56, 0xe1, 0xc0, 0x78, 0x13, 0x2e, 0x27, 0x97, 0x78, 0x30, 0xc1, 0xc7, 0x91, 0xbe, 0x45, 0xfa,
	0x18, 0xb5, 0xcd, 0xfd, 0x67, 0x16, 0xb8, 0xcf, 0xb6, 0x79, 0x88, 0x59, 0xcb, 0x42, 0xf8, 0xaf,
	0x2d, 0x38, 0x7e, 0x2a, 0x0b, 0x11, 0x62, 0x72, 0xa9, 0xfd, 0xb7, 0x16, 0x62, 0x3e, 0x91, 0xfa,
	0xd9, 0xf8, 0xd7, 0xab, 0x49, 0xf4, 0xea, 0x6a, 0x12, 0xfd, 0x7e, 0x35, 0x89, 0x7e, 0xb8, 0x9e,
	0xec, 0xbd, 0xba, 0x9e, 0xec, 0xfd, 0x76, 0x3d, 0xd9, 0xfb, 0x3c, 0x5a, 0xf5, 0xf0, 0xef, 0xc5,
	0xf2, 0xaf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x08, 0x7d, 0x6f, 0xd5, 0x73, 0x08, 0x00, 0x00,
}

func (m *WlstCom_0000) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstCom_0000) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstCom_0000) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CdmaPassword) > 0 {
		i -= len(m.CdmaPassword)
		copy(dAtA[i:], m.CdmaPassword)
		i = encodeVarintProtocol_3C(dAtA, i, uint64(len(m.CdmaPassword)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.CdmaUsername) > 0 {
		i -= len(m.CdmaUsername)
		copy(dAtA[i:], m.CdmaUsername)
		i = encodeVarintProtocol_3C(dAtA, i, uint64(len(m.CdmaUsername)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Sim) > 0 {
		i -= len(m.Sim)
		copy(dAtA[i:], m.Sim)
		i = encodeVarintProtocol_3C(dAtA, i, uint64(len(m.Sim)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintProtocol_3C(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.KeepAlive) > 0 {
		i -= len(m.KeepAlive)
		copy(dAtA[i:], m.KeepAlive)
		i = encodeVarintProtocol_3C(dAtA, i, uint64(len(m.KeepAlive)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Apn) > 0 {
		i -= len(m.Apn)
		copy(dAtA[i:], m.Apn)
		i = encodeVarintProtocol_3C(dAtA, i, uint64(len(m.Apn)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ServerPort) > 0 {
		i -= len(m.ServerPort)
		copy(dAtA[i:], m.ServerPort)
		i = encodeVarintProtocol_3C(dAtA, i, uint64(len(m.ServerPort)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ServerIp) > 0 {
		i -= len(m.ServerIp)
		copy(dAtA[i:], m.ServerIp)
		i = encodeVarintProtocol_3C(dAtA, i, uint64(len(m.ServerIp)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WlstCom_3E01) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstCom_3E01) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstCom_3E01) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ArgsMark) > 0 {
		dAtA2 := make([]byte, len(m.ArgsMark)*10)
		var j1 int
		for _, num1 := range m.ArgsMark {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintProtocol_3C(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x1a
	}
	if m.GroupMark != 0 {
		i = encodeVarintProtocol_3C(dAtA, i, uint64(m.GroupMark))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintProtocol_3C(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WlstCom_3E02) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstCom_3E02) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstCom_3E02) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocol_3C(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.Address != nil {
		{
			size, err := m.Address.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocol_3C(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Sms != nil {
		{
			size, err := m.Sms.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocol_3C(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Interface != nil {
		{
			size, err := m.Interface.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocol_3C(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Channel != nil {
		{
			size, err := m.Channel.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocol_3C(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Operators != nil {
		{
			size, err := m.Operators.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocol_3C(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ArgsMark) > 0 {
		dAtA10 := make([]byte, len(m.ArgsMark)*10)
		var j9 int
		for _, num1 := range m.ArgsMark {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		i -= j9
		copy(dAtA[i:], dAtA10[:j9])
		i = encodeVarintProtocol_3C(dAtA, i, uint64(j9))
		i--
		dAtA[i] = 0x1a
	}
	if m.GroupMark != 0 {
		i = encodeVarintProtocol_3C(dAtA, i, uint64(m.GroupMark))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintProtocol_3C(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WlstCom_3E02_Group01) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstCom_3E02_Group01) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstCom_3E02_Group01) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Pwd) > 0 {
		i -= len(m.Pwd)
		copy(dAtA[i:], m.Pwd)
		i = encodeVarintProtocol_3C(dAtA, i, uint64(len(m.Pwd)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintProtocol_3C(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Apn) > 0 {
		i -= len(m.Apn)
		copy(dAtA[i:], m.Apn)
		i = encodeVarintProtocol_3C(dAtA, i, uint64(len(m.Apn)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WlstCom_3E02_Group02) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstCom_3E02_Group02) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstCom_3E02_Group02) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Idle != 0 {
		i = encodeVarintProtocol_3C(dAtA, i, uint64(m.Idle))
		i--
		dAtA[i] = 0x50
	}
	if m.KeepAlive != 0 {
		i = encodeVarintProtocol_3C(dAtA, i, uint64(m.KeepAlive))
		i--
		dAtA[i] = 0x48
	}
	if m.Channel2LocalPort != 0 {
		i = encodeVarintProtocol_3C(dAtA, i, uint64(m.Channel2LocalPort))
		i--
		dAtA[i] = 0x40
	}
	if m.Channel2Port != 0 {
		i = encodeVarintProtocol_3C(dAtA, i, uint64(m.Channel2Port))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Channel2Ip) > 0 {
		dAtA12 := make([]byte, len(m.Channel2Ip)*10)
		var j11 int
		for _, num1 := range m.Channel2Ip {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		i -= j11
		copy(dAtA[i:], dAtA12[:j11])
		i = encodeVarintProtocol_3C(dAtA, i, uint64(j11))
		i--
		dAtA[i] = 0x32
	}
	if m.Channel2Type != 0 {
		i = encodeVarintProtocol_3C(dAtA, i, uint64(m.Channel2Type))
		i--
		dAtA[i] = 0x28
	}
	if m.Channel1LocalPort != 0 {
		i = encodeVarintProtocol_3C(dAtA, i, uint64(m.Channel1LocalPort))
		i--
		dAtA[i] = 0x20
	}
	if m.Channel1Port != 0 {
		i = encodeVarintProtocol_3C(dAtA, i, uint64(m.Channel1Port))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Channel1Ip) > 0 {
		dAtA14 := make([]byte, len(m.Channel1Ip)*10)
		var j13 int
		for _, num1 := range m.Channel1Ip {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		i -= j13
		copy(dAtA[i:], dAtA14[:j13])
		i = encodeVarintProtocol_3C(dAtA, i, uint64(j13))
		i--
		dAtA[i] = 0x12
	}
	if m.Channel1Type != 0 {
		i = encodeVarintProtocol_3C(dAtA, i, uint64(m.Channel1Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstCom_3E02_Group03) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstCom_3E02_Group03) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstCom_3E02_Group03) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WorkMode != 0 {
		i = encodeVarintProtocol_3C(dAtA, i, uint64(m.WorkMode))
		i--
		dAtA[i] = 0x28
	}
	if m.Port2Rc != 0 {
		i = encodeVarintProtocol_3C(dAtA, i, uint64(m.Port2Rc))
		i--
		dAtA[i] = 0x20
	}
	if m.Port2Br != 0 {
		i = encodeVarintProtocol_3C(dAtA, i, uint64(m.Port2Br))
		i--
		dAtA[i] = 0x18
	}
	if m.Port1Rc != 0 {
		i = encodeVarintProtocol_3C(dAtA, i, uint64(m.Port1Rc))
		i--
		dAtA[i] = 0x10
	}
	if m.Port1Br != 0 {
		i = encodeVarintProtocol_3C(dAtA, i, uint64(m.Port1Br))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstCom_3E02_Group04) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstCom_3E02_Group04) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstCom_3E02_Group04) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Yecx) > 0 {
		i -= len(m.Yecx)
		copy(dAtA[i:], m.Yecx)
		i = encodeVarintProtocol_3C(dAtA, i, uint64(len(m.Yecx)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Sim) > 0 {
		for iNdEx := len(m.Sim) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Sim[iNdEx])
			copy(dAtA[i:], m.Sim[iNdEx])
			i = encodeVarintProtocol_3C(dAtA, i, uint64(len(m.Sim[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ValidCount != 0 {
		i = encodeVarintProtocol_3C(dAtA, i, uint64(m.ValidCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstCom_3E02_Group05) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstCom_3E02_Group05) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstCom_3E02_Group05) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BatchNumber) > 0 {
		i -= len(m.BatchNumber)
		copy(dAtA[i:], m.BatchNumber)
		i = encodeVarintProtocol_3C(dAtA, i, uint64(len(m.BatchNumber)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Street) > 0 {
		i -= len(m.Street)
		copy(dAtA[i:], m.Street)
		i = encodeVarintProtocol_3C(dAtA, i, uint64(len(m.Street)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintProtocol_3C(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WlstCom_3E02_Group06) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstCom_3E02_Group06) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstCom_3E02_Group06) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Iccid) > 0 {
		i -= len(m.Iccid)
		copy(dAtA[i:], m.Iccid)
		i = encodeVarintProtocol_3C(dAtA, i, uint64(len(m.Iccid)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Ver) > 0 {
		i -= len(m.Ver)
		copy(dAtA[i:], m.Ver)
		i = encodeVarintProtocol_3C(dAtA, i, uint64(len(m.Ver)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Imei != 0 {
		i = encodeVarintProtocol_3C(dAtA, i, uint64(m.Imei))
		i--
		dAtA[i] = 0x10
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintProtocol_3C(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WlstCom_3E82) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstCom_3E82) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstCom_3E82) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ArgsMark) > 0 {
		dAtA16 := make([]byte, len(m.ArgsMark)*10)
		var j15 int
		for _, num1 := range m.ArgsMark {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA16[j15] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j15++
			}
			dAtA16[j15] = uint8(num)
			j15++
		}
		i -= j15
		copy(dAtA[i:], dAtA16[:j15])
		i = encodeVarintProtocol_3C(dAtA, i, uint64(j15))
		i--
		dAtA[i] = 0x1a
	}
	if m.GroupMark != 0 {
		i = encodeVarintProtocol_3C(dAtA, i, uint64(m.GroupMark))
		i--
		dAtA[i] = 0x10
	}
	if m.Status != 0 {
		i = encodeVarintProtocol_3C(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstCom_3E84) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstCom_3E84) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstCom_3E84) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ResetCount != 0 {
		i = encodeVarintProtocol_3C(dAtA, i, uint64(m.ResetCount))
		i--
		dAtA[i] = 0x28
	}
	if m.DisconnCount != 0 {
		i = encodeVarintProtocol_3C(dAtA, i, uint64(m.DisconnCount))
		i--
		dAtA[i] = 0x20
	}
	if m.NetType != 0 {
		i = encodeVarintProtocol_3C(dAtA, i, uint64(m.NetType))
		i--
		dAtA[i] = 0x18
	}
	if m.Signal != 0 {
		i = encodeVarintProtocol_3C(dAtA, i, uint64(m.Signal))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintProtocol_3C(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WlstFtp_0000) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstFtp_0000) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstFtp_0000) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FtpDir) > 0 {
		i -= len(m.FtpDir)
		copy(dAtA[i:], m.FtpDir)
		i = encodeVarintProtocol_3C(dAtA, i, uint64(len(m.FtpDir)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.FtpFile) > 0 {
		i -= len(m.FtpFile)
		copy(dAtA[i:], m.FtpFile)
		i = encodeVarintProtocol_3C(dAtA, i, uint64(len(m.FtpFile)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.FtpPwd) > 0 {
		i -= len(m.FtpPwd)
		copy(dAtA[i:], m.FtpPwd)
		i = encodeVarintProtocol_3C(dAtA, i, uint64(len(m.FtpPwd)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.FtpUser) > 0 {
		i -= len(m.FtpUser)
		copy(dAtA[i:], m.FtpUser)
		i = encodeVarintProtocol_3C(dAtA, i, uint64(len(m.FtpUser)))
		i--
		dAtA[i] = 0x22
	}
	if m.FtpPort != 0 {
		i = encodeVarintProtocol_3C(dAtA, i, uint64(m.FtpPort))
		i--
		dAtA[i] = 0x18
	}
	if len(m.FtpIp) > 0 {
		i -= len(m.FtpIp)
		copy(dAtA[i:], m.FtpIp)
		i = encodeVarintProtocol_3C(dAtA, i, uint64(len(m.FtpIp)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Target) > 0 {
		i -= len(m.Target)
		copy(dAtA[i:], m.Target)
		i = encodeVarintProtocol_3C(dAtA, i, uint64(len(m.Target)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintProtocol_3C(dAtA []byte, offset int, v uint64) int {
	offset -= sovProtocol_3C(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *WlstCom_0000) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServerIp)
	if l > 0 {
		n += 1 + l + sovProtocol_3C(uint64(l))
	}
	l = len(m.ServerPort)
	if l > 0 {
		n += 1 + l + sovProtocol_3C(uint64(l))
	}
	l = len(m.Apn)
	if l > 0 {
		n += 1 + l + sovProtocol_3C(uint64(l))
	}
	l = len(m.KeepAlive)
	if l > 0 {
		n += 1 + l + sovProtocol_3C(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovProtocol_3C(uint64(l))
	}
	l = len(m.Sim)
	if l > 0 {
		n += 1 + l + sovProtocol_3C(uint64(l))
	}
	l = len(m.CdmaUsername)
	if l > 0 {
		n += 1 + l + sovProtocol_3C(uint64(l))
	}
	l = len(m.CdmaPassword)
	if l > 0 {
		n += 1 + l + sovProtocol_3C(uint64(l))
	}
	return n
}

func (m *WlstCom_3E01) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovProtocol_3C(uint64(l))
	}
	if m.GroupMark != 0 {
		n += 1 + sovProtocol_3C(uint64(m.GroupMark))
	}
	if len(m.ArgsMark) > 0 {
		l = 0
		for _, e := range m.ArgsMark {
			l += sovProtocol_3C(uint64(e))
		}
		n += 1 + sovProtocol_3C(uint64(l)) + l
	}
	return n
}

func (m *WlstCom_3E02) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovProtocol_3C(uint64(l))
	}
	if m.GroupMark != 0 {
		n += 1 + sovProtocol_3C(uint64(m.GroupMark))
	}
	if len(m.ArgsMark) > 0 {
		l = 0
		for _, e := range m.ArgsMark {
			l += sovProtocol_3C(uint64(e))
		}
		n += 1 + sovProtocol_3C(uint64(l)) + l
	}
	if m.Operators != nil {
		l = m.Operators.Size()
		n += 1 + l + sovProtocol_3C(uint64(l))
	}
	if m.Channel != nil {
		l = m.Channel.Size()
		n += 1 + l + sovProtocol_3C(uint64(l))
	}
	if m.Interface != nil {
		l = m.Interface.Size()
		n += 1 + l + sovProtocol_3C(uint64(l))
	}
	if m.Sms != nil {
		l = m.Sms.Size()
		n += 1 + l + sovProtocol_3C(uint64(l))
	}
	if m.Address != nil {
		l = m.Address.Size()
		n += 1 + l + sovProtocol_3C(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovProtocol_3C(uint64(l))
	}
	return n
}

func (m *WlstCom_3E02_Group01) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Apn)
	if l > 0 {
		n += 1 + l + sovProtocol_3C(uint64(l))
	}
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovProtocol_3C(uint64(l))
	}
	l = len(m.Pwd)
	if l > 0 {
		n += 1 + l + sovProtocol_3C(uint64(l))
	}
	return n
}

func (m *WlstCom_3E02_Group02) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Channel1Type != 0 {
		n += 1 + sovProtocol_3C(uint64(m.Channel1Type))
	}
	if len(m.Channel1Ip) > 0 {
		l = 0
		for _, e := range m.Channel1Ip {
			l += sovProtocol_3C(uint64(e))
		}
		n += 1 + sovProtocol_3C(uint64(l)) + l
	}
	if m.Channel1Port != 0 {
		n += 1 + sovProtocol_3C(uint64(m.Channel1Port))
	}
	if m.Channel1LocalPort != 0 {
		n += 1 + sovProtocol_3C(uint64(m.Channel1LocalPort))
	}
	if m.Channel2Type != 0 {
		n += 1 + sovProtocol_3C(uint64(m.Channel2Type))
	}
	if len(m.Channel2Ip) > 0 {
		l = 0
		for _, e := range m.Channel2Ip {
			l += sovProtocol_3C(uint64(e))
		}
		n += 1 + sovProtocol_3C(uint64(l)) + l
	}
	if m.Channel2Port != 0 {
		n += 1 + sovProtocol_3C(uint64(m.Channel2Port))
	}
	if m.Channel2LocalPort != 0 {
		n += 1 + sovProtocol_3C(uint64(m.Channel2LocalPort))
	}
	if m.KeepAlive != 0 {
		n += 1 + sovProtocol_3C(uint64(m.KeepAlive))
	}
	if m.Idle != 0 {
		n += 1 + sovProtocol_3C(uint64(m.Idle))
	}
	return n
}

func (m *WlstCom_3E02_Group03) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Port1Br != 0 {
		n += 1 + sovProtocol_3C(uint64(m.Port1Br))
	}
	if m.Port1Rc != 0 {
		n += 1 + sovProtocol_3C(uint64(m.Port1Rc))
	}
	if m.Port2Br != 0 {
		n += 1 + sovProtocol_3C(uint64(m.Port2Br))
	}
	if m.Port2Rc != 0 {
		n += 1 + sovProtocol_3C(uint64(m.Port2Rc))
	}
	if m.WorkMode != 0 {
		n += 1 + sovProtocol_3C(uint64(m.WorkMode))
	}
	return n
}

func (m *WlstCom_3E02_Group04) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ValidCount != 0 {
		n += 1 + sovProtocol_3C(uint64(m.ValidCount))
	}
	if len(m.Sim) > 0 {
		for _, s := range m.Sim {
			l = len(s)
			n += 1 + l + sovProtocol_3C(uint64(l))
		}
	}
	l = len(m.Yecx)
	if l > 0 {
		n += 1 + l + sovProtocol_3C(uint64(l))
	}
	return n
}

func (m *WlstCom_3E02_Group05) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovProtocol_3C(uint64(l))
	}
	l = len(m.Street)
	if l > 0 {
		n += 1 + l + sovProtocol_3C(uint64(l))
	}
	l = len(m.BatchNumber)
	if l > 0 {
		n += 1 + l + sovProtocol_3C(uint64(l))
	}
	return n
}

func (m *WlstCom_3E02_Group06) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovProtocol_3C(uint64(l))
	}
	if m.Imei != 0 {
		n += 1 + sovProtocol_3C(uint64(m.Imei))
	}
	l = len(m.Ver)
	if l > 0 {
		n += 1 + l + sovProtocol_3C(uint64(l))
	}
	l = len(m.Iccid)
	if l > 0 {
		n += 1 + l + sovProtocol_3C(uint64(l))
	}
	return n
}

func (m *WlstCom_3E82) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovProtocol_3C(uint64(m.Status))
	}
	if m.GroupMark != 0 {
		n += 1 + sovProtocol_3C(uint64(m.GroupMark))
	}
	if len(m.ArgsMark) > 0 {
		l = 0
		for _, e := range m.ArgsMark {
			l += sovProtocol_3C(uint64(e))
		}
		n += 1 + sovProtocol_3C(uint64(l)) + l
	}
	return n
}

func (m *WlstCom_3E84) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovProtocol_3C(uint64(l))
	}
	if m.Signal != 0 {
		n += 1 + sovProtocol_3C(uint64(m.Signal))
	}
	if m.NetType != 0 {
		n += 1 + sovProtocol_3C(uint64(m.NetType))
	}
	if m.DisconnCount != 0 {
		n += 1 + sovProtocol_3C(uint64(m.DisconnCount))
	}
	if m.ResetCount != 0 {
		n += 1 + sovProtocol_3C(uint64(m.ResetCount))
	}
	return n
}

func (m *WlstFtp_0000) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Target)
	if l > 0 {
		n += 1 + l + sovProtocol_3C(uint64(l))
	}
	l = len(m.FtpIp)
	if l > 0 {
		n += 1 + l + sovProtocol_3C(uint64(l))
	}
	if m.FtpPort != 0 {
		n += 1 + sovProtocol_3C(uint64(m.FtpPort))
	}
	l = len(m.FtpUser)
	if l > 0 {
		n += 1 + l + sovProtocol_3C(uint64(l))
	}
	l = len(m.FtpPwd)
	if l > 0 {
		n += 1 + l + sovProtocol_3C(uint64(l))
	}
	l = len(m.FtpFile)
	if l > 0 {
		n += 1 + l + sovProtocol_3C(uint64(l))
	}
	l = len(m.FtpDir)
	if l > 0 {
		n += 1 + l + sovProtocol_3C(uint64(l))
	}
	return n
}

func sovProtocol_3C(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozProtocol_3C(x uint64) (n int) {
	return sovProtocol_3C(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *WlstCom_0000) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol_3C
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_com_0000: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_com_0000: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerPort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerPort = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Apn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Apn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeepAlive", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeepAlive = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sim", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sim = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CdmaUsername", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CdmaUsername = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CdmaPassword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CdmaPassword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol_3C(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstCom_3E01) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol_3C
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_com_3e01: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_com_3e01: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupMark", wireType)
			}
			m.GroupMark = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupMark |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocol_3C
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ArgsMark = append(m.ArgsMark, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocol_3C
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocol_3C
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocol_3C
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ArgsMark) == 0 {
					m.ArgsMark = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocol_3C
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ArgsMark = append(m.ArgsMark, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ArgsMark", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol_3C(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstCom_3E02) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol_3C
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_com_3e02: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_com_3e02: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupMark", wireType)
			}
			m.GroupMark = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupMark |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocol_3C
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ArgsMark = append(m.ArgsMark, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocol_3C
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocol_3C
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocol_3C
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ArgsMark) == 0 {
					m.ArgsMark = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocol_3C
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ArgsMark = append(m.ArgsMark, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ArgsMark", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operators", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Operators == nil {
				m.Operators = &WlstCom_3E02_Group01{}
			}
			if err := m.Operators.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Channel == nil {
				m.Channel = &WlstCom_3E02_Group02{}
			}
			if err := m.Channel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Interface == nil {
				m.Interface = &WlstCom_3E02_Group03{}
			}
			if err := m.Interface.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sms == nil {
				m.Sms = &WlstCom_3E02_Group04{}
			}
			if err := m.Sms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Address == nil {
				m.Address = &WlstCom_3E02_Group05{}
			}
			if err := m.Address.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &WlstCom_3E02_Group06{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol_3C(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstCom_3E02_Group01) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol_3C
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Group01: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Group01: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Apn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Apn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pwd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pwd = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol_3C(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstCom_3E02_Group02) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol_3C
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Group02: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Group02: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel1Type", wireType)
			}
			m.Channel1Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Channel1Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocol_3C
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Channel1Ip = append(m.Channel1Ip, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocol_3C
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocol_3C
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocol_3C
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Channel1Ip) == 0 {
					m.Channel1Ip = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocol_3C
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Channel1Ip = append(m.Channel1Ip, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel1Ip", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel1Port", wireType)
			}
			m.Channel1Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Channel1Port |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel1LocalPort", wireType)
			}
			m.Channel1LocalPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Channel1LocalPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel2Type", wireType)
			}
			m.Channel2Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Channel2Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocol_3C
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Channel2Ip = append(m.Channel2Ip, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocol_3C
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocol_3C
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocol_3C
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Channel2Ip) == 0 {
					m.Channel2Ip = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocol_3C
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Channel2Ip = append(m.Channel2Ip, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel2Ip", wireType)
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel2Port", wireType)
			}
			m.Channel2Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Channel2Port |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel2LocalPort", wireType)
			}
			m.Channel2LocalPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Channel2LocalPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeepAlive", wireType)
			}
			m.KeepAlive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeepAlive |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idle", wireType)
			}
			m.Idle = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Idle |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol_3C(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstCom_3E02_Group03) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol_3C
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Group03: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Group03: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port1Br", wireType)
			}
			m.Port1Br = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port1Br |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port1Rc", wireType)
			}
			m.Port1Rc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port1Rc |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port2Br", wireType)
			}
			m.Port2Br = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port2Br |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port2Rc", wireType)
			}
			m.Port2Rc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port2Rc |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkMode", wireType)
			}
			m.WorkMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkMode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol_3C(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstCom_3E02_Group04) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol_3C
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Group04: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Group04: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidCount", wireType)
			}
			m.ValidCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sim", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sim = append(m.Sim, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yecx", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Yecx = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol_3C(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstCom_3E02_Group05) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol_3C
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Group05: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Group05: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Street", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Street = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol_3C(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstCom_3E02_Group06) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol_3C
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Group06: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Group06: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Imei", wireType)
			}
			m.Imei = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Imei |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iccid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Iccid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol_3C(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstCom_3E82) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol_3C
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_com_3e82: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_com_3e82: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupMark", wireType)
			}
			m.GroupMark = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupMark |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocol_3C
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ArgsMark = append(m.ArgsMark, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocol_3C
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocol_3C
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocol_3C
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ArgsMark) == 0 {
					m.ArgsMark = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocol_3C
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ArgsMark = append(m.ArgsMark, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ArgsMark", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol_3C(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstCom_3E84) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol_3C
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_com_3e84: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_com_3e84: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signal", wireType)
			}
			m.Signal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Signal |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetType", wireType)
			}
			m.NetType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisconnCount", wireType)
			}
			m.DisconnCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DisconnCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResetCount", wireType)
			}
			m.ResetCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResetCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol_3C(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstFtp_0000) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocol_3C
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_ftp_0000: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_ftp_0000: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FtpIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FtpIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FtpPort", wireType)
			}
			m.FtpPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FtpPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FtpUser", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FtpUser = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FtpPwd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FtpPwd = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FtpFile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FtpFile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FtpDir", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FtpDir = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocol_3C(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocol_3C
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipProtocol_3C(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProtocol_3C
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProtocol_3C
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthProtocol_3C
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupProtocol_3C
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthProtocol_3C
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthProtocol_3C        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProtocol_3C          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupProtocol_3C = fmt.Errorf("proto: unexpected end of group")
)
