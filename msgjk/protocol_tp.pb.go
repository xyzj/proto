// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: protocol_tp.proto

package wlst_pb2

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type AhhfRtu_6804 struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 数据标记,1-开关量输出参数，2-模拟量采集参数，3-模拟量上下限参数
	DataMark []int32 `protobuf:"varint,2,rep,packed,name=data_mark,json=dataMark,proto3" json:"data_mark,omitempty"`
	// 信息点，暂不用
	DataPoint     []int32                     `protobuf:"varint,3,rep,packed,name=data_point,json=dataPoint,proto3" json:"data_point,omitempty"`
	SwitchOut     *AhhfRtu_6804_SwitchOut     `protobuf:"bytes,4,opt,name=switch_out,json=switchOut,proto3" json:"switch_out,omitempty"`
	SwitchIn      *AhhfRtu_6804_SwitchIn      `protobuf:"bytes,5,opt,name=switch_in,json=switchIn,proto3" json:"switch_in,omitempty"`
	SwitchInLimit *AhhfRtu_6804_SwitchInLimit `protobuf:"bytes,6,opt,name=switch_in_limit,json=switchInLimit,proto3" json:"switch_in_limit,omitempty"`
	// 应答,0-失败，1-成功，填充顺序和data_mark相同
	Status []int32 `protobuf:"varint,9,rep,packed,name=status,proto3" json:"status,omitempty"`
}

func (m *AhhfRtu_6804) Reset()         { *m = AhhfRtu_6804{} }
func (m *AhhfRtu_6804) String() string { return proto.CompactTextString(m) }
func (*AhhfRtu_6804) ProtoMessage()    {}
func (*AhhfRtu_6804) Descriptor() ([]byte, []int) {
	return fileDescriptor_905abe2d3bf4d8dd, []int{0}
}
func (m *AhhfRtu_6804) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AhhfRtu_6804) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AhhfRtu_6804.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AhhfRtu_6804) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AhhfRtu_6804.Merge(m, src)
}
func (m *AhhfRtu_6804) XXX_Size() int {
	return m.Size()
}
func (m *AhhfRtu_6804) XXX_DiscardUnknown() {
	xxx_messageInfo_AhhfRtu_6804.DiscardUnknown(m)
}

var xxx_messageInfo_AhhfRtu_6804 proto.InternalMessageInfo

func (m *AhhfRtu_6804) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *AhhfRtu_6804) GetDataMark() []int32 {
	if m != nil {
		return m.DataMark
	}
	return nil
}

func (m *AhhfRtu_6804) GetDataPoint() []int32 {
	if m != nil {
		return m.DataPoint
	}
	return nil
}

func (m *AhhfRtu_6804) GetSwitchOut() *AhhfRtu_6804_SwitchOut {
	if m != nil {
		return m.SwitchOut
	}
	return nil
}

func (m *AhhfRtu_6804) GetSwitchIn() *AhhfRtu_6804_SwitchIn {
	if m != nil {
		return m.SwitchIn
	}
	return nil
}

func (m *AhhfRtu_6804) GetSwitchInLimit() *AhhfRtu_6804_SwitchInLimit {
	if m != nil {
		return m.SwitchInLimit
	}
	return nil
}

func (m *AhhfRtu_6804) GetStatus() []int32 {
	if m != nil {
		return m.Status
	}
	return nil
}

type AhhfRtu_6804_SwitchOut struct {
	// 开关量输出路数
	SwitchOutTotal int32 `protobuf:"varint,1,opt,name=switch_out_total,json=switchOutTotal,proto3" json:"switch_out_total,omitempty"`
	// 每个开关量输出的回路数
	SwitchOutLoop []int32 `protobuf:"varint,2,rep,packed,name=switch_out_loop,json=switchOutLoop,proto3" json:"switch_out_loop,omitempty"`
}

func (m *AhhfRtu_6804_SwitchOut) Reset()         { *m = AhhfRtu_6804_SwitchOut{} }
func (m *AhhfRtu_6804_SwitchOut) String() string { return proto.CompactTextString(m) }
func (*AhhfRtu_6804_SwitchOut) ProtoMessage()    {}
func (*AhhfRtu_6804_SwitchOut) Descriptor() ([]byte, []int) {
	return fileDescriptor_905abe2d3bf4d8dd, []int{0, 0}
}
func (m *AhhfRtu_6804_SwitchOut) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AhhfRtu_6804_SwitchOut) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AhhfRtu_6804_SwitchOut.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AhhfRtu_6804_SwitchOut) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AhhfRtu_6804_SwitchOut.Merge(m, src)
}
func (m *AhhfRtu_6804_SwitchOut) XXX_Size() int {
	return m.Size()
}
func (m *AhhfRtu_6804_SwitchOut) XXX_DiscardUnknown() {
	xxx_messageInfo_AhhfRtu_6804_SwitchOut.DiscardUnknown(m)
}

var xxx_messageInfo_AhhfRtu_6804_SwitchOut proto.InternalMessageInfo

func (m *AhhfRtu_6804_SwitchOut) GetSwitchOutTotal() int32 {
	if m != nil {
		return m.SwitchOutTotal
	}
	return 0
}

func (m *AhhfRtu_6804_SwitchOut) GetSwitchOutLoop() []int32 {
	if m != nil {
		return m.SwitchOutLoop
	}
	return nil
}

type AhhfRtu_6804_SwitchIn struct {
	// 电压互感比,默认5
	VoltageTransformer int32 `protobuf:"varint,1,opt,name=voltage_transformer,json=voltageTransformer,proto3" json:"voltage_transformer,omitempty"`
	// 电流回路数
	LoopTotal int32 `protobuf:"varint,2,opt,name=loop_total,json=loopTotal,proto3" json:"loop_total,omitempty"`
	// 电流回路互感比,按真实值提交，通信下发时/5
	CurrentTransformer []int32 `protobuf:"varint,3,rep,packed,name=current_transformer,json=currentTransformer,proto3" json:"current_transformer,omitempty"`
	// 电流回路相位,0-a,1-b,2-c
	CurrentPhase []int32 `protobuf:"varint,4,rep,packed,name=current_phase,json=currentPhase,proto3" json:"current_phase,omitempty"`
}

func (m *AhhfRtu_6804_SwitchIn) Reset()         { *m = AhhfRtu_6804_SwitchIn{} }
func (m *AhhfRtu_6804_SwitchIn) String() string { return proto.CompactTextString(m) }
func (*AhhfRtu_6804_SwitchIn) ProtoMessage()    {}
func (*AhhfRtu_6804_SwitchIn) Descriptor() ([]byte, []int) {
	return fileDescriptor_905abe2d3bf4d8dd, []int{0, 1}
}
func (m *AhhfRtu_6804_SwitchIn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AhhfRtu_6804_SwitchIn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AhhfRtu_6804_SwitchIn.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AhhfRtu_6804_SwitchIn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AhhfRtu_6804_SwitchIn.Merge(m, src)
}
func (m *AhhfRtu_6804_SwitchIn) XXX_Size() int {
	return m.Size()
}
func (m *AhhfRtu_6804_SwitchIn) XXX_DiscardUnknown() {
	xxx_messageInfo_AhhfRtu_6804_SwitchIn.DiscardUnknown(m)
}

var xxx_messageInfo_AhhfRtu_6804_SwitchIn proto.InternalMessageInfo

func (m *AhhfRtu_6804_SwitchIn) GetVoltageTransformer() int32 {
	if m != nil {
		return m.VoltageTransformer
	}
	return 0
}

func (m *AhhfRtu_6804_SwitchIn) GetLoopTotal() int32 {
	if m != nil {
		return m.LoopTotal
	}
	return 0
}

func (m *AhhfRtu_6804_SwitchIn) GetCurrentTransformer() []int32 {
	if m != nil {
		return m.CurrentTransformer
	}
	return nil
}

func (m *AhhfRtu_6804_SwitchIn) GetCurrentPhase() []int32 {
	if m != nil {
		return m.CurrentPhase
	}
	return nil
}

type AhhfRtu_6804_SwitchInLimit struct {
	// 回路数量
	LoopTotal int32 `protobuf:"varint,5,opt,name=loop_total,json=loopTotal,proto3" json:"loop_total,omitempty"`
	// 电压上下限,按真实值提交，通信下发*100
	VoltageUplimit  []float64 `protobuf:"fixed64,1,rep,packed,name=voltage_uplimit,json=voltageUplimit,proto3" json:"voltage_uplimit,omitempty"`
	VoltageLowlimit []float64 `protobuf:"fixed64,2,rep,packed,name=voltage_lowlimit,json=voltageLowlimit,proto3" json:"voltage_lowlimit,omitempty"`
	// 电流上下限
	CurrentUplimit  []float64 `protobuf:"fixed64,3,rep,packed,name=current_uplimit,json=currentUplimit,proto3" json:"current_uplimit,omitempty"`
	CurrentLowlimit []float64 `protobuf:"fixed64,4,rep,packed,name=current_lowlimit,json=currentLowlimit,proto3" json:"current_lowlimit,omitempty"`
}

func (m *AhhfRtu_6804_SwitchInLimit) Reset()         { *m = AhhfRtu_6804_SwitchInLimit{} }
func (m *AhhfRtu_6804_SwitchInLimit) String() string { return proto.CompactTextString(m) }
func (*AhhfRtu_6804_SwitchInLimit) ProtoMessage()    {}
func (*AhhfRtu_6804_SwitchInLimit) Descriptor() ([]byte, []int) {
	return fileDescriptor_905abe2d3bf4d8dd, []int{0, 2}
}
func (m *AhhfRtu_6804_SwitchInLimit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AhhfRtu_6804_SwitchInLimit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AhhfRtu_6804_SwitchInLimit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AhhfRtu_6804_SwitchInLimit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AhhfRtu_6804_SwitchInLimit.Merge(m, src)
}
func (m *AhhfRtu_6804_SwitchInLimit) XXX_Size() int {
	return m.Size()
}
func (m *AhhfRtu_6804_SwitchInLimit) XXX_DiscardUnknown() {
	xxx_messageInfo_AhhfRtu_6804_SwitchInLimit.DiscardUnknown(m)
}

var xxx_messageInfo_AhhfRtu_6804_SwitchInLimit proto.InternalMessageInfo

func (m *AhhfRtu_6804_SwitchInLimit) GetLoopTotal() int32 {
	if m != nil {
		return m.LoopTotal
	}
	return 0
}

func (m *AhhfRtu_6804_SwitchInLimit) GetVoltageUplimit() []float64 {
	if m != nil {
		return m.VoltageUplimit
	}
	return nil
}

func (m *AhhfRtu_6804_SwitchInLimit) GetVoltageLowlimit() []float64 {
	if m != nil {
		return m.VoltageLowlimit
	}
	return nil
}

func (m *AhhfRtu_6804_SwitchInLimit) GetCurrentUplimit() []float64 {
	if m != nil {
		return m.CurrentUplimit
	}
	return nil
}

func (m *AhhfRtu_6804_SwitchInLimit) GetCurrentLowlimit() []float64 {
	if m != nil {
		return m.CurrentLowlimit
	}
	return nil
}

//江阴节能协议
// Wxjy_esu_d500
type WxjyEsu_5500 struct {
	//当前时间 hhmmss
	TimeNow string `protobuf:"bytes,1,opt,name=time_now,json=timeNow,proto3" json:"time_now,omitempty"`
	//时间1-3 hhmm
	XTime []int32 `protobuf:"varint,2,rep,packed,name=x_time,json=xTime,proto3" json:"x_time,omitempty"`
	//电压
	XVoltage []int32 `protobuf:"varint,3,rep,packed,name=x_voltage,json=xVoltage,proto3" json:"x_voltage,omitempty"`
}

func (m *WxjyEsu_5500) Reset()         { *m = WxjyEsu_5500{} }
func (m *WxjyEsu_5500) String() string { return proto.CompactTextString(m) }
func (*WxjyEsu_5500) ProtoMessage()    {}
func (*WxjyEsu_5500) Descriptor() ([]byte, []int) {
	return fileDescriptor_905abe2d3bf4d8dd, []int{1}
}
func (m *WxjyEsu_5500) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WxjyEsu_5500) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WxjyEsu_5500.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WxjyEsu_5500) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WxjyEsu_5500.Merge(m, src)
}
func (m *WxjyEsu_5500) XXX_Size() int {
	return m.Size()
}
func (m *WxjyEsu_5500) XXX_DiscardUnknown() {
	xxx_messageInfo_WxjyEsu_5500.DiscardUnknown(m)
}

var xxx_messageInfo_WxjyEsu_5500 proto.InternalMessageInfo

func (m *WxjyEsu_5500) GetTimeNow() string {
	if m != nil {
		return m.TimeNow
	}
	return ""
}

func (m *WxjyEsu_5500) GetXTime() []int32 {
	if m != nil {
		return m.XTime
	}
	return nil
}

func (m *WxjyEsu_5500) GetXVoltage() []int32 {
	if m != nil {
		return m.XVoltage
	}
	return nil
}

type WxjyEsuD700 struct {
	// A相输入电压
	PhaseAIn int32 `protobuf:"varint,1,opt,name=phase_a_in,json=phaseAIn,proto3" json:"phase_a_in,omitempty"`
	// B相输入电压
	PhaseBIn int32 `protobuf:"varint,2,opt,name=phase_b_in,json=phaseBIn,proto3" json:"phase_b_in,omitempty"`
	// C相输入电压
	PhaseCIn int32 `protobuf:"varint,3,opt,name=phase_c_in,json=phaseCIn,proto3" json:"phase_c_in,omitempty"`
	// A相输出电压
	PhaseAOut int32 `protobuf:"varint,4,opt,name=phase_a_out,json=phaseAOut,proto3" json:"phase_a_out,omitempty"`
	// B相输出电压
	PhaseBOut int32 `protobuf:"varint,5,opt,name=phase_b_out,json=phaseBOut,proto3" json:"phase_b_out,omitempty"`
	// C相输出电压
	PhaseCOut int32 `protobuf:"varint,6,opt,name=phase_c_out,json=phaseCOut,proto3" json:"phase_c_out,omitempty"`
}

func (m *WxjyEsuD700) Reset()         { *m = WxjyEsuD700{} }
func (m *WxjyEsuD700) String() string { return proto.CompactTextString(m) }
func (*WxjyEsuD700) ProtoMessage()    {}
func (*WxjyEsuD700) Descriptor() ([]byte, []int) {
	return fileDescriptor_905abe2d3bf4d8dd, []int{2}
}
func (m *WxjyEsuD700) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WxjyEsuD700) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WxjyEsuD700.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WxjyEsuD700) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WxjyEsuD700.Merge(m, src)
}
func (m *WxjyEsuD700) XXX_Size() int {
	return m.Size()
}
func (m *WxjyEsuD700) XXX_DiscardUnknown() {
	xxx_messageInfo_WxjyEsuD700.DiscardUnknown(m)
}

var xxx_messageInfo_WxjyEsuD700 proto.InternalMessageInfo

func (m *WxjyEsuD700) GetPhaseAIn() int32 {
	if m != nil {
		return m.PhaseAIn
	}
	return 0
}

func (m *WxjyEsuD700) GetPhaseBIn() int32 {
	if m != nil {
		return m.PhaseBIn
	}
	return 0
}

func (m *WxjyEsuD700) GetPhaseCIn() int32 {
	if m != nil {
		return m.PhaseCIn
	}
	return 0
}

func (m *WxjyEsuD700) GetPhaseAOut() int32 {
	if m != nil {
		return m.PhaseAOut
	}
	return 0
}

func (m *WxjyEsuD700) GetPhaseBOut() int32 {
	if m != nil {
		return m.PhaseBOut
	}
	return 0
}

func (m *WxjyEsuD700) GetPhaseCOut() int32 {
	if m != nil {
		return m.PhaseCOut
	}
	return 0
}

type WxjyEsuD800 struct {
	//报警状态
	Status string `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *WxjyEsuD800) Reset()         { *m = WxjyEsuD800{} }
func (m *WxjyEsuD800) String() string { return proto.CompactTextString(m) }
func (*WxjyEsuD800) ProtoMessage()    {}
func (*WxjyEsuD800) Descriptor() ([]byte, []int) {
	return fileDescriptor_905abe2d3bf4d8dd, []int{3}
}
func (m *WxjyEsuD800) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WxjyEsuD800) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WxjyEsuD800.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WxjyEsuD800) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WxjyEsuD800.Merge(m, src)
}
func (m *WxjyEsuD800) XXX_Size() int {
	return m.Size()
}
func (m *WxjyEsuD800) XXX_DiscardUnknown() {
	xxx_messageInfo_WxjyEsuD800.DiscardUnknown(m)
}

var xxx_messageInfo_WxjyEsuD800 proto.InternalMessageInfo

func (m *WxjyEsuD800) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

// 勃洛克单灯
type BlkSlu_6891 struct {
	// 高地址（集中器地址）
	SluId int32 `protobuf:"varint,1,opt,name=slu_id,json=sluId,proto3" json:"slu_id,omitempty"`
	// 低地址（控制器地址）
	SluitemId int32 `protobuf:"varint,2,opt,name=sluitem_id,json=sluitemId,proto3" json:"sluitem_id,omitempty"`
	// 控制器数量（1～100）/时钟时间戳/是否启动扫描
	SluitemConfig int64 `protobuf:"varint,3,opt,name=sluitem_config,json=sluitemConfig,proto3" json:"sluitem_config,omitempty"`
	// 每个控制器回路数量
	SluitemLoop []int32 `protobuf:"varint,4,rep,packed,name=sluitem_loop,json=sluitemLoop,proto3" json:"sluitem_loop,omitempty"`
	// 设备应答状态，0-失败，1-成功
	Status int32 `protobuf:"varint,5,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *BlkSlu_6891) Reset()         { *m = BlkSlu_6891{} }
func (m *BlkSlu_6891) String() string { return proto.CompactTextString(m) }
func (*BlkSlu_6891) ProtoMessage()    {}
func (*BlkSlu_6891) Descriptor() ([]byte, []int) {
	return fileDescriptor_905abe2d3bf4d8dd, []int{4}
}
func (m *BlkSlu_6891) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlkSlu_6891) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlkSlu_6891.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlkSlu_6891) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlkSlu_6891.Merge(m, src)
}
func (m *BlkSlu_6891) XXX_Size() int {
	return m.Size()
}
func (m *BlkSlu_6891) XXX_DiscardUnknown() {
	xxx_messageInfo_BlkSlu_6891.DiscardUnknown(m)
}

var xxx_messageInfo_BlkSlu_6891 proto.InternalMessageInfo

func (m *BlkSlu_6891) GetSluId() int32 {
	if m != nil {
		return m.SluId
	}
	return 0
}

func (m *BlkSlu_6891) GetSluitemId() int32 {
	if m != nil {
		return m.SluitemId
	}
	return 0
}

func (m *BlkSlu_6891) GetSluitemConfig() int64 {
	if m != nil {
		return m.SluitemConfig
	}
	return 0
}

func (m *BlkSlu_6891) GetSluitemLoop() []int32 {
	if m != nil {
		return m.SluitemLoop
	}
	return nil
}

func (m *BlkSlu_6891) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

type BlkSlu_6892 struct {
	// 高地址（集中器地址）
	SluId       int32                      `protobuf:"varint,1,opt,name=slu_id,json=sluId,proto3" json:"slu_id,omitempty"`
	SluitemData []*BlkSlu_6892_SluitemData `protobuf:"bytes,2,rep,name=sluitem_data,json=sluitemData,proto3" json:"sluitem_data,omitempty"`
}

func (m *BlkSlu_6892) Reset()         { *m = BlkSlu_6892{} }
func (m *BlkSlu_6892) String() string { return proto.CompactTextString(m) }
func (*BlkSlu_6892) ProtoMessage()    {}
func (*BlkSlu_6892) Descriptor() ([]byte, []int) {
	return fileDescriptor_905abe2d3bf4d8dd, []int{5}
}
func (m *BlkSlu_6892) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlkSlu_6892) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlkSlu_6892.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlkSlu_6892) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlkSlu_6892.Merge(m, src)
}
func (m *BlkSlu_6892) XXX_Size() int {
	return m.Size()
}
func (m *BlkSlu_6892) XXX_DiscardUnknown() {
	xxx_messageInfo_BlkSlu_6892.DiscardUnknown(m)
}

var xxx_messageInfo_BlkSlu_6892 proto.InternalMessageInfo

func (m *BlkSlu_6892) GetSluId() int32 {
	if m != nil {
		return m.SluId
	}
	return 0
}

func (m *BlkSlu_6892) GetSluitemData() []*BlkSlu_6892_SluitemData {
	if m != nil {
		return m.SluitemData
	}
	return nil
}

type BlkSlu_6892_SluitemData struct {
	// 依次各灯头电压
	Voltage []float64 `protobuf:"fixed64,1,rep,packed,name=voltage,proto3" json:"voltage,omitempty"`
	// 依次各灯头电流
	Current []float64 `protobuf:"fixed64,2,rep,packed,name=current,proto3" json:"current,omitempty"`
	// 依次各灯头功率
	Power []float64 `protobuf:"fixed64,3,rep,packed,name=power,proto3" json:"power,omitempty"`
	// 依次各灯头错误代码，0-关灯正常,1-关灯有电流，8-开灯正常，9-开灯无电流，10-开灯功率因数低，255-设备通讯故障
	Error []int32 `protobuf:"varint,5,rep,packed,name=error,proto3" json:"error,omitempty"`
	// 依次各灯头节点
	Node []int32 `protobuf:"varint,6,rep,packed,name=node,proto3" json:"node,omitempty"`
	// 控制器地址
	SluitemId int32 `protobuf:"varint,7,opt,name=sluitem_id,json=sluitemId,proto3" json:"sluitem_id,omitempty"`
	// 控制器回路数量
	SluitemLoop int32 `protobuf:"varint,8,opt,name=sluitem_loop,json=sluitemLoop,proto3" json:"sluitem_loop,omitempty"`
}

func (m *BlkSlu_6892_SluitemData) Reset()         { *m = BlkSlu_6892_SluitemData{} }
func (m *BlkSlu_6892_SluitemData) String() string { return proto.CompactTextString(m) }
func (*BlkSlu_6892_SluitemData) ProtoMessage()    {}
func (*BlkSlu_6892_SluitemData) Descriptor() ([]byte, []int) {
	return fileDescriptor_905abe2d3bf4d8dd, []int{5, 0}
}
func (m *BlkSlu_6892_SluitemData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlkSlu_6892_SluitemData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlkSlu_6892_SluitemData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlkSlu_6892_SluitemData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlkSlu_6892_SluitemData.Merge(m, src)
}
func (m *BlkSlu_6892_SluitemData) XXX_Size() int {
	return m.Size()
}
func (m *BlkSlu_6892_SluitemData) XXX_DiscardUnknown() {
	xxx_messageInfo_BlkSlu_6892_SluitemData.DiscardUnknown(m)
}

var xxx_messageInfo_BlkSlu_6892_SluitemData proto.InternalMessageInfo

func (m *BlkSlu_6892_SluitemData) GetVoltage() []float64 {
	if m != nil {
		return m.Voltage
	}
	return nil
}

func (m *BlkSlu_6892_SluitemData) GetCurrent() []float64 {
	if m != nil {
		return m.Current
	}
	return nil
}

func (m *BlkSlu_6892_SluitemData) GetPower() []float64 {
	if m != nil {
		return m.Power
	}
	return nil
}

func (m *BlkSlu_6892_SluitemData) GetError() []int32 {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *BlkSlu_6892_SluitemData) GetNode() []int32 {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *BlkSlu_6892_SluitemData) GetSluitemId() int32 {
	if m != nil {
		return m.SluitemId
	}
	return 0
}

func (m *BlkSlu_6892_SluitemData) GetSluitemLoop() int32 {
	if m != nil {
		return m.SluitemLoop
	}
	return 0
}

type BlkSlu_6895 struct {
	// 高地址（集中器地址）
	SluId int32 `protobuf:"varint,1,opt,name=slu_id,json=sluId,proto3" json:"slu_id,omitempty"`
	// addr_type==3时表示组地址，addr_type==4时表示单个控制器地址（单个控制器地址为255时下发0x1,0x1）
	SluitemId int32 `protobuf:"varint,2,opt,name=sluitem_id,json=sluitemId,proto3" json:"sluitem_id,omitempty"`
	// 地址类型，0-全部，1-单号，2-双号，3-组，4-单一
	AddrType int32 `protobuf:"varint,3,opt,name=addr_type,json=addrType,proto3" json:"addr_type,omitempty"`
	// 指令类型,0-清除，1-定时，3-即时
	OperationType int32 `protobuf:"varint,4,opt,name=operation_type,json=operationType,proto3" json:"operation_type,omitempty"`
	// 控制方式,按灯头数量填充，0-关灯，1-开灯，2-不操作，10～100-调光
	OperationValue []int32 `protobuf:"varint,5,rep,packed,name=operation_value,json=operationValue,proto3" json:"operation_value,omitempty"`
	// 定时序号,范围1-5
	TimerId int32 `protobuf:"varint,6,opt,name=timer_id,json=timerId,proto3" json:"timer_id,omitempty"`
	// 周设置，[周1,2,3,4,5,6,7],0-不操作，1-操作
	WeekSet []int32 `protobuf:"varint,7,rep,packed,name=week_set,json=weekSet,proto3" json:"week_set,omitempty"`
	// 时间hh×60+mm
	TimeSet int32 `protobuf:"varint,8,opt,name=time_set,json=timeSet,proto3" json:"time_set,omitempty"`
	// 命令序号，范围0-255
	CmdIdx int32 `protobuf:"varint,9,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 执行状态，0-失败，1-成功
	Status int32 `protobuf:"varint,10,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *BlkSlu_6895) Reset()         { *m = BlkSlu_6895{} }
func (m *BlkSlu_6895) String() string { return proto.CompactTextString(m) }
func (*BlkSlu_6895) ProtoMessage()    {}
func (*BlkSlu_6895) Descriptor() ([]byte, []int) {
	return fileDescriptor_905abe2d3bf4d8dd, []int{6}
}
func (m *BlkSlu_6895) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlkSlu_6895) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlkSlu_6895.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlkSlu_6895) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlkSlu_6895.Merge(m, src)
}
func (m *BlkSlu_6895) XXX_Size() int {
	return m.Size()
}
func (m *BlkSlu_6895) XXX_DiscardUnknown() {
	xxx_messageInfo_BlkSlu_6895.DiscardUnknown(m)
}

var xxx_messageInfo_BlkSlu_6895 proto.InternalMessageInfo

func (m *BlkSlu_6895) GetSluId() int32 {
	if m != nil {
		return m.SluId
	}
	return 0
}

func (m *BlkSlu_6895) GetSluitemId() int32 {
	if m != nil {
		return m.SluitemId
	}
	return 0
}

func (m *BlkSlu_6895) GetAddrType() int32 {
	if m != nil {
		return m.AddrType
	}
	return 0
}

func (m *BlkSlu_6895) GetOperationType() int32 {
	if m != nil {
		return m.OperationType
	}
	return 0
}

func (m *BlkSlu_6895) GetOperationValue() []int32 {
	if m != nil {
		return m.OperationValue
	}
	return nil
}

func (m *BlkSlu_6895) GetTimerId() int32 {
	if m != nil {
		return m.TimerId
	}
	return 0
}

func (m *BlkSlu_6895) GetWeekSet() []int32 {
	if m != nil {
		return m.WeekSet
	}
	return nil
}

func (m *BlkSlu_6895) GetTimeSet() int32 {
	if m != nil {
		return m.TimeSet
	}
	return 0
}

func (m *BlkSlu_6895) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *BlkSlu_6895) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

// 远帆除湿
// 读取数据
type YfDry_0300 struct {
	Addr                int32 `protobuf:"varint,1,opt,name=addr,proto3" json:"addr,omitempty"`
	CtlStatus           int32 `protobuf:"varint,2,opt,name=ctl_status,json=ctlStatus,proto3" json:"ctl_status,omitempty"`
	DewPoint            int32 `protobuf:"varint,3,opt,name=dew_point,json=dewPoint,proto3" json:"dew_point,omitempty"`
	Humidity            int32 `protobuf:"varint,4,opt,name=humidity,proto3" json:"humidity,omitempty"`
	Temperature         int32 `protobuf:"varint,5,opt,name=temperature,proto3" json:"temperature,omitempty"`
	HumidityUplimit     int32 `protobuf:"varint,6,opt,name=humidity_uplimit,json=humidityUplimit,proto3" json:"humidity_uplimit,omitempty"`
	HumidityLowlimit    int32 `protobuf:"varint,7,opt,name=humidity_lowlimit,json=humidityLowlimit,proto3" json:"humidity_lowlimit,omitempty"`
	TemperatureUplimit  int32 `protobuf:"varint,8,opt,name=temperature_uplimit,json=temperatureUplimit,proto3" json:"temperature_uplimit,omitempty"`
	TemperatureLowlimit int32 `protobuf:"varint,9,opt,name=temperature_lowlimit,json=temperatureLowlimit,proto3" json:"temperature_lowlimit,omitempty"`
}

func (m *YfDry_0300) Reset()         { *m = YfDry_0300{} }
func (m *YfDry_0300) String() string { return proto.CompactTextString(m) }
func (*YfDry_0300) ProtoMessage()    {}
func (*YfDry_0300) Descriptor() ([]byte, []int) {
	return fileDescriptor_905abe2d3bf4d8dd, []int{7}
}
func (m *YfDry_0300) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *YfDry_0300) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_YfDry_0300.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *YfDry_0300) XXX_Merge(src proto.Message) {
	xxx_messageInfo_YfDry_0300.Merge(m, src)
}
func (m *YfDry_0300) XXX_Size() int {
	return m.Size()
}
func (m *YfDry_0300) XXX_DiscardUnknown() {
	xxx_messageInfo_YfDry_0300.DiscardUnknown(m)
}

var xxx_messageInfo_YfDry_0300 proto.InternalMessageInfo

func (m *YfDry_0300) GetAddr() int32 {
	if m != nil {
		return m.Addr
	}
	return 0
}

func (m *YfDry_0300) GetCtlStatus() int32 {
	if m != nil {
		return m.CtlStatus
	}
	return 0
}

func (m *YfDry_0300) GetDewPoint() int32 {
	if m != nil {
		return m.DewPoint
	}
	return 0
}

func (m *YfDry_0300) GetHumidity() int32 {
	if m != nil {
		return m.Humidity
	}
	return 0
}

func (m *YfDry_0300) GetTemperature() int32 {
	if m != nil {
		return m.Temperature
	}
	return 0
}

func (m *YfDry_0300) GetHumidityUplimit() int32 {
	if m != nil {
		return m.HumidityUplimit
	}
	return 0
}

func (m *YfDry_0300) GetHumidityLowlimit() int32 {
	if m != nil {
		return m.HumidityLowlimit
	}
	return 0
}

func (m *YfDry_0300) GetTemperatureUplimit() int32 {
	if m != nil {
		return m.TemperatureUplimit
	}
	return 0
}

func (m *YfDry_0300) GetTemperatureLowlimit() int32 {
	if m != nil {
		return m.TemperatureLowlimit
	}
	return 0
}

// 设置参数
type YfDry_1005 struct {
	Addr                int32 `protobuf:"varint,1,opt,name=addr,proto3" json:"addr,omitempty"`
	HumidityUplimit     int32 `protobuf:"varint,6,opt,name=humidity_uplimit,json=humidityUplimit,proto3" json:"humidity_uplimit,omitempty"`
	HumidityLowlimit    int32 `protobuf:"varint,7,opt,name=humidity_lowlimit,json=humidityLowlimit,proto3" json:"humidity_lowlimit,omitempty"`
	TemperatureUplimit  int32 `protobuf:"varint,8,opt,name=temperature_uplimit,json=temperatureUplimit,proto3" json:"temperature_uplimit,omitempty"`
	TemperatureLowlimit int32 `protobuf:"varint,9,opt,name=temperature_lowlimit,json=temperatureLowlimit,proto3" json:"temperature_lowlimit,omitempty"`
}

func (m *YfDry_1005) Reset()         { *m = YfDry_1005{} }
func (m *YfDry_1005) String() string { return proto.CompactTextString(m) }
func (*YfDry_1005) ProtoMessage()    {}
func (*YfDry_1005) Descriptor() ([]byte, []int) {
	return fileDescriptor_905abe2d3bf4d8dd, []int{8}
}
func (m *YfDry_1005) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *YfDry_1005) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_YfDry_1005.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *YfDry_1005) XXX_Merge(src proto.Message) {
	xxx_messageInfo_YfDry_1005.Merge(m, src)
}
func (m *YfDry_1005) XXX_Size() int {
	return m.Size()
}
func (m *YfDry_1005) XXX_DiscardUnknown() {
	xxx_messageInfo_YfDry_1005.DiscardUnknown(m)
}

var xxx_messageInfo_YfDry_1005 proto.InternalMessageInfo

func (m *YfDry_1005) GetAddr() int32 {
	if m != nil {
		return m.Addr
	}
	return 0
}

func (m *YfDry_1005) GetHumidityUplimit() int32 {
	if m != nil {
		return m.HumidityUplimit
	}
	return 0
}

func (m *YfDry_1005) GetHumidityLowlimit() int32 {
	if m != nil {
		return m.HumidityLowlimit
	}
	return 0
}

func (m *YfDry_1005) GetTemperatureUplimit() int32 {
	if m != nil {
		return m.TemperatureUplimit
	}
	return 0
}

func (m *YfDry_1005) GetTemperatureLowlimit() int32 {
	if m != nil {
		return m.TemperatureLowlimit
	}
	return 0
}

// 运行控制
type YfDry_1001 struct {
	Addr      int32 `protobuf:"varint,1,opt,name=addr,proto3" json:"addr,omitempty"`
	CtlStatus int32 `protobuf:"varint,2,opt,name=ctl_status,json=ctlStatus,proto3" json:"ctl_status,omitempty"`
}

func (m *YfDry_1001) Reset()         { *m = YfDry_1001{} }
func (m *YfDry_1001) String() string { return proto.CompactTextString(m) }
func (*YfDry_1001) ProtoMessage()    {}
func (*YfDry_1001) Descriptor() ([]byte, []int) {
	return fileDescriptor_905abe2d3bf4d8dd, []int{9}
}
func (m *YfDry_1001) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *YfDry_1001) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_YfDry_1001.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *YfDry_1001) XXX_Merge(src proto.Message) {
	xxx_messageInfo_YfDry_1001.Merge(m, src)
}
func (m *YfDry_1001) XXX_Size() int {
	return m.Size()
}
func (m *YfDry_1001) XXX_DiscardUnknown() {
	xxx_messageInfo_YfDry_1001.DiscardUnknown(m)
}

var xxx_messageInfo_YfDry_1001 proto.InternalMessageInfo

func (m *YfDry_1001) GetAddr() int32 {
	if m != nil {
		return m.Addr
	}
	return 0
}

func (m *YfDry_1001) GetCtlStatus() int32 {
	if m != nil {
		return m.CtlStatus
	}
	return 0
}

func init() {
	proto.RegisterType((*AhhfRtu_6804)(nil), "wlst.pb2.Ahhf_rtu_6804")
	proto.RegisterType((*AhhfRtu_6804_SwitchOut)(nil), "wlst.pb2.Ahhf_rtu_6804.Switch_out")
	proto.RegisterType((*AhhfRtu_6804_SwitchIn)(nil), "wlst.pb2.Ahhf_rtu_6804.Switch_in")
	proto.RegisterType((*AhhfRtu_6804_SwitchInLimit)(nil), "wlst.pb2.Ahhf_rtu_6804.Switch_in_limit")
	proto.RegisterType((*WxjyEsu_5500)(nil), "wlst.pb2.Wxjy_esu_5500")
	proto.RegisterType((*WxjyEsuD700)(nil), "wlst.pb2.Wxjy_esu_d700")
	proto.RegisterType((*WxjyEsuD800)(nil), "wlst.pb2.Wxjy_esu_d800")
	proto.RegisterType((*BlkSlu_6891)(nil), "wlst.pb2.Blk_slu_6891")
	proto.RegisterType((*BlkSlu_6892)(nil), "wlst.pb2.Blk_slu_6892")
	proto.RegisterType((*BlkSlu_6892_SluitemData)(nil), "wlst.pb2.Blk_slu_6892.Sluitem_data")
	proto.RegisterType((*BlkSlu_6895)(nil), "wlst.pb2.Blk_slu_6895")
	proto.RegisterType((*YfDry_0300)(nil), "wlst.pb2.Yf_dry_0300")
	proto.RegisterType((*YfDry_1005)(nil), "wlst.pb2.Yf_dry_1005")
	proto.RegisterType((*YfDry_1001)(nil), "wlst.pb2.Yf_dry_1001")
}

func init() { proto.RegisterFile("protocol_tp.proto", fileDescriptor_905abe2d3bf4d8dd) }

var fileDescriptor_905abe2d3bf4d8dd = []byte{
	// 1069 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x56, 0xdd, 0x6e, 0x1b, 0x45,
	0x14, 0xce, 0xda, 0xf1, 0xdf, 0x71, 0x9c, 0xa4, 0x13, 0x28, 0x5b, 0x53, 0x4c, 0x62, 0x54, 0x25,
	0x10, 0xe1, 0x6e, 0x12, 0x02, 0xe5, 0x06, 0x91, 0x04, 0x21, 0x2c, 0x05, 0x52, 0x39, 0xa1, 0x88,
	0xab, 0xd1, 0xc6, 0x3b, 0x69, 0x96, 0xec, 0xee, 0xac, 0x76, 0x67, 0x6b, 0xe7, 0x2d, 0x78, 0x0e,
	0x5e, 0x00, 0xf1, 0x06, 0xe5, 0xae, 0x77, 0xf4, 0x06, 0x09, 0x25, 0x17, 0xf0, 0x18, 0x68, 0x7e,
	0x77, 0x6c, 0x81, 0x2a, 0xf5, 0xae, 0x77, 0x9e, 0xef, 0x3b, 0xf3, 0xcd, 0x39, 0xdf, 0x9c, 0x33,
	0x6b, 0xb8, 0x93, 0x66, 0x94, 0xd1, 0x31, 0x8d, 0x30, 0x4b, 0x07, 0xe2, 0x37, 0x6a, 0x4e, 0xa2,
	0x9c, 0x0d, 0xd2, 0xf3, 0xdd, 0xfe, 0xdf, 0x75, 0xe8, 0x1c, 0x5c, 0x5e, 0x5e, 0xe0, 0x8c, 0x15,
	0xf8, 0xd3, 0x47, 0xde, 0x27, 0xe8, 0x1d, 0x68, 0x8c, 0xe3, 0x00, 0x87, 0xc1, 0xd4, 0x75, 0xd6,
	0x9d, 0xad, 0xda, 0xa8, 0x3e, 0x8e, 0x83, 0x61, 0x30, 0x45, 0xef, 0x43, 0x2b, 0xf0, 0x99, 0x8f,
	0x63, 0x3f, 0xbb, 0x72, 0x2b, 0xeb, 0xd5, 0xad, 0xda, 0x61, 0x65, 0xd5, 0x19, 0x35, 0x39, 0xf8,
	0xad, 0x9f, 0x5d, 0xa1, 0x0d, 0x00, 0x11, 0x90, 0xd2, 0x30, 0x61, 0x6e, 0xd5, 0x44, 0x88, 0x6d,
	0x8f, 0x39, 0x88, 0x0e, 0x00, 0xf2, 0x49, 0xc8, 0xc6, 0x97, 0x98, 0x16, 0xcc, 0x5d, 0x5c, 0x77,
	0xb6, 0xda, 0xbb, 0xfd, 0x81, 0xce, 0x66, 0x30, 0x93, 0xc9, 0xe0, 0xd4, 0x44, 0x8e, 0x5a, 0x72,
	0xd7, 0x49, 0xc1, 0xd0, 0x17, 0xa0, 0x16, 0x38, 0x4c, 0xdc, 0x9a, 0x50, 0xd8, 0x78, 0x85, 0x42,
	0x98, 0x8c, 0x9a, 0x72, 0xcf, 0x30, 0x41, 0x27, 0xb0, 0x62, 0xf6, 0xe3, 0x28, 0x8c, 0x43, 0xe6,
	0xd6, 0x85, 0xca, 0xe6, 0x2b, 0x55, 0x64, 0xf8, 0xa8, 0xa3, 0xb5, 0x8e, 0xf9, 0x12, 0x75, 0xa1,
	0x9e, 0x33, 0x9f, 0x15, 0xb9, 0xdb, 0x32, 0x25, 0x2b, 0xa4, 0x7b, 0x0e, 0x50, 0x56, 0x81, 0xb6,
	0x60, 0xb5, 0xac, 0x1e, 0x33, 0xca, 0xfc, 0x48, 0x79, 0xbc, 0x6c, 0xea, 0x3b, 0xe3, 0x28, 0xfa,
	0xc8, 0x24, 0xc9, 0x23, 0x23, 0x4a, 0x53, 0xcb, 0xf1, 0x8e, 0x09, 0x3e, 0xa6, 0x34, 0xed, 0xfe,
	0xe6, 0x40, 0xcb, 0xa4, 0x88, 0x1e, 0xc2, 0xda, 0x33, 0x1a, 0x31, 0xff, 0x29, 0xc1, 0x2c, 0xf3,
	0x93, 0xfc, 0x82, 0x66, 0x31, 0xc9, 0xd4, 0x31, 0x48, 0x51, 0x67, 0x25, 0x83, 0xde, 0x03, 0xe0,
	0xfa, 0x2a, 0x9d, 0x8a, 0x88, 0x6b, 0x71, 0x44, 0x66, 0xb2, 0x07, 0x6b, 0xe3, 0x22, 0xcb, 0x48,
	0xc2, 0x66, 0xf4, 0xca, 0xdb, 0x45, 0x8a, 0xb6, 0x35, 0x37, 0xa1, 0xa3, 0x37, 0xa5, 0x97, 0x7e,
	0x4e, 0xdc, 0x45, 0x13, 0xbe, 0xa4, 0x88, 0xc7, 0x1c, 0xef, 0xfe, 0xe3, 0xc0, 0xca, 0x9c, 0xbd,
	0x73, 0x09, 0xd5, 0xe6, 0x13, 0xda, 0x86, 0x15, 0x5d, 0x60, 0x91, 0xca, 0xfb, 0x73, 0xd6, 0xab,
	0x5b, 0x8e, 0x50, 0x5f, 0x56, 0xd4, 0xf7, 0x92, 0x41, 0x1f, 0xc3, 0xaa, 0x0e, 0x8e, 0xe8, 0x44,
	0x46, 0x57, 0x4c, 0xb4, 0x16, 0x3a, 0x56, 0x14, 0xd7, 0xd6, 0x79, 0x6b, 0xed, 0x6a, 0xa9, 0xad,
	0x28, 0x4b, 0x5b, 0x07, 0x1b, 0xed, 0xc5, 0x52, 0x5b, 0x71, 0x5a, 0xbb, 0x7f, 0x01, 0x9d, 0x1f,
	0xa6, 0x3f, 0x5d, 0x63, 0x92, 0x17, 0x78, 0x7f, 0xdf, 0xf3, 0xd0, 0x3d, 0x68, 0xb2, 0x30, 0x26,
	0x38, 0xa1, 0x13, 0x71, 0x3d, 0xad, 0x51, 0x83, 0xaf, 0xbf, 0xa3, 0x13, 0x74, 0x0f, 0xea, 0x53,
	0xcc, 0x17, 0xd6, 0xad, 0xd7, 0xa6, 0x67, 0x61, 0x4c, 0xf8, 0x14, 0x4e, 0xb1, 0xca, 0xdb, 0xba,
	0x85, 0xe6, 0xf4, 0x89, 0xc4, 0xfa, 0xbf, 0x3b, 0xd6, 0x41, 0xc1, 0x67, 0x9e, 0x87, 0xee, 0x03,
	0x88, 0x5b, 0xc0, 0x3e, 0x1f, 0x19, 0xd9, 0x09, 0x4d, 0x81, 0x1c, 0x0c, 0x93, 0x92, 0x3d, 0xe7,
	0x6c, 0xc5, 0x62, 0x0f, 0x6d, 0x76, 0xcc, 0xd9, 0xaa, 0xc5, 0x1e, 0x0d, 0x13, 0xd4, 0x83, 0xb6,
	0x56, 0xd6, 0xf3, 0x5c, 0x1b, 0xb5, 0xa4, 0x34, 0x9f, 0x55, 0xc3, 0x9f, 0x0b, 0xbe, 0x66, 0xf1,
	0x87, 0x33, 0xfc, 0x58, 0xf0, 0x75, 0x8b, 0x3f, 0x3a, 0x29, 0x58, 0x7f, 0xd3, 0x2e, 0xe5, 0x91,
	0xe7, 0xa1, 0xbb, 0x66, 0xd6, 0xa4, 0x63, 0x6a, 0xd5, 0xff, 0xc5, 0x81, 0xa5, 0xc3, 0xe8, 0x0a,
	0xe7, 0x11, 0x9f, 0xd9, 0xcf, 0x77, 0xd0, 0xdb, 0x50, 0xe7, 0xbf, 0xc3, 0x40, 0xd5, 0x5b, 0xcb,
	0xa3, 0x62, 0x18, 0xf0, 0xde, 0xca, 0xa3, 0x22, 0x64, 0x24, 0xe6, 0x94, 0x6a, 0x76, 0x85, 0x0c,
	0x03, 0xf4, 0x00, 0x96, 0x35, 0x3d, 0xa6, 0xc9, 0x45, 0xf8, 0x54, 0x54, 0x5c, 0x1d, 0x75, 0x14,
	0x7a, 0x24, 0x40, 0xf4, 0x00, 0x96, 0x74, 0x98, 0x18, 0xcd, 0xb2, 0xbb, 0xdb, 0x0a, 0xe7, 0x83,
	0x69, 0x25, 0x2b, 0x0b, 0xd7, 0xc9, 0x3e, 0xaf, 0xcc, 0x24, 0xbb, 0xfb, 0x7f, 0xc9, 0x7e, 0x5d,
	0x1e, 0xc3, 0x5f, 0x50, 0xd1, 0x0b, 0xed, 0xdd, 0x0f, 0xca, 0x67, 0xca, 0x16, 0x19, 0x9c, 0x5a,
	0xa1, 0x26, 0x8f, 0xaf, 0x7c, 0xe6, 0x77, 0x5f, 0x3a, 0xb0, 0x64, 0xb3, 0xe8, 0x3e, 0x34, 0x74,
	0x07, 0x95, 0xa3, 0xa3, 0x21, 0xce, 0xaa, 0xde, 0xb5, 0x46, 0x45, 0x43, 0xc8, 0x85, 0x5a, 0x4a,
	0x27, 0xea, 0x05, 0x90, 0x9c, 0x04, 0x38, 0x43, 0xb2, 0x8c, 0x66, 0x6e, 0xad, 0xec, 0x59, 0x01,
	0xa0, 0xbb, 0xb0, 0x98, 0xd0, 0x80, 0xb8, 0x75, 0x43, 0x88, 0xf5, 0xdc, 0x6d, 0x34, 0xe6, 0x6f,
	0x63, 0x63, 0xce, 0xe6, 0xa6, 0x08, 0xb0, 0x2d, 0xee, 0xff, 0x3a, 0x6b, 0xe5, 0xfe, 0x6b, 0xde,
	0xfb, 0xbb, 0xd0, 0xf2, 0x83, 0x20, 0xc3, 0xec, 0x3a, 0x25, 0xba, 0xc9, 0x39, 0x70, 0x76, 0x9d,
	0x12, 0xde, 0x14, 0x34, 0x25, 0x99, 0xcf, 0x42, 0x9a, 0xc8, 0x08, 0xd9, 0xe7, 0x1d, 0x83, 0x8a,
	0xb0, 0x6d, 0x58, 0x29, 0xc3, 0x9e, 0xf9, 0x51, 0x41, 0x2c, 0x23, 0x4a, 0x85, 0x27, 0x9c, 0xd1,
	0xb3, 0x9f, 0xf1, 0x6c, 0x64, 0xd7, 0x8b, 0xd9, 0xcf, 0x86, 0x01, 0xa7, 0x26, 0x84, 0x5c, 0xe1,
	0x9c, 0x30, 0xb7, 0xc1, 0x05, 0x46, 0x0d, 0xbe, 0x3e, 0x25, 0xcc, 0xbc, 0x18, 0x9c, 0x6a, 0x96,
	0xbb, 0x38, 0x65, 0x7d, 0xb5, 0x5b, 0x33, 0x5f, 0xed, 0xb2, 0x09, 0x61, 0xa6, 0x09, 0xff, 0xa8,
	0x40, 0xfb, 0xc7, 0x0b, 0x1c, 0x64, 0xd7, 0xd8, 0xdb, 0xf3, 0x3c, 0x84, 0x60, 0x91, 0x57, 0xac,
	0x6c, 0x13, 0xbf, 0xb9, 0x6b, 0x63, 0x16, 0x61, 0xb5, 0x5f, 0xb9, 0x36, 0x66, 0xd1, 0xa9, 0x00,
	0xb8, 0x6b, 0x01, 0x99, 0x98, 0xcf, 0xbd, 0x70, 0x2d, 0x20, 0x13, 0xf9, 0xa5, 0xef, 0x42, 0xf3,
	0xb2, 0x88, 0xc3, 0x20, 0x64, 0xd7, 0xca, 0x2f, 0xb3, 0x46, 0xeb, 0xd0, 0x66, 0x24, 0x16, 0x8e,
	0x14, 0x19, 0x51, 0xd3, 0x61, 0x43, 0xe8, 0x43, 0x58, 0xd5, 0xd1, 0xe6, 0x25, 0x96, 0x3e, 0xad,
	0x68, 0x5c, 0x3f, 0xc3, 0xdb, 0x70, 0xc7, 0x84, 0x9a, 0x77, 0x58, 0xf6, 0x92, 0xd1, 0x30, 0x0f,
	0xfc, 0x43, 0x58, 0xb3, 0x8e, 0x31, 0xd2, 0xd2, 0x4c, 0x64, 0x51, 0x5a, 0x7d, 0x07, 0xde, 0xb2,
	0x37, 0x98, 0x03, 0xa4, 0xc9, 0xb6, 0x98, 0x79, 0xe8, 0xff, 0x74, 0x8c, 0xb3, 0x3b, 0x9e, 0xb7,
	0xff, 0x9f, 0xce, 0xbe, 0xc9, 0xf5, 0x7d, 0x69, 0x97, 0xb7, 0xf3, 0x1a, 0x8d, 0x73, 0xd8, 0x7d,
	0x7e, 0xd3, 0x73, 0x5e, 0xdc, 0xf4, 0x9c, 0xbf, 0x6e, 0x7a, 0xce, 0xcf, 0xb7, 0xbd, 0x85, 0x17,
	0xb7, 0xbd, 0x85, 0x97, 0xb7, 0xbd, 0x85, 0x6f, 0x9c, 0xf3, 0xba, 0xf8, 0x87, 0xba, 0xf7, 0x6f,
	0x00, 0x00, 0x00, 0xff, 0xff, 0xf4, 0xab, 0x77, 0x8e, 0xb6, 0x0a, 0x00, 0x00,
}

func (m *AhhfRtu_6804) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AhhfRtu_6804) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AhhfRtu_6804) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Status) > 0 {
		dAtA2 := make([]byte, len(m.Status)*10)
		var j1 int
		for _, num1 := range m.Status {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintProtocolTp(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x4a
	}
	if m.SwitchInLimit != nil {
		{
			size, err := m.SwitchInLimit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocolTp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.SwitchIn != nil {
		{
			size, err := m.SwitchIn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocolTp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.SwitchOut != nil {
		{
			size, err := m.SwitchOut.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocolTp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.DataPoint) > 0 {
		dAtA7 := make([]byte, len(m.DataPoint)*10)
		var j6 int
		for _, num1 := range m.DataPoint {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		i -= j6
		copy(dAtA[i:], dAtA7[:j6])
		i = encodeVarintProtocolTp(dAtA, i, uint64(j6))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DataMark) > 0 {
		dAtA9 := make([]byte, len(m.DataMark)*10)
		var j8 int
		for _, num1 := range m.DataMark {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		i -= j8
		copy(dAtA[i:], dAtA9[:j8])
		i = encodeVarintProtocolTp(dAtA, i, uint64(j8))
		i--
		dAtA[i] = 0x12
	}
	if m.CmdIdx != 0 {
		i = encodeVarintProtocolTp(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AhhfRtu_6804_SwitchOut) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AhhfRtu_6804_SwitchOut) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AhhfRtu_6804_SwitchOut) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SwitchOutLoop) > 0 {
		dAtA11 := make([]byte, len(m.SwitchOutLoop)*10)
		var j10 int
		for _, num1 := range m.SwitchOutLoop {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		i -= j10
		copy(dAtA[i:], dAtA11[:j10])
		i = encodeVarintProtocolTp(dAtA, i, uint64(j10))
		i--
		dAtA[i] = 0x12
	}
	if m.SwitchOutTotal != 0 {
		i = encodeVarintProtocolTp(dAtA, i, uint64(m.SwitchOutTotal))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AhhfRtu_6804_SwitchIn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AhhfRtu_6804_SwitchIn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AhhfRtu_6804_SwitchIn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CurrentPhase) > 0 {
		dAtA13 := make([]byte, len(m.CurrentPhase)*10)
		var j12 int
		for _, num1 := range m.CurrentPhase {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA13[j12] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j12++
			}
			dAtA13[j12] = uint8(num)
			j12++
		}
		i -= j12
		copy(dAtA[i:], dAtA13[:j12])
		i = encodeVarintProtocolTp(dAtA, i, uint64(j12))
		i--
		dAtA[i] = 0x22
	}
	if len(m.CurrentTransformer) > 0 {
		dAtA15 := make([]byte, len(m.CurrentTransformer)*10)
		var j14 int
		for _, num1 := range m.CurrentTransformer {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA15[j14] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j14++
			}
			dAtA15[j14] = uint8(num)
			j14++
		}
		i -= j14
		copy(dAtA[i:], dAtA15[:j14])
		i = encodeVarintProtocolTp(dAtA, i, uint64(j14))
		i--
		dAtA[i] = 0x1a
	}
	if m.LoopTotal != 0 {
		i = encodeVarintProtocolTp(dAtA, i, uint64(m.LoopTotal))
		i--
		dAtA[i] = 0x10
	}
	if m.VoltageTransformer != 0 {
		i = encodeVarintProtocolTp(dAtA, i, uint64(m.VoltageTransformer))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AhhfRtu_6804_SwitchInLimit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AhhfRtu_6804_SwitchInLimit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AhhfRtu_6804_SwitchInLimit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LoopTotal != 0 {
		i = encodeVarintProtocolTp(dAtA, i, uint64(m.LoopTotal))
		i--
		dAtA[i] = 0x28
	}
	if len(m.CurrentLowlimit) > 0 {
		for iNdEx := len(m.CurrentLowlimit) - 1; iNdEx >= 0; iNdEx-- {
			f16 := math.Float64bits(float64(m.CurrentLowlimit[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f16))
		}
		i = encodeVarintProtocolTp(dAtA, i, uint64(len(m.CurrentLowlimit)*8))
		i--
		dAtA[i] = 0x22
	}
	if len(m.CurrentUplimit) > 0 {
		for iNdEx := len(m.CurrentUplimit) - 1; iNdEx >= 0; iNdEx-- {
			f17 := math.Float64bits(float64(m.CurrentUplimit[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f17))
		}
		i = encodeVarintProtocolTp(dAtA, i, uint64(len(m.CurrentUplimit)*8))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.VoltageLowlimit) > 0 {
		for iNdEx := len(m.VoltageLowlimit) - 1; iNdEx >= 0; iNdEx-- {
			f18 := math.Float64bits(float64(m.VoltageLowlimit[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f18))
		}
		i = encodeVarintProtocolTp(dAtA, i, uint64(len(m.VoltageLowlimit)*8))
		i--
		dAtA[i] = 0x12
	}
	if len(m.VoltageUplimit) > 0 {
		for iNdEx := len(m.VoltageUplimit) - 1; iNdEx >= 0; iNdEx-- {
			f19 := math.Float64bits(float64(m.VoltageUplimit[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f19))
		}
		i = encodeVarintProtocolTp(dAtA, i, uint64(len(m.VoltageUplimit)*8))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WxjyEsu_5500) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WxjyEsu_5500) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WxjyEsu_5500) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.XVoltage) > 0 {
		dAtA21 := make([]byte, len(m.XVoltage)*10)
		var j20 int
		for _, num1 := range m.XVoltage {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA21[j20] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j20++
			}
			dAtA21[j20] = uint8(num)
			j20++
		}
		i -= j20
		copy(dAtA[i:], dAtA21[:j20])
		i = encodeVarintProtocolTp(dAtA, i, uint64(j20))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.XTime) > 0 {
		dAtA23 := make([]byte, len(m.XTime)*10)
		var j22 int
		for _, num1 := range m.XTime {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA23[j22] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j22++
			}
			dAtA23[j22] = uint8(num)
			j22++
		}
		i -= j22
		copy(dAtA[i:], dAtA23[:j22])
		i = encodeVarintProtocolTp(dAtA, i, uint64(j22))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TimeNow) > 0 {
		i -= len(m.TimeNow)
		copy(dAtA[i:], m.TimeNow)
		i = encodeVarintProtocolTp(dAtA, i, uint64(len(m.TimeNow)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WxjyEsuD700) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WxjyEsuD700) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WxjyEsuD700) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PhaseCOut != 0 {
		i = encodeVarintProtocolTp(dAtA, i, uint64(m.PhaseCOut))
		i--
		dAtA[i] = 0x30
	}
	if m.PhaseBOut != 0 {
		i = encodeVarintProtocolTp(dAtA, i, uint64(m.PhaseBOut))
		i--
		dAtA[i] = 0x28
	}
	if m.PhaseAOut != 0 {
		i = encodeVarintProtocolTp(dAtA, i, uint64(m.PhaseAOut))
		i--
		dAtA[i] = 0x20
	}
	if m.PhaseCIn != 0 {
		i = encodeVarintProtocolTp(dAtA, i, uint64(m.PhaseCIn))
		i--
		dAtA[i] = 0x18
	}
	if m.PhaseBIn != 0 {
		i = encodeVarintProtocolTp(dAtA, i, uint64(m.PhaseBIn))
		i--
		dAtA[i] = 0x10
	}
	if m.PhaseAIn != 0 {
		i = encodeVarintProtocolTp(dAtA, i, uint64(m.PhaseAIn))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WxjyEsuD800) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WxjyEsuD800) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WxjyEsuD800) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintProtocolTp(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlkSlu_6891) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlkSlu_6891) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlkSlu_6891) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintProtocolTp(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x28
	}
	if len(m.SluitemLoop) > 0 {
		dAtA25 := make([]byte, len(m.SluitemLoop)*10)
		var j24 int
		for _, num1 := range m.SluitemLoop {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA25[j24] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j24++
			}
			dAtA25[j24] = uint8(num)
			j24++
		}
		i -= j24
		copy(dAtA[i:], dAtA25[:j24])
		i = encodeVarintProtocolTp(dAtA, i, uint64(j24))
		i--
		dAtA[i] = 0x22
	}
	if m.SluitemConfig != 0 {
		i = encodeVarintProtocolTp(dAtA, i, uint64(m.SluitemConfig))
		i--
		dAtA[i] = 0x18
	}
	if m.SluitemId != 0 {
		i = encodeVarintProtocolTp(dAtA, i, uint64(m.SluitemId))
		i--
		dAtA[i] = 0x10
	}
	if m.SluId != 0 {
		i = encodeVarintProtocolTp(dAtA, i, uint64(m.SluId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BlkSlu_6892) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlkSlu_6892) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlkSlu_6892) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SluitemData) > 0 {
		for iNdEx := len(m.SluitemData) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SluitemData[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProtocolTp(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.SluId != 0 {
		i = encodeVarintProtocolTp(dAtA, i, uint64(m.SluId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BlkSlu_6892_SluitemData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlkSlu_6892_SluitemData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlkSlu_6892_SluitemData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SluitemLoop != 0 {
		i = encodeVarintProtocolTp(dAtA, i, uint64(m.SluitemLoop))
		i--
		dAtA[i] = 0x40
	}
	if m.SluitemId != 0 {
		i = encodeVarintProtocolTp(dAtA, i, uint64(m.SluitemId))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Node) > 0 {
		dAtA27 := make([]byte, len(m.Node)*10)
		var j26 int
		for _, num1 := range m.Node {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA27[j26] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j26++
			}
			dAtA27[j26] = uint8(num)
			j26++
		}
		i -= j26
		copy(dAtA[i:], dAtA27[:j26])
		i = encodeVarintProtocolTp(dAtA, i, uint64(j26))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Error) > 0 {
		dAtA29 := make([]byte, len(m.Error)*10)
		var j28 int
		for _, num1 := range m.Error {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA29[j28] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j28++
			}
			dAtA29[j28] = uint8(num)
			j28++
		}
		i -= j28
		copy(dAtA[i:], dAtA29[:j28])
		i = encodeVarintProtocolTp(dAtA, i, uint64(j28))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Power) > 0 {
		for iNdEx := len(m.Power) - 1; iNdEx >= 0; iNdEx-- {
			f30 := math.Float64bits(float64(m.Power[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f30))
		}
		i = encodeVarintProtocolTp(dAtA, i, uint64(len(m.Power)*8))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Current) > 0 {
		for iNdEx := len(m.Current) - 1; iNdEx >= 0; iNdEx-- {
			f31 := math.Float64bits(float64(m.Current[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f31))
		}
		i = encodeVarintProtocolTp(dAtA, i, uint64(len(m.Current)*8))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Voltage) > 0 {
		for iNdEx := len(m.Voltage) - 1; iNdEx >= 0; iNdEx-- {
			f32 := math.Float64bits(float64(m.Voltage[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f32))
		}
		i = encodeVarintProtocolTp(dAtA, i, uint64(len(m.Voltage)*8))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlkSlu_6895) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlkSlu_6895) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlkSlu_6895) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintProtocolTp(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x50
	}
	if m.CmdIdx != 0 {
		i = encodeVarintProtocolTp(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x48
	}
	if m.TimeSet != 0 {
		i = encodeVarintProtocolTp(dAtA, i, uint64(m.TimeSet))
		i--
		dAtA[i] = 0x40
	}
	if len(m.WeekSet) > 0 {
		dAtA34 := make([]byte, len(m.WeekSet)*10)
		var j33 int
		for _, num1 := range m.WeekSet {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA34[j33] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j33++
			}
			dAtA34[j33] = uint8(num)
			j33++
		}
		i -= j33
		copy(dAtA[i:], dAtA34[:j33])
		i = encodeVarintProtocolTp(dAtA, i, uint64(j33))
		i--
		dAtA[i] = 0x3a
	}
	if m.TimerId != 0 {
		i = encodeVarintProtocolTp(dAtA, i, uint64(m.TimerId))
		i--
		dAtA[i] = 0x30
	}
	if len(m.OperationValue) > 0 {
		dAtA36 := make([]byte, len(m.OperationValue)*10)
		var j35 int
		for _, num1 := range m.OperationValue {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA36[j35] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j35++
			}
			dAtA36[j35] = uint8(num)
			j35++
		}
		i -= j35
		copy(dAtA[i:], dAtA36[:j35])
		i = encodeVarintProtocolTp(dAtA, i, uint64(j35))
		i--
		dAtA[i] = 0x2a
	}
	if m.OperationType != 0 {
		i = encodeVarintProtocolTp(dAtA, i, uint64(m.OperationType))
		i--
		dAtA[i] = 0x20
	}
	if m.AddrType != 0 {
		i = encodeVarintProtocolTp(dAtA, i, uint64(m.AddrType))
		i--
		dAtA[i] = 0x18
	}
	if m.SluitemId != 0 {
		i = encodeVarintProtocolTp(dAtA, i, uint64(m.SluitemId))
		i--
		dAtA[i] = 0x10
	}
	if m.SluId != 0 {
		i = encodeVarintProtocolTp(dAtA, i, uint64(m.SluId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *YfDry_0300) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *YfDry_0300) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *YfDry_0300) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TemperatureLowlimit != 0 {
		i = encodeVarintProtocolTp(dAtA, i, uint64(m.TemperatureLowlimit))
		i--
		dAtA[i] = 0x48
	}
	if m.TemperatureUplimit != 0 {
		i = encodeVarintProtocolTp(dAtA, i, uint64(m.TemperatureUplimit))
		i--
		dAtA[i] = 0x40
	}
	if m.HumidityLowlimit != 0 {
		i = encodeVarintProtocolTp(dAtA, i, uint64(m.HumidityLowlimit))
		i--
		dAtA[i] = 0x38
	}
	if m.HumidityUplimit != 0 {
		i = encodeVarintProtocolTp(dAtA, i, uint64(m.HumidityUplimit))
		i--
		dAtA[i] = 0x30
	}
	if m.Temperature != 0 {
		i = encodeVarintProtocolTp(dAtA, i, uint64(m.Temperature))
		i--
		dAtA[i] = 0x28
	}
	if m.Humidity != 0 {
		i = encodeVarintProtocolTp(dAtA, i, uint64(m.Humidity))
		i--
		dAtA[i] = 0x20
	}
	if m.DewPoint != 0 {
		i = encodeVarintProtocolTp(dAtA, i, uint64(m.DewPoint))
		i--
		dAtA[i] = 0x18
	}
	if m.CtlStatus != 0 {
		i = encodeVarintProtocolTp(dAtA, i, uint64(m.CtlStatus))
		i--
		dAtA[i] = 0x10
	}
	if m.Addr != 0 {
		i = encodeVarintProtocolTp(dAtA, i, uint64(m.Addr))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *YfDry_1005) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *YfDry_1005) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *YfDry_1005) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TemperatureLowlimit != 0 {
		i = encodeVarintProtocolTp(dAtA, i, uint64(m.TemperatureLowlimit))
		i--
		dAtA[i] = 0x48
	}
	if m.TemperatureUplimit != 0 {
		i = encodeVarintProtocolTp(dAtA, i, uint64(m.TemperatureUplimit))
		i--
		dAtA[i] = 0x40
	}
	if m.HumidityLowlimit != 0 {
		i = encodeVarintProtocolTp(dAtA, i, uint64(m.HumidityLowlimit))
		i--
		dAtA[i] = 0x38
	}
	if m.HumidityUplimit != 0 {
		i = encodeVarintProtocolTp(dAtA, i, uint64(m.HumidityUplimit))
		i--
		dAtA[i] = 0x30
	}
	if m.Addr != 0 {
		i = encodeVarintProtocolTp(dAtA, i, uint64(m.Addr))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *YfDry_1001) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *YfDry_1001) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *YfDry_1001) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CtlStatus != 0 {
		i = encodeVarintProtocolTp(dAtA, i, uint64(m.CtlStatus))
		i--
		dAtA[i] = 0x10
	}
	if m.Addr != 0 {
		i = encodeVarintProtocolTp(dAtA, i, uint64(m.Addr))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintProtocolTp(dAtA []byte, offset int, v uint64) int {
	offset -= sovProtocolTp(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AhhfRtu_6804) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovProtocolTp(uint64(m.CmdIdx))
	}
	if len(m.DataMark) > 0 {
		l = 0
		for _, e := range m.DataMark {
			l += sovProtocolTp(uint64(e))
		}
		n += 1 + sovProtocolTp(uint64(l)) + l
	}
	if len(m.DataPoint) > 0 {
		l = 0
		for _, e := range m.DataPoint {
			l += sovProtocolTp(uint64(e))
		}
		n += 1 + sovProtocolTp(uint64(l)) + l
	}
	if m.SwitchOut != nil {
		l = m.SwitchOut.Size()
		n += 1 + l + sovProtocolTp(uint64(l))
	}
	if m.SwitchIn != nil {
		l = m.SwitchIn.Size()
		n += 1 + l + sovProtocolTp(uint64(l))
	}
	if m.SwitchInLimit != nil {
		l = m.SwitchInLimit.Size()
		n += 1 + l + sovProtocolTp(uint64(l))
	}
	if len(m.Status) > 0 {
		l = 0
		for _, e := range m.Status {
			l += sovProtocolTp(uint64(e))
		}
		n += 1 + sovProtocolTp(uint64(l)) + l
	}
	return n
}

func (m *AhhfRtu_6804_SwitchOut) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SwitchOutTotal != 0 {
		n += 1 + sovProtocolTp(uint64(m.SwitchOutTotal))
	}
	if len(m.SwitchOutLoop) > 0 {
		l = 0
		for _, e := range m.SwitchOutLoop {
			l += sovProtocolTp(uint64(e))
		}
		n += 1 + sovProtocolTp(uint64(l)) + l
	}
	return n
}

func (m *AhhfRtu_6804_SwitchIn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VoltageTransformer != 0 {
		n += 1 + sovProtocolTp(uint64(m.VoltageTransformer))
	}
	if m.LoopTotal != 0 {
		n += 1 + sovProtocolTp(uint64(m.LoopTotal))
	}
	if len(m.CurrentTransformer) > 0 {
		l = 0
		for _, e := range m.CurrentTransformer {
			l += sovProtocolTp(uint64(e))
		}
		n += 1 + sovProtocolTp(uint64(l)) + l
	}
	if len(m.CurrentPhase) > 0 {
		l = 0
		for _, e := range m.CurrentPhase {
			l += sovProtocolTp(uint64(e))
		}
		n += 1 + sovProtocolTp(uint64(l)) + l
	}
	return n
}

func (m *AhhfRtu_6804_SwitchInLimit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.VoltageUplimit) > 0 {
		n += 1 + sovProtocolTp(uint64(len(m.VoltageUplimit)*8)) + len(m.VoltageUplimit)*8
	}
	if len(m.VoltageLowlimit) > 0 {
		n += 1 + sovProtocolTp(uint64(len(m.VoltageLowlimit)*8)) + len(m.VoltageLowlimit)*8
	}
	if len(m.CurrentUplimit) > 0 {
		n += 1 + sovProtocolTp(uint64(len(m.CurrentUplimit)*8)) + len(m.CurrentUplimit)*8
	}
	if len(m.CurrentLowlimit) > 0 {
		n += 1 + sovProtocolTp(uint64(len(m.CurrentLowlimit)*8)) + len(m.CurrentLowlimit)*8
	}
	if m.LoopTotal != 0 {
		n += 1 + sovProtocolTp(uint64(m.LoopTotal))
	}
	return n
}

func (m *WxjyEsu_5500) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TimeNow)
	if l > 0 {
		n += 1 + l + sovProtocolTp(uint64(l))
	}
	if len(m.XTime) > 0 {
		l = 0
		for _, e := range m.XTime {
			l += sovProtocolTp(uint64(e))
		}
		n += 1 + sovProtocolTp(uint64(l)) + l
	}
	if len(m.XVoltage) > 0 {
		l = 0
		for _, e := range m.XVoltage {
			l += sovProtocolTp(uint64(e))
		}
		n += 1 + sovProtocolTp(uint64(l)) + l
	}
	return n
}

func (m *WxjyEsuD700) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PhaseAIn != 0 {
		n += 1 + sovProtocolTp(uint64(m.PhaseAIn))
	}
	if m.PhaseBIn != 0 {
		n += 1 + sovProtocolTp(uint64(m.PhaseBIn))
	}
	if m.PhaseCIn != 0 {
		n += 1 + sovProtocolTp(uint64(m.PhaseCIn))
	}
	if m.PhaseAOut != 0 {
		n += 1 + sovProtocolTp(uint64(m.PhaseAOut))
	}
	if m.PhaseBOut != 0 {
		n += 1 + sovProtocolTp(uint64(m.PhaseBOut))
	}
	if m.PhaseCOut != 0 {
		n += 1 + sovProtocolTp(uint64(m.PhaseCOut))
	}
	return n
}

func (m *WxjyEsuD800) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovProtocolTp(uint64(l))
	}
	return n
}

func (m *BlkSlu_6891) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SluId != 0 {
		n += 1 + sovProtocolTp(uint64(m.SluId))
	}
	if m.SluitemId != 0 {
		n += 1 + sovProtocolTp(uint64(m.SluitemId))
	}
	if m.SluitemConfig != 0 {
		n += 1 + sovProtocolTp(uint64(m.SluitemConfig))
	}
	if len(m.SluitemLoop) > 0 {
		l = 0
		for _, e := range m.SluitemLoop {
			l += sovProtocolTp(uint64(e))
		}
		n += 1 + sovProtocolTp(uint64(l)) + l
	}
	if m.Status != 0 {
		n += 1 + sovProtocolTp(uint64(m.Status))
	}
	return n
}

func (m *BlkSlu_6892) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SluId != 0 {
		n += 1 + sovProtocolTp(uint64(m.SluId))
	}
	if len(m.SluitemData) > 0 {
		for _, e := range m.SluitemData {
			l = e.Size()
			n += 1 + l + sovProtocolTp(uint64(l))
		}
	}
	return n
}

func (m *BlkSlu_6892_SluitemData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Voltage) > 0 {
		n += 1 + sovProtocolTp(uint64(len(m.Voltage)*8)) + len(m.Voltage)*8
	}
	if len(m.Current) > 0 {
		n += 1 + sovProtocolTp(uint64(len(m.Current)*8)) + len(m.Current)*8
	}
	if len(m.Power) > 0 {
		n += 1 + sovProtocolTp(uint64(len(m.Power)*8)) + len(m.Power)*8
	}
	if len(m.Error) > 0 {
		l = 0
		for _, e := range m.Error {
			l += sovProtocolTp(uint64(e))
		}
		n += 1 + sovProtocolTp(uint64(l)) + l
	}
	if len(m.Node) > 0 {
		l = 0
		for _, e := range m.Node {
			l += sovProtocolTp(uint64(e))
		}
		n += 1 + sovProtocolTp(uint64(l)) + l
	}
	if m.SluitemId != 0 {
		n += 1 + sovProtocolTp(uint64(m.SluitemId))
	}
	if m.SluitemLoop != 0 {
		n += 1 + sovProtocolTp(uint64(m.SluitemLoop))
	}
	return n
}

func (m *BlkSlu_6895) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SluId != 0 {
		n += 1 + sovProtocolTp(uint64(m.SluId))
	}
	if m.SluitemId != 0 {
		n += 1 + sovProtocolTp(uint64(m.SluitemId))
	}
	if m.AddrType != 0 {
		n += 1 + sovProtocolTp(uint64(m.AddrType))
	}
	if m.OperationType != 0 {
		n += 1 + sovProtocolTp(uint64(m.OperationType))
	}
	if len(m.OperationValue) > 0 {
		l = 0
		for _, e := range m.OperationValue {
			l += sovProtocolTp(uint64(e))
		}
		n += 1 + sovProtocolTp(uint64(l)) + l
	}
	if m.TimerId != 0 {
		n += 1 + sovProtocolTp(uint64(m.TimerId))
	}
	if len(m.WeekSet) > 0 {
		l = 0
		for _, e := range m.WeekSet {
			l += sovProtocolTp(uint64(e))
		}
		n += 1 + sovProtocolTp(uint64(l)) + l
	}
	if m.TimeSet != 0 {
		n += 1 + sovProtocolTp(uint64(m.TimeSet))
	}
	if m.CmdIdx != 0 {
		n += 1 + sovProtocolTp(uint64(m.CmdIdx))
	}
	if m.Status != 0 {
		n += 1 + sovProtocolTp(uint64(m.Status))
	}
	return n
}

func (m *YfDry_0300) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Addr != 0 {
		n += 1 + sovProtocolTp(uint64(m.Addr))
	}
	if m.CtlStatus != 0 {
		n += 1 + sovProtocolTp(uint64(m.CtlStatus))
	}
	if m.DewPoint != 0 {
		n += 1 + sovProtocolTp(uint64(m.DewPoint))
	}
	if m.Humidity != 0 {
		n += 1 + sovProtocolTp(uint64(m.Humidity))
	}
	if m.Temperature != 0 {
		n += 1 + sovProtocolTp(uint64(m.Temperature))
	}
	if m.HumidityUplimit != 0 {
		n += 1 + sovProtocolTp(uint64(m.HumidityUplimit))
	}
	if m.HumidityLowlimit != 0 {
		n += 1 + sovProtocolTp(uint64(m.HumidityLowlimit))
	}
	if m.TemperatureUplimit != 0 {
		n += 1 + sovProtocolTp(uint64(m.TemperatureUplimit))
	}
	if m.TemperatureLowlimit != 0 {
		n += 1 + sovProtocolTp(uint64(m.TemperatureLowlimit))
	}
	return n
}

func (m *YfDry_1005) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Addr != 0 {
		n += 1 + sovProtocolTp(uint64(m.Addr))
	}
	if m.HumidityUplimit != 0 {
		n += 1 + sovProtocolTp(uint64(m.HumidityUplimit))
	}
	if m.HumidityLowlimit != 0 {
		n += 1 + sovProtocolTp(uint64(m.HumidityLowlimit))
	}
	if m.TemperatureUplimit != 0 {
		n += 1 + sovProtocolTp(uint64(m.TemperatureUplimit))
	}
	if m.TemperatureLowlimit != 0 {
		n += 1 + sovProtocolTp(uint64(m.TemperatureLowlimit))
	}
	return n
}

func (m *YfDry_1001) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Addr != 0 {
		n += 1 + sovProtocolTp(uint64(m.Addr))
	}
	if m.CtlStatus != 0 {
		n += 1 + sovProtocolTp(uint64(m.CtlStatus))
	}
	return n
}

func sovProtocolTp(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozProtocolTp(x uint64) (n int) {
	return sovProtocolTp(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AhhfRtu_6804) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolTp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ahhf_rtu_6804: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ahhf_rtu_6804: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolTp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolTp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DataMark = append(m.DataMark, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolTp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolTp
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolTp
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DataMark) == 0 {
					m.DataMark = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolTp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DataMark = append(m.DataMark, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DataMark", wireType)
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolTp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DataPoint = append(m.DataPoint, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolTp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolTp
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolTp
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DataPoint) == 0 {
					m.DataPoint = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolTp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DataPoint = append(m.DataPoint, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DataPoint", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchOut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolTp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolTp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolTp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SwitchOut == nil {
				m.SwitchOut = &AhhfRtu_6804_SwitchOut{}
			}
			if err := m.SwitchOut.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchIn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolTp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolTp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolTp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SwitchIn == nil {
				m.SwitchIn = &AhhfRtu_6804_SwitchIn{}
			}
			if err := m.SwitchIn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchInLimit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolTp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolTp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolTp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SwitchInLimit == nil {
				m.SwitchInLimit = &AhhfRtu_6804_SwitchInLimit{}
			}
			if err := m.SwitchInLimit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolTp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Status = append(m.Status, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolTp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolTp
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolTp
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Status) == 0 {
					m.Status = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolTp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Status = append(m.Status, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolTp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProtocolTp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AhhfRtu_6804_SwitchOut) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolTp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Switch_out: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Switch_out: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchOutTotal", wireType)
			}
			m.SwitchOutTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolTp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SwitchOutTotal |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolTp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SwitchOutLoop = append(m.SwitchOutLoop, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolTp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolTp
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolTp
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SwitchOutLoop) == 0 {
					m.SwitchOutLoop = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolTp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SwitchOutLoop = append(m.SwitchOutLoop, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchOutLoop", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolTp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProtocolTp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AhhfRtu_6804_SwitchIn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolTp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Switch_in: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Switch_in: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoltageTransformer", wireType)
			}
			m.VoltageTransformer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolTp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VoltageTransformer |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoopTotal", wireType)
			}
			m.LoopTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolTp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoopTotal |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolTp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CurrentTransformer = append(m.CurrentTransformer, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolTp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolTp
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolTp
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.CurrentTransformer) == 0 {
					m.CurrentTransformer = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolTp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CurrentTransformer = append(m.CurrentTransformer, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentTransformer", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolTp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CurrentPhase = append(m.CurrentPhase, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolTp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolTp
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolTp
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.CurrentPhase) == 0 {
					m.CurrentPhase = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolTp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CurrentPhase = append(m.CurrentPhase, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentPhase", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolTp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProtocolTp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AhhfRtu_6804_SwitchInLimit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolTp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Switch_in_limit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Switch_in_limit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.VoltageUplimit = append(m.VoltageUplimit, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolTp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolTp
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolTp
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.VoltageUplimit) == 0 {
					m.VoltageUplimit = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.VoltageUplimit = append(m.VoltageUplimit, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field VoltageUplimit", wireType)
			}
		case 2:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.VoltageLowlimit = append(m.VoltageLowlimit, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolTp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolTp
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolTp
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.VoltageLowlimit) == 0 {
					m.VoltageLowlimit = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.VoltageLowlimit = append(m.VoltageLowlimit, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field VoltageLowlimit", wireType)
			}
		case 3:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.CurrentUplimit = append(m.CurrentUplimit, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolTp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolTp
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolTp
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.CurrentUplimit) == 0 {
					m.CurrentUplimit = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.CurrentUplimit = append(m.CurrentUplimit, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentUplimit", wireType)
			}
		case 4:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.CurrentLowlimit = append(m.CurrentLowlimit, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolTp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolTp
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolTp
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.CurrentLowlimit) == 0 {
					m.CurrentLowlimit = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.CurrentLowlimit = append(m.CurrentLowlimit, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentLowlimit", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoopTotal", wireType)
			}
			m.LoopTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolTp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoopTotal |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolTp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProtocolTp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WxjyEsu_5500) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolTp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wxjy_esu_5500: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wxjy_esu_5500: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeNow", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolTp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolTp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolTp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TimeNow = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolTp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.XTime = append(m.XTime, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolTp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolTp
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolTp
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.XTime) == 0 {
					m.XTime = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolTp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.XTime = append(m.XTime, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field XTime", wireType)
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolTp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.XVoltage = append(m.XVoltage, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolTp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolTp
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolTp
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.XVoltage) == 0 {
					m.XVoltage = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolTp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.XVoltage = append(m.XVoltage, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field XVoltage", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolTp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProtocolTp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WxjyEsuD700) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolTp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wxjy_esu_d700: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wxjy_esu_d700: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhaseAIn", wireType)
			}
			m.PhaseAIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolTp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PhaseAIn |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhaseBIn", wireType)
			}
			m.PhaseBIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolTp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PhaseBIn |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhaseCIn", wireType)
			}
			m.PhaseCIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolTp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PhaseCIn |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhaseAOut", wireType)
			}
			m.PhaseAOut = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolTp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PhaseAOut |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhaseBOut", wireType)
			}
			m.PhaseBOut = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolTp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PhaseBOut |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhaseCOut", wireType)
			}
			m.PhaseCOut = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolTp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PhaseCOut |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolTp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProtocolTp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WxjyEsuD800) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolTp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wxjy_esu_d800: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wxjy_esu_d800: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolTp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolTp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolTp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolTp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProtocolTp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlkSlu_6891) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolTp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Blk_slu_6891: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Blk_slu_6891: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluId", wireType)
			}
			m.SluId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolTp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemId", wireType)
			}
			m.SluitemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolTp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemConfig", wireType)
			}
			m.SluitemConfig = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolTp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemConfig |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolTp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SluitemLoop = append(m.SluitemLoop, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolTp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolTp
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolTp
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SluitemLoop) == 0 {
					m.SluitemLoop = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolTp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SluitemLoop = append(m.SluitemLoop, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemLoop", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolTp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolTp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProtocolTp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlkSlu_6892) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolTp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Blk_slu_6892: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Blk_slu_6892: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluId", wireType)
			}
			m.SluId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolTp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolTp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolTp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolTp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SluitemData = append(m.SluitemData, &BlkSlu_6892_SluitemData{})
			if err := m.SluitemData[len(m.SluitemData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolTp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProtocolTp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlkSlu_6892_SluitemData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolTp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sluitem_data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sluitem_data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.Voltage = append(m.Voltage, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolTp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolTp
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolTp
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.Voltage) == 0 {
					m.Voltage = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.Voltage = append(m.Voltage, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Voltage", wireType)
			}
		case 2:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.Current = append(m.Current, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolTp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolTp
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolTp
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.Current) == 0 {
					m.Current = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.Current = append(m.Current, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Current", wireType)
			}
		case 3:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.Power = append(m.Power, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolTp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolTp
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolTp
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.Power) == 0 {
					m.Power = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.Power = append(m.Power, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Power", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolTp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Error = append(m.Error, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolTp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolTp
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolTp
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Error) == 0 {
					m.Error = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolTp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Error = append(m.Error, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolTp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Node = append(m.Node, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolTp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolTp
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolTp
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Node) == 0 {
					m.Node = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolTp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Node = append(m.Node, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemId", wireType)
			}
			m.SluitemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolTp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemLoop", wireType)
			}
			m.SluitemLoop = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolTp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemLoop |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolTp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProtocolTp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlkSlu_6895) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolTp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Blk_slu_6895: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Blk_slu_6895: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluId", wireType)
			}
			m.SluId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolTp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemId", wireType)
			}
			m.SluitemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolTp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddrType", wireType)
			}
			m.AddrType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolTp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddrType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationType", wireType)
			}
			m.OperationType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolTp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperationType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolTp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OperationValue = append(m.OperationValue, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolTp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolTp
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolTp
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OperationValue) == 0 {
					m.OperationValue = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolTp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OperationValue = append(m.OperationValue, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationValue", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimerId", wireType)
			}
			m.TimerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolTp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolTp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.WeekSet = append(m.WeekSet, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolTp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolTp
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolTp
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.WeekSet) == 0 {
					m.WeekSet = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolTp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.WeekSet = append(m.WeekSet, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field WeekSet", wireType)
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeSet", wireType)
			}
			m.TimeSet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolTp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeSet |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolTp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolTp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolTp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProtocolTp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *YfDry_0300) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolTp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Yf_dry_0300: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Yf_dry_0300: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			m.Addr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolTp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Addr |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CtlStatus", wireType)
			}
			m.CtlStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolTp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CtlStatus |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DewPoint", wireType)
			}
			m.DewPoint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolTp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DewPoint |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Humidity", wireType)
			}
			m.Humidity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolTp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Humidity |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Temperature", wireType)
			}
			m.Temperature = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolTp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Temperature |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HumidityUplimit", wireType)
			}
			m.HumidityUplimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolTp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HumidityUplimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HumidityLowlimit", wireType)
			}
			m.HumidityLowlimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolTp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HumidityLowlimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemperatureUplimit", wireType)
			}
			m.TemperatureUplimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolTp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TemperatureUplimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemperatureLowlimit", wireType)
			}
			m.TemperatureLowlimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolTp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TemperatureLowlimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolTp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProtocolTp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *YfDry_1005) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolTp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Yf_dry_1005: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Yf_dry_1005: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			m.Addr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolTp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Addr |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HumidityUplimit", wireType)
			}
			m.HumidityUplimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolTp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HumidityUplimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HumidityLowlimit", wireType)
			}
			m.HumidityLowlimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolTp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HumidityLowlimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemperatureUplimit", wireType)
			}
			m.TemperatureUplimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolTp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TemperatureUplimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemperatureLowlimit", wireType)
			}
			m.TemperatureLowlimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolTp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TemperatureLowlimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolTp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProtocolTp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *YfDry_1001) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolTp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Yf_dry_1001: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Yf_dry_1001: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			m.Addr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolTp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Addr |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CtlStatus", wireType)
			}
			m.CtlStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolTp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CtlStatus |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolTp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProtocolTp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipProtocolTp(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProtocolTp
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProtocolTp
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProtocolTp
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthProtocolTp
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupProtocolTp
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthProtocolTp
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthProtocolTp        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProtocolTp          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupProtocolTp = fmt.Errorf("proto: unexpected end of group")
)
