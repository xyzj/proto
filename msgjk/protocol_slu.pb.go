// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: protocol_slu.proto

package wlst_pb2

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Wlst_slu_fd00_a800_a400_b000_9c00_b000_f600_fc00_eb00
type WlstSluF400 struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 操作结果
	Status int32 `protobuf:"varint,2,opt,name=status,proto3" json:"status,omitempty"`
	// 等待队列 status == 0x62时有效
	Remark int32 `protobuf:"varint,3,opt,name=remark,proto3" json:"remark,omitempty"`
	// 操作地址
	SluitemAddr int32 `protobuf:"varint,4,opt,name=sluitem_addr,json=sluitemAddr,proto3" json:"sluitem_addr,omitempty"`
}

func (m *WlstSluF400) Reset()      { *m = WlstSluF400{} }
func (*WlstSluF400) ProtoMessage() {}
func (*WlstSluF400) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{0}
}
func (m *WlstSluF400) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSluF400) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSluF400.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSluF400) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSluF400.Merge(m, src)
}
func (m *WlstSluF400) XXX_Size() int {
	return m.Size()
}
func (m *WlstSluF400) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSluF400.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSluF400 proto.InternalMessageInfo

func (m *WlstSluF400) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *WlstSluF400) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *WlstSluF400) GetRemark() int32 {
	if m != nil {
		return m.Remark
	}
	return 0
}

func (m *WlstSluF400) GetSluitemAddr() int32 {
	if m != nil {
		return m.SluitemAddr
	}
	return 0
}

// Wlst_slu_b900 nb控制器数据主报
type WlstSlu_3900 struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 型号
	ModelInfo *WlstSlu_3900_ModelInfo `protobuf:"bytes,2,opt,name=model_info,json=modelInfo,proto3" json:"model_info,omitempty"`
	// 回路数据
	LightData []*WlstSlu_3900_LightData `protobuf:"bytes,3,rep,name=light_data,json=lightData,proto3" json:"light_data,omitempty"`
	// 漏电流
	LeakageCurrent float64 `protobuf:"fixed64,4,opt,name=leakage_current,json=leakageCurrent,proto3" json:"leakage_current,omitempty"`
	// 控制器状态
	SluitemStatus *WlstSlu_3900_SluitemStatus `protobuf:"bytes,5,opt,name=sluitem_status,json=sluitemStatus,proto3" json:"sluitem_status,omitempty"`
	// 时钟故障
	TimeFault *WlstSlu_3900_TimeFault `protobuf:"bytes,6,opt,name=time_fault,json=timeFault,proto3" json:"time_fault,omitempty"`
	// 自复位次数
	ResetCount int32 `protobuf:"varint,7,opt,name=reset_count,json=resetCount,proto3" json:"reset_count,omitempty"`
	// 时间
	DateTime int64 `protobuf:"varint,8,opt,name=date_time,json=dateTime,proto3" json:"date_time,omitempty"`
	// 控制器运行参数
	SluitemPara *WlstSlu_3900_SluitemPara `protobuf:"bytes,9,opt,name=sluitem_para,json=sluitemPara,proto3" json:"sluitem_para,omitempty"`
	// 参考信号接收功率
	Rsrp int64 `protobuf:"varint,10,opt,name=rsrp,proto3" json:"rsrp,omitempty"`
	// 接收信号强度等级
	Rssi int64 `protobuf:"varint,11,opt,name=rssi,proto3" json:"rssi,omitempty"`
	// 信噪比
	Snr int64 `protobuf:"varint,12,opt,name=snr,proto3" json:"snr,omitempty"`
	// 物理小区标识
	Pci int64 `protobuf:"varint,13,opt,name=pci,proto3" json:"pci,omitempty"`
	// 参考信号接收质量
	Rsrq int64 `protobuf:"varint,14,opt,name=rsrq,proto3" json:"rsrq,omitempty"`
	// 终端发射功率
	Txpower int64 `protobuf:"varint,15,opt,name=txpower,proto3" json:"txpower,omitempty"`
	// 频点号
	Earfcn int64 `protobuf:"varint,16,opt,name=earfcn,proto3" json:"earfcn,omitempty"`
	// 信号覆盖等级
	Ecl int32 `protobuf:"varint,17,opt,name=ecl,proto3" json:"ecl,omitempty"`
	// 信号强度值
	Csq int32 `protobuf:"varint,18,opt,name=csq,proto3" json:"csq,omitempty"`
	// 主动上报原因，0-非主动上报，1-上电，2-开关灯状态变化，3-故障发生/消除，4-定时主动上报
	Reson int32 `protobuf:"varint,19,opt,name=reson,proto3" json:"reson,omitempty"`
	// 重连次数
	Retry int32 `protobuf:"varint,20,opt,name=retry,proto3" json:"retry,omitempty"`
	// 日出时间
	Sunrise int32 `protobuf:"varint,21,opt,name=sunrise,proto3" json:"sunrise,omitempty"`
	// 日落时间
	Sunset int32 `protobuf:"varint,22,opt,name=sunset,proto3" json:"sunset,omitempty"`
}

func (m *WlstSlu_3900) Reset()      { *m = WlstSlu_3900{} }
func (*WlstSlu_3900) ProtoMessage() {}
func (*WlstSlu_3900) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{1}
}
func (m *WlstSlu_3900) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_3900) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_3900.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_3900) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_3900.Merge(m, src)
}
func (m *WlstSlu_3900) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_3900) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_3900.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_3900 proto.InternalMessageInfo

func (m *WlstSlu_3900) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *WlstSlu_3900) GetModelInfo() *WlstSlu_3900_ModelInfo {
	if m != nil {
		return m.ModelInfo
	}
	return nil
}

func (m *WlstSlu_3900) GetLightData() []*WlstSlu_3900_LightData {
	if m != nil {
		return m.LightData
	}
	return nil
}

func (m *WlstSlu_3900) GetLeakageCurrent() float64 {
	if m != nil {
		return m.LeakageCurrent
	}
	return 0
}

func (m *WlstSlu_3900) GetSluitemStatus() *WlstSlu_3900_SluitemStatus {
	if m != nil {
		return m.SluitemStatus
	}
	return nil
}

func (m *WlstSlu_3900) GetTimeFault() *WlstSlu_3900_TimeFault {
	if m != nil {
		return m.TimeFault
	}
	return nil
}

func (m *WlstSlu_3900) GetResetCount() int32 {
	if m != nil {
		return m.ResetCount
	}
	return 0
}

func (m *WlstSlu_3900) GetDateTime() int64 {
	if m != nil {
		return m.DateTime
	}
	return 0
}

func (m *WlstSlu_3900) GetSluitemPara() *WlstSlu_3900_SluitemPara {
	if m != nil {
		return m.SluitemPara
	}
	return nil
}

func (m *WlstSlu_3900) GetRsrp() int64 {
	if m != nil {
		return m.Rsrp
	}
	return 0
}

func (m *WlstSlu_3900) GetRssi() int64 {
	if m != nil {
		return m.Rssi
	}
	return 0
}

func (m *WlstSlu_3900) GetSnr() int64 {
	if m != nil {
		return m.Snr
	}
	return 0
}

func (m *WlstSlu_3900) GetPci() int64 {
	if m != nil {
		return m.Pci
	}
	return 0
}

func (m *WlstSlu_3900) GetRsrq() int64 {
	if m != nil {
		return m.Rsrq
	}
	return 0
}

func (m *WlstSlu_3900) GetTxpower() int64 {
	if m != nil {
		return m.Txpower
	}
	return 0
}

func (m *WlstSlu_3900) GetEarfcn() int64 {
	if m != nil {
		return m.Earfcn
	}
	return 0
}

func (m *WlstSlu_3900) GetEcl() int32 {
	if m != nil {
		return m.Ecl
	}
	return 0
}

func (m *WlstSlu_3900) GetCsq() int32 {
	if m != nil {
		return m.Csq
	}
	return 0
}

func (m *WlstSlu_3900) GetReson() int32 {
	if m != nil {
		return m.Reson
	}
	return 0
}

func (m *WlstSlu_3900) GetRetry() int32 {
	if m != nil {
		return m.Retry
	}
	return 0
}

func (m *WlstSlu_3900) GetSunrise() int32 {
	if m != nil {
		return m.Sunrise
	}
	return 0
}

func (m *WlstSlu_3900) GetSunset() int32 {
	if m != nil {
		return m.Sunset
	}
	return 0
}

type WlstSlu_3900_ModelInfo struct {
	// 控制器回路数量
	SluitemLoop int32 `protobuf:"varint,1,opt,name=sluitem_loop,json=sluitemLoop,proto3" json:"sluitem_loop,omitempty"`
	// 节能方式 0-无控制，1-只有开关灯，2-一档节能，3-二档节能，4-RS485，5-PWM，6-0~10V
	PowerSaving int32 `protobuf:"varint,2,opt,name=power_saving,json=powerSaving,proto3" json:"power_saving,omitempty"`
	// 漏电流测量 0-无，1-有
	HasLeakage int32 `protobuf:"varint,3,opt,name=has_leakage,json=hasLeakage,proto3" json:"has_leakage,omitempty"`
	// 温度采集 0-无，1-有
	HasTemperature int32 `protobuf:"varint,4,opt,name=has_temperature,json=hasTemperature,proto3" json:"has_temperature,omitempty"`
	// 时钟 0-无，1-有
	HasTimer int32 `protobuf:"varint,5,opt,name=has_timer,json=hasTimer,proto3" json:"has_timer,omitempty"`
	// 型号 0-unknow
	Model int32 `protobuf:"varint,6,opt,name=model,proto3" json:"model,omitempty"`
	// 字符串型号
	SluitemType string `protobuf:"bytes,7,opt,name=sluitem_type,json=sluitemType,proto3" json:"sluitem_type,omitempty"`
}

func (m *WlstSlu_3900_ModelInfo) Reset()      { *m = WlstSlu_3900_ModelInfo{} }
func (*WlstSlu_3900_ModelInfo) ProtoMessage() {}
func (*WlstSlu_3900_ModelInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{1, 0}
}
func (m *WlstSlu_3900_ModelInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_3900_ModelInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_3900_ModelInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_3900_ModelInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_3900_ModelInfo.Merge(m, src)
}
func (m *WlstSlu_3900_ModelInfo) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_3900_ModelInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_3900_ModelInfo.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_3900_ModelInfo proto.InternalMessageInfo

func (m *WlstSlu_3900_ModelInfo) GetSluitemLoop() int32 {
	if m != nil {
		return m.SluitemLoop
	}
	return 0
}

func (m *WlstSlu_3900_ModelInfo) GetPowerSaving() int32 {
	if m != nil {
		return m.PowerSaving
	}
	return 0
}

func (m *WlstSlu_3900_ModelInfo) GetHasLeakage() int32 {
	if m != nil {
		return m.HasLeakage
	}
	return 0
}

func (m *WlstSlu_3900_ModelInfo) GetHasTemperature() int32 {
	if m != nil {
		return m.HasTemperature
	}
	return 0
}

func (m *WlstSlu_3900_ModelInfo) GetHasTimer() int32 {
	if m != nil {
		return m.HasTimer
	}
	return 0
}

func (m *WlstSlu_3900_ModelInfo) GetModel() int32 {
	if m != nil {
		return m.Model
	}
	return 0
}

func (m *WlstSlu_3900_ModelInfo) GetSluitemType() string {
	if m != nil {
		return m.SluitemType
	}
	return ""
}

type WlstSlu_3900_LightData struct {
	// 电压
	Voltage float64 `protobuf:"fixed64,1,opt,name=voltage,proto3" json:"voltage,omitempty"`
	// 电流
	Current float64 `protobuf:"fixed64,2,opt,name=current,proto3" json:"current,omitempty"`
	// 有功功率
	ActivePower float64 `protobuf:"fixed64,3,opt,name=active_power,json=activePower,proto3" json:"active_power,omitempty"`
	// 无功功率
	ReactivePower float64 `protobuf:"fixed64,4,opt,name=reactive_power,json=reactivePower,proto3" json:"reactive_power,omitempty"`
	// 视在功率
	ApparentPower float64 `protobuf:"fixed64,5,opt,name=apparent_power,json=apparentPower,proto3" json:"apparent_power,omitempty"`
	// 电量
	Electricity float64 `protobuf:"fixed64,6,opt,name=electricity,proto3" json:"electricity,omitempty"`
	// 运行时间
	ActiveTime float64 `protobuf:"fixed64,7,opt,name=active_time,json=activeTime,proto3" json:"active_time,omitempty"`
	// 灯状态
	LightStatus *WlstSlu_3900_LightStatus `protobuf:"bytes,8,opt,name=light_status,json=lightStatus,proto3" json:"light_status,omitempty"`
	// 节能档位
	PowerLevel int32 `protobuf:"varint,9,opt,name=power_level,json=powerLevel,proto3" json:"power_level,omitempty"`
	// 控制器上电开灯 true-开灯，false-关灯
	SluitemPowerTurnon int32 `protobuf:"varint,10,opt,name=sluitem_power_turnon,json=sluitemPowerTurnon,proto3" json:"sluitem_power_turnon,omitempty"`
	// 1-4回路额定功率
	RatedPower int32 `protobuf:"varint,11,opt,name=rated_power,json=ratedPower,proto3" json:"rated_power,omitempty"`
}

func (m *WlstSlu_3900_LightData) Reset()      { *m = WlstSlu_3900_LightData{} }
func (*WlstSlu_3900_LightData) ProtoMessage() {}
func (*WlstSlu_3900_LightData) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{1, 1}
}
func (m *WlstSlu_3900_LightData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_3900_LightData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_3900_LightData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_3900_LightData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_3900_LightData.Merge(m, src)
}
func (m *WlstSlu_3900_LightData) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_3900_LightData) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_3900_LightData.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_3900_LightData proto.InternalMessageInfo

func (m *WlstSlu_3900_LightData) GetVoltage() float64 {
	if m != nil {
		return m.Voltage
	}
	return 0
}

func (m *WlstSlu_3900_LightData) GetCurrent() float64 {
	if m != nil {
		return m.Current
	}
	return 0
}

func (m *WlstSlu_3900_LightData) GetActivePower() float64 {
	if m != nil {
		return m.ActivePower
	}
	return 0
}

func (m *WlstSlu_3900_LightData) GetReactivePower() float64 {
	if m != nil {
		return m.ReactivePower
	}
	return 0
}

func (m *WlstSlu_3900_LightData) GetApparentPower() float64 {
	if m != nil {
		return m.ApparentPower
	}
	return 0
}

func (m *WlstSlu_3900_LightData) GetElectricity() float64 {
	if m != nil {
		return m.Electricity
	}
	return 0
}

func (m *WlstSlu_3900_LightData) GetActiveTime() float64 {
	if m != nil {
		return m.ActiveTime
	}
	return 0
}

func (m *WlstSlu_3900_LightData) GetLightStatus() *WlstSlu_3900_LightStatus {
	if m != nil {
		return m.LightStatus
	}
	return nil
}

func (m *WlstSlu_3900_LightData) GetPowerLevel() int32 {
	if m != nil {
		return m.PowerLevel
	}
	return 0
}

func (m *WlstSlu_3900_LightData) GetSluitemPowerTurnon() int32 {
	if m != nil {
		return m.SluitemPowerTurnon
	}
	return 0
}

func (m *WlstSlu_3900_LightData) GetRatedPower() int32 {
	if m != nil {
		return m.RatedPower
	}
	return 0
}

type WlstSlu_3900_LightStatus struct {
	// 灯具漏电 0-正常，1-漏电
	Leakage int32 `protobuf:"varint,1,opt,name=leakage,proto3" json:"leakage,omitempty"`
	// 故障 0-正常，1-光源故障，2-补偿电容故障，3-意外灭灯，4-意外亮灯，5-自熄灯
	Fault int32 `protobuf:"varint,2,opt,name=fault,proto3" json:"fault,omitempty"`
	// 工作状态 0-正常亮灯，1-保留，2-调光节能，3-关灯
	WorkingOn int32 `protobuf:"varint,3,opt,name=working_on,json=workingOn,proto3" json:"working_on,omitempty"`
}

func (m *WlstSlu_3900_LightStatus) Reset()      { *m = WlstSlu_3900_LightStatus{} }
func (*WlstSlu_3900_LightStatus) ProtoMessage() {}
func (*WlstSlu_3900_LightStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{1, 2}
}
func (m *WlstSlu_3900_LightStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_3900_LightStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_3900_LightStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_3900_LightStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_3900_LightStatus.Merge(m, src)
}
func (m *WlstSlu_3900_LightStatus) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_3900_LightStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_3900_LightStatus.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_3900_LightStatus proto.InternalMessageInfo

func (m *WlstSlu_3900_LightStatus) GetLeakage() int32 {
	if m != nil {
		return m.Leakage
	}
	return 0
}

func (m *WlstSlu_3900_LightStatus) GetFault() int32 {
	if m != nil {
		return m.Fault
	}
	return 0
}

func (m *WlstSlu_3900_LightStatus) GetWorkingOn() int32 {
	if m != nil {
		return m.WorkingOn
	}
	return 0
}

type WlstSlu_3900_SluitemStatus struct {
	// flash故障 0-正常 1-故障
	FlashFault int32 `protobuf:"varint,1,opt,name=flash_fault,json=flashFault,proto3" json:"flash_fault,omitempty"`
	// 主动报警禁止 0-正常 1-禁止
	EnableAlarm int32 `protobuf:"varint,2,opt,name=enable_alarm,json=enableAlarm,proto3" json:"enable_alarm,omitempty"`
}

func (m *WlstSlu_3900_SluitemStatus) Reset()      { *m = WlstSlu_3900_SluitemStatus{} }
func (*WlstSlu_3900_SluitemStatus) ProtoMessage() {}
func (*WlstSlu_3900_SluitemStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{1, 3}
}
func (m *WlstSlu_3900_SluitemStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_3900_SluitemStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_3900_SluitemStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_3900_SluitemStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_3900_SluitemStatus.Merge(m, src)
}
func (m *WlstSlu_3900_SluitemStatus) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_3900_SluitemStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_3900_SluitemStatus.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_3900_SluitemStatus proto.InternalMessageInfo

func (m *WlstSlu_3900_SluitemStatus) GetFlashFault() int32 {
	if m != nil {
		return m.FlashFault
	}
	return 0
}

func (m *WlstSlu_3900_SluitemStatus) GetEnableAlarm() int32 {
	if m != nil {
		return m.EnableAlarm
	}
	return 0
}

type WlstSlu_3900_TimeFault struct {
	// 本地时钟故障 0-正常 1-故障
	ClockFault int32 `protobuf:"varint,1,opt,name=clock_fault,json=clockFault,proto3" json:"clock_fault,omitempty"`
	// 本地时钟超差故障 0-正常 1-故障
	ClockOutFault int32 `protobuf:"varint,2,opt,name=clock_out_fault,json=clockOutFault,proto3" json:"clock_out_fault,omitempty"`
	// 校时超差故障 0-正常 1-故障
	ClockOutAlarm int32 `protobuf:"varint,3,opt,name=clock_out_alarm,json=clockOutAlarm,proto3" json:"clock_out_alarm,omitempty"`
}

func (m *WlstSlu_3900_TimeFault) Reset()      { *m = WlstSlu_3900_TimeFault{} }
func (*WlstSlu_3900_TimeFault) ProtoMessage() {}
func (*WlstSlu_3900_TimeFault) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{1, 4}
}
func (m *WlstSlu_3900_TimeFault) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_3900_TimeFault) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_3900_TimeFault.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_3900_TimeFault) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_3900_TimeFault.Merge(m, src)
}
func (m *WlstSlu_3900_TimeFault) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_3900_TimeFault) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_3900_TimeFault.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_3900_TimeFault proto.InternalMessageInfo

func (m *WlstSlu_3900_TimeFault) GetClockFault() int32 {
	if m != nil {
		return m.ClockFault
	}
	return 0
}

func (m *WlstSlu_3900_TimeFault) GetClockOutFault() int32 {
	if m != nil {
		return m.ClockOutFault
	}
	return 0
}

func (m *WlstSlu_3900_TimeFault) GetClockOutAlarm() int32 {
	if m != nil {
		return m.ClockOutAlarm
	}
	return 0
}

type WlstSlu_3900_SluitemPara struct {
	// 经度
	Longitude float64 `protobuf:"fixed64,1,opt,name=longitude,proto3" json:"longitude,omitempty"`
	// 纬度
	Latitude float64 `protobuf:"fixed64,2,opt,name=latitude,proto3" json:"latitude,omitempty"`
	// 是否允许主报 1-允许 0-不允许
	HasEnableAlarm int32 `protobuf:"varint,3,opt,name=has_enable_alarm,json=hasEnableAlarm,proto3" json:"has_enable_alarm,omitempty"`
	// 是否投运 1-投运 0-停运
	IsRunning int32 `protobuf:"varint,4,opt,name=is_running,json=isRunning,proto3" json:"is_running,omitempty"`
	// 主动报警间隔 单位分钟 0表示30分钟
	AlarmInterval int32 `protobuf:"varint,5,opt,name=alarm_interval,json=alarmInterval,proto3" json:"alarm_interval,omitempty"`
	// nb主报需要主站应答，0-不需要，1-需要
	UplinkReply int32 `protobuf:"varint,6,opt,name=uplink_reply,json=uplinkReply,proto3" json:"uplink_reply,omitempty"`
}

func (m *WlstSlu_3900_SluitemPara) Reset()      { *m = WlstSlu_3900_SluitemPara{} }
func (*WlstSlu_3900_SluitemPara) ProtoMessage() {}
func (*WlstSlu_3900_SluitemPara) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{1, 5}
}
func (m *WlstSlu_3900_SluitemPara) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_3900_SluitemPara) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_3900_SluitemPara.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_3900_SluitemPara) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_3900_SluitemPara.Merge(m, src)
}
func (m *WlstSlu_3900_SluitemPara) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_3900_SluitemPara) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_3900_SluitemPara.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_3900_SluitemPara proto.InternalMessageInfo

func (m *WlstSlu_3900_SluitemPara) GetLongitude() float64 {
	if m != nil {
		return m.Longitude
	}
	return 0
}

func (m *WlstSlu_3900_SluitemPara) GetLatitude() float64 {
	if m != nil {
		return m.Latitude
	}
	return 0
}

func (m *WlstSlu_3900_SluitemPara) GetHasEnableAlarm() int32 {
	if m != nil {
		return m.HasEnableAlarm
	}
	return 0
}

func (m *WlstSlu_3900_SluitemPara) GetIsRunning() int32 {
	if m != nil {
		return m.IsRunning
	}
	return 0
}

func (m *WlstSlu_3900_SluitemPara) GetAlarmInterval() int32 {
	if m != nil {
		return m.AlarmInterval
	}
	return 0
}

func (m *WlstSlu_3900_SluitemPara) GetUplinkReply() int32 {
	if m != nil {
		return m.UplinkReply
	}
	return 0
}

// 单灯事件查询
type WlstSlu_7800 struct {
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 事件类型, 0-上电复位记录，1-开关灯操作记录，2-液晶操作记录，3-控制器告警记录，4-集中器告警记录，5-主站操作记录
	EventType int32 `protobuf:"varint,2,opt,name=event_type,json=eventType,proto3" json:"event_type,omitempty"`
	// 分类标记，默认0xff
	ClassType int32 `protobuf:"varint,3,opt,name=class_type,json=classType,proto3" json:"class_type,omitempty"`
	// 记录条数
	RecordCount int32 `protobuf:"varint,4,opt,name=record_count,json=recordCount,proto3" json:"record_count,omitempty"`
	// 开始时间
	DtStart int64 `protobuf:"varint,5,opt,name=dt_start,json=dtStart,proto3" json:"dt_start,omitempty"`
	// 结束时间
	DtEnd int64 `protobuf:"varint,6,opt,name=dt_end,json=dtEnd,proto3" json:"dt_end,omitempty"`
}

func (m *WlstSlu_7800) Reset()      { *m = WlstSlu_7800{} }
func (*WlstSlu_7800) ProtoMessage() {}
func (*WlstSlu_7800) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{2}
}
func (m *WlstSlu_7800) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_7800) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_7800.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_7800) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_7800.Merge(m, src)
}
func (m *WlstSlu_7800) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_7800) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_7800.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_7800 proto.InternalMessageInfo

func (m *WlstSlu_7800) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *WlstSlu_7800) GetEventType() int32 {
	if m != nil {
		return m.EventType
	}
	return 0
}

func (m *WlstSlu_7800) GetClassType() int32 {
	if m != nil {
		return m.ClassType
	}
	return 0
}

func (m *WlstSlu_7800) GetRecordCount() int32 {
	if m != nil {
		return m.RecordCount
	}
	return 0
}

func (m *WlstSlu_7800) GetDtStart() int64 {
	if m != nil {
		return m.DtStart
	}
	return 0
}

func (m *WlstSlu_7800) GetDtEnd() int64 {
	if m != nil {
		return m.DtEnd
	}
	return 0
}

// 单灯事件查询应答
type WlstSluF800 struct {
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 事件类型, 0-上电复位记录，1-开关灯操作记录，2-液晶操作记录，3-控制器告警记录，4-集中器告警记录，5-主站操作记录
	EventType int32 `protobuf:"varint,2,opt,name=event_type,json=eventType,proto3" json:"event_type,omitempty"`
	// 分类标记，默认0xff
	ClassType int32 `protobuf:"varint,3,opt,name=class_type,json=classType,proto3" json:"class_type,omitempty"`
	// 总包数
	DataTotal int32 `protobuf:"varint,4,opt,name=data_total,json=dataTotal,proto3" json:"data_total,omitempty"`
	// 当前包号
	DataIdx int32 `protobuf:"varint,5,opt,name=data_idx,json=dataIdx,proto3" json:"data_idx,omitempty"`
	// 该包记录数
	RecordCount int32                   `protobuf:"varint,6,opt,name=record_count,json=recordCount,proto3" json:"record_count,omitempty"`
	View_0X20   []*WlstSluF800_View0X20 `protobuf:"bytes,7,rep,name=view_0x20,json=view0x20,proto3" json:"view_0x20,omitempty"`
	View_0X21   []*WlstSluF800_View0X21 `protobuf:"bytes,8,rep,name=view_0x21,json=view0x21,proto3" json:"view_0x21,omitempty"`
	View_0X22   []*WlstSluF800_View0X20 `protobuf:"bytes,9,rep,name=view_0x22,json=view0x22,proto3" json:"view_0x22,omitempty"`
	View_0X23   []*WlstSluF800_View0X23 `protobuf:"bytes,10,rep,name=view_0x23,json=view0x23,proto3" json:"view_0x23,omitempty"`
	View_0X24   []*WlstSluF800_View0X20 `protobuf:"bytes,11,rep,name=view_0x24,json=view0x24,proto3" json:"view_0x24,omitempty"`
	View_0X25   []*WlstSluF800_View0X20 `protobuf:"bytes,12,rep,name=view_0x25,json=view0x25,proto3" json:"view_0x25,omitempty"`
}

func (m *WlstSluF800) Reset()      { *m = WlstSluF800{} }
func (*WlstSluF800) ProtoMessage() {}
func (*WlstSluF800) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{3}
}
func (m *WlstSluF800) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSluF800) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSluF800.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSluF800) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSluF800.Merge(m, src)
}
func (m *WlstSluF800) XXX_Size() int {
	return m.Size()
}
func (m *WlstSluF800) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSluF800.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSluF800 proto.InternalMessageInfo

func (m *WlstSluF800) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *WlstSluF800) GetEventType() int32 {
	if m != nil {
		return m.EventType
	}
	return 0
}

func (m *WlstSluF800) GetClassType() int32 {
	if m != nil {
		return m.ClassType
	}
	return 0
}

func (m *WlstSluF800) GetDataTotal() int32 {
	if m != nil {
		return m.DataTotal
	}
	return 0
}

func (m *WlstSluF800) GetDataIdx() int32 {
	if m != nil {
		return m.DataIdx
	}
	return 0
}

func (m *WlstSluF800) GetRecordCount() int32 {
	if m != nil {
		return m.RecordCount
	}
	return 0
}

func (m *WlstSluF800) GetView_0X20() []*WlstSluF800_View0X20 {
	if m != nil {
		return m.View_0X20
	}
	return nil
}

func (m *WlstSluF800) GetView_0X21() []*WlstSluF800_View0X21 {
	if m != nil {
		return m.View_0X21
	}
	return nil
}

func (m *WlstSluF800) GetView_0X22() []*WlstSluF800_View0X20 {
	if m != nil {
		return m.View_0X22
	}
	return nil
}

func (m *WlstSluF800) GetView_0X23() []*WlstSluF800_View0X23 {
	if m != nil {
		return m.View_0X23
	}
	return nil
}

func (m *WlstSluF800) GetView_0X24() []*WlstSluF800_View0X20 {
	if m != nil {
		return m.View_0X24
	}
	return nil
}

func (m *WlstSluF800) GetView_0X25() []*WlstSluF800_View0X20 {
	if m != nil {
		return m.View_0X25
	}
	return nil
}

type WlstSluF800_View0X20 struct {
	// 发生时间
	DtHappen int64 `protobuf:"varint,1,opt,name=dt_happen,json=dtHappen,proto3" json:"dt_happen,omitempty"`
	// 0x20->[复位类型]，0-上电复位，1-外部复位，2-看门狗复位，3-欠压复位
	// 0x22,0x25->[命令字节]
	// 0x24->[集中器地址出错，
	// 控制器参数出错，
	// 集中器其他参数出错，
	// 集中器运行参数出错，
	// 集中器告警参数出错，
	// 时钟出错，
	// 时钟硬件出错，
	// fram出错，
	// 电力载波模块出错，
	// zigbee模块出错，
	// 蓝牙模块出错]
	Status []int32 `protobuf:"varint,2,rep,packed,name=status,proto3" json:"status,omitempty"`
}

func (m *WlstSluF800_View0X20) Reset()      { *m = WlstSluF800_View0X20{} }
func (*WlstSluF800_View0X20) ProtoMessage() {}
func (*WlstSluF800_View0X20) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{3, 0}
}
func (m *WlstSluF800_View0X20) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSluF800_View0X20) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSluF800_View0X20.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSluF800_View0X20) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSluF800_View0X20.Merge(m, src)
}
func (m *WlstSluF800_View0X20) XXX_Size() int {
	return m.Size()
}
func (m *WlstSluF800_View0X20) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSluF800_View0X20.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSluF800_View0X20 proto.InternalMessageInfo

func (m *WlstSluF800_View0X20) GetDtHappen() int64 {
	if m != nil {
		return m.DtHappen
	}
	return 0
}

func (m *WlstSluF800_View0X20) GetStatus() []int32 {
	if m != nil {
		return m.Status
	}
	return nil
}

type WlstSluF800_View0X21 struct {
	// 发生时间
	DtHappen int64 `protobuf:"varint,1,opt,name=dt_happen,json=dtHappen,proto3" json:"dt_happen,omitempty"`
	// 指令类型 0-清除，1-定时，2-经纬度，3-即时
	OperationType int32 `protobuf:"varint,2,opt,name=operation_type,json=operationType,proto3" json:"operation_type,omitempty"`
	// 操作顺序 0-广播，1-依次
	OperationOrder int32 `protobuf:"varint,3,opt,name=operation_order,json=operationOrder,proto3" json:"operation_order,omitempty"`
	// 地址类型 0-全部，1-组，2-规则，3-单一，4-gprs
	AddrType int32 `protobuf:"varint,4,opt,name=addr_type,json=addrType,proto3" json:"addr_type,omitempty"`
	// 地址
	Addr int32 `protobuf:"varint,5,opt,name=addr,proto3" json:"addr,omitempty"`
	// 操作源,0~7-远程控制，8～15-短程控制，16～23-本地键盘操作，24～31-节假日控制
	OperationSource int32 `protobuf:"varint,6,opt,name=operation_source,json=operationSource,proto3" json:"operation_source,omitempty"`
}

func (m *WlstSluF800_View0X21) Reset()      { *m = WlstSluF800_View0X21{} }
func (*WlstSluF800_View0X21) ProtoMessage() {}
func (*WlstSluF800_View0X21) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{3, 1}
}
func (m *WlstSluF800_View0X21) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSluF800_View0X21) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSluF800_View0X21.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSluF800_View0X21) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSluF800_View0X21.Merge(m, src)
}
func (m *WlstSluF800_View0X21) XXX_Size() int {
	return m.Size()
}
func (m *WlstSluF800_View0X21) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSluF800_View0X21.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSluF800_View0X21 proto.InternalMessageInfo

func (m *WlstSluF800_View0X21) GetDtHappen() int64 {
	if m != nil {
		return m.DtHappen
	}
	return 0
}

func (m *WlstSluF800_View0X21) GetOperationType() int32 {
	if m != nil {
		return m.OperationType
	}
	return 0
}

func (m *WlstSluF800_View0X21) GetOperationOrder() int32 {
	if m != nil {
		return m.OperationOrder
	}
	return 0
}

func (m *WlstSluF800_View0X21) GetAddrType() int32 {
	if m != nil {
		return m.AddrType
	}
	return 0
}

func (m *WlstSluF800_View0X21) GetAddr() int32 {
	if m != nil {
		return m.Addr
	}
	return 0
}

func (m *WlstSluF800_View0X21) GetOperationSource() int32 {
	if m != nil {
		return m.OperationSource
	}
	return 0
}

type WlstSluF800_View0X23 struct {
	// 发生时间
	DtHappen int64 `protobuf:"varint,1,opt,name=dt_happen,json=dtHappen,proto3" json:"dt_happen,omitempty"`
	Addr     int32 `protobuf:"varint,2,opt,name=addr,proto3" json:"addr,omitempty"`
	// 告警类型，1-告警，0-消警，[意外灭灯，漏电告警，意外亮灯，光源故障，自熄灯故障，系统告警，通信故障，补偿电容故障，电压越限，电流越限，通信成功率过低，欠载，过载]
	AlarmType []int32 `protobuf:"varint,3,rep,packed,name=alarm_type,json=alarmType,proto3" json:"alarm_type,omitempty"`
	// 控制器状态0-false，1-true[继电器校准参数错误，eeprom故障，停运，禁止主动报警，工作参数设置，已校准，电压越上限，电压越下限，通信故障]
	SluitemStatus []int32 `protobuf:"varint,4,rep,packed,name=sluitem_status,json=sluitemStatus,proto3" json:"sluitem_status,omitempty"`
	// 控制器电压
	SluitemVoltage float64 `protobuf:"fixed64,5,opt,name=sluitem_voltage,json=sluitemVoltage,proto3" json:"sluitem_voltage,omitempty"`
	// 控制器电流,1-4路
	SluitemCurrent []float64 `protobuf:"fixed64,6,rep,packed,name=sluitem_current,json=sluitemCurrent,proto3" json:"sluitem_current,omitempty"`
	// 控制器有功，1-4路
	SluitemActivePower []float64 `protobuf:"fixed64,7,rep,packed,name=sluitem_active_power,json=sluitemActivePower,proto3" json:"sluitem_active_power,omitempty"`
	// 控制器无功，1-4路
	SluitemReactivePower []float64 `protobuf:"fixed64,8,rep,packed,name=sluitem_reactive_power,json=sluitemReactivePower,proto3" json:"sluitem_reactive_power,omitempty"`
	// 控制器最大电压
	SluitemMaxVoltage float64 `protobuf:"fixed64,9,opt,name=sluitem_max_voltage,json=sluitemMaxVoltage,proto3" json:"sluitem_max_voltage,omitempty"`
	// 控制器最大电流1-4路
	SluitemMaxCurrent []float64 `protobuf:"fixed64,10,rep,packed,name=sluitem_max_current,json=sluitemMaxCurrent,proto3" json:"sluitem_max_current,omitempty"`
	// 控制器累计电量，1-4路
	SluitemElectricity []float64 `protobuf:"fixed64,11,rep,packed,name=sluitem_electricity,json=sluitemElectricity,proto3" json:"sluitem_electricity,omitempty"`
	// 控制器物理信息
	// [信号强度(0-15)，
	// 路由级数(电力载波0-6，zigbee0-10)，
	// 所在相位(0-无法确定，1-a，2-b，3-c)，
	// 控制器回路数(0～3->1～4路)，
	// 节能方式(0-无控制，1-只有开关灯，2-一档节能，3-二档节能，4-rs485节能，5-pwm节能)，
	// 漏电流(0-无，1-有),
	// 温度采集(0-无，1-有),
	// 时钟(0-无，1-有),
	// 型号(0-无法确定，1-wj2090j，2-wj2090k，3-wj2080c,4-wj2080d,5-wj2090l,6-wj2090m, 7-wj4090),
	// 通信成功次数范围(0-16)，
	// 通信总次数范围(0-16)]
	SluitemPhyinfo []int32 `protobuf:"varint,12,rep,packed,name=sluitem_phyinfo,json=sluitemPhyinfo,proto3" json:"sluitem_phyinfo,omitempty"`
}

func (m *WlstSluF800_View0X23) Reset()      { *m = WlstSluF800_View0X23{} }
func (*WlstSluF800_View0X23) ProtoMessage() {}
func (*WlstSluF800_View0X23) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{3, 2}
}
func (m *WlstSluF800_View0X23) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSluF800_View0X23) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSluF800_View0X23.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSluF800_View0X23) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSluF800_View0X23.Merge(m, src)
}
func (m *WlstSluF800_View0X23) XXX_Size() int {
	return m.Size()
}
func (m *WlstSluF800_View0X23) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSluF800_View0X23.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSluF800_View0X23 proto.InternalMessageInfo

func (m *WlstSluF800_View0X23) GetDtHappen() int64 {
	if m != nil {
		return m.DtHappen
	}
	return 0
}

func (m *WlstSluF800_View0X23) GetAddr() int32 {
	if m != nil {
		return m.Addr
	}
	return 0
}

func (m *WlstSluF800_View0X23) GetAlarmType() []int32 {
	if m != nil {
		return m.AlarmType
	}
	return nil
}

func (m *WlstSluF800_View0X23) GetSluitemStatus() []int32 {
	if m != nil {
		return m.SluitemStatus
	}
	return nil
}

func (m *WlstSluF800_View0X23) GetSluitemVoltage() float64 {
	if m != nil {
		return m.SluitemVoltage
	}
	return 0
}

func (m *WlstSluF800_View0X23) GetSluitemCurrent() []float64 {
	if m != nil {
		return m.SluitemCurrent
	}
	return nil
}

func (m *WlstSluF800_View0X23) GetSluitemActivePower() []float64 {
	if m != nil {
		return m.SluitemActivePower
	}
	return nil
}

func (m *WlstSluF800_View0X23) GetSluitemReactivePower() []float64 {
	if m != nil {
		return m.SluitemReactivePower
	}
	return nil
}

func (m *WlstSluF800_View0X23) GetSluitemMaxVoltage() float64 {
	if m != nil {
		return m.SluitemMaxVoltage
	}
	return 0
}

func (m *WlstSluF800_View0X23) GetSluitemMaxCurrent() []float64 {
	if m != nil {
		return m.SluitemMaxCurrent
	}
	return nil
}

func (m *WlstSluF800_View0X23) GetSluitemElectricity() []float64 {
	if m != nil {
		return m.SluitemElectricity
	}
	return nil
}

func (m *WlstSluF800_View0X23) GetSluitemPhyinfo() []int32 {
	if m != nil {
		return m.SluitemPhyinfo
	}
	return nil
}

type WlstSluEc00 struct {
	// 命令序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 读取参数开始序号
	StartIdx int32 `protobuf:"varint,2,opt,name=start_idx,json=startIdx,proto3" json:"start_idx,omitempty"`
	// 读取条数
	ReadCount    int32           `protobuf:"varint,3,opt,name=read_count,json=readCount,proto3" json:"read_count,omitempty"`
	WlstSlu_6B00 []*WlstSlu_6B00 `protobuf:"bytes,4,rep,name=wlst_slu_6b00,json=wlstSlu6b00,proto3" json:"wlst_slu_6b00,omitempty"`
}

func (m *WlstSluEc00) Reset()      { *m = WlstSluEc00{} }
func (*WlstSluEc00) ProtoMessage() {}
func (*WlstSluEc00) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{4}
}
func (m *WlstSluEc00) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSluEc00) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSluEc00.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSluEc00) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSluEc00.Merge(m, src)
}
func (m *WlstSluEc00) XXX_Size() int {
	return m.Size()
}
func (m *WlstSluEc00) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSluEc00.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSluEc00 proto.InternalMessageInfo

func (m *WlstSluEc00) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *WlstSluEc00) GetStartIdx() int32 {
	if m != nil {
		return m.StartIdx
	}
	return 0
}

func (m *WlstSluEc00) GetReadCount() int32 {
	if m != nil {
		return m.ReadCount
	}
	return 0
}

func (m *WlstSluEc00) GetWlstSlu_6B00() []*WlstSlu_6B00 {
	if m != nil {
		return m.WlstSlu_6B00
	}
	return nil
}

type WlstSlu_6B00 struct {
	// 命令序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 设置参数序号,0-20,0-删除设备保存的所有节假日设置
	SetIdx int32 `protobuf:"varint,2,opt,name=set_idx,json=setIdx,proto3" json:"set_idx,omitempty"`
	// 开始时间, linux时间戳格式，精确到秒，服务取月，日，时
	DtStart int64 `protobuf:"varint,3,opt,name=dt_start,json=dtStart,proto3" json:"dt_start,omitempty"`
	// 结束时间, linux时间戳格式，精确到秒，服务取月，日，时
	DtEnd int64 `protobuf:"varint,4,opt,name=dt_end,json=dtEnd,proto3" json:"dt_end,omitempty"`
	// 指令类型 1-定时，2-经纬度
	OperationType int32 `protobuf:"varint,5,opt,name=operation_type,json=operationType,proto3" json:"operation_type,omitempty"`
	// 操作顺序 0-广播，1-依次
	OperationOrder int32 `protobuf:"varint,6,opt,name=operation_order,json=operationOrder,proto3" json:"operation_order,omitempty"`
	// 定时 hh:mm->int32 或偏移量 依据 operation_type定
	TimerOrOffset int32 `protobuf:"varint,7,opt,name=timer_or_offset,json=timerOrOffset,proto3" json:"timer_or_offset,omitempty"`
	// 地址类型 0-全部，1-组，2-规则，4-gprs
	AddrType int32 `protobuf:"varint,8,opt,name=addr_type,json=addrType,proto3" json:"addr_type,omitempty"`
	// gprs/组/规则操作地址,addr_type=2时，仅第一个值有效
	Addrs []int32 `protobuf:"varint,9,rep,packed,name=addrs,proto3" json:"addrs,omitempty"`
	// 操作类型 3-经纬度关灯，4-混合控制，5-pwm调节
	CmdType int32 `protobuf:"varint,10,opt,name=cmd_type,json=cmdType,proto3" json:"cmd_type,omitempty"`
	// 混合回路操作 0-不操作，1-开灯，2-1档节能，3-2档节能，4-关灯（经纬度关灯时，cmd_type<4视为不操作）
	CmdMix []int32 `protobuf:"varint,11,rep,packed,name=cmd_mix,json=cmdMix,proto3" json:"cmd_mix,omitempty"`
	// pwm功率调节
	CmdPwm *WlstSlu_6B00_CmdPwm `protobuf:"bytes,12,opt,name=cmd_pwm,json=cmdPwm,proto3" json:"cmd_pwm,omitempty"`
}

func (m *WlstSlu_6B00) Reset()      { *m = WlstSlu_6B00{} }
func (*WlstSlu_6B00) ProtoMessage() {}
func (*WlstSlu_6B00) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{5}
}
func (m *WlstSlu_6B00) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_6B00) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_6B00.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_6B00) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_6B00.Merge(m, src)
}
func (m *WlstSlu_6B00) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_6B00) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_6B00.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_6B00 proto.InternalMessageInfo

func (m *WlstSlu_6B00) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *WlstSlu_6B00) GetSetIdx() int32 {
	if m != nil {
		return m.SetIdx
	}
	return 0
}

func (m *WlstSlu_6B00) GetDtStart() int64 {
	if m != nil {
		return m.DtStart
	}
	return 0
}

func (m *WlstSlu_6B00) GetDtEnd() int64 {
	if m != nil {
		return m.DtEnd
	}
	return 0
}

func (m *WlstSlu_6B00) GetOperationType() int32 {
	if m != nil {
		return m.OperationType
	}
	return 0
}

func (m *WlstSlu_6B00) GetOperationOrder() int32 {
	if m != nil {
		return m.OperationOrder
	}
	return 0
}

func (m *WlstSlu_6B00) GetTimerOrOffset() int32 {
	if m != nil {
		return m.TimerOrOffset
	}
	return 0
}

func (m *WlstSlu_6B00) GetAddrType() int32 {
	if m != nil {
		return m.AddrType
	}
	return 0
}

func (m *WlstSlu_6B00) GetAddrs() []int32 {
	if m != nil {
		return m.Addrs
	}
	return nil
}

func (m *WlstSlu_6B00) GetCmdType() int32 {
	if m != nil {
		return m.CmdType
	}
	return 0
}

func (m *WlstSlu_6B00) GetCmdMix() []int32 {
	if m != nil {
		return m.CmdMix
	}
	return nil
}

func (m *WlstSlu_6B00) GetCmdPwm() *WlstSlu_6B00_CmdPwm {
	if m != nil {
		return m.CmdPwm
	}
	return nil
}

type WlstSlu_6B00_CmdPwm struct {
	// 回路(仅需要操作的回路序号)
	LoopCanDo []int32 `protobuf:"varint,1,rep,packed,name=loop_can_do,json=loopCanDo,proto3" json:"loop_can_do,omitempty"`
	// 比例 0-100 -> 0%-100%
	Scale int32 `protobuf:"varint,2,opt,name=scale,proto3" json:"scale,omitempty"`
	// 频率 /100为发送值
	Rate int32 `protobuf:"varint,3,opt,name=rate,proto3" json:"rate,omitempty"`
}

func (m *WlstSlu_6B00_CmdPwm) Reset()      { *m = WlstSlu_6B00_CmdPwm{} }
func (*WlstSlu_6B00_CmdPwm) ProtoMessage() {}
func (*WlstSlu_6B00_CmdPwm) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{5, 0}
}
func (m *WlstSlu_6B00_CmdPwm) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_6B00_CmdPwm) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_6B00_CmdPwm.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_6B00_CmdPwm) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_6B00_CmdPwm.Merge(m, src)
}
func (m *WlstSlu_6B00_CmdPwm) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_6B00_CmdPwm) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_6B00_CmdPwm.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_6B00_CmdPwm proto.InternalMessageInfo

func (m *WlstSlu_6B00_CmdPwm) GetLoopCanDo() []int32 {
	if m != nil {
		return m.LoopCanDo
	}
	return nil
}

func (m *WlstSlu_6B00_CmdPwm) GetScale() int32 {
	if m != nil {
		return m.Scale
	}
	return 0
}

func (m *WlstSlu_6B00_CmdPwm) GetRate() int32 {
	if m != nil {
		return m.Rate
	}
	return 0
}

type WlstSlu_6C00 struct {
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 读取参数开始序号
	StartIdx int32 `protobuf:"varint,2,opt,name=start_idx,json=startIdx,proto3" json:"start_idx,omitempty"`
	// 读取条数
	ReadCount int32 `protobuf:"varint,3,opt,name=read_count,json=readCount,proto3" json:"read_count,omitempty"`
}

func (m *WlstSlu_6C00) Reset()      { *m = WlstSlu_6C00{} }
func (*WlstSlu_6C00) ProtoMessage() {}
func (*WlstSlu_6C00) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{6}
}
func (m *WlstSlu_6C00) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_6C00) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_6C00.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_6C00) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_6C00.Merge(m, src)
}
func (m *WlstSlu_6C00) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_6C00) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_6C00.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_6C00 proto.InternalMessageInfo

func (m *WlstSlu_6C00) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *WlstSlu_6C00) GetStartIdx() int32 {
	if m != nil {
		return m.StartIdx
	}
	return 0
}

func (m *WlstSlu_6C00) GetReadCount() int32 {
	if m != nil {
		return m.ReadCount
	}
	return 0
}

type WlstSluD000 struct {
	// 集中器版本
	Ver string `protobuf:"bytes,1,opt,name=ver,proto3" json:"ver,omitempty"`
}

func (m *WlstSluD000) Reset()      { *m = WlstSluD000{} }
func (*WlstSluD000) ProtoMessage() {}
func (*WlstSluD000) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{7}
}
func (m *WlstSluD000) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSluD000) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSluD000.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSluD000) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSluD000.Merge(m, src)
}
func (m *WlstSluD000) XXX_Size() int {
	return m.Size()
}
func (m *WlstSluD000) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSluD000.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSluD000 proto.InternalMessageInfo

func (m *WlstSluD000) GetVer() string {
	if m != nil {
		return m.Ver
	}
	return ""
}

type WlstSlu_2800 struct {
	// 2-投运，1-停运
	Status int32 `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
	// 2-告警，1-不告警
	Alarm int32 `protobuf:"varint,2,opt,name=alarm,proto3" json:"alarm,omitempty"`
}

func (m *WlstSlu_2800) Reset()      { *m = WlstSlu_2800{} }
func (*WlstSlu_2800) ProtoMessage() {}
func (*WlstSlu_2800) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{8}
}
func (m *WlstSlu_2800) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_2800) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_2800.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_2800) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_2800.Merge(m, src)
}
func (m *WlstSlu_2800) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_2800) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_2800.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_2800 proto.InternalMessageInfo

func (m *WlstSlu_2800) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *WlstSlu_2800) GetAlarm() int32 {
	if m != nil {
		return m.Alarm
	}
	return 0
}

// Wlst_slu_9900_1900
type WlstSlu_2400 struct {
	// 操作标识（19-99：1-复位整个网络，2-以路由形式加入当前网络，3-创建网络，4-以路由形式加入新网络）（24-a4：0-停止，1-启动，2-延时启动）
	DoFlag int32 `protobuf:"varint,1,opt,name=do_flag,json=doFlag,proto3" json:"do_flag,omitempty"`
	// 操作结果 0x3a-失败，0x5a-成功
	Status int32 `protobuf:"varint,2,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *WlstSlu_2400) Reset()      { *m = WlstSlu_2400{} }
func (*WlstSlu_2400) ProtoMessage() {}
func (*WlstSlu_2400) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{9}
}
func (m *WlstSlu_2400) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_2400) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_2400.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_2400) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_2400.Merge(m, src)
}
func (m *WlstSlu_2400) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_2400) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_2400.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_2400 proto.InternalMessageInfo

func (m *WlstSlu_2400) GetDoFlag() int32 {
	if m != nil {
		return m.DoFlag
	}
	return 0
}

func (m *WlstSlu_2400) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

// Wlst_slu_ee00
type WlstSlu_6E00 struct {
	// 操作标识（0-清除设置，1-设置，2-读取设置）
	DoFlag int32 `protobuf:"varint,1,opt,name=do_flag,json=doFlag,proto3" json:"do_flag,omitempty"`
	// 巡测开始时间 hhmm->int32(hh*60+mm)
	PatrolStart int32 `protobuf:"varint,2,opt,name=patrol_start,json=patrolStart,proto3" json:"patrol_start,omitempty"`
	// 巡测间隔时间 mm(0<=mm<=255)
	PatrolInterval int32 `protobuf:"varint,3,opt,name=patrol_interval,json=patrolInterval,proto3" json:"patrol_interval,omitempty"`
	// 巡测序号
	PatrolOrder int32 `protobuf:"varint,4,opt,name=patrol_order,json=patrolOrder,proto3" json:"patrol_order,omitempty"`
	// 巡测数量
	PatrolCount int32 `protobuf:"varint,5,opt,name=patrol_count,json=patrolCount,proto3" json:"patrol_count,omitempty"`
	// 序号
	CmdIdx int32 `protobuf:"varint,6,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
}

func (m *WlstSlu_6E00) Reset()      { *m = WlstSlu_6E00{} }
func (*WlstSlu_6E00) ProtoMessage() {}
func (*WlstSlu_6E00) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{10}
}
func (m *WlstSlu_6E00) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_6E00) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_6E00.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_6E00) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_6E00.Merge(m, src)
}
func (m *WlstSlu_6E00) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_6E00) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_6E00.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_6E00 proto.InternalMessageInfo

func (m *WlstSlu_6E00) GetDoFlag() int32 {
	if m != nil {
		return m.DoFlag
	}
	return 0
}

func (m *WlstSlu_6E00) GetPatrolStart() int32 {
	if m != nil {
		return m.PatrolStart
	}
	return 0
}

func (m *WlstSlu_6E00) GetPatrolInterval() int32 {
	if m != nil {
		return m.PatrolInterval
	}
	return 0
}

func (m *WlstSlu_6E00) GetPatrolOrder() int32 {
	if m != nil {
		return m.PatrolOrder
	}
	return 0
}

func (m *WlstSlu_6E00) GetPatrolCount() int32 {
	if m != nil {
		return m.PatrolCount
	}
	return 0
}

func (m *WlstSlu_6E00) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

// Wlst_slu_b200
type WlstSlu_3000 struct {
	// 控制器数量
	Ctrls int32 `protobuf:"varint,1,opt,name=ctrls,proto3" json:"ctrls,omitempty"`
	// 域名
	DomainName int32 `protobuf:"varint,2,opt,name=domain_name,json=domainName,proto3" json:"domain_name,omitempty"`
	// 电压上限
	UpperVoltageLimit int32 `protobuf:"varint,3,opt,name=upper_voltage_limit,json=upperVoltageLimit,proto3" json:"upper_voltage_limit,omitempty"`
	// 电压下限
	LowerVoltageLimit int32 `protobuf:"varint,4,opt,name=lower_voltage_limit,json=lowerVoltageLimit,proto3" json:"lower_voltage_limit,omitempty"`
	// 64位地址
	MacAddr int64 `protobuf:"varint,5,opt,name=mac_addr,json=macAddr,proto3" json:"mac_addr,omitempty"`
}

func (m *WlstSlu_3000) Reset()      { *m = WlstSlu_3000{} }
func (*WlstSlu_3000) ProtoMessage() {}
func (*WlstSlu_3000) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{11}
}
func (m *WlstSlu_3000) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_3000) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_3000.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_3000) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_3000.Merge(m, src)
}
func (m *WlstSlu_3000) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_3000) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_3000.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_3000 proto.InternalMessageInfo

func (m *WlstSlu_3000) GetCtrls() int32 {
	if m != nil {
		return m.Ctrls
	}
	return 0
}

func (m *WlstSlu_3000) GetDomainName() int32 {
	if m != nil {
		return m.DomainName
	}
	return 0
}

func (m *WlstSlu_3000) GetUpperVoltageLimit() int32 {
	if m != nil {
		return m.UpperVoltageLimit
	}
	return 0
}

func (m *WlstSlu_3000) GetLowerVoltageLimit() int32 {
	if m != nil {
		return m.LowerVoltageLimit
	}
	return 0
}

func (m *WlstSlu_3000) GetMacAddr() int64 {
	if m != nil {
		return m.MacAddr
	}
	return 0
}

type WlstSlu_9A00 struct {
	// 域名已设置标志
	DomainNameStatus []int32 `protobuf:"varint,1,rep,packed,name=domain_name_status,json=domainNameStatus,proto3" json:"domain_name_status,omitempty"`
}

func (m *WlstSlu_9A00) Reset()      { *m = WlstSlu_9A00{} }
func (*WlstSlu_9A00) ProtoMessage() {}
func (*WlstSlu_9A00) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{12}
}
func (m *WlstSlu_9A00) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_9A00) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_9A00.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_9A00) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_9A00.Merge(m, src)
}
func (m *WlstSlu_9A00) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_9A00) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_9A00.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_9A00 proto.InternalMessageInfo

func (m *WlstSlu_9A00) GetDomainNameStatus() []int32 {
	if m != nil {
		return m.DomainNameStatus
	}
	return nil
}

// Wlst_slu_7600
type WlstSluCd00 struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,13,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 通讯失败次数
	CommunicationFailures int32 `protobuf:"varint,1,opt,name=communication_failures,json=communicationFailures,proto3" json:"communication_failures,omitempty"`
	// 功率因数
	PowerFactor int32 `protobuf:"varint,2,opt,name=power_factor,json=powerFactor,proto3" json:"power_factor,omitempty"`
	// 通信信道(仅包含启用的通道)
	CommunicationChannel int32 `protobuf:"varint,3,opt,name=communication_channel,json=communicationChannel,proto3" json:"communication_channel,omitempty"`
	// 电流最大量程
	CurrentRange float64 `protobuf:"fixed64,4,opt,name=current_range,json=currentRange,proto3" json:"current_range,omitempty"`
	// 有功最大量程
	PowerRange int32 `protobuf:"varint,5,opt,name=power_range,json=powerRange,proto3" json:"power_range,omitempty"`
	// 集中器自动控制功能 1-自动补发，0-不补发
	AutoMode int32 `protobuf:"varint,6,opt,name=auto_mode,json=autoMode,proto3" json:"auto_mode,omitempty"`
	// 经度
	Longitude float64 `protobuf:"fixed64,7,opt,name=longitude,proto3" json:"longitude,omitempty"`
	// 纬度
	Latitude float64 `protobuf:"fixed64,8,opt,name=latitude,proto3" json:"latitude,omitempty"`
	// 载波路由模式 1-标准，2-扩展，3-III代，4-IV代，5-自适应
	CarrierRoutingMode int32 `protobuf:"varint,9,opt,name=carrier_routing_mode,json=carrierRoutingMode,proto3" json:"carrier_routing_mode,omitempty"`
	// 蓝牙模块pin码，默认62547600
	BluetoothPin int32 `protobuf:"varint,10,opt,name=bluetooth_pin,json=bluetoothPin,proto3" json:"bluetooth_pin,omitempty"`
	// 蓝牙安全模式 0-无，1-安全模式1,2-安全模式2
	BluetoothMode int32 `protobuf:"varint,11,opt,name=bluetooth_mode,json=bluetoothMode,proto3" json:"bluetooth_mode,omitempty"`
	// 集中器通讯类型,concentrator communication type 0-gprs，1-485
	Cct int32 `protobuf:"varint,12,opt,name=cct,proto3" json:"cct,omitempty"`
	// 控制器24小时带电，0-不带电（集中器不转发时间），1-带电（集中器转发时间）
	AlwaysOnline int32 `protobuf:"varint,14,opt,name=always_online,json=alwaysOnline,proto3" json:"always_online,omitempty"`
}

func (m *WlstSluCd00) Reset()      { *m = WlstSluCd00{} }
func (*WlstSluCd00) ProtoMessage() {}
func (*WlstSluCd00) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{13}
}
func (m *WlstSluCd00) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSluCd00) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSluCd00.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSluCd00) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSluCd00.Merge(m, src)
}
func (m *WlstSluCd00) XXX_Size() int {
	return m.Size()
}
func (m *WlstSluCd00) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSluCd00.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSluCd00 proto.InternalMessageInfo

func (m *WlstSluCd00) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *WlstSluCd00) GetCommunicationFailures() int32 {
	if m != nil {
		return m.CommunicationFailures
	}
	return 0
}

func (m *WlstSluCd00) GetPowerFactor() int32 {
	if m != nil {
		return m.PowerFactor
	}
	return 0
}

func (m *WlstSluCd00) GetCommunicationChannel() int32 {
	if m != nil {
		return m.CommunicationChannel
	}
	return 0
}

func (m *WlstSluCd00) GetCurrentRange() float64 {
	if m != nil {
		return m.CurrentRange
	}
	return 0
}

func (m *WlstSluCd00) GetPowerRange() int32 {
	if m != nil {
		return m.PowerRange
	}
	return 0
}

func (m *WlstSluCd00) GetAutoMode() int32 {
	if m != nil {
		return m.AutoMode
	}
	return 0
}

func (m *WlstSluCd00) GetLongitude() float64 {
	if m != nil {
		return m.Longitude
	}
	return 0
}

func (m *WlstSluCd00) GetLatitude() float64 {
	if m != nil {
		return m.Latitude
	}
	return 0
}

func (m *WlstSluCd00) GetCarrierRoutingMode() int32 {
	if m != nil {
		return m.CarrierRoutingMode
	}
	return 0
}

func (m *WlstSluCd00) GetBluetoothPin() int32 {
	if m != nil {
		return m.BluetoothPin
	}
	return 0
}

func (m *WlstSluCd00) GetBluetoothMode() int32 {
	if m != nil {
		return m.BluetoothMode
	}
	return 0
}

func (m *WlstSluCd00) GetCct() int32 {
	if m != nil {
		return m.Cct
	}
	return 0
}

func (m *WlstSluCd00) GetAlwaysOnline() int32 {
	if m != nil {
		return m.AlwaysOnline
	}
	return 0
}

type WlstSlu_1C00 struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 控制器条码
	SluitemIdx int64 `protobuf:"varint,2,opt,name=sluitem_idx,json=sluitemIdx,proto3" json:"sluitem_idx,omitempty"`
	// 域名
	DomainName int32 `protobuf:"varint,3,opt,name=domain_name,json=domainName,proto3" json:"domain_name,omitempty"`
}

func (m *WlstSlu_1C00) Reset()      { *m = WlstSlu_1C00{} }
func (*WlstSlu_1C00) ProtoMessage() {}
func (*WlstSlu_1C00) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{14}
}
func (m *WlstSlu_1C00) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_1C00) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_1C00.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_1C00) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_1C00.Merge(m, src)
}
func (m *WlstSlu_1C00) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_1C00) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_1C00.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_1C00 proto.InternalMessageInfo

func (m *WlstSlu_1C00) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *WlstSlu_1C00) GetSluitemIdx() int64 {
	if m != nil {
		return m.SluitemIdx
	}
	return 0
}

func (m *WlstSlu_1C00) GetDomainName() int32 {
	if m != nil {
		return m.DomainName
	}
	return 0
}

// Wlst_slu_7a00
type WlstSlu_1D00 struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 控制器条码（4字节）
	SluitemIdx int64 `protobuf:"varint,2,opt,name=sluitem_idx,json=sluitemIdx,proto3" json:"sluitem_idx,omitempty"`
	// 控制器地址（2字节）
	// int64 sluitem_idx = 3;
	// 选测数据标识
	DataMark *WlstSlu_1D00_DataMark `protobuf:"bytes,4,opt,name=data_mark,json=dataMark,proto3" json:"data_mark,omitempty"`
}

func (m *WlstSlu_1D00) Reset()      { *m = WlstSlu_1D00{} }
func (*WlstSlu_1D00) ProtoMessage() {}
func (*WlstSlu_1D00) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{15}
}
func (m *WlstSlu_1D00) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_1D00) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_1D00.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_1D00) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_1D00.Merge(m, src)
}
func (m *WlstSlu_1D00) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_1D00) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_1D00.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_1D00 proto.InternalMessageInfo

func (m *WlstSlu_1D00) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *WlstSlu_1D00) GetSluitemIdx() int64 {
	if m != nil {
		return m.SluitemIdx
	}
	return 0
}

func (m *WlstSlu_1D00) GetDataMark() *WlstSlu_1D00_DataMark {
	if m != nil {
		return m.DataMark
	}
	return nil
}

type WlstSlu_1D00_DataMark struct {
	// 选测
	ReadData int32 `protobuf:"varint,1,opt,name=read_data,json=readData,proto3" json:"read_data,omitempty"`
	// 读取时钟
	ReadTimer int32 `protobuf:"varint,2,opt,name=read_timer,json=readTimer,proto3" json:"read_timer,omitempty"`
	// 读取运行参数
	ReadArgs int32 `protobuf:"varint,3,opt,name=read_args,json=readArgs,proto3" json:"read_args,omitempty"`
	// 读取组地址
	ReadGroup int32 `protobuf:"varint,4,opt,name=read_group,json=readGroup,proto3" json:"read_group,omitempty"`
	// 读取版本
	ReadVer int32 `protobuf:"varint,5,opt,name=read_ver,json=readVer,proto3" json:"read_ver,omitempty"`
	// 读取当天日出日落
	ReadSunriseset int32 `protobuf:"varint,6,opt,name=read_sunriseset,json=readSunriseset,proto3" json:"read_sunriseset,omitempty"`
	// 读取本地参数（新）
	ReadTimetable int32 `protobuf:"varint,7,opt,name=read_timetable,json=readTimetable,proto3" json:"read_timetable,omitempty"`
	// 读取控制器数据（新）
	ReadCtrldata int32 `protobuf:"varint,8,opt,name=read_ctrldata,json=readCtrldata,proto3" json:"read_ctrldata,omitempty"`
}

func (m *WlstSlu_1D00_DataMark) Reset()      { *m = WlstSlu_1D00_DataMark{} }
func (*WlstSlu_1D00_DataMark) ProtoMessage() {}
func (*WlstSlu_1D00_DataMark) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{15, 0}
}
func (m *WlstSlu_1D00_DataMark) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_1D00_DataMark) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_1D00_DataMark.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_1D00_DataMark) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_1D00_DataMark.Merge(m, src)
}
func (m *WlstSlu_1D00_DataMark) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_1D00_DataMark) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_1D00_DataMark.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_1D00_DataMark proto.InternalMessageInfo

func (m *WlstSlu_1D00_DataMark) GetReadData() int32 {
	if m != nil {
		return m.ReadData
	}
	return 0
}

func (m *WlstSlu_1D00_DataMark) GetReadTimer() int32 {
	if m != nil {
		return m.ReadTimer
	}
	return 0
}

func (m *WlstSlu_1D00_DataMark) GetReadArgs() int32 {
	if m != nil {
		return m.ReadArgs
	}
	return 0
}

func (m *WlstSlu_1D00_DataMark) GetReadGroup() int32 {
	if m != nil {
		return m.ReadGroup
	}
	return 0
}

func (m *WlstSlu_1D00_DataMark) GetReadVer() int32 {
	if m != nil {
		return m.ReadVer
	}
	return 0
}

func (m *WlstSlu_1D00_DataMark) GetReadSunriseset() int32 {
	if m != nil {
		return m.ReadSunriseset
	}
	return 0
}

func (m *WlstSlu_1D00_DataMark) GetReadTimetable() int32 {
	if m != nil {
		return m.ReadTimetable
	}
	return 0
}

func (m *WlstSlu_1D00_DataMark) GetReadCtrldata() int32 {
	if m != nil {
		return m.ReadCtrldata
	}
	return 0
}

// Wlst_slu_fa00
type WlstSlu_9D00 struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 控制器条码（4字节）
	SluitemIdx int64 `protobuf:"varint,2,opt,name=sluitem_idx,json=sluitemIdx,proto3" json:"sluitem_idx,omitempty"`
	// 控制器地址（2字节）
	// int32 sluitem_idx = 3;
	// 选测数据标识
	DataMark *WlstSlu_1D00_DataMark `protobuf:"bytes,4,opt,name=data_mark,json=dataMark,proto3" json:"data_mark,omitempty"`
	// 控制器回路数量
	LoopCount int32 `protobuf:"varint,5,opt,name=loop_count,json=loopCount,proto3" json:"loop_count,omitempty"`
	// 控制器选测数据(read_data)
	SluitemData *WlstSlu_9D00_SluitemData `protobuf:"bytes,6,opt,name=sluitem_data,json=sluitemData,proto3" json:"sluitem_data,omitempty"`
	// 控制器时钟(read_timer)
	SluitemTime int64 `protobuf:"varint,7,opt,name=sluitem_time,json=sluitemTime,proto3" json:"sluitem_time,omitempty"`
	// 控制器运行参数(read_args)
	SluitemPara *WlstSlu_9D00_SluitemPara `protobuf:"bytes,8,opt,name=sluitem_para,json=sluitemPara,proto3" json:"sluitem_para,omitempty"`
	// 控制器组地址(read_group)
	SluitemGroup []int32 `protobuf:"varint,9,rep,packed,name=sluitem_group,json=sluitemGroup,proto3" json:"sluitem_group,omitempty"`
	// 控制器版本(read_ver)
	SluitemVer *WlstSlu_9D00_SluitemVer `protobuf:"bytes,10,opt,name=sluitem_ver,json=sluitemVer,proto3" json:"sluitem_ver,omitempty"`
	// 控制器当日日出日落(read_sunriseset)
	SluitemSunriseset *WlstSlu_9D00_SluitemSunriseset `protobuf:"bytes,11,opt,name=sluitem_sunriseset,json=sluitemSunriseset,proto3" json:"sluitem_sunriseset,omitempty"`
	// 控制器本地参数(read_timetable)
	SluitemRuntime []*WlstSlu_9D00_SluitemRuntime `protobuf:"bytes,12,rep,name=sluitem_runtime,json=sluitemRuntime,proto3" json:"sluitem_runtime,omitempty"`
	// 控制器数据（新）(read_ctrldata)
	SluitemDataNew *WlstSlu_9D00_SluitemDataNew `protobuf:"bytes,13,opt,name=sluitem_data_new,json=sluitemDataNew,proto3" json:"sluitem_data_new,omitempty"`
	// 读取状态0-失败，1-成功
	Status  int32                 `protobuf:"varint,14,opt,name=status,proto3" json:"status,omitempty"`
	SetMark *WlstSlu_9D00_SetMark `protobuf:"bytes,15,opt,name=set_mark,json=setMark,proto3" json:"set_mark,omitempty"`
	// 是否有后续数据,0-没有，1-有
	DataContinue int32 `protobuf:"varint,16,opt,name=data_continue,json=dataContinue,proto3" json:"data_continue,omitempty"`
}

func (m *WlstSlu_9D00) Reset()      { *m = WlstSlu_9D00{} }
func (*WlstSlu_9D00) ProtoMessage() {}
func (*WlstSlu_9D00) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{16}
}
func (m *WlstSlu_9D00) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_9D00) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_9D00.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_9D00) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_9D00.Merge(m, src)
}
func (m *WlstSlu_9D00) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_9D00) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_9D00.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_9D00 proto.InternalMessageInfo

func (m *WlstSlu_9D00) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *WlstSlu_9D00) GetSluitemIdx() int64 {
	if m != nil {
		return m.SluitemIdx
	}
	return 0
}

func (m *WlstSlu_9D00) GetDataMark() *WlstSlu_1D00_DataMark {
	if m != nil {
		return m.DataMark
	}
	return nil
}

func (m *WlstSlu_9D00) GetLoopCount() int32 {
	if m != nil {
		return m.LoopCount
	}
	return 0
}

func (m *WlstSlu_9D00) GetSluitemData() *WlstSlu_9D00_SluitemData {
	if m != nil {
		return m.SluitemData
	}
	return nil
}

func (m *WlstSlu_9D00) GetSluitemTime() int64 {
	if m != nil {
		return m.SluitemTime
	}
	return 0
}

func (m *WlstSlu_9D00) GetSluitemPara() *WlstSlu_9D00_SluitemPara {
	if m != nil {
		return m.SluitemPara
	}
	return nil
}

func (m *WlstSlu_9D00) GetSluitemGroup() []int32 {
	if m != nil {
		return m.SluitemGroup
	}
	return nil
}

func (m *WlstSlu_9D00) GetSluitemVer() *WlstSlu_9D00_SluitemVer {
	if m != nil {
		return m.SluitemVer
	}
	return nil
}

func (m *WlstSlu_9D00) GetSluitemSunriseset() *WlstSlu_9D00_SluitemSunriseset {
	if m != nil {
		return m.SluitemSunriseset
	}
	return nil
}

func (m *WlstSlu_9D00) GetSluitemRuntime() []*WlstSlu_9D00_SluitemRuntime {
	if m != nil {
		return m.SluitemRuntime
	}
	return nil
}

func (m *WlstSlu_9D00) GetSluitemDataNew() *WlstSlu_9D00_SluitemDataNew {
	if m != nil {
		return m.SluitemDataNew
	}
	return nil
}

func (m *WlstSlu_9D00) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *WlstSlu_9D00) GetSetMark() *WlstSlu_9D00_SetMark {
	if m != nil {
		return m.SetMark
	}
	return nil
}

func (m *WlstSlu_9D00) GetDataContinue() int32 {
	if m != nil {
		return m.DataContinue
	}
	return 0
}

type WlstSlu_9D00_SetMark struct {
	SetTimer   int32 `protobuf:"varint,1,opt,name=set_timer,json=setTimer,proto3" json:"set_timer,omitempty"`
	SetArgs    int32 `protobuf:"varint,2,opt,name=set_args,json=setArgs,proto3" json:"set_args,omitempty"`
	SetGroup   int32 `protobuf:"varint,3,opt,name=set_group,json=setGroup,proto3" json:"set_group,omitempty"`
	SetReset   int32 `protobuf:"varint,4,opt,name=set_reset,json=setReset,proto3" json:"set_reset,omitempty"`
	SetControl int32 `protobuf:"varint,5,opt,name=set_control,json=setControl,proto3" json:"set_control,omitempty"`
}

func (m *WlstSlu_9D00_SetMark) Reset()      { *m = WlstSlu_9D00_SetMark{} }
func (*WlstSlu_9D00_SetMark) ProtoMessage() {}
func (*WlstSlu_9D00_SetMark) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{16, 0}
}
func (m *WlstSlu_9D00_SetMark) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_9D00_SetMark) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_9D00_SetMark.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_9D00_SetMark) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_9D00_SetMark.Merge(m, src)
}
func (m *WlstSlu_9D00_SetMark) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_9D00_SetMark) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_9D00_SetMark.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_9D00_SetMark proto.InternalMessageInfo

func (m *WlstSlu_9D00_SetMark) GetSetTimer() int32 {
	if m != nil {
		return m.SetTimer
	}
	return 0
}

func (m *WlstSlu_9D00_SetMark) GetSetArgs() int32 {
	if m != nil {
		return m.SetArgs
	}
	return 0
}

func (m *WlstSlu_9D00_SetMark) GetSetGroup() int32 {
	if m != nil {
		return m.SetGroup
	}
	return 0
}

func (m *WlstSlu_9D00_SetMark) GetSetReset() int32 {
	if m != nil {
		return m.SetReset
	}
	return 0
}

func (m *WlstSlu_9D00_SetMark) GetSetControl() int32 {
	if m != nil {
		return m.SetControl
	}
	return 0
}

type WlstSlu_9D00_SluitemData struct {
	// 电压 /100
	Voltage float64 `protobuf:"fixed64,1,opt,name=voltage,proto3" json:"voltage,omitempty"`
	// 电流 /100
	Current []float64 `protobuf:"fixed64,2,rep,packed,name=current,proto3" json:"current,omitempty"`
	// 有功功率 /10
	ActivePower []float64 `protobuf:"fixed64,3,rep,packed,name=active_power,json=activePower,proto3" json:"active_power,omitempty"`
	// 无功功率 /10
	ReactivePower []float64 `protobuf:"fixed64,4,rep,packed,name=reactive_power,json=reactivePower,proto3" json:"reactive_power,omitempty"`
	// 最大电压 /100
	MaxVoltage float64 `protobuf:"fixed64,5,opt,name=max_voltage,json=maxVoltage,proto3" json:"max_voltage,omitempty"`
	// 最大电流 /100
	MaxCurrent []float64 `protobuf:"fixed64,6,rep,packed,name=max_current,json=maxCurrent,proto3" json:"max_current,omitempty"`
	// 累计电量
	TotalElectricity []float64 `protobuf:"fixed64,7,rep,packed,name=total_electricity,json=totalElectricity,proto3" json:"total_electricity,omitempty"`
	// 温度 0xff无效
	Temperature int32 `protobuf:"varint,8,opt,name=temperature,proto3" json:"temperature,omitempty"`
	// 漏电流 /100
	LeakageCurrent float64 `protobuf:"fixed64,9,opt,name=leakage_current,json=leakageCurrent,proto3" json:"leakage_current,omitempty"`
	// 时钟故障
	TimerError int32 `protobuf:"varint,10,opt,name=timer_error,json=timerError,proto3" json:"timer_error,omitempty"`
	// 控制器状态
	SluitemStatus *WlstSlu_7300_BaseSluitemData_SluitemStatus `protobuf:"bytes,11,opt,name=sluitem_status,json=sluitemStatus,proto3" json:"sluitem_status,omitempty"`
	// 灯状态
	LightStatus []*WlstSlu_7300_BaseSluitemData_LightStatus `protobuf:"bytes,12,rep,name=light_status,json=lightStatus,proto3" json:"light_status,omitempty"`
	// 自复位次数
	ResetCount int32 `protobuf:"varint,13,opt,name=reset_count,json=resetCount,proto3" json:"reset_count,omitempty"`
}

func (m *WlstSlu_9D00_SluitemData) Reset()      { *m = WlstSlu_9D00_SluitemData{} }
func (*WlstSlu_9D00_SluitemData) ProtoMessage() {}
func (*WlstSlu_9D00_SluitemData) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{16, 1}
}
func (m *WlstSlu_9D00_SluitemData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_9D00_SluitemData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_9D00_SluitemData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_9D00_SluitemData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_9D00_SluitemData.Merge(m, src)
}
func (m *WlstSlu_9D00_SluitemData) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_9D00_SluitemData) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_9D00_SluitemData.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_9D00_SluitemData proto.InternalMessageInfo

func (m *WlstSlu_9D00_SluitemData) GetVoltage() float64 {
	if m != nil {
		return m.Voltage
	}
	return 0
}

func (m *WlstSlu_9D00_SluitemData) GetCurrent() []float64 {
	if m != nil {
		return m.Current
	}
	return nil
}

func (m *WlstSlu_9D00_SluitemData) GetActivePower() []float64 {
	if m != nil {
		return m.ActivePower
	}
	return nil
}

func (m *WlstSlu_9D00_SluitemData) GetReactivePower() []float64 {
	if m != nil {
		return m.ReactivePower
	}
	return nil
}

func (m *WlstSlu_9D00_SluitemData) GetMaxVoltage() float64 {
	if m != nil {
		return m.MaxVoltage
	}
	return 0
}

func (m *WlstSlu_9D00_SluitemData) GetMaxCurrent() []float64 {
	if m != nil {
		return m.MaxCurrent
	}
	return nil
}

func (m *WlstSlu_9D00_SluitemData) GetTotalElectricity() []float64 {
	if m != nil {
		return m.TotalElectricity
	}
	return nil
}

func (m *WlstSlu_9D00_SluitemData) GetTemperature() int32 {
	if m != nil {
		return m.Temperature
	}
	return 0
}

func (m *WlstSlu_9D00_SluitemData) GetLeakageCurrent() float64 {
	if m != nil {
		return m.LeakageCurrent
	}
	return 0
}

func (m *WlstSlu_9D00_SluitemData) GetTimerError() int32 {
	if m != nil {
		return m.TimerError
	}
	return 0
}

func (m *WlstSlu_9D00_SluitemData) GetSluitemStatus() *WlstSlu_7300_BaseSluitemData_SluitemStatus {
	if m != nil {
		return m.SluitemStatus
	}
	return nil
}

func (m *WlstSlu_9D00_SluitemData) GetLightStatus() []*WlstSlu_7300_BaseSluitemData_LightStatus {
	if m != nil {
		return m.LightStatus
	}
	return nil
}

func (m *WlstSlu_9D00_SluitemData) GetResetCount() int32 {
	if m != nil {
		return m.ResetCount
	}
	return 0
}

type WlstSlu_9D00_SluitemDataNew struct {
	// 电压 /100
	Voltage []float64 `protobuf:"fixed64,1,rep,packed,name=voltage,proto3" json:"voltage,omitempty"`
	// 电流 /100
	Current []float64 `protobuf:"fixed64,2,rep,packed,name=current,proto3" json:"current,omitempty"`
	// 有功功率 /10
	ActivePower []float64 `protobuf:"fixed64,3,rep,packed,name=active_power,json=activePower,proto3" json:"active_power,omitempty"`
	// 运行时间
	RunTime []int32 `protobuf:"varint,4,rep,packed,name=run_time,json=runTime,proto3" json:"run_time,omitempty"`
	// 相位，0-无法确认,1-a,2-b,3-c
	Phase int32 `protobuf:"varint,5,opt,name=phase,proto3" json:"phase,omitempty"`
	// 累计电量
	TotalElectricity []float64 `protobuf:"fixed64,7,rep,packed,name=total_electricity,json=totalElectricity,proto3" json:"total_electricity,omitempty"`
	// 漏电流 /100
	LeakageCurrent float64 `protobuf:"fixed64,9,opt,name=leakage_current,json=leakageCurrent,proto3" json:"leakage_current,omitempty"`
	// 时钟故障
	TimerError int32 `protobuf:"varint,10,opt,name=timer_error,json=timerError,proto3" json:"timer_error,omitempty"`
	// 控制器状态
	SluitemStatus *WlstSlu_7300_BaseSluitemData_SluitemStatus `protobuf:"bytes,11,opt,name=sluitem_status,json=sluitemStatus,proto3" json:"sluitem_status,omitempty"`
	// 灯状态
	LightStatus []*WlstSlu_7300_BaseSluitemData_LightStatus `protobuf:"bytes,12,rep,name=light_status,json=lightStatus,proto3" json:"light_status,omitempty"`
	// 自复位次数
	ResetCount int32 `protobuf:"varint,13,opt,name=reset_count,json=resetCount,proto3" json:"reset_count,omitempty"`
	// 节能档位
	EnergySaving []int32 `protobuf:"varint,14,rep,packed,name=energy_saving,json=energySaving,proto3" json:"energy_saving,omitempty"`
}

func (m *WlstSlu_9D00_SluitemDataNew) Reset()      { *m = WlstSlu_9D00_SluitemDataNew{} }
func (*WlstSlu_9D00_SluitemDataNew) ProtoMessage() {}
func (*WlstSlu_9D00_SluitemDataNew) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{16, 2}
}
func (m *WlstSlu_9D00_SluitemDataNew) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_9D00_SluitemDataNew) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_9D00_SluitemDataNew.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_9D00_SluitemDataNew) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_9D00_SluitemDataNew.Merge(m, src)
}
func (m *WlstSlu_9D00_SluitemDataNew) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_9D00_SluitemDataNew) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_9D00_SluitemDataNew.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_9D00_SluitemDataNew proto.InternalMessageInfo

func (m *WlstSlu_9D00_SluitemDataNew) GetVoltage() []float64 {
	if m != nil {
		return m.Voltage
	}
	return nil
}

func (m *WlstSlu_9D00_SluitemDataNew) GetCurrent() []float64 {
	if m != nil {
		return m.Current
	}
	return nil
}

func (m *WlstSlu_9D00_SluitemDataNew) GetActivePower() []float64 {
	if m != nil {
		return m.ActivePower
	}
	return nil
}

func (m *WlstSlu_9D00_SluitemDataNew) GetRunTime() []int32 {
	if m != nil {
		return m.RunTime
	}
	return nil
}

func (m *WlstSlu_9D00_SluitemDataNew) GetPhase() int32 {
	if m != nil {
		return m.Phase
	}
	return 0
}

func (m *WlstSlu_9D00_SluitemDataNew) GetTotalElectricity() []float64 {
	if m != nil {
		return m.TotalElectricity
	}
	return nil
}

func (m *WlstSlu_9D00_SluitemDataNew) GetLeakageCurrent() float64 {
	if m != nil {
		return m.LeakageCurrent
	}
	return 0
}

func (m *WlstSlu_9D00_SluitemDataNew) GetTimerError() int32 {
	if m != nil {
		return m.TimerError
	}
	return 0
}

func (m *WlstSlu_9D00_SluitemDataNew) GetSluitemStatus() *WlstSlu_7300_BaseSluitemData_SluitemStatus {
	if m != nil {
		return m.SluitemStatus
	}
	return nil
}

func (m *WlstSlu_9D00_SluitemDataNew) GetLightStatus() []*WlstSlu_7300_BaseSluitemData_LightStatus {
	if m != nil {
		return m.LightStatus
	}
	return nil
}

func (m *WlstSlu_9D00_SluitemDataNew) GetResetCount() int32 {
	if m != nil {
		return m.ResetCount
	}
	return 0
}

func (m *WlstSlu_9D00_SluitemDataNew) GetEnergySaving() []int32 {
	if m != nil {
		return m.EnergySaving
	}
	return nil
}

type WlstSlu_9D00_SluitemPara struct {
	// 域名
	DomainName int32 `protobuf:"varint,1,opt,name=domain_name,json=domainName,proto3" json:"domain_name,omitempty"`
	// 控制器状态 0-停运，1-投运
	SluitemStatus int32 `protobuf:"varint,2,opt,name=sluitem_status,json=sluitemStatus,proto3" json:"sluitem_status,omitempty"`
	// 控制器主报 0-禁止主报，1-允许主报
	SluitemEnableAlarm int32 `protobuf:"varint,3,opt,name=sluitem_enable_alarm,json=sluitemEnableAlarm,proto3" json:"sluitem_enable_alarm,omitempty"`
	// 控制器上电开灯 1-开灯，0-关灯
	SluitemPowerTurnon []int32 `protobuf:"varint,4,rep,packed,name=sluitem_power_turnon,json=sluitemPowerTurnon,proto3" json:"sluitem_power_turnon,omitempty"`
	// 控制器1-4回路矢量
	SluitemVector []int32 `protobuf:"varint,5,rep,packed,name=sluitem_vector,json=sluitemVector,proto3" json:"sluitem_vector,omitempty"`
	// 经度
	Longitude float64 `protobuf:"fixed64,6,opt,name=longitude,proto3" json:"longitude,omitempty"`
	// 纬度
	Latitude float64 `protobuf:"fixed64,7,opt,name=latitude,proto3" json:"latitude,omitempty"`
	// 1-4回路额定功率
	RatedPower []int32 `protobuf:"varint,8,rep,packed,name=rated_power,json=ratedPower,proto3" json:"rated_power,omitempty"`
	// nb主报间隔，(0～127)*5
	UplinkTimer int32 `protobuf:"varint,9,opt,name=uplink_timer,json=uplinkTimer,proto3" json:"uplink_timer,omitempty"`
	// nb主报需要主站应答，0-不需要，1-需要
	UplinkReply int32 `protobuf:"varint,10,opt,name=uplink_reply,json=uplinkReply,proto3" json:"uplink_reply,omitempty"`
}

func (m *WlstSlu_9D00_SluitemPara) Reset()      { *m = WlstSlu_9D00_SluitemPara{} }
func (*WlstSlu_9D00_SluitemPara) ProtoMessage() {}
func (*WlstSlu_9D00_SluitemPara) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{16, 3}
}
func (m *WlstSlu_9D00_SluitemPara) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_9D00_SluitemPara) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_9D00_SluitemPara.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_9D00_SluitemPara) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_9D00_SluitemPara.Merge(m, src)
}
func (m *WlstSlu_9D00_SluitemPara) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_9D00_SluitemPara) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_9D00_SluitemPara.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_9D00_SluitemPara proto.InternalMessageInfo

func (m *WlstSlu_9D00_SluitemPara) GetDomainName() int32 {
	if m != nil {
		return m.DomainName
	}
	return 0
}

func (m *WlstSlu_9D00_SluitemPara) GetSluitemStatus() int32 {
	if m != nil {
		return m.SluitemStatus
	}
	return 0
}

func (m *WlstSlu_9D00_SluitemPara) GetSluitemEnableAlarm() int32 {
	if m != nil {
		return m.SluitemEnableAlarm
	}
	return 0
}

func (m *WlstSlu_9D00_SluitemPara) GetSluitemPowerTurnon() []int32 {
	if m != nil {
		return m.SluitemPowerTurnon
	}
	return nil
}

func (m *WlstSlu_9D00_SluitemPara) GetSluitemVector() []int32 {
	if m != nil {
		return m.SluitemVector
	}
	return nil
}

func (m *WlstSlu_9D00_SluitemPara) GetLongitude() float64 {
	if m != nil {
		return m.Longitude
	}
	return 0
}

func (m *WlstSlu_9D00_SluitemPara) GetLatitude() float64 {
	if m != nil {
		return m.Latitude
	}
	return 0
}

func (m *WlstSlu_9D00_SluitemPara) GetRatedPower() []int32 {
	if m != nil {
		return m.RatedPower
	}
	return nil
}

func (m *WlstSlu_9D00_SluitemPara) GetUplinkTimer() int32 {
	if m != nil {
		return m.UplinkTimer
	}
	return 0
}

func (m *WlstSlu_9D00_SluitemPara) GetUplinkReply() int32 {
	if m != nil {
		return m.UplinkReply
	}
	return 0
}

type WlstSlu_9D00_SluitemVer struct {
	// 控制器回路
	SluitemLoop int32 `protobuf:"varint,1,opt,name=sluitem_loop,json=sluitemLoop,proto3" json:"sluitem_loop,omitempty"`
	// 节能方式
	EnergySaving int32 `protobuf:"varint,2,opt,name=energy_saving,json=energySaving,proto3" json:"energy_saving,omitempty"`
	// 有漏电模块
	ElectricLeakageModule int32 `protobuf:"varint,3,opt,name=electric_leakage_module,json=electricLeakageModule,proto3" json:"electric_leakage_module,omitempty"`
	// 有温度检测模块
	TemperatureModule int32 `protobuf:"varint,4,opt,name=temperature_module,json=temperatureModule,proto3" json:"temperature_module,omitempty"`
	// 有时钟
	TimerModule int32 `protobuf:"varint,5,opt,name=timer_module,json=timerModule,proto3" json:"timer_module,omitempty"`
	// 型号 0-unknow,1-wj2090j
	SluitemType string `protobuf:"bytes,6,opt,name=sluitem_type,json=sluitemType,proto3" json:"sluitem_type,omitempty"`
	// 软件版本
	Ver string `protobuf:"bytes,7,opt,name=ver,proto3" json:"ver,omitempty"`
}

func (m *WlstSlu_9D00_SluitemVer) Reset()      { *m = WlstSlu_9D00_SluitemVer{} }
func (*WlstSlu_9D00_SluitemVer) ProtoMessage() {}
func (*WlstSlu_9D00_SluitemVer) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{16, 4}
}
func (m *WlstSlu_9D00_SluitemVer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_9D00_SluitemVer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_9D00_SluitemVer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_9D00_SluitemVer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_9D00_SluitemVer.Merge(m, src)
}
func (m *WlstSlu_9D00_SluitemVer) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_9D00_SluitemVer) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_9D00_SluitemVer.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_9D00_SluitemVer proto.InternalMessageInfo

func (m *WlstSlu_9D00_SluitemVer) GetSluitemLoop() int32 {
	if m != nil {
		return m.SluitemLoop
	}
	return 0
}

func (m *WlstSlu_9D00_SluitemVer) GetEnergySaving() int32 {
	if m != nil {
		return m.EnergySaving
	}
	return 0
}

func (m *WlstSlu_9D00_SluitemVer) GetElectricLeakageModule() int32 {
	if m != nil {
		return m.ElectricLeakageModule
	}
	return 0
}

func (m *WlstSlu_9D00_SluitemVer) GetTemperatureModule() int32 {
	if m != nil {
		return m.TemperatureModule
	}
	return 0
}

func (m *WlstSlu_9D00_SluitemVer) GetTimerModule() int32 {
	if m != nil {
		return m.TimerModule
	}
	return 0
}

func (m *WlstSlu_9D00_SluitemVer) GetSluitemType() string {
	if m != nil {
		return m.SluitemType
	}
	return ""
}

func (m *WlstSlu_9D00_SluitemVer) GetVer() string {
	if m != nil {
		return m.Ver
	}
	return ""
}

type WlstSlu_9D00_SluitemSunriseset struct {
	// 当日日出日落时间 hhmm->int32
	Sunrise int32 `protobuf:"varint,1,opt,name=sunrise,proto3" json:"sunrise,omitempty"`
	Sunset  int32 `protobuf:"varint,2,opt,name=sunset,proto3" json:"sunset,omitempty"`
}

func (m *WlstSlu_9D00_SluitemSunriseset) Reset()      { *m = WlstSlu_9D00_SluitemSunriseset{} }
func (*WlstSlu_9D00_SluitemSunriseset) ProtoMessage() {}
func (*WlstSlu_9D00_SluitemSunriseset) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{16, 5}
}
func (m *WlstSlu_9D00_SluitemSunriseset) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_9D00_SluitemSunriseset) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_9D00_SluitemSunriseset.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_9D00_SluitemSunriseset) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_9D00_SluitemSunriseset.Merge(m, src)
}
func (m *WlstSlu_9D00_SluitemSunriseset) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_9D00_SluitemSunriseset) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_9D00_SluitemSunriseset.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_9D00_SluitemSunriseset proto.InternalMessageInfo

func (m *WlstSlu_9D00_SluitemSunriseset) GetSunrise() int32 {
	if m != nil {
		return m.Sunrise
	}
	return 0
}

func (m *WlstSlu_9D00_SluitemSunriseset) GetSunset() int32 {
	if m != nil {
		return m.Sunset
	}
	return 0
}

type WlstSlu_9D00_SluitemRuntime struct {
	// 本地控制数据类型0-基本类型（6字节），1-扩展类型（6+20字节）
	DataType int32 `protobuf:"varint,1,opt,name=data_type,json=dataType,proto3" json:"data_type,omitempty"`
	// 输出类型0-继电器，1-pwm输出，2-485
	OutputType int32 `protobuf:"varint,2,opt,name=output_type,json=outputType,proto3" json:"output_type,omitempty"`
	// 操作类型1-定时操作，2-经纬度操作，3-即时操作
	OperateType int32 `protobuf:"varint,3,opt,name=operate_type,json=operateType,proto3" json:"operate_type,omitempty"`
	// 有效日期，0-6～周日-周6
	DateEnable []int32 `protobuf:"varint,4,rep,packed,name=date_enable,json=dateEnable,proto3" json:"date_enable,omitempty"`
	// 开关灯操作时间 hhmm->int32
	OperateTime int32 `protobuf:"varint,5,opt,name=operate_time,json=operateTime,proto3" json:"operate_time,omitempty"`
	// 操作偏移 -720~+720
	OperateOffset int32 `protobuf:"varint,6,opt,name=operate_offset,json=operateOffset,proto3" json:"operate_offset,omitempty"`
	// 继电器操作回路1-4 0-不操作，3-开灯，5-一档节能，a-二档节能，c-关灯
	RelayOperate []int32 `protobuf:"varint,7,rep,packed,name=relay_operate,json=relayOperate,proto3" json:"relay_operate,omitempty"`
	// PWM操作回路
	PwmLoop []int32 `protobuf:"varint,8,rep,packed,name=pwm_loop,json=pwmLoop,proto3" json:"pwm_loop,omitempty"`
	// PWM操作占空比
	PwmPower int32 `protobuf:"varint,9,opt,name=pwm_power,json=pwmPower,proto3" json:"pwm_power,omitempty"`
	// PWM频率 (1~255) * 100
	PwmBaudrate int32 `protobuf:"varint,10,opt,name=pwm_baudrate,json=pwmBaudrate,proto3" json:"pwm_baudrate,omitempty"`
	// 485波特率 0-300,1-600,2-1200,3-2400,4-4800,5-9600,6-19200
	Rs485Baudrate int32 `protobuf:"varint,11,opt,name=rs485_baudrate,json=rs485Baudrate,proto3" json:"rs485_baudrate,omitempty"`
	// 485校验位 0-无校验，1-奇校验，2-偶校验
	Rs485Check int32 `protobuf:"varint,12,opt,name=rs485_check,json=rs485Check,proto3" json:"rs485_check,omitempty"`
}

func (m *WlstSlu_9D00_SluitemRuntime) Reset()      { *m = WlstSlu_9D00_SluitemRuntime{} }
func (*WlstSlu_9D00_SluitemRuntime) ProtoMessage() {}
func (*WlstSlu_9D00_SluitemRuntime) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{16, 6}
}
func (m *WlstSlu_9D00_SluitemRuntime) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_9D00_SluitemRuntime) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_9D00_SluitemRuntime.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_9D00_SluitemRuntime) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_9D00_SluitemRuntime.Merge(m, src)
}
func (m *WlstSlu_9D00_SluitemRuntime) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_9D00_SluitemRuntime) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_9D00_SluitemRuntime.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_9D00_SluitemRuntime proto.InternalMessageInfo

func (m *WlstSlu_9D00_SluitemRuntime) GetDataType() int32 {
	if m != nil {
		return m.DataType
	}
	return 0
}

func (m *WlstSlu_9D00_SluitemRuntime) GetOutputType() int32 {
	if m != nil {
		return m.OutputType
	}
	return 0
}

func (m *WlstSlu_9D00_SluitemRuntime) GetOperateType() int32 {
	if m != nil {
		return m.OperateType
	}
	return 0
}

func (m *WlstSlu_9D00_SluitemRuntime) GetDateEnable() []int32 {
	if m != nil {
		return m.DateEnable
	}
	return nil
}

func (m *WlstSlu_9D00_SluitemRuntime) GetOperateTime() int32 {
	if m != nil {
		return m.OperateTime
	}
	return 0
}

func (m *WlstSlu_9D00_SluitemRuntime) GetOperateOffset() int32 {
	if m != nil {
		return m.OperateOffset
	}
	return 0
}

func (m *WlstSlu_9D00_SluitemRuntime) GetRelayOperate() []int32 {
	if m != nil {
		return m.RelayOperate
	}
	return nil
}

func (m *WlstSlu_9D00_SluitemRuntime) GetPwmLoop() []int32 {
	if m != nil {
		return m.PwmLoop
	}
	return nil
}

func (m *WlstSlu_9D00_SluitemRuntime) GetPwmPower() int32 {
	if m != nil {
		return m.PwmPower
	}
	return 0
}

func (m *WlstSlu_9D00_SluitemRuntime) GetPwmBaudrate() int32 {
	if m != nil {
		return m.PwmBaudrate
	}
	return 0
}

func (m *WlstSlu_9D00_SluitemRuntime) GetRs485Baudrate() int32 {
	if m != nil {
		return m.Rs485Baudrate
	}
	return 0
}

func (m *WlstSlu_9D00_SluitemRuntime) GetRs485Check() int32 {
	if m != nil {
		return m.Rs485Check
	}
	return 0
}

// Wlst_slu_7000
type WlstSluF000 struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 复位标识
	ResetMark *WlstSluF000_ResetMark `protobuf:"bytes,2,opt,name=reset_mark,json=resetMark,proto3" json:"reset_mark,omitempty"`
}

func (m *WlstSluF000) Reset()      { *m = WlstSluF000{} }
func (*WlstSluF000) ProtoMessage() {}
func (*WlstSluF000) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{17}
}
func (m *WlstSluF000) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSluF000) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSluF000.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSluF000) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSluF000.Merge(m, src)
}
func (m *WlstSluF000) XXX_Size() int {
	return m.Size()
}
func (m *WlstSluF000) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSluF000.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSluF000 proto.InternalMessageInfo

func (m *WlstSluF000) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *WlstSluF000) GetResetMark() *WlstSluF000_ResetMark {
	if m != nil {
		return m.ResetMark
	}
	return nil
}

type WlstSluF000_ResetMark struct {
	// 清除任务
	ClearTask int32 `protobuf:"varint,1,opt,name=clear_task,json=clearTask,proto3" json:"clear_task,omitempty"`
	// 复位集中器
	ResetConcentrator int32 `protobuf:"varint,2,opt,name=reset_concentrator,json=resetConcentrator,proto3" json:"reset_concentrator,omitempty"`
	// 硬件复位zigbee
	HardResetZigbee int32 `protobuf:"varint,3,opt,name=hard_reset_zigbee,json=hardResetZigbee,proto3" json:"hard_reset_zigbee,omitempty"`
	// 软件复位zigbee
	SoftResetZigbee int32 `protobuf:"varint,4,opt,name=soft_reset_zigbee,json=softResetZigbee,proto3" json:"soft_reset_zigbee,omitempty"`
	// 复位电力载波
	ResetCarrier int32 `protobuf:"varint,5,opt,name=reset_carrier,json=resetCarrier,proto3" json:"reset_carrier,omitempty"`
	// 初始化所有
	InitAll int32 `protobuf:"varint,6,opt,name=init_all,json=initAll,proto3" json:"init_all,omitempty"`
	// 清除数据
	ClearData int32 `protobuf:"varint,7,opt,name=clear_data,json=clearData,proto3" json:"clear_data,omitempty"`
	// 清除参数
	ClearArgs int32 `protobuf:"varint,8,opt,name=clear_args,json=clearArgs,proto3" json:"clear_args,omitempty"`
}

func (m *WlstSluF000_ResetMark) Reset()      { *m = WlstSluF000_ResetMark{} }
func (*WlstSluF000_ResetMark) ProtoMessage() {}
func (*WlstSluF000_ResetMark) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{17, 0}
}
func (m *WlstSluF000_ResetMark) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSluF000_ResetMark) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSluF000_ResetMark.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSluF000_ResetMark) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSluF000_ResetMark.Merge(m, src)
}
func (m *WlstSluF000_ResetMark) XXX_Size() int {
	return m.Size()
}
func (m *WlstSluF000_ResetMark) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSluF000_ResetMark.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSluF000_ResetMark proto.InternalMessageInfo

func (m *WlstSluF000_ResetMark) GetClearTask() int32 {
	if m != nil {
		return m.ClearTask
	}
	return 0
}

func (m *WlstSluF000_ResetMark) GetResetConcentrator() int32 {
	if m != nil {
		return m.ResetConcentrator
	}
	return 0
}

func (m *WlstSluF000_ResetMark) GetHardResetZigbee() int32 {
	if m != nil {
		return m.HardResetZigbee
	}
	return 0
}

func (m *WlstSluF000_ResetMark) GetSoftResetZigbee() int32 {
	if m != nil {
		return m.SoftResetZigbee
	}
	return 0
}

func (m *WlstSluF000_ResetMark) GetResetCarrier() int32 {
	if m != nil {
		return m.ResetCarrier
	}
	return 0
}

func (m *WlstSluF000_ResetMark) GetInitAll() int32 {
	if m != nil {
		return m.InitAll
	}
	return 0
}

func (m *WlstSluF000_ResetMark) GetClearData() int32 {
	if m != nil {
		return m.ClearData
	}
	return 0
}

func (m *WlstSluF000_ResetMark) GetClearArgs() int32 {
	if m != nil {
		return m.ClearArgs
	}
	return 0
}

// Wlst_slu_7100
type WlstSluF100 struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 操作标识0-设置时钟，1-读取时钟
	OptMark int32 `protobuf:"varint,2,opt,name=opt_mark,json=optMark,proto3" json:"opt_mark,omitempty"`
	// 时间（c#需加1970-1-1）
	DateTime int64 `protobuf:"varint,3,opt,name=date_time,json=dateTime,proto3" json:"date_time,omitempty"`
	// 强制对时
	ForceTimer int32 `protobuf:"varint,4,opt,name=force_timer,json=forceTimer,proto3" json:"force_timer,omitempty"`
	// 错误标识
	TimerStatus *WlstSluF100_TimerStatus `protobuf:"bytes,5,opt,name=timer_status,json=timerStatus,proto3" json:"timer_status,omitempty"`
}

func (m *WlstSluF100) Reset()      { *m = WlstSluF100{} }
func (*WlstSluF100) ProtoMessage() {}
func (*WlstSluF100) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{18}
}
func (m *WlstSluF100) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSluF100) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSluF100.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSluF100) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSluF100.Merge(m, src)
}
func (m *WlstSluF100) XXX_Size() int {
	return m.Size()
}
func (m *WlstSluF100) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSluF100.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSluF100 proto.InternalMessageInfo

func (m *WlstSluF100) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *WlstSluF100) GetOptMark() int32 {
	if m != nil {
		return m.OptMark
	}
	return 0
}

func (m *WlstSluF100) GetDateTime() int64 {
	if m != nil {
		return m.DateTime
	}
	return 0
}

func (m *WlstSluF100) GetForceTimer() int32 {
	if m != nil {
		return m.ForceTimer
	}
	return 0
}

func (m *WlstSluF100) GetTimerStatus() *WlstSluF100_TimerStatus {
	if m != nil {
		return m.TimerStatus
	}
	return nil
}

type WlstSluF100_TimerStatus struct {
	// 时间数据错误
	DtformatError int32 `protobuf:"varint,1,opt,name=dtformat_error,json=dtformatError,proto3" json:"dtformat_error,omitempty"`
	// 时钟超差
	TimerError int32 `protobuf:"varint,2,opt,name=timer_error,json=timerError,proto3" json:"timer_error,omitempty"`
	// 对时失败
	TimeFault int32 `protobuf:"varint,3,opt,name=time_fault,json=timeFault,proto3" json:"time_fault,omitempty"`
}

func (m *WlstSluF100_TimerStatus) Reset()      { *m = WlstSluF100_TimerStatus{} }
func (*WlstSluF100_TimerStatus) ProtoMessage() {}
func (*WlstSluF100_TimerStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{18, 0}
}
func (m *WlstSluF100_TimerStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSluF100_TimerStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSluF100_TimerStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSluF100_TimerStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSluF100_TimerStatus.Merge(m, src)
}
func (m *WlstSluF100_TimerStatus) XXX_Size() int {
	return m.Size()
}
func (m *WlstSluF100_TimerStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSluF100_TimerStatus.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSluF100_TimerStatus proto.InternalMessageInfo

func (m *WlstSluF100_TimerStatus) GetDtformatError() int32 {
	if m != nil {
		return m.DtformatError
	}
	return 0
}

func (m *WlstSluF100_TimerStatus) GetTimerError() int32 {
	if m != nil {
		return m.TimerError
	}
	return 0
}

func (m *WlstSluF100_TimerStatus) GetTimeFault() int32 {
	if m != nil {
		return m.TimeFault
	}
	return 0
}

// Wlst_slu_7200
type WlstSluF200 struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 起始控制器地址
	SluitemIdx int32 `protobuf:"varint,2,opt,name=sluitem_idx,json=sluitemIdx,proto3" json:"sluitem_idx,omitempty"`
	// 控制器数量
	SluitemCount int32 `protobuf:"varint,3,opt,name=sluitem_count,json=sluitemCount,proto3" json:"sluitem_count,omitempty"`
	// 数据类型
	DataMark *WlstSluF200_DataMark `protobuf:"bytes,4,opt,name=data_mark,json=dataMark,proto3" json:"data_mark,omitempty"`
	// 控制器数据
	SluitemData []*WlstSluF200_ControllerData `protobuf:"bytes,5,rep,name=sluitem_data,json=sluitemData,proto3" json:"sluitem_data,omitempty"`
	// 操作结果0-失败，1-成功
	Status int32 `protobuf:"varint,6,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *WlstSluF200) Reset()      { *m = WlstSluF200{} }
func (*WlstSluF200) ProtoMessage() {}
func (*WlstSluF200) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{19}
}
func (m *WlstSluF200) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSluF200) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSluF200.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSluF200) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSluF200.Merge(m, src)
}
func (m *WlstSluF200) XXX_Size() int {
	return m.Size()
}
func (m *WlstSluF200) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSluF200.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSluF200 proto.InternalMessageInfo

func (m *WlstSluF200) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *WlstSluF200) GetSluitemIdx() int32 {
	if m != nil {
		return m.SluitemIdx
	}
	return 0
}

func (m *WlstSluF200) GetSluitemCount() int32 {
	if m != nil {
		return m.SluitemCount
	}
	return 0
}

func (m *WlstSluF200) GetDataMark() *WlstSluF200_DataMark {
	if m != nil {
		return m.DataMark
	}
	return nil
}

func (m *WlstSluF200) GetSluitemData() []*WlstSluF200_ControllerData {
	if m != nil {
		return m.SluitemData
	}
	return nil
}

func (m *WlstSluF200) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

type WlstSluF200_DataMark struct {
	// 指令类型 0-读取数据，1-设置数据
	SetData int32 `protobuf:"varint,20,opt,name=set_data,json=setData,proto3" json:"set_data,omitempty"`
	// 控制器所属组（5个）
	Group int32 `protobuf:"varint,1,opt,name=group,proto3" json:"group,omitempty"`
	// 控制器条码
	Barcode int32 `protobuf:"varint,2,opt,name=barcode,proto3" json:"barcode,omitempty"`
	// 控制器路由（前4级通信控制器编号1,2,3...)
	Route int32 `protobuf:"varint,3,opt,name=route,proto3" json:"route,omitempty"`
	// 开灯序号
	Order int32 `protobuf:"varint,4,opt,name=order,proto3" json:"order,omitempty"`
	// 功率上限/下限
	Limit int32 `protobuf:"varint,5,opt,name=limit,proto3" json:"limit,omitempty"`
	// 上电控制状态
	PowerOnStatus int32 `protobuf:"varint,6,opt,name=power_on_status,json=powerOnStatus,proto3" json:"power_on_status,omitempty"`
	// 2-投运，1-停运
	RunStatus int32 `protobuf:"varint,7,opt,name=run_status,json=runStatus,proto3" json:"run_status,omitempty"`
	// 控制器物理矢量
	Vector int32 `protobuf:"varint,8,opt,name=vector,proto3" json:"vector,omitempty"`
	// 额定功率
	RatedPower int32 `protobuf:"varint,9,opt,name=rated_power,json=ratedPower,proto3" json:"rated_power,omitempty"`
	// 回路数量
	LoopCount int32 `protobuf:"varint,10,opt,name=loop_count,json=loopCount,proto3" json:"loop_count,omitempty"`
}

func (m *WlstSluF200_DataMark) Reset()      { *m = WlstSluF200_DataMark{} }
func (*WlstSluF200_DataMark) ProtoMessage() {}
func (*WlstSluF200_DataMark) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{19, 0}
}
func (m *WlstSluF200_DataMark) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSluF200_DataMark) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSluF200_DataMark.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSluF200_DataMark) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSluF200_DataMark.Merge(m, src)
}
func (m *WlstSluF200_DataMark) XXX_Size() int {
	return m.Size()
}
func (m *WlstSluF200_DataMark) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSluF200_DataMark.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSluF200_DataMark proto.InternalMessageInfo

func (m *WlstSluF200_DataMark) GetSetData() int32 {
	if m != nil {
		return m.SetData
	}
	return 0
}

func (m *WlstSluF200_DataMark) GetGroup() int32 {
	if m != nil {
		return m.Group
	}
	return 0
}

func (m *WlstSluF200_DataMark) GetBarcode() int32 {
	if m != nil {
		return m.Barcode
	}
	return 0
}

func (m *WlstSluF200_DataMark) GetRoute() int32 {
	if m != nil {
		return m.Route
	}
	return 0
}

func (m *WlstSluF200_DataMark) GetOrder() int32 {
	if m != nil {
		return m.Order
	}
	return 0
}

func (m *WlstSluF200_DataMark) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *WlstSluF200_DataMark) GetPowerOnStatus() int32 {
	if m != nil {
		return m.PowerOnStatus
	}
	return 0
}

func (m *WlstSluF200_DataMark) GetRunStatus() int32 {
	if m != nil {
		return m.RunStatus
	}
	return 0
}

func (m *WlstSluF200_DataMark) GetVector() int32 {
	if m != nil {
		return m.Vector
	}
	return 0
}

func (m *WlstSluF200_DataMark) GetRatedPower() int32 {
	if m != nil {
		return m.RatedPower
	}
	return 0
}

func (m *WlstSluF200_DataMark) GetLoopCount() int32 {
	if m != nil {
		return m.LoopCount
	}
	return 0
}

type WlstSluF200_ControllerData struct {
	// 控制器所属组（5个）
	SluitemGroup []int32 `protobuf:"varint,1,rep,packed,name=sluitem_group,json=sluitemGroup,proto3" json:"sluitem_group,omitempty"`
	// 控制器条码
	SluitemIdx int64 `protobuf:"varint,2,opt,name=sluitem_idx,json=sluitemIdx,proto3" json:"sluitem_idx,omitempty"`
	// 控制器路由（前4级通信控制器编号1,2,3...)
	SluitemRoute []int32 `protobuf:"varint,3,rep,packed,name=sluitem_route,json=sluitemRoute,proto3" json:"sluitem_route,omitempty"`
	// 开灯序号
	SluitemOrder int32 `protobuf:"varint,4,opt,name=sluitem_order,json=sluitemOrder,proto3" json:"sluitem_order,omitempty"`
	// 功率上限
	UpperPowerLimit int32 `protobuf:"varint,5,opt,name=upper_power_limit,json=upperPowerLimit,proto3" json:"upper_power_limit,omitempty"`
	// 功率下限
	LowerPowerLimit int32 `protobuf:"varint,6,opt,name=lower_power_limit,json=lowerPowerLimit,proto3" json:"lower_power_limit,omitempty"`
	// 控制器上电开灯 true-开灯，false-关灯
	SluitemPowerTurnon []int32 `protobuf:"varint,7,rep,packed,name=sluitem_power_turnon,json=sluitemPowerTurnon,proto3" json:"sluitem_power_turnon,omitempty"`
	// 控制器状态 false-停运，true-投运
	SluitemStatus int32 `protobuf:"varint,8,opt,name=sluitem_status,json=sluitemStatus,proto3" json:"sluitem_status,omitempty"`
	// 控制器主报 false-禁止主报，true-允许主报
	SluitemEnableAlarm int32 `protobuf:"varint,9,opt,name=sluitem_enable_alarm,json=sluitemEnableAlarm,proto3" json:"sluitem_enable_alarm,omitempty"`
	// 控制器物理矢量
	SluitemVector []int32 `protobuf:"varint,10,rep,packed,name=sluitem_vector,json=sluitemVector,proto3" json:"sluitem_vector,omitempty"`
	// 额定功率
	RatedPower []int32 `protobuf:"varint,11,rep,packed,name=rated_power,json=ratedPower,proto3" json:"rated_power,omitempty"`
	// 回路数量
	LoopCount int32 `protobuf:"varint,12,opt,name=loop_count,json=loopCount,proto3" json:"loop_count,omitempty"`
	// 经度
	Longitude float64 `protobuf:"fixed64,13,opt,name=longitude,proto3" json:"longitude,omitempty"`
	// 纬度
	Latitude float64 `protobuf:"fixed64,14,opt,name=latitude,proto3" json:"latitude,omitempty"`
	// nb主报间隔，(0～127)*5
	UplinkTimer int32 `protobuf:"varint,15,opt,name=uplink_timer,json=uplinkTimer,proto3" json:"uplink_timer,omitempty"`
	// nb主报需要主站应答，0-不需要，1-需要
	UplinkReply int32 `protobuf:"varint,16,opt,name=uplink_reply,json=uplinkReply,proto3" json:"uplink_reply,omitempty"`
}

func (m *WlstSluF200_ControllerData) Reset()      { *m = WlstSluF200_ControllerData{} }
func (*WlstSluF200_ControllerData) ProtoMessage() {}
func (*WlstSluF200_ControllerData) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{19, 1}
}
func (m *WlstSluF200_ControllerData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSluF200_ControllerData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSluF200_ControllerData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSluF200_ControllerData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSluF200_ControllerData.Merge(m, src)
}
func (m *WlstSluF200_ControllerData) XXX_Size() int {
	return m.Size()
}
func (m *WlstSluF200_ControllerData) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSluF200_ControllerData.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSluF200_ControllerData proto.InternalMessageInfo

func (m *WlstSluF200_ControllerData) GetSluitemGroup() []int32 {
	if m != nil {
		return m.SluitemGroup
	}
	return nil
}

func (m *WlstSluF200_ControllerData) GetSluitemIdx() int64 {
	if m != nil {
		return m.SluitemIdx
	}
	return 0
}

func (m *WlstSluF200_ControllerData) GetSluitemRoute() []int32 {
	if m != nil {
		return m.SluitemRoute
	}
	return nil
}

func (m *WlstSluF200_ControllerData) GetSluitemOrder() int32 {
	if m != nil {
		return m.SluitemOrder
	}
	return 0
}

func (m *WlstSluF200_ControllerData) GetUpperPowerLimit() int32 {
	if m != nil {
		return m.UpperPowerLimit
	}
	return 0
}

func (m *WlstSluF200_ControllerData) GetLowerPowerLimit() int32 {
	if m != nil {
		return m.LowerPowerLimit
	}
	return 0
}

func (m *WlstSluF200_ControllerData) GetSluitemPowerTurnon() []int32 {
	if m != nil {
		return m.SluitemPowerTurnon
	}
	return nil
}

func (m *WlstSluF200_ControllerData) GetSluitemStatus() int32 {
	if m != nil {
		return m.SluitemStatus
	}
	return 0
}

func (m *WlstSluF200_ControllerData) GetSluitemEnableAlarm() int32 {
	if m != nil {
		return m.SluitemEnableAlarm
	}
	return 0
}

func (m *WlstSluF200_ControllerData) GetSluitemVector() []int32 {
	if m != nil {
		return m.SluitemVector
	}
	return nil
}

func (m *WlstSluF200_ControllerData) GetRatedPower() []int32 {
	if m != nil {
		return m.RatedPower
	}
	return nil
}

func (m *WlstSluF200_ControllerData) GetLoopCount() int32 {
	if m != nil {
		return m.LoopCount
	}
	return 0
}

func (m *WlstSluF200_ControllerData) GetLongitude() float64 {
	if m != nil {
		return m.Longitude
	}
	return 0
}

func (m *WlstSluF200_ControllerData) GetLatitude() float64 {
	if m != nil {
		return m.Latitude
	}
	return 0
}

func (m *WlstSluF200_ControllerData) GetUplinkTimer() int32 {
	if m != nil {
		return m.UplinkTimer
	}
	return 0
}

func (m *WlstSluF200_ControllerData) GetUplinkReply() int32 {
	if m != nil {
		return m.UplinkReply
	}
	return 0
}

// Wlst_slu_f300
type WlstSlu_7300 struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 起始控制器地址(带标识)
	SluitemStart int32 `protobuf:"varint,2,opt,name=sluitem_start,json=sluitemStart,proto3" json:"sluitem_start,omitempty"`
	// 控制器数量
	SluitemCount int32 `protobuf:"varint,3,opt,name=sluitem_count,json=sluitemCount,proto3" json:"sluitem_count,omitempty"`
	// 选测数据类型 0-选测集中器，1-选测控制器基本数据（不用），2-选测未知控制器，3-选测控制器辅助参数（不用），4-选测控制器物理信息，5-选测控制器带时标数据，6-选测控制器带时标辅助数据, 7-控制器双字节电压电流数据，带电量
	DataMark int32 `protobuf:"varint,4,opt,name=data_mark,json=dataMark,proto3" json:"data_mark,omitempty"`
	// 选测集中器
	ConcentratorData *WlstSlu_7300_ConcentratorData `protobuf:"bytes,5,opt,name=concentrator_data,json=concentratorData,proto3" json:"concentrator_data,omitempty"`
	// 选测控制器基本参数
	BaseSluitemData []*WlstSlu_7300_BaseSluitemData `protobuf:"bytes,6,rep,name=base_sluitem_data,json=baseSluitemData,proto3" json:"base_sluitem_data,omitempty"`
	// 选测未知控制器
	UnknowSluitem []*WlstSlu_7300_UnknowSluitem `protobuf:"bytes,7,rep,name=unknow_sluitem,json=unknowSluitem,proto3" json:"unknow_sluitem,omitempty"`
	// 选测控制器辅助参数
	AssistSluitemData []*WlstSlu_7300_AssistSluitemData `protobuf:"bytes,8,rep,name=assist_sluitem_data,json=assistSluitemData,proto3" json:"assist_sluitem_data,omitempty"`
	// 选测控制器物理信息
	SluitemPhyinfo []*WlstSlu_7300_SluitemPhyinfo `protobuf:"bytes,9,rep,name=sluitem_phyinfo,json=sluitemPhyinfo,proto3" json:"sluitem_phyinfo,omitempty"`
	// 控制器序号(地址)
	SluitemAddrs []int32 `protobuf:"varint,10,rep,packed,name=sluitem_addrs,json=sluitemAddrs,proto3" json:"sluitem_addrs,omitempty"`
}

func (m *WlstSlu_7300) Reset()      { *m = WlstSlu_7300{} }
func (*WlstSlu_7300) ProtoMessage() {}
func (*WlstSlu_7300) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{20}
}
func (m *WlstSlu_7300) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_7300) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_7300.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_7300) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_7300.Merge(m, src)
}
func (m *WlstSlu_7300) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_7300) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_7300.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_7300 proto.InternalMessageInfo

func (m *WlstSlu_7300) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *WlstSlu_7300) GetSluitemStart() int32 {
	if m != nil {
		return m.SluitemStart
	}
	return 0
}

func (m *WlstSlu_7300) GetSluitemCount() int32 {
	if m != nil {
		return m.SluitemCount
	}
	return 0
}

func (m *WlstSlu_7300) GetDataMark() int32 {
	if m != nil {
		return m.DataMark
	}
	return 0
}

func (m *WlstSlu_7300) GetConcentratorData() *WlstSlu_7300_ConcentratorData {
	if m != nil {
		return m.ConcentratorData
	}
	return nil
}

func (m *WlstSlu_7300) GetBaseSluitemData() []*WlstSlu_7300_BaseSluitemData {
	if m != nil {
		return m.BaseSluitemData
	}
	return nil
}

func (m *WlstSlu_7300) GetUnknowSluitem() []*WlstSlu_7300_UnknowSluitem {
	if m != nil {
		return m.UnknowSluitem
	}
	return nil
}

func (m *WlstSlu_7300) GetAssistSluitemData() []*WlstSlu_7300_AssistSluitemData {
	if m != nil {
		return m.AssistSluitemData
	}
	return nil
}

func (m *WlstSlu_7300) GetSluitemPhyinfo() []*WlstSlu_7300_SluitemPhyinfo {
	if m != nil {
		return m.SluitemPhyinfo
	}
	return nil
}

func (m *WlstSlu_7300) GetSluitemAddrs() []int32 {
	if m != nil {
		return m.SluitemAddrs
	}
	return nil
}

type WlstSlu_7300_ConcentratorData struct {
	// 复位次数
	ResetCount []int32 `protobuf:"varint,1,rep,packed,name=reset_count,json=resetCount,proto3" json:"reset_count,omitempty"`
	// 集中器状态
	RunStatus *WlstSlu_7300_ConcentratorData_RunStatus `protobuf:"bytes,2,opt,name=run_status,json=runStatus,proto3" json:"run_status,omitempty"`
	// 参数状态
	ArgsStatus *WlstSlu_7300_ConcentratorData_ArgsStatus `protobuf:"bytes,3,opt,name=args_status,json=argsStatus,proto3" json:"args_status,omitempty"`
	// 硬件状态
	HardwareStatus *WlstSlu_7300_ConcentratorData_HardwareStatus `protobuf:"bytes,4,opt,name=hardware_status,json=hardwareStatus,proto3" json:"hardware_status,omitempty"`
	// 未知控制器
	UnknowSluitemCount int32 `protobuf:"varint,5,opt,name=unknow_sluitem_count,json=unknowSluitemCount,proto3" json:"unknow_sluitem_count,omitempty"`
	// 通信信道 -10为当前值
	CommunicationChannel int32 `protobuf:"varint,6,opt,name=communication_channel,json=communicationChannel,proto3" json:"communication_channel,omitempty"`
}

func (m *WlstSlu_7300_ConcentratorData) Reset()      { *m = WlstSlu_7300_ConcentratorData{} }
func (*WlstSlu_7300_ConcentratorData) ProtoMessage() {}
func (*WlstSlu_7300_ConcentratorData) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{20, 0}
}
func (m *WlstSlu_7300_ConcentratorData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_7300_ConcentratorData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_7300_ConcentratorData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_7300_ConcentratorData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_7300_ConcentratorData.Merge(m, src)
}
func (m *WlstSlu_7300_ConcentratorData) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_7300_ConcentratorData) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_7300_ConcentratorData.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_7300_ConcentratorData proto.InternalMessageInfo

func (m *WlstSlu_7300_ConcentratorData) GetResetCount() []int32 {
	if m != nil {
		return m.ResetCount
	}
	return nil
}

func (m *WlstSlu_7300_ConcentratorData) GetRunStatus() *WlstSlu_7300_ConcentratorData_RunStatus {
	if m != nil {
		return m.RunStatus
	}
	return nil
}

func (m *WlstSlu_7300_ConcentratorData) GetArgsStatus() *WlstSlu_7300_ConcentratorData_ArgsStatus {
	if m != nil {
		return m.ArgsStatus
	}
	return nil
}

func (m *WlstSlu_7300_ConcentratorData) GetHardwareStatus() *WlstSlu_7300_ConcentratorData_HardwareStatus {
	if m != nil {
		return m.HardwareStatus
	}
	return nil
}

func (m *WlstSlu_7300_ConcentratorData) GetUnknowSluitemCount() int32 {
	if m != nil {
		return m.UnknowSluitemCount
	}
	return 0
}

func (m *WlstSlu_7300_ConcentratorData) GetCommunicationChannel() int32 {
	if m != nil {
		return m.CommunicationChannel
	}
	return 0
}

type WlstSlu_7300_ConcentratorData_RunStatus struct {
	// 停运 0-正常，1-停运
	Offline int32 `protobuf:"varint,1,opt,name=offline,proto3" json:"offline,omitempty"`
	// 允许主报 0-禁止主报，1-允许主报
	EnableAlarm int32 `protobuf:"varint,2,opt,name=enable_alarm,json=enableAlarm,proto3" json:"enable_alarm,omitempty"`
	// 开机申请 0-非开机，1-开机
	PoweronMark int32 `protobuf:"varint,3,opt,name=poweron_mark,json=poweronMark,proto3" json:"poweron_mark,omitempty"`
	// gprs通讯 0-485,1-gprs
	EnableGprs int32 `protobuf:"varint,4,opt,name=enable_gprs,json=enableGprs,proto3" json:"enable_gprs,omitempty"`
	// 允许巡测 0-不允许,1-允许
	EnableAutochk int32 `protobuf:"varint,5,opt,name=enable_autochk,json=enableAutochk,proto3" json:"enable_autochk,omitempty"`
}

func (m *WlstSlu_7300_ConcentratorData_RunStatus) Reset() {
	*m = WlstSlu_7300_ConcentratorData_RunStatus{}
}
func (*WlstSlu_7300_ConcentratorData_RunStatus) ProtoMessage() {}
func (*WlstSlu_7300_ConcentratorData_RunStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{20, 0, 0}
}
func (m *WlstSlu_7300_ConcentratorData_RunStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_7300_ConcentratorData_RunStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_7300_ConcentratorData_RunStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_7300_ConcentratorData_RunStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_7300_ConcentratorData_RunStatus.Merge(m, src)
}
func (m *WlstSlu_7300_ConcentratorData_RunStatus) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_7300_ConcentratorData_RunStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_7300_ConcentratorData_RunStatus.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_7300_ConcentratorData_RunStatus proto.InternalMessageInfo

func (m *WlstSlu_7300_ConcentratorData_RunStatus) GetOffline() int32 {
	if m != nil {
		return m.Offline
	}
	return 0
}

func (m *WlstSlu_7300_ConcentratorData_RunStatus) GetEnableAlarm() int32 {
	if m != nil {
		return m.EnableAlarm
	}
	return 0
}

func (m *WlstSlu_7300_ConcentratorData_RunStatus) GetPoweronMark() int32 {
	if m != nil {
		return m.PoweronMark
	}
	return 0
}

func (m *WlstSlu_7300_ConcentratorData_RunStatus) GetEnableGprs() int32 {
	if m != nil {
		return m.EnableGprs
	}
	return 0
}

func (m *WlstSlu_7300_ConcentratorData_RunStatus) GetEnableAutochk() int32 {
	if m != nil {
		return m.EnableAutochk
	}
	return 0
}

type WlstSlu_7300_ConcentratorData_ArgsStatus struct {
	// 集中器参数错误
	ConcentratorArgsError int32 `protobuf:"varint,1,opt,name=concentrator_args_error,json=concentratorArgsError,proto3" json:"concentrator_args_error,omitempty"`
	// 控制器参数错误
	SluitemArgsError int32 `protobuf:"varint,2,opt,name=sluitem_args_error,json=sluitemArgsError,proto3" json:"sluitem_args_error,omitempty"`
	// 开关灯控制参数错误
	TurnOnoffError int32 `protobuf:"varint,3,opt,name=turn_onoff_error,json=turnOnoffError,proto3" json:"turn_onoff_error,omitempty"`
}

func (m *WlstSlu_7300_ConcentratorData_ArgsStatus) Reset() {
	*m = WlstSlu_7300_ConcentratorData_ArgsStatus{}
}
func (*WlstSlu_7300_ConcentratorData_ArgsStatus) ProtoMessage() {}
func (*WlstSlu_7300_ConcentratorData_ArgsStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{20, 0, 1}
}
func (m *WlstSlu_7300_ConcentratorData_ArgsStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_7300_ConcentratorData_ArgsStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_7300_ConcentratorData_ArgsStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_7300_ConcentratorData_ArgsStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_7300_ConcentratorData_ArgsStatus.Merge(m, src)
}
func (m *WlstSlu_7300_ConcentratorData_ArgsStatus) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_7300_ConcentratorData_ArgsStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_7300_ConcentratorData_ArgsStatus.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_7300_ConcentratorData_ArgsStatus proto.InternalMessageInfo

func (m *WlstSlu_7300_ConcentratorData_ArgsStatus) GetConcentratorArgsError() int32 {
	if m != nil {
		return m.ConcentratorArgsError
	}
	return 0
}

func (m *WlstSlu_7300_ConcentratorData_ArgsStatus) GetSluitemArgsError() int32 {
	if m != nil {
		return m.SluitemArgsError
	}
	return 0
}

func (m *WlstSlu_7300_ConcentratorData_ArgsStatus) GetTurnOnoffError() int32 {
	if m != nil {
		return m.TurnOnoffError
	}
	return 0
}

type WlstSlu_7300_ConcentratorData_HardwareStatus struct {
	// zigbee模块出错
	ZigbeeError int32 `protobuf:"varint,1,opt,name=zigbee_error,json=zigbeeError,proto3" json:"zigbee_error,omitempty"`
	// 电力载波模块出错
	CarrierError int32 `protobuf:"varint,2,opt,name=carrier_error,json=carrierError,proto3" json:"carrier_error,omitempty"`
	// fram出错
	FramError int32 `protobuf:"varint,3,opt,name=fram_error,json=framError,proto3" json:"fram_error,omitempty"`
	// 蓝牙模块出错
	BluetoothError int32 `protobuf:"varint,4,opt,name=bluetooth_error,json=bluetoothError,proto3" json:"bluetooth_error,omitempty"`
	// 硬件时钟出错
	TimerError int32 `protobuf:"varint,5,opt,name=timer_error,json=timerError,proto3" json:"timer_error,omitempty"`
}

func (m *WlstSlu_7300_ConcentratorData_HardwareStatus) Reset() {
	*m = WlstSlu_7300_ConcentratorData_HardwareStatus{}
}
func (*WlstSlu_7300_ConcentratorData_HardwareStatus) ProtoMessage() {}
func (*WlstSlu_7300_ConcentratorData_HardwareStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{20, 0, 2}
}
func (m *WlstSlu_7300_ConcentratorData_HardwareStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_7300_ConcentratorData_HardwareStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_7300_ConcentratorData_HardwareStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_7300_ConcentratorData_HardwareStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_7300_ConcentratorData_HardwareStatus.Merge(m, src)
}
func (m *WlstSlu_7300_ConcentratorData_HardwareStatus) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_7300_ConcentratorData_HardwareStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_7300_ConcentratorData_HardwareStatus.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_7300_ConcentratorData_HardwareStatus proto.InternalMessageInfo

func (m *WlstSlu_7300_ConcentratorData_HardwareStatus) GetZigbeeError() int32 {
	if m != nil {
		return m.ZigbeeError
	}
	return 0
}

func (m *WlstSlu_7300_ConcentratorData_HardwareStatus) GetCarrierError() int32 {
	if m != nil {
		return m.CarrierError
	}
	return 0
}

func (m *WlstSlu_7300_ConcentratorData_HardwareStatus) GetFramError() int32 {
	if m != nil {
		return m.FramError
	}
	return 0
}

func (m *WlstSlu_7300_ConcentratorData_HardwareStatus) GetBluetoothError() int32 {
	if m != nil {
		return m.BluetoothError
	}
	return 0
}

func (m *WlstSlu_7300_ConcentratorData_HardwareStatus) GetTimerError() int32 {
	if m != nil {
		return m.TimerError
	}
	return 0
}

type WlstSlu_7300_BaseSluitemData struct {
	// 控制器数据
	// 日 时:分 c#需加1970-1-1
	DateTime int64 `protobuf:"varint,1,opt,name=date_time,json=dateTime,proto3" json:"date_time,omitempty"`
	// 控制器状态
	SluitemStatus *WlstSlu_7300_BaseSluitemData_SluitemStatus `protobuf:"bytes,2,opt,name=sluitem_status,json=sluitemStatus,proto3" json:"sluitem_status,omitempty"`
	// 温度
	Temperature int32 `protobuf:"varint,3,opt,name=temperature,proto3" json:"temperature,omitempty"`
	// 灯状态
	LightStatus []*WlstSlu_7300_BaseSluitemData_LightStatus `protobuf:"bytes,4,rep,name=light_status,json=lightStatus,proto3" json:"light_status,omitempty"`
	// 灯数据
	LightData []*WlstSlu_7300_BaseSluitemData_LightData `protobuf:"bytes,5,rep,name=light_data,json=lightData,proto3" json:"light_data,omitempty"`
	// 字节数 =控制器数量 / 4 每2位一个控制器 0-3（1路，2路，3路，4路）
	SluitemLoop int32 `protobuf:"varint,6,opt,name=sluitem_loop,json=sluitemLoop,proto3" json:"sluitem_loop,omitempty"`
}

func (m *WlstSlu_7300_BaseSluitemData) Reset()      { *m = WlstSlu_7300_BaseSluitemData{} }
func (*WlstSlu_7300_BaseSluitemData) ProtoMessage() {}
func (*WlstSlu_7300_BaseSluitemData) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{20, 1}
}
func (m *WlstSlu_7300_BaseSluitemData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_7300_BaseSluitemData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_7300_BaseSluitemData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_7300_BaseSluitemData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_7300_BaseSluitemData.Merge(m, src)
}
func (m *WlstSlu_7300_BaseSluitemData) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_7300_BaseSluitemData) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_7300_BaseSluitemData.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_7300_BaseSluitemData proto.InternalMessageInfo

func (m *WlstSlu_7300_BaseSluitemData) GetDateTime() int64 {
	if m != nil {
		return m.DateTime
	}
	return 0
}

func (m *WlstSlu_7300_BaseSluitemData) GetSluitemStatus() *WlstSlu_7300_BaseSluitemData_SluitemStatus {
	if m != nil {
		return m.SluitemStatus
	}
	return nil
}

func (m *WlstSlu_7300_BaseSluitemData) GetTemperature() int32 {
	if m != nil {
		return m.Temperature
	}
	return 0
}

func (m *WlstSlu_7300_BaseSluitemData) GetLightStatus() []*WlstSlu_7300_BaseSluitemData_LightStatus {
	if m != nil {
		return m.LightStatus
	}
	return nil
}

func (m *WlstSlu_7300_BaseSluitemData) GetLightData() []*WlstSlu_7300_BaseSluitemData_LightData {
	if m != nil {
		return m.LightData
	}
	return nil
}

func (m *WlstSlu_7300_BaseSluitemData) GetSluitemLoop() int32 {
	if m != nil {
		return m.SluitemLoop
	}
	return 0
}

type WlstSlu_7300_BaseSluitemData_SluitemStatus struct {
	// 状态 0-正常，1-电压越上限，2-电压越下限，3-通讯故障
	Status int32 `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
	// 已校准 0-未校准，1-已校准
	Adjust int32 `protobuf:"varint,2,opt,name=adjust,proto3" json:"adjust,omitempty"`
	// 工作参数设置 0-未设置，1-已设置
	WorkingArgs int32 `protobuf:"varint,3,opt,name=working_args,json=workingArgs,proto3" json:"working_args,omitempty"`
	// 禁止主动报警 0-允许，1-禁止
	NoAlarm int32 `protobuf:"varint,4,opt,name=no_alarm,json=noAlarm,proto3" json:"no_alarm,omitempty"`
	// 停运 0-正常，1-停运
	OffLine int32 `protobuf:"varint,5,opt,name=off_line,json=offLine,proto3" json:"off_line,omitempty"`
	// EEPROM故障 0-正常，1-故障
	EepromError int32 `protobuf:"varint,6,opt,name=eeprom_error,json=eepromError,proto3" json:"eeprom_error,omitempty"`
	// 温度传感器故障 0-正常，1-故障
	TemperatureSensor int32 `protobuf:"varint,7,opt,name=temperature_sensor,json=temperatureSensor,proto3" json:"temperature_sensor,omitempty"`
}

func (m *WlstSlu_7300_BaseSluitemData_SluitemStatus) Reset() {
	*m = WlstSlu_7300_BaseSluitemData_SluitemStatus{}
}
func (*WlstSlu_7300_BaseSluitemData_SluitemStatus) ProtoMessage() {}
func (*WlstSlu_7300_BaseSluitemData_SluitemStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{20, 1, 0}
}
func (m *WlstSlu_7300_BaseSluitemData_SluitemStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_7300_BaseSluitemData_SluitemStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_7300_BaseSluitemData_SluitemStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_7300_BaseSluitemData_SluitemStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_7300_BaseSluitemData_SluitemStatus.Merge(m, src)
}
func (m *WlstSlu_7300_BaseSluitemData_SluitemStatus) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_7300_BaseSluitemData_SluitemStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_7300_BaseSluitemData_SluitemStatus.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_7300_BaseSluitemData_SluitemStatus proto.InternalMessageInfo

func (m *WlstSlu_7300_BaseSluitemData_SluitemStatus) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *WlstSlu_7300_BaseSluitemData_SluitemStatus) GetAdjust() int32 {
	if m != nil {
		return m.Adjust
	}
	return 0
}

func (m *WlstSlu_7300_BaseSluitemData_SluitemStatus) GetWorkingArgs() int32 {
	if m != nil {
		return m.WorkingArgs
	}
	return 0
}

func (m *WlstSlu_7300_BaseSluitemData_SluitemStatus) GetNoAlarm() int32 {
	if m != nil {
		return m.NoAlarm
	}
	return 0
}

func (m *WlstSlu_7300_BaseSluitemData_SluitemStatus) GetOffLine() int32 {
	if m != nil {
		return m.OffLine
	}
	return 0
}

func (m *WlstSlu_7300_BaseSluitemData_SluitemStatus) GetEepromError() int32 {
	if m != nil {
		return m.EepromError
	}
	return 0
}

func (m *WlstSlu_7300_BaseSluitemData_SluitemStatus) GetTemperatureSensor() int32 {
	if m != nil {
		return m.TemperatureSensor
	}
	return 0
}

type WlstSlu_7300_BaseSluitemData_LightStatus struct {
	// 功率状态 0-正常，1-功率越上限，2-功率越下限
	PowerStatus int32 `protobuf:"varint,1,opt,name=power_status,json=powerStatus,proto3" json:"power_status,omitempty"`
	// 灯具漏电 0-正常，1-漏电
	Leakage int32 `protobuf:"varint,2,opt,name=leakage,proto3" json:"leakage,omitempty"`
	// 故障 0-正常，1-光源故障，2-补偿电容故障，3-意外灭灯，4-意外亮灯，5-自熄灯，6-控制器断电告警（苏州）,7-继电器故障
	Fault int32 `protobuf:"varint,3,opt,name=fault,proto3" json:"fault,omitempty"`
	// 工作状态 0-正常亮灯，1-一档节能，2-二档节能，3-关灯
	WorkingOn int32 `protobuf:"varint,4,opt,name=working_on,json=workingOn,proto3" json:"working_on,omitempty"`
}

func (m *WlstSlu_7300_BaseSluitemData_LightStatus) Reset() {
	*m = WlstSlu_7300_BaseSluitemData_LightStatus{}
}
func (*WlstSlu_7300_BaseSluitemData_LightStatus) ProtoMessage() {}
func (*WlstSlu_7300_BaseSluitemData_LightStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{20, 1, 1}
}
func (m *WlstSlu_7300_BaseSluitemData_LightStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_7300_BaseSluitemData_LightStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_7300_BaseSluitemData_LightStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_7300_BaseSluitemData_LightStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_7300_BaseSluitemData_LightStatus.Merge(m, src)
}
func (m *WlstSlu_7300_BaseSluitemData_LightStatus) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_7300_BaseSluitemData_LightStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_7300_BaseSluitemData_LightStatus.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_7300_BaseSluitemData_LightStatus proto.InternalMessageInfo

func (m *WlstSlu_7300_BaseSluitemData_LightStatus) GetPowerStatus() int32 {
	if m != nil {
		return m.PowerStatus
	}
	return 0
}

func (m *WlstSlu_7300_BaseSluitemData_LightStatus) GetLeakage() int32 {
	if m != nil {
		return m.Leakage
	}
	return 0
}

func (m *WlstSlu_7300_BaseSluitemData_LightStatus) GetFault() int32 {
	if m != nil {
		return m.Fault
	}
	return 0
}

func (m *WlstSlu_7300_BaseSluitemData_LightStatus) GetWorkingOn() int32 {
	if m != nil {
		return m.WorkingOn
	}
	return 0
}

type WlstSlu_7300_BaseSluitemData_LightData struct {
	// 电压
	Voltage float64 `protobuf:"fixed64,1,opt,name=voltage,proto3" json:"voltage,omitempty"`
	// 电流
	Current float64 `protobuf:"fixed64,2,opt,name=current,proto3" json:"current,omitempty"`
	// 有功功率
	ActivePower float64 `protobuf:"fixed64,3,opt,name=active_power,json=activePower,proto3" json:"active_power,omitempty"`
	// 电量
	Electricity float64 `protobuf:"fixed64,4,opt,name=electricity,proto3" json:"electricity,omitempty"`
	// 运行时间
	ActiveTime float64 `protobuf:"fixed64,5,opt,name=active_time,json=activeTime,proto3" json:"active_time,omitempty"`
	// 节能档位
	PowerLevel int32 `protobuf:"varint,6,opt,name=power_level,json=powerLevel,proto3" json:"power_level,omitempty"`
}

func (m *WlstSlu_7300_BaseSluitemData_LightData) Reset() {
	*m = WlstSlu_7300_BaseSluitemData_LightData{}
}
func (*WlstSlu_7300_BaseSluitemData_LightData) ProtoMessage() {}
func (*WlstSlu_7300_BaseSluitemData_LightData) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{20, 1, 2}
}
func (m *WlstSlu_7300_BaseSluitemData_LightData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_7300_BaseSluitemData_LightData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_7300_BaseSluitemData_LightData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_7300_BaseSluitemData_LightData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_7300_BaseSluitemData_LightData.Merge(m, src)
}
func (m *WlstSlu_7300_BaseSluitemData_LightData) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_7300_BaseSluitemData_LightData) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_7300_BaseSluitemData_LightData.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_7300_BaseSluitemData_LightData proto.InternalMessageInfo

func (m *WlstSlu_7300_BaseSluitemData_LightData) GetVoltage() float64 {
	if m != nil {
		return m.Voltage
	}
	return 0
}

func (m *WlstSlu_7300_BaseSluitemData_LightData) GetCurrent() float64 {
	if m != nil {
		return m.Current
	}
	return 0
}

func (m *WlstSlu_7300_BaseSluitemData_LightData) GetActivePower() float64 {
	if m != nil {
		return m.ActivePower
	}
	return 0
}

func (m *WlstSlu_7300_BaseSluitemData_LightData) GetElectricity() float64 {
	if m != nil {
		return m.Electricity
	}
	return 0
}

func (m *WlstSlu_7300_BaseSluitemData_LightData) GetActiveTime() float64 {
	if m != nil {
		return m.ActiveTime
	}
	return 0
}

func (m *WlstSlu_7300_BaseSluitemData_LightData) GetPowerLevel() int32 {
	if m != nil {
		return m.PowerLevel
	}
	return 0
}

type WlstSlu_7300_UnknowSluitem struct {
	// 条码
	SluitemIdx int64 `protobuf:"varint,1,opt,name=sluitem_idx,json=sluitemIdx,proto3" json:"sluitem_idx,omitempty"`
	// 型号信息
	ModelInfo *WlstSlu_7300_ModelInfo `protobuf:"bytes,2,opt,name=model_info,json=modelInfo,proto3" json:"model_info,omitempty"`
}

func (m *WlstSlu_7300_UnknowSluitem) Reset()      { *m = WlstSlu_7300_UnknowSluitem{} }
func (*WlstSlu_7300_UnknowSluitem) ProtoMessage() {}
func (*WlstSlu_7300_UnknowSluitem) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{20, 2}
}
func (m *WlstSlu_7300_UnknowSluitem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_7300_UnknowSluitem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_7300_UnknowSluitem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_7300_UnknowSluitem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_7300_UnknowSluitem.Merge(m, src)
}
func (m *WlstSlu_7300_UnknowSluitem) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_7300_UnknowSluitem) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_7300_UnknowSluitem.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_7300_UnknowSluitem proto.InternalMessageInfo

func (m *WlstSlu_7300_UnknowSluitem) GetSluitemIdx() int64 {
	if m != nil {
		return m.SluitemIdx
	}
	return 0
}

func (m *WlstSlu_7300_UnknowSluitem) GetModelInfo() *WlstSlu_7300_ModelInfo {
	if m != nil {
		return m.ModelInfo
	}
	return nil
}

type WlstSlu_7300_AssistSluitemData struct {
	// 日 时:分 c#需加1970-1-1
	DateTime int64 `protobuf:"varint,1,opt,name=date_time,json=dateTime,proto3" json:"date_time,omitempty"`
	// 漏电流 / 100 0xff为满量程，此时=2.55A
	LeakageCurrent float64 `protobuf:"fixed64,2,opt,name=leakage_current,json=leakageCurrent,proto3" json:"leakage_current,omitempty"`
	// 灯数据
	LightData []*WlstSlu_7300_AssistSluitemData_LightData `protobuf:"bytes,3,rep,name=light_data,json=lightData,proto3" json:"light_data,omitempty"`
	// 字节数 =控制器数量 / 4 每2位一个控制器 0-3（1路，2路，3路，4路）
	SluitemLoop int32 `protobuf:"varint,4,opt,name=sluitem_loop,json=sluitemLoop,proto3" json:"sluitem_loop,omitempty"`
}

func (m *WlstSlu_7300_AssistSluitemData) Reset()      { *m = WlstSlu_7300_AssistSluitemData{} }
func (*WlstSlu_7300_AssistSluitemData) ProtoMessage() {}
func (*WlstSlu_7300_AssistSluitemData) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{20, 3}
}
func (m *WlstSlu_7300_AssistSluitemData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_7300_AssistSluitemData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_7300_AssistSluitemData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_7300_AssistSluitemData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_7300_AssistSluitemData.Merge(m, src)
}
func (m *WlstSlu_7300_AssistSluitemData) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_7300_AssistSluitemData) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_7300_AssistSluitemData.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_7300_AssistSluitemData proto.InternalMessageInfo

func (m *WlstSlu_7300_AssistSluitemData) GetDateTime() int64 {
	if m != nil {
		return m.DateTime
	}
	return 0
}

func (m *WlstSlu_7300_AssistSluitemData) GetLeakageCurrent() float64 {
	if m != nil {
		return m.LeakageCurrent
	}
	return 0
}

func (m *WlstSlu_7300_AssistSluitemData) GetLightData() []*WlstSlu_7300_AssistSluitemData_LightData {
	if m != nil {
		return m.LightData
	}
	return nil
}

func (m *WlstSlu_7300_AssistSluitemData) GetSluitemLoop() int32 {
	if m != nil {
		return m.SluitemLoop
	}
	return 0
}

type WlstSlu_7300_AssistSluitemData_LightData struct {
	// 最大电压
	MaxVoltage float64 `protobuf:"fixed64,1,opt,name=max_voltage,json=maxVoltage,proto3" json:"max_voltage,omitempty"`
	// 最大电流
	MaxCurrent float64 `protobuf:"fixed64,2,opt,name=max_current,json=maxCurrent,proto3" json:"max_current,omitempty"`
	// 电量 满量程250kw/h，超出清零
	Electricity float64 `protobuf:"fixed64,3,opt,name=electricity,proto3" json:"electricity,omitempty"`
}

func (m *WlstSlu_7300_AssistSluitemData_LightData) Reset() {
	*m = WlstSlu_7300_AssistSluitemData_LightData{}
}
func (*WlstSlu_7300_AssistSluitemData_LightData) ProtoMessage() {}
func (*WlstSlu_7300_AssistSluitemData_LightData) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{20, 3, 0}
}
func (m *WlstSlu_7300_AssistSluitemData_LightData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_7300_AssistSluitemData_LightData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_7300_AssistSluitemData_LightData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_7300_AssistSluitemData_LightData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_7300_AssistSluitemData_LightData.Merge(m, src)
}
func (m *WlstSlu_7300_AssistSluitemData_LightData) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_7300_AssistSluitemData_LightData) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_7300_AssistSluitemData_LightData.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_7300_AssistSluitemData_LightData proto.InternalMessageInfo

func (m *WlstSlu_7300_AssistSluitemData_LightData) GetMaxVoltage() float64 {
	if m != nil {
		return m.MaxVoltage
	}
	return 0
}

func (m *WlstSlu_7300_AssistSluitemData_LightData) GetMaxCurrent() float64 {
	if m != nil {
		return m.MaxCurrent
	}
	return 0
}

func (m *WlstSlu_7300_AssistSluitemData_LightData) GetElectricity() float64 {
	if m != nil {
		return m.Electricity
	}
	return 0
}

type WlstSlu_7300_SluitemPhyinfo struct {
	// 信号强度
	SignalStrength int32 `protobuf:"varint,1,opt,name=signal_strength,json=signalStrength,proto3" json:"signal_strength,omitempty"`
	// 路由级数 电力载波 0-6,zigbee 0-10
	Routing int32 `protobuf:"varint,2,opt,name=routing,proto3" json:"routing,omitempty"`
	// 所在相位 0-无法确定，1-A，2-B，3-C
	Phase int32 `protobuf:"varint,3,opt,name=phase,proto3" json:"phase,omitempty"`
	// 通信成功次数 1-16
	UsefulCommunicate int32 `protobuf:"varint,4,opt,name=useful_communicate,json=usefulCommunicate,proto3" json:"useful_communicate,omitempty"`
	// 通信总次数 1-16
	AllCommunicate int32 `protobuf:"varint,5,opt,name=all_communicate,json=allCommunicate,proto3" json:"all_communicate,omitempty"`
	// 型号信息
	ModelInfo *WlstSlu_7300_ModelInfo `protobuf:"bytes,6,opt,name=model_info,json=modelInfo,proto3" json:"model_info,omitempty"`
}

func (m *WlstSlu_7300_SluitemPhyinfo) Reset()      { *m = WlstSlu_7300_SluitemPhyinfo{} }
func (*WlstSlu_7300_SluitemPhyinfo) ProtoMessage() {}
func (*WlstSlu_7300_SluitemPhyinfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{20, 4}
}
func (m *WlstSlu_7300_SluitemPhyinfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_7300_SluitemPhyinfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_7300_SluitemPhyinfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_7300_SluitemPhyinfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_7300_SluitemPhyinfo.Merge(m, src)
}
func (m *WlstSlu_7300_SluitemPhyinfo) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_7300_SluitemPhyinfo) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_7300_SluitemPhyinfo.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_7300_SluitemPhyinfo proto.InternalMessageInfo

func (m *WlstSlu_7300_SluitemPhyinfo) GetSignalStrength() int32 {
	if m != nil {
		return m.SignalStrength
	}
	return 0
}

func (m *WlstSlu_7300_SluitemPhyinfo) GetRouting() int32 {
	if m != nil {
		return m.Routing
	}
	return 0
}

func (m *WlstSlu_7300_SluitemPhyinfo) GetPhase() int32 {
	if m != nil {
		return m.Phase
	}
	return 0
}

func (m *WlstSlu_7300_SluitemPhyinfo) GetUsefulCommunicate() int32 {
	if m != nil {
		return m.UsefulCommunicate
	}
	return 0
}

func (m *WlstSlu_7300_SluitemPhyinfo) GetAllCommunicate() int32 {
	if m != nil {
		return m.AllCommunicate
	}
	return 0
}

func (m *WlstSlu_7300_SluitemPhyinfo) GetModelInfo() *WlstSlu_7300_ModelInfo {
	if m != nil {
		return m.ModelInfo
	}
	return nil
}

type WlstSlu_7300_ModelInfo struct {
	// 控制器回路
	SluitemLoop int32 `protobuf:"varint,1,opt,name=sluitem_loop,json=sluitemLoop,proto3" json:"sluitem_loop,omitempty"`
	// 节能方式 0-无控制，1-只有开关灯，2-一档节能，3-二档节能，4-RS485，5-PWM
	PowerSaving int32 `protobuf:"varint,2,opt,name=power_saving,json=powerSaving,proto3" json:"power_saving,omitempty"`
	// 漏电流测量 0-无，1-有
	HasLeakage int32 `protobuf:"varint,3,opt,name=has_leakage,json=hasLeakage,proto3" json:"has_leakage,omitempty"`
	// 温度采集 0-无，1-有
	HasTemperature int32 `protobuf:"varint,4,opt,name=has_temperature,json=hasTemperature,proto3" json:"has_temperature,omitempty"`
	// 时钟 0-无，1-有
	HasTimer int32 `protobuf:"varint,5,opt,name=has_timer,json=hasTimer,proto3" json:"has_timer,omitempty"`
	// 型号 0-unknow,1-wj2090j
	Model int32 `protobuf:"varint,6,opt,name=model,proto3" json:"model,omitempty"`
	// 字符串型号
	SluitemType string `protobuf:"bytes,7,opt,name=sluitem_type,json=sluitemType,proto3" json:"sluitem_type,omitempty"`
}

func (m *WlstSlu_7300_ModelInfo) Reset()      { *m = WlstSlu_7300_ModelInfo{} }
func (*WlstSlu_7300_ModelInfo) ProtoMessage() {}
func (*WlstSlu_7300_ModelInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{20, 5}
}
func (m *WlstSlu_7300_ModelInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_7300_ModelInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_7300_ModelInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_7300_ModelInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_7300_ModelInfo.Merge(m, src)
}
func (m *WlstSlu_7300_ModelInfo) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_7300_ModelInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_7300_ModelInfo.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_7300_ModelInfo proto.InternalMessageInfo

func (m *WlstSlu_7300_ModelInfo) GetSluitemLoop() int32 {
	if m != nil {
		return m.SluitemLoop
	}
	return 0
}

func (m *WlstSlu_7300_ModelInfo) GetPowerSaving() int32 {
	if m != nil {
		return m.PowerSaving
	}
	return 0
}

func (m *WlstSlu_7300_ModelInfo) GetHasLeakage() int32 {
	if m != nil {
		return m.HasLeakage
	}
	return 0
}

func (m *WlstSlu_7300_ModelInfo) GetHasTemperature() int32 {
	if m != nil {
		return m.HasTemperature
	}
	return 0
}

func (m *WlstSlu_7300_ModelInfo) GetHasTimer() int32 {
	if m != nil {
		return m.HasTimer
	}
	return 0
}

func (m *WlstSlu_7300_ModelInfo) GetModel() int32 {
	if m != nil {
		return m.Model
	}
	return 0
}

func (m *WlstSlu_7300_ModelInfo) GetSluitemType() string {
	if m != nil {
		return m.SluitemType
	}
	return ""
}

type WlstSluF900 struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 告警类型 0-集中器告警，1-控制器通讯故障，2-控制器状态告警，3-主动上报巡测结束，4-蓝牙模块连接申请，5-设置新域名成功, 6-控制器基本数据(双字节)
	AlarmType int32 `protobuf:"varint,2,opt,name=alarm_type,json=alarmType,proto3" json:"alarm_type,omitempty"`
	// 集中器数据
	ConcentratorData *WlstSlu_7300_ConcentratorData `protobuf:"bytes,3,opt,name=concentrator_data,json=concentratorData,proto3" json:"concentrator_data,omitempty"`
	// 通讯故障控制器编号
	ErrorCtrls []int32 `protobuf:"varint,4,rep,packed,name=error_ctrls,json=errorCtrls,proto3" json:"error_ctrls,omitempty"`
	// 控制器状态
	SluitemStatusAlarm []*WlstSluF900_SluitemStatusAlarm `protobuf:"bytes,5,rep,name=sluitem_status_alarm,json=sluitemStatusAlarm,proto3" json:"sluitem_status_alarm,omitempty"`
	// 蓝牙连接申请
	BluetoothApply *WlstSluF900_BluetoothApply `protobuf:"bytes,6,opt,name=bluetooth_apply,json=bluetoothApply,proto3" json:"bluetooth_apply,omitempty"`
	// 新域名设置状态
	SetDomainResult *WlstSluF900_SetDomainResult `protobuf:"bytes,7,opt,name=set_domain_result,json=setDomainResult,proto3" json:"set_domain_result,omitempty"`
}

func (m *WlstSluF900) Reset()      { *m = WlstSluF900{} }
func (*WlstSluF900) ProtoMessage() {}
func (*WlstSluF900) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{21}
}
func (m *WlstSluF900) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSluF900) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSluF900.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSluF900) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSluF900.Merge(m, src)
}
func (m *WlstSluF900) XXX_Size() int {
	return m.Size()
}
func (m *WlstSluF900) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSluF900.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSluF900 proto.InternalMessageInfo

func (m *WlstSluF900) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *WlstSluF900) GetAlarmType() int32 {
	if m != nil {
		return m.AlarmType
	}
	return 0
}

func (m *WlstSluF900) GetConcentratorData() *WlstSlu_7300_ConcentratorData {
	if m != nil {
		return m.ConcentratorData
	}
	return nil
}

func (m *WlstSluF900) GetErrorCtrls() []int32 {
	if m != nil {
		return m.ErrorCtrls
	}
	return nil
}

func (m *WlstSluF900) GetSluitemStatusAlarm() []*WlstSluF900_SluitemStatusAlarm {
	if m != nil {
		return m.SluitemStatusAlarm
	}
	return nil
}

func (m *WlstSluF900) GetBluetoothApply() *WlstSluF900_BluetoothApply {
	if m != nil {
		return m.BluetoothApply
	}
	return nil
}

func (m *WlstSluF900) GetSetDomainResult() *WlstSluF900_SetDomainResult {
	if m != nil {
		return m.SetDomainResult
	}
	return nil
}

type WlstSluF900_SluitemStatusAlarm struct {
	// 控制器地址
	SluitemIdx int32 `protobuf:"varint,1,opt,name=sluitem_idx,json=sluitemIdx,proto3" json:"sluitem_idx,omitempty"`
	// 控制器回路数量
	SluitemLoop int32 `protobuf:"varint,2,opt,name=sluitem_loop,json=sluitemLoop,proto3" json:"sluitem_loop,omitempty"`
	// 控制器状态
	SluitemStatus *WlstSlu_7300_BaseSluitemData_SluitemStatus `protobuf:"bytes,3,opt,name=sluitem_status,json=sluitemStatus,proto3" json:"sluitem_status,omitempty"`
	// 灯状态
	LightStatus []*WlstSlu_7300_BaseSluitemData_LightStatus `protobuf:"bytes,4,rep,name=light_status,json=lightStatus,proto3" json:"light_status,omitempty"`
}

func (m *WlstSluF900_SluitemStatusAlarm) Reset()      { *m = WlstSluF900_SluitemStatusAlarm{} }
func (*WlstSluF900_SluitemStatusAlarm) ProtoMessage() {}
func (*WlstSluF900_SluitemStatusAlarm) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{21, 0}
}
func (m *WlstSluF900_SluitemStatusAlarm) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSluF900_SluitemStatusAlarm) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSluF900_SluitemStatusAlarm.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSluF900_SluitemStatusAlarm) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSluF900_SluitemStatusAlarm.Merge(m, src)
}
func (m *WlstSluF900_SluitemStatusAlarm) XXX_Size() int {
	return m.Size()
}
func (m *WlstSluF900_SluitemStatusAlarm) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSluF900_SluitemStatusAlarm.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSluF900_SluitemStatusAlarm proto.InternalMessageInfo

func (m *WlstSluF900_SluitemStatusAlarm) GetSluitemIdx() int32 {
	if m != nil {
		return m.SluitemIdx
	}
	return 0
}

func (m *WlstSluF900_SluitemStatusAlarm) GetSluitemLoop() int32 {
	if m != nil {
		return m.SluitemLoop
	}
	return 0
}

func (m *WlstSluF900_SluitemStatusAlarm) GetSluitemStatus() *WlstSlu_7300_BaseSluitemData_SluitemStatus {
	if m != nil {
		return m.SluitemStatus
	}
	return nil
}

func (m *WlstSluF900_SluitemStatusAlarm) GetLightStatus() []*WlstSlu_7300_BaseSluitemData_LightStatus {
	if m != nil {
		return m.LightStatus
	}
	return nil
}

type WlstSluF900_BluetoothApply struct {
	// 设备标识码
	SimNumber int64 `protobuf:"varint,1,opt,name=sim_number,json=simNumber,proto3" json:"sim_number,omitempty"`
	// 动态码
	CheckCode string `protobuf:"bytes,2,opt,name=check_code,json=checkCode,proto3" json:"check_code,omitempty"`
}

func (m *WlstSluF900_BluetoothApply) Reset()      { *m = WlstSluF900_BluetoothApply{} }
func (*WlstSluF900_BluetoothApply) ProtoMessage() {}
func (*WlstSluF900_BluetoothApply) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{21, 1}
}
func (m *WlstSluF900_BluetoothApply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSluF900_BluetoothApply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSluF900_BluetoothApply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSluF900_BluetoothApply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSluF900_BluetoothApply.Merge(m, src)
}
func (m *WlstSluF900_BluetoothApply) XXX_Size() int {
	return m.Size()
}
func (m *WlstSluF900_BluetoothApply) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSluF900_BluetoothApply.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSluF900_BluetoothApply proto.InternalMessageInfo

func (m *WlstSluF900_BluetoothApply) GetSimNumber() int64 {
	if m != nil {
		return m.SimNumber
	}
	return 0
}

func (m *WlstSluF900_BluetoothApply) GetCheckCode() string {
	if m != nil {
		return m.CheckCode
	}
	return ""
}

type WlstSluF900_SetDomainResult struct {
	// 域名
	DomainName int32 `protobuf:"varint,1,opt,name=domain_name,json=domainName,proto3" json:"domain_name,omitempty"`
	// 状态 设置成功
	SetSuccess []int32 `protobuf:"varint,2,rep,packed,name=set_success,json=setSuccess,proto3" json:"set_success,omitempty"`
}

func (m *WlstSluF900_SetDomainResult) Reset()      { *m = WlstSluF900_SetDomainResult{} }
func (*WlstSluF900_SetDomainResult) ProtoMessage() {}
func (*WlstSluF900_SetDomainResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{21, 2}
}
func (m *WlstSluF900_SetDomainResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSluF900_SetDomainResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSluF900_SetDomainResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSluF900_SetDomainResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSluF900_SetDomainResult.Merge(m, src)
}
func (m *WlstSluF900_SetDomainResult) XXX_Size() int {
	return m.Size()
}
func (m *WlstSluF900_SetDomainResult) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSluF900_SetDomainResult.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSluF900_SetDomainResult proto.InternalMessageInfo

func (m *WlstSluF900_SetDomainResult) GetDomainName() int32 {
	if m != nil {
		return m.DomainName
	}
	return 0
}

func (m *WlstSluF900_SetDomainResult) GetSetSuccess() []int32 {
	if m != nil {
		return m.SetSuccess
	}
	return nil
}

// Wlst_slu_fb00
type WlstSlu_7B00 struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 起始地址
	SluitemIdx int32 `protobuf:"varint,2,opt,name=sluitem_idx,json=sluitemIdx,proto3" json:"sluitem_idx,omitempty"`
	// 记录数量
	DataCount int32 `protobuf:"varint,3,opt,name=data_count,json=dataCount,proto3" json:"data_count,omitempty"`
	// 控制参数
	OperationData []*WlstSlu_7B00_ReadConcentratorOperationData `protobuf:"bytes,4,rep,name=operation_data,json=operationData,proto3" json:"operation_data,omitempty"`
}

func (m *WlstSlu_7B00) Reset()      { *m = WlstSlu_7B00{} }
func (*WlstSlu_7B00) ProtoMessage() {}
func (*WlstSlu_7B00) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{22}
}
func (m *WlstSlu_7B00) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_7B00) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_7B00.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_7B00) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_7B00.Merge(m, src)
}
func (m *WlstSlu_7B00) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_7B00) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_7B00.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_7B00 proto.InternalMessageInfo

func (m *WlstSlu_7B00) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *WlstSlu_7B00) GetSluitemIdx() int32 {
	if m != nil {
		return m.SluitemIdx
	}
	return 0
}

func (m *WlstSlu_7B00) GetDataCount() int32 {
	if m != nil {
		return m.DataCount
	}
	return 0
}

func (m *WlstSlu_7B00) GetOperationData() []*WlstSlu_7B00_ReadConcentratorOperationData {
	if m != nil {
		return m.OperationData
	}
	return nil
}

type WlstSlu_7B00_ReadConcentratorOperationData struct {
	// （集中器：操作顺序 0-广播，1-依次）（控制器：数据类型 0-base，1-adv）
	OperationOrder int32 `protobuf:"varint,1,opt,name=operation_order,json=operationOrder,proto3" json:"operation_order,omitempty"`
	// 指令类型 0-清除(发送到控制器时无此值)，1-定时，2-经纬度，3-即时
	OperationType int32 `protobuf:"varint,2,opt,name=operation_type,json=operationType,proto3" json:"operation_type,omitempty"`
	// 周设置
	WeekSet []int32 `protobuf:"varint,3,rep,packed,name=week_set,json=weekSet,proto3" json:"week_set,omitempty"`
	// 定时 hh:mm->int32 或偏移量 依据 operation_type定
	TimerOrOffset int32 `protobuf:"varint,4,opt,name=timer_or_offset,json=timerOrOffset,proto3" json:"timer_or_offset,omitempty"`
	// 地址类型 0-全部，1-组，2-规则，3-单一，4-gprs
	AddrType int32 `protobuf:"varint,5,opt,name=addr_type,json=addrType,proto3" json:"addr_type,omitempty"`
	// 地址
	Addr []int32 `protobuf:"varint,6,rep,packed,name=addr,proto3" json:"addr,omitempty"`
	// 操作类型，1-传统，4-混合，5-pwm
	CmdType int32 `protobuf:"varint,7,opt,name=cmd_type,json=cmdType,proto3" json:"cmd_type,omitempty"`
	// 操作内容
	CmdMix []*WlstSlu_7B00_ReadConcentratorOperationData_CmdOperation `protobuf:"bytes,8,rep,name=cmd_mix,json=cmdMix,proto3" json:"cmd_mix,omitempty"`
}

func (m *WlstSlu_7B00_ReadConcentratorOperationData) Reset() {
	*m = WlstSlu_7B00_ReadConcentratorOperationData{}
}
func (*WlstSlu_7B00_ReadConcentratorOperationData) ProtoMessage() {}
func (*WlstSlu_7B00_ReadConcentratorOperationData) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{22, 0}
}
func (m *WlstSlu_7B00_ReadConcentratorOperationData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_7B00_ReadConcentratorOperationData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_7B00_ReadConcentratorOperationData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_7B00_ReadConcentratorOperationData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_7B00_ReadConcentratorOperationData.Merge(m, src)
}
func (m *WlstSlu_7B00_ReadConcentratorOperationData) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_7B00_ReadConcentratorOperationData) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_7B00_ReadConcentratorOperationData.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_7B00_ReadConcentratorOperationData proto.InternalMessageInfo

func (m *WlstSlu_7B00_ReadConcentratorOperationData) GetOperationOrder() int32 {
	if m != nil {
		return m.OperationOrder
	}
	return 0
}

func (m *WlstSlu_7B00_ReadConcentratorOperationData) GetOperationType() int32 {
	if m != nil {
		return m.OperationType
	}
	return 0
}

func (m *WlstSlu_7B00_ReadConcentratorOperationData) GetWeekSet() []int32 {
	if m != nil {
		return m.WeekSet
	}
	return nil
}

func (m *WlstSlu_7B00_ReadConcentratorOperationData) GetTimerOrOffset() int32 {
	if m != nil {
		return m.TimerOrOffset
	}
	return 0
}

func (m *WlstSlu_7B00_ReadConcentratorOperationData) GetAddrType() int32 {
	if m != nil {
		return m.AddrType
	}
	return 0
}

func (m *WlstSlu_7B00_ReadConcentratorOperationData) GetAddr() []int32 {
	if m != nil {
		return m.Addr
	}
	return nil
}

func (m *WlstSlu_7B00_ReadConcentratorOperationData) GetCmdType() int32 {
	if m != nil {
		return m.CmdType
	}
	return 0
}

func (m *WlstSlu_7B00_ReadConcentratorOperationData) GetCmdMix() []*WlstSlu_7B00_ReadConcentratorOperationData_CmdOperation {
	if m != nil {
		return m.CmdMix
	}
	return nil
}

type WlstSlu_7B00_ReadConcentratorOperationData_CmdOperation struct {
	// 回路1-4操作，-1-不操作，0-开灯，1-一档节能，2-二档节能，3-关灯，100～200-pwm0%～100%
	Handle int32 `protobuf:"varint,1,opt,name=handle,proto3" json:"handle,omitempty"`
	// pwm频率 /100为发送值
	Rate int32 `protobuf:"varint,2,opt,name=rate,proto3" json:"rate,omitempty"`
}

func (m *WlstSlu_7B00_ReadConcentratorOperationData_CmdOperation) Reset() {
	*m = WlstSlu_7B00_ReadConcentratorOperationData_CmdOperation{}
}
func (*WlstSlu_7B00_ReadConcentratorOperationData_CmdOperation) ProtoMessage() {}
func (*WlstSlu_7B00_ReadConcentratorOperationData_CmdOperation) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{22, 0, 0}
}
func (m *WlstSlu_7B00_ReadConcentratorOperationData_CmdOperation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_7B00_ReadConcentratorOperationData_CmdOperation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_7B00_ReadConcentratorOperationData_CmdOperation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_7B00_ReadConcentratorOperationData_CmdOperation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_7B00_ReadConcentratorOperationData_CmdOperation.Merge(m, src)
}
func (m *WlstSlu_7B00_ReadConcentratorOperationData_CmdOperation) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_7B00_ReadConcentratorOperationData_CmdOperation) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_7B00_ReadConcentratorOperationData_CmdOperation.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_7B00_ReadConcentratorOperationData_CmdOperation proto.InternalMessageInfo

func (m *WlstSlu_7B00_ReadConcentratorOperationData_CmdOperation) GetHandle() int32 {
	if m != nil {
		return m.Handle
	}
	return 0
}

func (m *WlstSlu_7B00_ReadConcentratorOperationData_CmdOperation) GetRate() int32 {
	if m != nil {
		return m.Rate
	}
	return 0
}

type WlstSluFe00 struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 操作命令
	OperationCmd int32 `protobuf:"varint,2,opt,name=operation_cmd,json=operationCmd,proto3" json:"operation_cmd,omitempty"`
	// 不成功数量
	FaultCount int32 `protobuf:"varint,3,opt,name=fault_count,json=faultCount,proto3" json:"fault_count,omitempty"`
	// 控制器地址
	SluitemIdx []int32 `protobuf:"varint,4,rep,packed,name=sluitem_idx,json=sluitemIdx,proto3" json:"sluitem_idx,omitempty"`
}

func (m *WlstSluFe00) Reset()      { *m = WlstSluFe00{} }
func (*WlstSluFe00) ProtoMessage() {}
func (*WlstSluFe00) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{23}
}
func (m *WlstSluFe00) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSluFe00) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSluFe00.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSluFe00) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSluFe00.Merge(m, src)
}
func (m *WlstSluFe00) XXX_Size() int {
	return m.Size()
}
func (m *WlstSluFe00) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSluFe00.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSluFe00 proto.InternalMessageInfo

func (m *WlstSluFe00) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *WlstSluFe00) GetOperationCmd() int32 {
	if m != nil {
		return m.OperationCmd
	}
	return 0
}

func (m *WlstSluFe00) GetFaultCount() int32 {
	if m != nil {
		return m.FaultCount
	}
	return 0
}

func (m *WlstSluFe00) GetSluitemIdx() []int32 {
	if m != nil {
		return m.SluitemIdx
	}
	return nil
}

// Wlst_slu_7d00
type WlstSlu_7400 struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 指令类型 0-清除，1-定时，2-经纬度，3-即时
	OperationType int32 `protobuf:"varint,2,opt,name=operation_type,json=operationType,proto3" json:"operation_type,omitempty"`
	// 操作顺序 0-广播，1-依次
	OperationOrder int32 `protobuf:"varint,3,opt,name=operation_order,json=operationOrder,proto3" json:"operation_order,omitempty"`
	// 地址类型 0-全部，1-组，2-规则，3-单一，4-gprs
	AddrType int32 `protobuf:"varint,4,opt,name=addr_type,json=addrType,proto3" json:"addr_type,omitempty"`
	// 地址(需要操作的序号)
	// int32 addr = 5;
	// gprs操作地址
	Addrs []int32 `protobuf:"varint,6,rep,packed,name=addrs,proto3" json:"addrs,omitempty"`
	// 周设置
	WeekSet []int32 `protobuf:"varint,7,rep,packed,name=week_set,json=weekSet,proto3" json:"week_set,omitempty"`
	// 定时 hh:mm->int32 或偏移量 依据 operation_type定
	TimerOrOffset int32 `protobuf:"varint,8,opt,name=timer_or_offset,json=timerOrOffset,proto3" json:"timer_or_offset,omitempty"`
	// 操作类型 3-经纬度关灯，4-混合控制，5-pwm调节，6-485调节
	CmdType int32 `protobuf:"varint,9,opt,name=cmd_type,json=cmdType,proto3" json:"cmd_type,omitempty"`
	// 混合回路操作 0-不操作，1-开灯，2-1档节能，3-2档节能，4-关灯（经纬度关灯时，cmd_type<4视为不操作）
	CmdMix []int32 `protobuf:"varint,10,rep,packed,name=cmd_mix,json=cmdMix,proto3" json:"cmd_mix,omitempty"`
	// pwm功率调节
	CmdPwm *WlstSlu_7400_CmdPwm `protobuf:"bytes,11,opt,name=cmd_pwm,json=cmdPwm,proto3" json:"cmd_pwm,omitempty"`
}

func (m *WlstSlu_7400) Reset()      { *m = WlstSlu_7400{} }
func (*WlstSlu_7400) ProtoMessage() {}
func (*WlstSlu_7400) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{24}
}
func (m *WlstSlu_7400) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_7400) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_7400.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_7400) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_7400.Merge(m, src)
}
func (m *WlstSlu_7400) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_7400) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_7400.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_7400 proto.InternalMessageInfo

func (m *WlstSlu_7400) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *WlstSlu_7400) GetOperationType() int32 {
	if m != nil {
		return m.OperationType
	}
	return 0
}

func (m *WlstSlu_7400) GetOperationOrder() int32 {
	if m != nil {
		return m.OperationOrder
	}
	return 0
}

func (m *WlstSlu_7400) GetAddrType() int32 {
	if m != nil {
		return m.AddrType
	}
	return 0
}

func (m *WlstSlu_7400) GetAddrs() []int32 {
	if m != nil {
		return m.Addrs
	}
	return nil
}

func (m *WlstSlu_7400) GetWeekSet() []int32 {
	if m != nil {
		return m.WeekSet
	}
	return nil
}

func (m *WlstSlu_7400) GetTimerOrOffset() int32 {
	if m != nil {
		return m.TimerOrOffset
	}
	return 0
}

func (m *WlstSlu_7400) GetCmdType() int32 {
	if m != nil {
		return m.CmdType
	}
	return 0
}

func (m *WlstSlu_7400) GetCmdMix() []int32 {
	if m != nil {
		return m.CmdMix
	}
	return nil
}

func (m *WlstSlu_7400) GetCmdPwm() *WlstSlu_7400_CmdPwm {
	if m != nil {
		return m.CmdPwm
	}
	return nil
}

type WlstSlu_7400_CmdPwm struct {
	// 回路(仅需要操作的回路序号)
	LoopCanDo []int32 `protobuf:"varint,1,rep,packed,name=loop_can_do,json=loopCanDo,proto3" json:"loop_can_do,omitempty"`
	// 比例 0-100 -> 0%-100%
	Scale int32 `protobuf:"varint,2,opt,name=scale,proto3" json:"scale,omitempty"`
	// 频率 /100为发送值
	Rate int32 `protobuf:"varint,3,opt,name=rate,proto3" json:"rate,omitempty"`
}

func (m *WlstSlu_7400_CmdPwm) Reset()      { *m = WlstSlu_7400_CmdPwm{} }
func (*WlstSlu_7400_CmdPwm) ProtoMessage() {}
func (*WlstSlu_7400_CmdPwm) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{24, 0}
}
func (m *WlstSlu_7400_CmdPwm) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_7400_CmdPwm) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_7400_CmdPwm.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_7400_CmdPwm) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_7400_CmdPwm.Merge(m, src)
}
func (m *WlstSlu_7400_CmdPwm) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_7400_CmdPwm) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_7400_CmdPwm.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_7400_CmdPwm proto.InternalMessageInfo

func (m *WlstSlu_7400_CmdPwm) GetLoopCanDo() []int32 {
	if m != nil {
		return m.LoopCanDo
	}
	return nil
}

func (m *WlstSlu_7400_CmdPwm) GetScale() int32 {
	if m != nil {
		return m.Scale
	}
	return 0
}

func (m *WlstSlu_7400_CmdPwm) GetRate() int32 {
	if m != nil {
		return m.Rate
	}
	return 0
}

type WlstSlu_7C00 struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 地址类型 0-全部，1-组，2-规则，3-单一，4-gprs
	AddrType int32 `protobuf:"varint,2,opt,name=addr_type,json=addrType,proto3" json:"addr_type,omitempty"`
	// 地址
	Addr int32 `protobuf:"varint,3,opt,name=addr,proto3" json:"addr,omitempty"`
	// 数据条数（==-1时表示发送给集中器）
	CmdCount int32 `protobuf:"varint,4,opt,name=cmd_count,json=cmdCount,proto3" json:"cmd_count,omitempty"`
	// 更新或清除 0-add,1-clean&add（仅发送给控制器时有效）
	AddOrUpdate int32 `protobuf:"varint,5,opt,name=add_or_update,json=addOrUpdate,proto3" json:"add_or_update,omitempty"`
	// 控制参数
	OperationData []*WlstSlu_7C00_ConcentratorOperationData `protobuf:"bytes,6,rep,name=operation_data,json=operationData,proto3" json:"operation_data,omitempty"`
}

func (m *WlstSlu_7C00) Reset()      { *m = WlstSlu_7C00{} }
func (*WlstSlu_7C00) ProtoMessage() {}
func (*WlstSlu_7C00) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{25}
}
func (m *WlstSlu_7C00) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_7C00) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_7C00.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_7C00) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_7C00.Merge(m, src)
}
func (m *WlstSlu_7C00) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_7C00) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_7C00.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_7C00 proto.InternalMessageInfo

func (m *WlstSlu_7C00) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *WlstSlu_7C00) GetAddrType() int32 {
	if m != nil {
		return m.AddrType
	}
	return 0
}

func (m *WlstSlu_7C00) GetAddr() int32 {
	if m != nil {
		return m.Addr
	}
	return 0
}

func (m *WlstSlu_7C00) GetCmdCount() int32 {
	if m != nil {
		return m.CmdCount
	}
	return 0
}

func (m *WlstSlu_7C00) GetAddOrUpdate() int32 {
	if m != nil {
		return m.AddOrUpdate
	}
	return 0
}

func (m *WlstSlu_7C00) GetOperationData() []*WlstSlu_7C00_ConcentratorOperationData {
	if m != nil {
		return m.OperationData
	}
	return nil
}

type WlstSlu_7C00_ConcentratorOperationData struct {
	// 指令类型 1-定时，2-经纬度，3-即时
	OperationType int32 `protobuf:"varint,1,opt,name=operation_type,json=operationType,proto3" json:"operation_type,omitempty"`
	// 操作类型 4-混合控制，5-pwm调节，6-485调节
	CmdType int32 `protobuf:"varint,2,opt,name=cmd_type,json=cmdType,proto3" json:"cmd_type,omitempty"`
	// 周设置
	WeekSet []int32 `protobuf:"varint,3,rep,packed,name=week_set,json=weekSet,proto3" json:"week_set,omitempty"`
	// 定时 hh:mm->int32 或偏移量 依据 operation_type定
	TimerOrOffset int32 `protobuf:"varint,4,opt,name=timer_or_offset,json=timerOrOffset,proto3" json:"timer_or_offset,omitempty"`
	// 混合回路操作 0-不操作，1-开灯，2-1档节能，3-2档节能，4-关灯
	CmdMix []int32 `protobuf:"varint,5,rep,packed,name=cmd_mix,json=cmdMix,proto3" json:"cmd_mix,omitempty"`
	// pwm功率调节
	CmdPwm *WlstSlu_7C00_ConcentratorOperationData_CmdPwm `protobuf:"bytes,6,opt,name=cmd_pwm,json=cmdPwm,proto3" json:"cmd_pwm,omitempty"`
	// 485调节
	Cmd_485 *WlstSlu_7C00_ConcentratorOperationData_Cmd_485 `protobuf:"bytes,7,opt,name=cmd_485,json=cmd485,proto3" json:"cmd_485,omitempty"`
}

func (m *WlstSlu_7C00_ConcentratorOperationData) Reset() {
	*m = WlstSlu_7C00_ConcentratorOperationData{}
}
func (*WlstSlu_7C00_ConcentratorOperationData) ProtoMessage() {}
func (*WlstSlu_7C00_ConcentratorOperationData) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{25, 0}
}
func (m *WlstSlu_7C00_ConcentratorOperationData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_7C00_ConcentratorOperationData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_7C00_ConcentratorOperationData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_7C00_ConcentratorOperationData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_7C00_ConcentratorOperationData.Merge(m, src)
}
func (m *WlstSlu_7C00_ConcentratorOperationData) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_7C00_ConcentratorOperationData) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_7C00_ConcentratorOperationData.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_7C00_ConcentratorOperationData proto.InternalMessageInfo

func (m *WlstSlu_7C00_ConcentratorOperationData) GetOperationType() int32 {
	if m != nil {
		return m.OperationType
	}
	return 0
}

func (m *WlstSlu_7C00_ConcentratorOperationData) GetCmdType() int32 {
	if m != nil {
		return m.CmdType
	}
	return 0
}

func (m *WlstSlu_7C00_ConcentratorOperationData) GetWeekSet() []int32 {
	if m != nil {
		return m.WeekSet
	}
	return nil
}

func (m *WlstSlu_7C00_ConcentratorOperationData) GetTimerOrOffset() int32 {
	if m != nil {
		return m.TimerOrOffset
	}
	return 0
}

func (m *WlstSlu_7C00_ConcentratorOperationData) GetCmdMix() []int32 {
	if m != nil {
		return m.CmdMix
	}
	return nil
}

func (m *WlstSlu_7C00_ConcentratorOperationData) GetCmdPwm() *WlstSlu_7C00_ConcentratorOperationData_CmdPwm {
	if m != nil {
		return m.CmdPwm
	}
	return nil
}

func (m *WlstSlu_7C00_ConcentratorOperationData) GetCmd_485() *WlstSlu_7C00_ConcentratorOperationData_Cmd_485 {
	if m != nil {
		return m.Cmd_485
	}
	return nil
}

type WlstSlu_7C00_ConcentratorOperationData_CmdPwm struct {
	// 回路
	LoopCanDo []int32 `protobuf:"varint,1,rep,packed,name=loop_can_do,json=loopCanDo,proto3" json:"loop_can_do,omitempty"`
	// 比例 0-100～10%-100%
	Scale int32 `protobuf:"varint,2,opt,name=scale,proto3" json:"scale,omitempty"`
	// 频率 /100为发送值
	Rate int32 `protobuf:"varint,3,opt,name=rate,proto3" json:"rate,omitempty"`
}

func (m *WlstSlu_7C00_ConcentratorOperationData_CmdPwm) Reset() {
	*m = WlstSlu_7C00_ConcentratorOperationData_CmdPwm{}
}
func (*WlstSlu_7C00_ConcentratorOperationData_CmdPwm) ProtoMessage() {}
func (*WlstSlu_7C00_ConcentratorOperationData_CmdPwm) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{25, 0, 0}
}
func (m *WlstSlu_7C00_ConcentratorOperationData_CmdPwm) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_7C00_ConcentratorOperationData_CmdPwm) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_7C00_ConcentratorOperationData_CmdPwm.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_7C00_ConcentratorOperationData_CmdPwm) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_7C00_ConcentratorOperationData_CmdPwm.Merge(m, src)
}
func (m *WlstSlu_7C00_ConcentratorOperationData_CmdPwm) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_7C00_ConcentratorOperationData_CmdPwm) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_7C00_ConcentratorOperationData_CmdPwm.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_7C00_ConcentratorOperationData_CmdPwm proto.InternalMessageInfo

func (m *WlstSlu_7C00_ConcentratorOperationData_CmdPwm) GetLoopCanDo() []int32 {
	if m != nil {
		return m.LoopCanDo
	}
	return nil
}

func (m *WlstSlu_7C00_ConcentratorOperationData_CmdPwm) GetScale() int32 {
	if m != nil {
		return m.Scale
	}
	return 0
}

func (m *WlstSlu_7C00_ConcentratorOperationData_CmdPwm) GetRate() int32 {
	if m != nil {
		return m.Rate
	}
	return 0
}

type WlstSlu_7C00_ConcentratorOperationData_Cmd_485 struct {
	// 波特率 1-600,2-1200,3-2400,4-4800,5-9600,6-19200
	Baudrate int32 `protobuf:"varint,1,opt,name=baudrate,proto3" json:"baudrate,omitempty"`
	// 校验位 0-无，1-奇校验，2-偶校验
	Check int32 `protobuf:"varint,2,opt,name=check,proto3" json:"check,omitempty"`
	// 数据长度 0-20
	DataLength int32 `protobuf:"varint,3,opt,name=data_length,json=dataLength,proto3" json:"data_length,omitempty"`
	// 数据
	Data_485 string `protobuf:"bytes,4,opt,name=data_485,json=data485,proto3" json:"data_485,omitempty"`
}

func (m *WlstSlu_7C00_ConcentratorOperationData_Cmd_485) Reset() {
	*m = WlstSlu_7C00_ConcentratorOperationData_Cmd_485{}
}
func (*WlstSlu_7C00_ConcentratorOperationData_Cmd_485) ProtoMessage() {}
func (*WlstSlu_7C00_ConcentratorOperationData_Cmd_485) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{25, 0, 1}
}
func (m *WlstSlu_7C00_ConcentratorOperationData_Cmd_485) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_7C00_ConcentratorOperationData_Cmd_485) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_7C00_ConcentratorOperationData_Cmd_485.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_7C00_ConcentratorOperationData_Cmd_485) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_7C00_ConcentratorOperationData_Cmd_485.Merge(m, src)
}
func (m *WlstSlu_7C00_ConcentratorOperationData_Cmd_485) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_7C00_ConcentratorOperationData_Cmd_485) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_7C00_ConcentratorOperationData_Cmd_485.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_7C00_ConcentratorOperationData_Cmd_485 proto.InternalMessageInfo

func (m *WlstSlu_7C00_ConcentratorOperationData_Cmd_485) GetBaudrate() int32 {
	if m != nil {
		return m.Baudrate
	}
	return 0
}

func (m *WlstSlu_7C00_ConcentratorOperationData_Cmd_485) GetCheck() int32 {
	if m != nil {
		return m.Check
	}
	return 0
}

func (m *WlstSlu_7C00_ConcentratorOperationData_Cmd_485) GetDataLength() int32 {
	if m != nil {
		return m.DataLength
	}
	return 0
}

func (m *WlstSlu_7C00_ConcentratorOperationData_Cmd_485) GetData_485() string {
	if m != nil {
		return m.Data_485
	}
	return ""
}

type WlstSlu_6F00 struct {
	// 序号
	CmdIdx int32 `protobuf:"varint,1,opt,name=cmd_idx,json=cmdIdx,proto3" json:"cmd_idx,omitempty"`
	// 地址类型 0-全部，1-组，2-规则，3-单一，4-gprs
	AddrType int32 `protobuf:"varint,2,opt,name=addr_type,json=addrType,proto3" json:"addr_type,omitempty"`
	// 地址
	Addr int32 `protobuf:"varint,3,opt,name=addr,proto3" json:"addr,omitempty"`
	// 操作标识
	ResetMark *WlstSlu_6F00_ResetMark `protobuf:"bytes,4,opt,name=reset_mark,json=resetMark,proto3" json:"reset_mark,omitempty"`
	// 操作结果 0x3a-成功，0x5a-失败, 0x60-数据错误，0x61-正在操作，0x62-等待操作，0x63-队列已满
	Status int32 `protobuf:"varint,5,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *WlstSlu_6F00) Reset()      { *m = WlstSlu_6F00{} }
func (*WlstSlu_6F00) ProtoMessage() {}
func (*WlstSlu_6F00) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{26}
}
func (m *WlstSlu_6F00) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_6F00) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_6F00.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_6F00) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_6F00.Merge(m, src)
}
func (m *WlstSlu_6F00) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_6F00) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_6F00.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_6F00 proto.InternalMessageInfo

func (m *WlstSlu_6F00) GetCmdIdx() int32 {
	if m != nil {
		return m.CmdIdx
	}
	return 0
}

func (m *WlstSlu_6F00) GetAddrType() int32 {
	if m != nil {
		return m.AddrType
	}
	return 0
}

func (m *WlstSlu_6F00) GetAddr() int32 {
	if m != nil {
		return m.Addr
	}
	return 0
}

func (m *WlstSlu_6F00) GetResetMark() *WlstSlu_6F00_ResetMark {
	if m != nil {
		return m.ResetMark
	}
	return nil
}

func (m *WlstSlu_6F00) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

type WlstSlu_6F00_ResetMark struct {
	// mcu复位
	ResetMcu int32 `protobuf:"varint,1,opt,name=reset_mcu,json=resetMcu,proto3" json:"reset_mcu,omitempty"`
	// 通讯模块复位
	ResetComm int32 `protobuf:"varint,2,opt,name=reset_comm,json=resetComm,proto3" json:"reset_comm,omitempty"`
	// 初始化mcu硬件配置
	InitMcuHardware int32 `protobuf:"varint,3,opt,name=init_mcu_hardware,json=initMcuHardware,proto3" json:"init_mcu_hardware,omitempty"`
	// 初始化ram
	InitRam int32 `protobuf:"varint,4,opt,name=init_ram,json=initRam,proto3" json:"init_ram,omitempty"`
	// eerom 清零
	ZeroEerom int32 `protobuf:"varint,5,opt,name=zero_eerom,json=zeroEerom,proto3" json:"zero_eerom,omitempty"`
	// 电量计数清零
	ZeroCount int32 `protobuf:"varint,6,opt,name=zero_count,json=zeroCount,proto3" json:"zero_count,omitempty"`
}

func (m *WlstSlu_6F00_ResetMark) Reset()      { *m = WlstSlu_6F00_ResetMark{} }
func (*WlstSlu_6F00_ResetMark) ProtoMessage() {}
func (*WlstSlu_6F00_ResetMark) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab6bd86311f0b5fd, []int{26, 0}
}
func (m *WlstSlu_6F00_ResetMark) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstSlu_6F00_ResetMark) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstSlu_6F00_ResetMark.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstSlu_6F00_ResetMark) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstSlu_6F00_ResetMark.Merge(m, src)
}
func (m *WlstSlu_6F00_ResetMark) XXX_Size() int {
	return m.Size()
}
func (m *WlstSlu_6F00_ResetMark) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstSlu_6F00_ResetMark.DiscardUnknown(m)
}

var xxx_messageInfo_WlstSlu_6F00_ResetMark proto.InternalMessageInfo

func (m *WlstSlu_6F00_ResetMark) GetResetMcu() int32 {
	if m != nil {
		return m.ResetMcu
	}
	return 0
}

func (m *WlstSlu_6F00_ResetMark) GetResetComm() int32 {
	if m != nil {
		return m.ResetComm
	}
	return 0
}

func (m *WlstSlu_6F00_ResetMark) GetInitMcuHardware() int32 {
	if m != nil {
		return m.InitMcuHardware
	}
	return 0
}

func (m *WlstSlu_6F00_ResetMark) GetInitRam() int32 {
	if m != nil {
		return m.InitRam
	}
	return 0
}

func (m *WlstSlu_6F00_ResetMark) GetZeroEerom() int32 {
	if m != nil {
		return m.ZeroEerom
	}
	return 0
}

func (m *WlstSlu_6F00_ResetMark) GetZeroCount() int32 {
	if m != nil {
		return m.ZeroCount
	}
	return 0
}

func init() {
	proto.RegisterType((*WlstSluF400)(nil), "wlst.pb2.Wlst_slu_f400")
	proto.RegisterType((*WlstSlu_3900)(nil), "wlst.pb2.Wlst_slu_3900")
	proto.RegisterType((*WlstSlu_3900_ModelInfo)(nil), "wlst.pb2.Wlst_slu_3900.Model_info")
	proto.RegisterType((*WlstSlu_3900_LightData)(nil), "wlst.pb2.Wlst_slu_3900.Light_data")
	proto.RegisterType((*WlstSlu_3900_LightStatus)(nil), "wlst.pb2.Wlst_slu_3900.Light_status")
	proto.RegisterType((*WlstSlu_3900_SluitemStatus)(nil), "wlst.pb2.Wlst_slu_3900.Sluitem_status")
	proto.RegisterType((*WlstSlu_3900_TimeFault)(nil), "wlst.pb2.Wlst_slu_3900.Time_fault")
	proto.RegisterType((*WlstSlu_3900_SluitemPara)(nil), "wlst.pb2.Wlst_slu_3900.Sluitem_para")
	proto.RegisterType((*WlstSlu_7800)(nil), "wlst.pb2.Wlst_slu_7800")
	proto.RegisterType((*WlstSluF800)(nil), "wlst.pb2.Wlst_slu_f800")
	proto.RegisterType((*WlstSluF800_View0X20)(nil), "wlst.pb2.Wlst_slu_f800.View0x20")
	proto.RegisterType((*WlstSluF800_View0X21)(nil), "wlst.pb2.Wlst_slu_f800.View0x21")
	proto.RegisterType((*WlstSluF800_View0X23)(nil), "wlst.pb2.Wlst_slu_f800.View0x23")
	proto.RegisterType((*WlstSluEc00)(nil), "wlst.pb2.Wlst_slu_ec00")
	proto.RegisterType((*WlstSlu_6B00)(nil), "wlst.pb2.Wlst_slu_6b00")
	proto.RegisterType((*WlstSlu_6B00_CmdPwm)(nil), "wlst.pb2.Wlst_slu_6b00.Cmd_pwm")
	proto.RegisterType((*WlstSlu_6C00)(nil), "wlst.pb2.Wlst_slu_6c00")
	proto.RegisterType((*WlstSluD000)(nil), "wlst.pb2.Wlst_slu_d000")
	proto.RegisterType((*WlstSlu_2800)(nil), "wlst.pb2.Wlst_slu_2800")
	proto.RegisterType((*WlstSlu_2400)(nil), "wlst.pb2.Wlst_slu_2400")
	proto.RegisterType((*WlstSlu_6E00)(nil), "wlst.pb2.Wlst_slu_6e00")
	proto.RegisterType((*WlstSlu_3000)(nil), "wlst.pb2.Wlst_slu_3000")
	proto.RegisterType((*WlstSlu_9A00)(nil), "wlst.pb2.Wlst_slu_9a00")
	proto.RegisterType((*WlstSluCd00)(nil), "wlst.pb2.Wlst_slu_cd00")
	proto.RegisterType((*WlstSlu_1C00)(nil), "wlst.pb2.Wlst_slu_1c00")
	proto.RegisterType((*WlstSlu_1D00)(nil), "wlst.pb2.Wlst_slu_1d00")
	proto.RegisterType((*WlstSlu_1D00_DataMark)(nil), "wlst.pb2.Wlst_slu_1d00.Data_mark")
	proto.RegisterType((*WlstSlu_9D00)(nil), "wlst.pb2.Wlst_slu_9d00")
	proto.RegisterType((*WlstSlu_9D00_SetMark)(nil), "wlst.pb2.Wlst_slu_9d00.Set_mark")
	proto.RegisterType((*WlstSlu_9D00_SluitemData)(nil), "wlst.pb2.Wlst_slu_9d00.Sluitem_data")
	proto.RegisterType((*WlstSlu_9D00_SluitemDataNew)(nil), "wlst.pb2.Wlst_slu_9d00.Sluitem_data_new")
	proto.RegisterType((*WlstSlu_9D00_SluitemPara)(nil), "wlst.pb2.Wlst_slu_9d00.Sluitem_para")
	proto.RegisterType((*WlstSlu_9D00_SluitemVer)(nil), "wlst.pb2.Wlst_slu_9d00.Sluitem_ver")
	proto.RegisterType((*WlstSlu_9D00_SluitemSunriseset)(nil), "wlst.pb2.Wlst_slu_9d00.Sluitem_sunriseset")
	proto.RegisterType((*WlstSlu_9D00_SluitemRuntime)(nil), "wlst.pb2.Wlst_slu_9d00.Sluitem_runtime")
	proto.RegisterType((*WlstSluF000)(nil), "wlst.pb2.Wlst_slu_f000")
	proto.RegisterType((*WlstSluF000_ResetMark)(nil), "wlst.pb2.Wlst_slu_f000.Reset_mark")
	proto.RegisterType((*WlstSluF100)(nil), "wlst.pb2.Wlst_slu_f100")
	proto.RegisterType((*WlstSluF100_TimerStatus)(nil), "wlst.pb2.Wlst_slu_f100.Timer_status")
	proto.RegisterType((*WlstSluF200)(nil), "wlst.pb2.Wlst_slu_f200")
	proto.RegisterType((*WlstSluF200_DataMark)(nil), "wlst.pb2.Wlst_slu_f200.Data_mark")
	proto.RegisterType((*WlstSluF200_ControllerData)(nil), "wlst.pb2.Wlst_slu_f200.Controller_data")
	proto.RegisterType((*WlstSlu_7300)(nil), "wlst.pb2.Wlst_slu_7300")
	proto.RegisterType((*WlstSlu_7300_ConcentratorData)(nil), "wlst.pb2.Wlst_slu_7300.Concentrator_data")
	proto.RegisterType((*WlstSlu_7300_ConcentratorData_RunStatus)(nil), "wlst.pb2.Wlst_slu_7300.Concentrator_data.Run_status")
	proto.RegisterType((*WlstSlu_7300_ConcentratorData_ArgsStatus)(nil), "wlst.pb2.Wlst_slu_7300.Concentrator_data.Args_status")
	proto.RegisterType((*WlstSlu_7300_ConcentratorData_HardwareStatus)(nil), "wlst.pb2.Wlst_slu_7300.Concentrator_data.Hardware_status")
	proto.RegisterType((*WlstSlu_7300_BaseSluitemData)(nil), "wlst.pb2.Wlst_slu_7300.Base_sluitem_data")
	proto.RegisterType((*WlstSlu_7300_BaseSluitemData_SluitemStatus)(nil), "wlst.pb2.Wlst_slu_7300.Base_sluitem_data.Sluitem_status")
	proto.RegisterType((*WlstSlu_7300_BaseSluitemData_LightStatus)(nil), "wlst.pb2.Wlst_slu_7300.Base_sluitem_data.Light_status")
	proto.RegisterType((*WlstSlu_7300_BaseSluitemData_LightData)(nil), "wlst.pb2.Wlst_slu_7300.Base_sluitem_data.Light_data")
	proto.RegisterType((*WlstSlu_7300_UnknowSluitem)(nil), "wlst.pb2.Wlst_slu_7300.Unknow_sluitem")
	proto.RegisterType((*WlstSlu_7300_AssistSluitemData)(nil), "wlst.pb2.Wlst_slu_7300.Assist_sluitem_data")
	proto.RegisterType((*WlstSlu_7300_AssistSluitemData_LightData)(nil), "wlst.pb2.Wlst_slu_7300.Assist_sluitem_data.Light_data")
	proto.RegisterType((*WlstSlu_7300_SluitemPhyinfo)(nil), "wlst.pb2.Wlst_slu_7300.Sluitem_phyinfo")
	proto.RegisterType((*WlstSlu_7300_ModelInfo)(nil), "wlst.pb2.Wlst_slu_7300.Model_info")
	proto.RegisterType((*WlstSluF900)(nil), "wlst.pb2.Wlst_slu_f900")
	proto.RegisterType((*WlstSluF900_SluitemStatusAlarm)(nil), "wlst.pb2.Wlst_slu_f900.Sluitem_status_alarm")
	proto.RegisterType((*WlstSluF900_BluetoothApply)(nil), "wlst.pb2.Wlst_slu_f900.Bluetooth_apply")
	proto.RegisterType((*WlstSluF900_SetDomainResult)(nil), "wlst.pb2.Wlst_slu_f900.Set_domain_result")
	proto.RegisterType((*WlstSlu_7B00)(nil), "wlst.pb2.Wlst_slu_7b00")
	proto.RegisterType((*WlstSlu_7B00_ReadConcentratorOperationData)(nil), "wlst.pb2.Wlst_slu_7b00.Read_concentrator_operation_data")
	proto.RegisterType((*WlstSlu_7B00_ReadConcentratorOperationData_CmdOperation)(nil), "wlst.pb2.Wlst_slu_7b00.Read_concentrator_operation_data.Cmd_operation")
	proto.RegisterType((*WlstSluFe00)(nil), "wlst.pb2.Wlst_slu_fe00")
	proto.RegisterType((*WlstSlu_7400)(nil), "wlst.pb2.Wlst_slu_7400")
	proto.RegisterType((*WlstSlu_7400_CmdPwm)(nil), "wlst.pb2.Wlst_slu_7400.Cmd_pwm")
	proto.RegisterType((*WlstSlu_7C00)(nil), "wlst.pb2.Wlst_slu_7c00")
	proto.RegisterType((*WlstSlu_7C00_ConcentratorOperationData)(nil), "wlst.pb2.Wlst_slu_7c00.Concentrator_operation_data")
	proto.RegisterType((*WlstSlu_7C00_ConcentratorOperationData_CmdPwm)(nil), "wlst.pb2.Wlst_slu_7c00.Concentrator_operation_data.Cmd_pwm")
	proto.RegisterType((*WlstSlu_7C00_ConcentratorOperationData_Cmd_485)(nil), "wlst.pb2.Wlst_slu_7c00.Concentrator_operation_data.Cmd_485")
	proto.RegisterType((*WlstSlu_6F00)(nil), "wlst.pb2.Wlst_slu_6f00")
	proto.RegisterType((*WlstSlu_6F00_ResetMark)(nil), "wlst.pb2.Wlst_slu_6f00.Reset_mark")
}

func init() { proto.RegisterFile("protocol_slu.proto", fileDescriptor_ab6bd86311f0b5fd) }

var fileDescriptor_ab6bd86311f0b5fd = []byte{
	// 5278 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5c, 0xcd, 0x6f, 0x1c, 0x47,
	0x76, 0xd7, 0xcc, 0x70, 0xbe, 0x6a, 0x38, 0x1c, 0xb2, 0x4d, 0xcb, 0xe3, 0xd1, 0x8a, 0x92, 0x86,
	0xb1, 0x25, 0x7b, 0x77, 0x19, 0x8a, 0xa4, 0x64, 0x19, 0xc6, 0x06, 0xa1, 0x69, 0xcb, 0x76, 0x20,
	0x99, 0x42, 0x53, 0xd6, 0xc2, 0x1b, 0x24, 0x8d, 0x62, 0x77, 0x0d, 0xd9, 0xcb, 0x9e, 0xee, 0x71,
	0x7f, 0x90, 0xd2, 0x06, 0x01, 0xf6, 0x90, 0x1c, 0x72, 0x09, 0x82, 0xec, 0x26, 0xb7, 0x4d, 0x90,
	0x53, 0x02, 0xe4, 0x92, 0x05, 0x12, 0x04, 0x48, 0x0e, 0x81, 0x72, 0xd9, 0x1c, 0x92, 0xc0, 0xc0,
	0x5e, 0x0c, 0xe4, 0x12, 0xcb, 0x97, 0x00, 0x41, 0x00, 0x23, 0xf9, 0x03, 0x12, 0xbc, 0xf7, 0xaa,
	0xba, 0xab, 0x7b, 0x3e, 0x48, 0xd9, 0xb2, 0x73, 0x48, 0x6e, 0x53, 0xbf, 0x7a, 0x55, 0xd5, 0x55,
	0xf5, 0xea, 0xd5, 0xfb, 0xaa, 0x61, 0xc6, 0x28, 0x0c, 0xe2, 0xc0, 0x0e, 0x3c, 0x2b, 0xf2, 0x92,
	0x35, 0x2c, 0x18, 0x8d, 0x13, 0x2f, 0x8a, 0xd7, 0x46, 0xfb, 0x1b, 0xfd, 0xdf, 0x60, 0xed, 0xef,
	0x7a, 0x51, 0x0c, 0x75, 0xd6, 0x60, 0x6b, 0x7d, 0xdd, 0x78, 0x81, 0xd5, 0xed, 0xa1, 0x63, 0xb9,
	0xce, 0xc3, 0x6e, 0xe9, 0x72, 0xe9, 0x5a, 0xd5, 0xac, 0xd9, 0x43, 0xe7, 0x3d, 0xe7, 0xa1, 0x71,
	0x9e, 0xd5, 0xa2, 0x98, 0xc7, 0x49, 0xd4, 0x2d, 0x13, 0x4e, 0x25, 0xc0, 0x43, 0x31, 0xe4, 0xe1,
	0x51, 0xb7, 0x42, 0x38, 0x95, 0x8c, 0x2b, 0x6c, 0x3e, 0xf2, 0x12, 0x37, 0x16, 0x43, 0x8b, 0x3b,
	0x4e, 0xd8, 0x9d, 0xc3, 0xda, 0x96, 0xc4, 0xb6, 0x1d, 0x27, 0xec, 0xff, 0x5d, 0x47, 0x1b, 0x7d,
	0xf3, 0xf5, 0x59, 0xa3, 0x6f, 0x33, 0x36, 0x0c, 0x1c, 0xe1, 0x59, 0xae, 0x3f, 0x08, 0xf0, 0x0b,
	0x5a, 0x1b, 0xfd, 0x35, 0x35, 0x8d, 0xb5, 0x5c, 0x2f, 0x6b, 0x77, 0x53, 0x4a, 0xb3, 0x89, 0xad,
	0xde, 0xf3, 0x07, 0x01, 0x74, 0xe1, 0xb9, 0x07, 0x87, 0xb1, 0xe5, 0xf0, 0x98, 0x77, 0x2b, 0x97,
	0x2b, 0xb3, 0xba, 0xb8, 0x93, 0x52, 0x9a, 0x4d, 0x6c, 0xf5, 0x16, 0x8f, 0xb9, 0x71, 0x95, 0x75,
	0x3c, 0xc1, 0x8f, 0xf8, 0x81, 0xb0, 0xec, 0x24, 0x0c, 0x85, 0x1f, 0xe3, 0xb4, 0x4a, 0xe6, 0x82,
	0x84, 0x77, 0x08, 0x35, 0xee, 0xb2, 0x05, 0x35, 0x79, 0xb9, 0x68, 0x55, 0xfc, 0xe4, 0x97, 0xa7,
	0x8d, 0xb7, 0x97, 0xa3, 0x36, 0xdb, 0xb2, 0xf5, 0x1e, 0xad, 0xf1, 0x36, 0x63, 0xb1, 0x3b, 0x14,
	0xd6, 0x80, 0x27, 0x5e, 0xdc, 0xad, 0xcd, 0x9e, 0xfd, 0xfd, 0x94, 0xd2, 0x6c, 0x42, 0xab, 0xdb,
	0xf0, 0xd3, 0xb8, 0xc4, 0x5a, 0xa1, 0x88, 0x44, 0x6c, 0xd9, 0x41, 0xe2, 0xc7, 0xdd, 0x3a, 0xae,
	0x2e, 0x43, 0x68, 0x07, 0x10, 0xe3, 0x02, 0x6b, 0x3a, 0x3c, 0x16, 0x16, 0x34, 0xe9, 0x36, 0x2e,
	0x97, 0xae, 0x55, 0xcc, 0x06, 0x00, 0xd0, 0x9d, 0xf1, 0x4e, 0xb6, 0x99, 0x23, 0x1e, 0xf2, 0x6e,
	0x13, 0x3f, 0xe1, 0x17, 0x4e, 0x9b, 0x0d, 0xd0, 0xa6, 0x5b, 0x7e, 0x8f, 0x87, 0xdc, 0x30, 0xd8,
	0x5c, 0x18, 0x85, 0xa3, 0x2e, 0xc3, 0x01, 0xf0, 0x37, 0x61, 0x91, 0xdb, 0x6d, 0x29, 0x2c, 0x72,
	0x8d, 0x45, 0x56, 0x89, 0xfc, 0xb0, 0x3b, 0x8f, 0x10, 0xfc, 0x04, 0x64, 0x64, 0xbb, 0xdd, 0x36,
	0x21, 0x23, 0xdb, 0x95, 0x7d, 0x7d, 0xd4, 0x5d, 0x48, 0xfb, 0xfa, 0xc8, 0xe8, 0xb2, 0x7a, 0xfc,
	0x70, 0x14, 0x9c, 0x88, 0xb0, 0xdb, 0x41, 0x58, 0x15, 0x81, 0x4f, 0x05, 0x0f, 0x07, 0xb6, 0xdf,
	0x5d, 0xc4, 0x0a, 0x59, 0x82, 0x7e, 0x85, 0xed, 0x75, 0x97, 0x70, 0x41, 0xe0, 0x27, 0x20, 0x76,
	0xf4, 0x51, 0xd7, 0x20, 0xc4, 0x8e, 0x3e, 0x32, 0x96, 0x59, 0x35, 0x14, 0x51, 0xe0, 0x77, 0x9f,
	0x43, 0x8c, 0x0a, 0x84, 0xc6, 0xe1, 0xa3, 0xee, 0xb2, 0x42, 0xe3, 0xf0, 0x11, 0x7c, 0x41, 0x94,
	0xf8, 0xa1, 0x1b, 0x89, 0xee, 0xf3, 0x88, 0xab, 0x22, 0x9e, 0xa0, 0xc4, 0x8f, 0x44, 0xdc, 0x3d,
	0x2f, 0x4f, 0x10, 0x96, 0x7a, 0xff, 0x59, 0x62, 0x2c, 0x63, 0x59, 0xfd, 0xe0, 0x78, 0x41, 0x30,
	0x92, 0x07, 0x41, 0xad, 0xe2, 0x9d, 0x20, 0x18, 0x01, 0x09, 0x4e, 0xca, 0x8a, 0xf8, 0xb1, 0xeb,
	0x1f, 0xc8, 0x13, 0xd9, 0x42, 0x6c, 0x0f, 0x21, 0xd8, 0xef, 0x43, 0x1e, 0x59, 0x92, 0x2f, 0xe5,
	0xd9, 0x64, 0x87, 0x3c, 0xba, 0x43, 0x08, 0xf0, 0x32, 0x10, 0xc4, 0x62, 0x38, 0x12, 0x21, 0x8f,
	0x93, 0x50, 0xc8, 0x23, 0xba, 0x70, 0xc8, 0xa3, 0xfb, 0x19, 0x0a, 0x8c, 0x81, 0x84, 0xee, 0x50,
	0x84, 0xc8, 0xc6, 0x55, 0xb3, 0x01, 0x24, 0x50, 0x86, 0x35, 0xc0, 0x13, 0x86, 0x4c, 0x59, 0x35,
	0xa9, 0xa0, 0x4f, 0x21, 0x7e, 0x34, 0x12, 0xc8, 0x6d, 0xcd, 0x74, 0x0a, 0xf7, 0x1f, 0x8d, 0x44,
	0xef, 0xa7, 0x15, 0xc6, 0xb2, 0x43, 0x06, 0xab, 0x76, 0x1c, 0x78, 0x31, 0x7c, 0x6a, 0x09, 0x4f,
	0x94, 0x2a, 0x42, 0x8d, 0x3a, 0x6b, 0x65, 0xaa, 0x91, 0x45, 0x18, 0x85, 0xdb, 0xb1, 0x7b, 0x2c,
	0x2c, 0xda, 0xf0, 0x0a, 0x56, 0xb7, 0x08, 0xbb, 0x87, 0x9b, 0xfe, 0x12, 0x5b, 0x08, 0x45, 0x8e,
	0x88, 0xce, 0x6b, 0x5b, 0xa1, 0x29, 0x19, 0x1f, 0x8d, 0x38, 0xf4, 0x2a, 0xc9, 0xaa, 0x44, 0xa6,
	0x50, 0x22, 0xbb, 0xcc, 0x5a, 0xc2, 0x13, 0x76, 0x1c, 0xba, 0xb6, 0x1b, 0x3f, 0xc2, 0x29, 0x97,
	0x4c, 0x1d, 0x82, 0x55, 0x97, 0xa3, 0xe1, 0x31, 0xaa, 0x23, 0x05, 0x23, 0x48, 0x1d, 0x24, 0x12,
	0x42, 0x52, 0x2c, 0x34, 0x66, 0x1f, 0xa4, 0x3b, 0x1a, 0xad, 0xd9, 0xc2, 0x96, 0x52, 0x24, 0x5c,
	0x62, 0xb4, 0xdd, 0x96, 0x27, 0x8e, 0x85, 0x87, 0x07, 0xb2, 0x6a, 0x32, 0x84, 0xee, 0x00, 0x62,
	0xac, 0xb3, 0xe5, 0xf4, 0xc8, 0x22, 0x61, 0x9c, 0x84, 0x7e, 0xe0, 0xe3, 0xc9, 0xab, 0x9a, 0x86,
	0x3a, 0x94, 0x50, 0x75, 0x1f, 0x6b, 0x50, 0x44, 0xf0, 0x58, 0x38, 0x72, 0x09, 0x5a, 0x52, 0x44,
	0x00, 0x84, 0x64, 0xbd, 0x5f, 0x63, 0xf3, 0xfa, 0x07, 0xc1, 0xd6, 0x28, 0xfe, 0x22, 0x26, 0x55,
	0x45, 0x60, 0x0b, 0x92, 0x55, 0xc4, 0x99, 0x54, 0x30, 0x2e, 0x32, 0x76, 0x12, 0x84, 0x47, 0xae,
	0x7f, 0x60, 0x05, 0xbe, 0x64, 0xc9, 0xa6, 0x44, 0x76, 0xfd, 0xde, 0x7d, 0xb6, 0x90, 0x17, 0x83,
	0xf0, 0x45, 0x03, 0x8f, 0x47, 0x87, 0x52, 0xf0, 0xd1, 0x20, 0x0c, 0x21, 0x92, 0x6a, 0x57, 0xd8,
	0xbc, 0xf0, 0xf9, 0xbe, 0x27, 0x2c, 0xee, 0xf1, 0x70, 0xa8, 0x0e, 0x02, 0x61, 0xdb, 0x00, 0xf5,
	0x7e, 0x93, 0xb1, 0x4c, 0x22, 0x42, 0x8f, 0xb6, 0x17, 0xd8, 0x47, 0xf9, 0x1e, 0x11, 0xa2, 0x1e,
	0x5f, 0x66, 0x1d, 0x22, 0x08, 0x92, 0xd8, 0xd2, 0xe7, 0xd0, 0x46, 0x78, 0x37, 0x89, 0x27, 0xd0,
	0xd1, 0xe0, 0x95, 0x3c, 0x1d, 0x0d, 0xff, 0x2f, 0x25, 0x36, 0xaf, 0x8b, 0x43, 0xe3, 0x1b, 0xac,
	0xe9, 0x05, 0xfe, 0x81, 0x1b, 0x27, 0x8e, 0xe2, 0xf5, 0x0c, 0x30, 0x7a, 0xac, 0xe1, 0xf1, 0x98,
	0x2a, 0x89, 0xdd, 0xd3, 0xb2, 0x71, 0x8d, 0x2d, 0xc2, 0x41, 0xcc, 0x4d, 0xb8, 0x92, 0x1e, 0xd9,
	0xb7, 0xb3, 0x39, 0xc3, 0x42, 0xbb, 0x91, 0x15, 0x26, 0xbe, 0x0f, 0xd2, 0x81, 0x8e, 0x75, 0xd3,
	0x8d, 0x4c, 0x02, 0x90, 0xdd, 0x81, 0xce, 0x72, 0xfd, 0x58, 0x84, 0xc7, 0xdc, 0x93, 0xc7, 0xba,
	0x8d, 0xe8, 0x7b, 0x12, 0x84, 0xc5, 0x4d, 0x46, 0x9e, 0xeb, 0x1f, 0x59, 0xa1, 0x18, 0x79, 0x8f,
	0xe4, 0x11, 0x6f, 0x11, 0x66, 0x02, 0xd4, 0xff, 0xdb, 0x92, 0x76, 0x83, 0xbf, 0x76, 0x6b, 0xd6,
	0x0d, 0x7e, 0x91, 0x31, 0x71, 0x0c, 0x07, 0x0c, 0x25, 0x02, 0xad, 0x69, 0x13, 0x11, 0x90, 0x07,
	0x50, 0x6d, 0x7b, 0x3c, 0x8a, 0xa8, 0x5a, 0xf2, 0x06, 0x22, 0x58, 0x7d, 0x85, 0xcd, 0x87, 0xc2,
	0x0e, 0x42, 0x47, 0xde, 0x5f, 0x52, 0x9b, 0x20, 0x8c, 0x2e, 0xb0, 0x17, 0x59, 0xc3, 0x41, 0xd6,
	0x0c, 0x63, 0x9c, 0x4f, 0xc5, 0xac, 0x3b, 0x70, 0x5a, 0xc2, 0xd8, 0x78, 0x9e, 0xd5, 0x9c, 0xd8,
	0x12, 0xbe, 0x83, 0x73, 0xa8, 0x98, 0x55, 0x27, 0x7e, 0xdb, 0x77, 0xfa, 0x9f, 0x33, 0x5d, 0xfb,
	0xf9, 0x0a, 0xbf, 0xfe, 0x22, 0x63, 0x20, 0xe5, 0xac, 0x38, 0x88, 0xb9, 0xa7, 0xf6, 0x03, 0x90,
	0xfb, 0x00, 0xe0, 0x97, 0x43, 0x35, 0x0c, 0x4b, 0x3b, 0x51, 0x87, 0x32, 0x8c, 0x5b, 0x9c, 0x77,
	0x6d, 0x7c, 0xde, 0xdf, 0x61, 0xcd, 0x63, 0x57, 0x9c, 0x58, 0xeb, 0x0f, 0x37, 0xd6, 0xbb, 0x75,
	0x54, 0x6b, 0x2e, 0x4f, 0x90, 0x27, 0x30, 0xbf, 0xb5, 0x07, 0xae, 0x38, 0x01, 0x3a, 0xb3, 0x71,
	0x2c, 0x7f, 0xe9, 0xcd, 0xaf, 0x77, 0x1b, 0x67, 0x6a, 0x7e, 0x3d, 0x6d, 0x7e, 0x5d, 0x6f, 0xbe,
	0xd1, 0x6d, 0x3e, 0xe5, 0xe8, 0x1b, 0x7a, 0xf3, 0xcd, 0x2e, 0x3b, 0x53, 0xf3, 0xcd, 0xb4, 0xf9,
	0xa6, 0xde, 0x7c, 0xab, 0xdb, 0x7a, 0xca, 0xd1, 0xb7, 0xf4, 0xe6, 0x37, 0xba, 0xf3, 0x4f, 0xd9,
	0xfc, 0x46, 0x6f, 0x87, 0x35, 0x14, 0x8a, 0xea, 0x53, 0x6c, 0x1d, 0xf2, 0xd1, 0x48, 0xf8, 0xc8,
	0x3b, 0xa0, 0x3e, 0xc5, 0xef, 0x62, 0xd9, 0xe8, 0x69, 0xba, 0x73, 0xe5, 0x5a, 0xf5, 0xcd, 0xf2,
	0x62, 0x49, 0xe9, 0xcf, 0xbd, 0x9f, 0x97, 0xd2, 0x5e, 0xae, 0xcf, 0xee, 0xe5, 0x25, 0xb6, 0x10,
	0xe0, 0xad, 0xec, 0x06, 0xbe, 0xce, 0x87, 0xed, 0x14, 0x45, 0x66, 0xbb, 0xca, 0x3a, 0x19, 0x59,
	0x10, 0x3a, 0xf2, 0x66, 0xac, 0x9a, 0x59, 0xeb, 0x5d, 0x40, 0x61, 0x30, 0xd0, 0xcc, 0xa9, 0x2b,
	0x62, 0xca, 0x06, 0x00, 0xd8, 0x8b, 0xc1, 0xe6, 0x50, 0x6d, 0x27, 0x7e, 0xc4, 0xdf, 0xc6, 0x2b,
	0x6c, 0x31, 0xeb, 0x39, 0x0a, 0x92, 0xd0, 0x16, 0x92, 0x21, 0xb3, 0x11, 0xf7, 0x10, 0xee, 0xfd,
	0xc1, 0x5c, 0x3a, 0xab, 0xcd, 0xd9, 0xb3, 0x52, 0x03, 0x95, 0xb5, 0x81, 0xae, 0x30, 0x46, 0x02,
	0x4a, 0x1e, 0x27, 0xb5, 0x66, 0x4d, 0x44, 0xf1, 0xfb, 0x5e, 0x19, 0xd3, 0xb0, 0xe7, 0x52, 0xb2,
	0x82, 0xf6, 0x7c, 0x95, 0x75, 0x14, 0xa9, 0xd2, 0x31, 0xe8, 0x7a, 0x57, 0x3d, 0x3c, 0x90, 0xaa,
	0xc6, 0x37, 0x33, 0x42, 0xa5, 0x72, 0xd4, 0x2e, 0x57, 0xae, 0x95, 0xb0, 0x53, 0x45, 0xac, 0x54,
	0xfc, 0xad, 0xec, 0x7e, 0xcd, 0x29, 0x18, 0xf5, 0xb4, 0x85, 0xba, 0x63, 0xb7, 0x35, 0x4d, 0xe3,
	0x16, 0x3b, 0xaf, 0x5a, 0x15, 0x14, 0x93, 0x46, 0xda, 0x4e, 0xf5, 0x6b, 0xe6, 0x74, 0x94, 0x35,
	0xf6, 0x9c, 0x6a, 0x39, 0xe4, 0x0f, 0xd3, 0x99, 0x34, 0x71, 0x26, 0x4b, 0xb2, 0xea, 0x2e, 0x7f,
	0xa8, 0x26, 0xb3, 0x91, 0xa7, 0x57, 0x13, 0x62, 0xe9, 0x30, 0x5a, 0x1b, 0x35, 0xa7, 0xcd, 0xac,
	0x8d, 0xae, 0xe8, 0xb4, 0xc6, 0xa6, 0xf4, 0xb6, 0xa6, 0xf3, 0x68, 0xab, 0x36, 0x3a, 0x7c, 0x84,
	0xf6, 0xd9, 0x7c, 0xba, 0x15, 0x6a, 0xd5, 0xee, 0x51, 0x4d, 0xff, 0x4f, 0xf4, 0x0b, 0x43, 0xd8,
	0xb3, 0x44, 0xee, 0x05, 0xd6, 0x44, 0x61, 0x8e, 0x55, 0xc4, 0x1d, 0x0d, 0x04, 0xa4, 0x3c, 0x0e,
	0x05, 0x57, 0x52, 0x51, 0x0a, 0x5c, 0x40, 0x48, 0x26, 0xbe, 0xc1, 0xda, 0x27, 0x6a, 0x94, 0x9b,
	0xfb, 0xeb, 0xeb, 0xc8, 0x1c, 0xad, 0x8d, 0x17, 0x26, 0x1c, 0x6e, 0xa8, 0x36, 0x5b, 0x80, 0xef,
	0x79, 0x09, 0x14, 0xfa, 0xff, 0x51, 0xd1, 0xbe, 0x11, 0x90, 0xe9, 0xdf, 0xf8, 0x02, 0xab, 0x83,
	0x4d, 0x95, 0x7d, 0x61, 0x2d, 0x12, 0xf8, 0x7d, 0xfa, 0x65, 0x54, 0x99, 0x76, 0x19, 0xcd, 0x69,
	0x97, 0xd1, 0x84, 0xd3, 0x5d, 0x3d, 0xe3, 0xe9, 0xae, 0x4d, 0x3c, 0xdd, 0x2f, 0xb3, 0x0e, 0xaa,
	0xec, 0x56, 0x10, 0x5a, 0xc1, 0x60, 0x00, 0x66, 0x07, 0x19, 0x7d, 0x6d, 0x84, 0x77, 0xc3, 0x5d,
	0x04, 0xf3, 0x52, 0xa0, 0x51, 0x90, 0x02, 0x5d, 0x56, 0x85, 0xdf, 0x11, 0x4a, 0x76, 0xda, 0x51,
	0x02, 0x60, 0x82, 0xb0, 0x24, 0xd8, 0x8a, 0x54, 0x4a, 0x58, 0x22, 0x6c, 0x74, 0x81, 0x56, 0x6b,
	0xe8, 0x3e, 0x44, 0xce, 0x91, 0xe2, 0xce, 0x1e, 0x3a, 0x77, 0xdd, 0x87, 0xc6, 0x2d, 0xaa, 0x1c,
	0x9d, 0x0c, 0xd1, 0xb8, 0x6b, 0x6d, 0x5c, 0x9a, 0xb2, 0x27, 0x6b, 0x3b, 0x44, 0x86, 0x2d, 0xef,
	0x9d, 0x0c, 0x7b, 0xdf, 0x65, 0x75, 0x09, 0x19, 0x7d, 0xd6, 0x02, 0xd3, 0xc8, 0xb2, 0xb9, 0x6f,
	0x39, 0x41, 0xb7, 0x94, 0x09, 0x08, 0x80, 0x77, 0xb8, 0xff, 0x56, 0x00, 0x2a, 0x68, 0x64, 0x73,
	0x4f, 0x09, 0x49, 0x2a, 0xa0, 0xcd, 0xc8, 0x63, 0x75, 0x45, 0xe3, 0xef, 0xbe, 0xa3, 0x6f, 0xf7,
	0x57, 0xc5, 0x92, 0xfd, 0x2b, 0xda, 0x28, 0xce, 0xfa, 0xfa, 0x3a, 0x98, 0x99, 0xc7, 0x22, 0xc4,
	0x11, 0x9a, 0x26, 0xfc, 0xec, 0x7f, 0x47, 0x23, 0xd9, 0x00, 0x75, 0x24, 0xf3, 0xb9, 0x94, 0x72,
	0x3e, 0x97, 0x65, 0x56, 0xd5, 0xf5, 0x5d, 0x2a, 0xf4, 0x7f, 0x59, 0x6f, 0x2e, 0x7d, 0x39, 0x4e,
	0x60, 0x0d, 0x3c, 0x7e, 0xa0, 0xda, 0x3b, 0xc1, 0x6d, 0x8f, 0x1f, 0x4c, 0xf3, 0xe5, 0xf4, 0x7f,
	0xae, 0x9f, 0xce, 0x9b, 0x62, 0x56, 0x17, 0x60, 0x82, 0xf2, 0x38, 0x0c, 0x3c, 0xc9, 0xe4, 0xca,
	0x04, 0x45, 0x8c, 0x18, 0xfd, 0x2a, 0xeb, 0x48, 0x92, 0x54, 0xcf, 0x94, 0x17, 0x11, 0xc1, 0xba,
	0xa2, 0x29, 0x09, 0x89, 0xa1, 0xe7, 0xf4, 0xbe, 0x88, 0x9b, 0x33, 0x12, 0x5a, 0xde, 0xaa, 0x4e,
	0x42, 0x67, 0x5e, 0xdb, 0xb5, 0x9a, 0xbe, 0x6b, 0xfd, 0xc7, 0xfa, 0xac, 0x36, 0x61, 0xe9, 0x97,
	0x59, 0xd5, 0x8e, 0x43, 0x4f, 0x2d, 0x2b, 0x15, 0xc0, 0x36, 0x70, 0x82, 0x21, 0x77, 0x7d, 0xcb,
	0xe7, 0x43, 0xc5, 0x37, 0x8c, 0xa0, 0xf7, 0xf9, 0x50, 0x80, 0x08, 0x4e, 0x46, 0x23, 0x11, 0x2a,
	0xe1, 0x6b, 0x79, 0xee, 0xd0, 0x55, 0x5b, 0xbd, 0x84, 0x55, 0x52, 0xfa, 0xde, 0x81, 0x0a, 0xa0,
	0xf7, 0xd0, 0xf4, 0xca, 0xd3, 0xd3, 0xf4, 0x96, 0xb0, 0x2a, 0x47, 0xff, 0x22, 0x6b, 0x0c, 0xb9,
	0x6d, 0xa5, 0xf7, 0x6e, 0xc5, 0xac, 0x0f, 0xb9, 0x8d, 0xae, 0xb2, 0x6d, 0x6d, 0x0a, 0xaf, 0xf3,
	0xf5, 0x75, 0x63, 0x9d, 0x19, 0xda, 0xc7, 0x5a, 0x29, 0x9b, 0xa8, 0x93, 0xb0, 0x98, 0x7d, 0x37,
	0x5d, 0x83, 0xfd, 0xdf, 0x99, 0xd3, 0xfa, 0xb0, 0x9d, 0x3c, 0x9f, 0xb7, 0x73, 0x7c, 0x7e, 0x83,
	0x9d, 0xb7, 0x83, 0xe1, 0x30, 0xf1, 0x5d, 0x9b, 0x04, 0xcd, 0x80, 0xbb, 0x5e, 0x12, 0x0a, 0xb5,
	0x60, 0xcf, 0xe7, 0x6a, 0x6f, 0xcb, 0xca, 0xcc, 0x2d, 0x31, 0xe0, 0x76, 0x1c, 0x84, 0x39, 0xb7,
	0xc4, 0x6d, 0x84, 0x8c, 0x4d, 0x96, 0x6f, 0x6b, 0xd9, 0x87, 0xdc, 0xf7, 0x85, 0xe2, 0x8c, 0xe5,
	0x5c, 0xe5, 0x0e, 0xd5, 0x19, 0xab, 0xac, 0x2d, 0xaf, 0x2f, 0x2b, 0xe4, 0xfe, 0x81, 0x90, 0x46,
	0xfc, 0xbc, 0x04, 0x4d, 0xc0, 0x32, 0x83, 0x98, 0x48, 0xaa, 0x9a, 0x41, 0x4c, 0x04, 0x20, 0xe8,
	0x92, 0x38, 0xb0, 0x86, 0x81, 0xa3, 0xd4, 0x96, 0x06, 0x00, 0x77, 0x03, 0x47, 0xe4, 0xad, 0xb2,
	0xfa, 0x2c, 0xab, 0xac, 0x51, 0xb0, 0xca, 0xd6, 0xd9, 0xb2, 0xcd, 0xc3, 0xd0, 0x85, 0x91, 0x83,
	0x24, 0x06, 0xe3, 0x16, 0x47, 0x20, 0x8b, 0xdc, 0x90, 0x75, 0x26, 0x55, 0xe1, 0x58, 0xab, 0xac,
	0xbd, 0xef, 0x25, 0x22, 0x0e, 0x82, 0xf8, 0xd0, 0x1a, 0xb9, 0xca, 0x24, 0x9f, 0x4f, 0xc1, 0x7b,
	0x2e, 0x2a, 0x7b, 0x19, 0x11, 0x76, 0x48, 0xf6, 0x78, 0xd6, 0x14, 0xfb, 0x5a, 0x64, 0x15, 0xdb,
	0x8e, 0x51, 0x94, 0x56, 0x4d, 0xf8, 0x09, 0xbd, 0x73, 0xef, 0x84, 0x3f, 0x8a, 0xac, 0xc0, 0xf7,
	0x5c, 0x5f, 0xa0, 0x7b, 0xac, 0x6a, 0xce, 0x13, 0xb8, 0x8b, 0x58, 0xff, 0xfb, 0x1a, 0x2b, 0x5c,
	0x9f, 0x29, 0xf2, 0x2e, 0x31, 0xe5, 0xb6, 0x49, 0x85, 0x5e, 0xc5, 0x64, 0x12, 0x92, 0x04, 0xfa,
	0xa9, 0xa9, 0x14, 0x4f, 0x4d, 0xff, 0x8f, 0xf5, 0xeb, 0xf4, 0xba, 0xf3, 0xa5, 0x06, 0xfb, 0x25,
	0x74, 0x52, 0x72, 0x0b, 0xfd, 0xcd, 0x73, 0x78, 0x7f, 0x5c, 0x99, 0x70, 0x7f, 0xc0, 0x28, 0x6b,
	0x6f, 0x29, 0x42, 0xf4, 0x63, 0xf2, 0xbb, 0x3c, 0x3c, 0xea, 0xfd, 0xa8, 0xcc, 0x9a, 0x29, 0x0e,
	0x1c, 0x81, 0x12, 0x1b, 0x1d, 0xc2, 0xf4, 0x25, 0x0d, 0x00, 0xd0, 0xd7, 0xab, 0xc4, 0x39, 0xf9,
	0xbd, 0xca, 0x99, 0x38, 0x27, 0xc7, 0x97, 0x6a, 0xcb, 0xc3, 0x83, 0x48, 0x4e, 0x1a, 0xdb, 0x6e,
	0x87, 0x07, 0x51, 0xda, 0xf6, 0x20, 0x0c, 0x92, 0x91, 0xb2, 0xf7, 0x00, 0x79, 0x07, 0x00, 0x38,
	0xe7, 0x58, 0x7d, 0x9c, 0x3a, 0xd4, 0xea, 0x50, 0x7e, 0x20, 0x42, 0x90, 0x99, 0x58, 0x25, 0x7d,
	0x86, 0x70, 0x6b, 0xcb, 0xeb, 0x1d, 0xe0, 0xbd, 0x14, 0x95, 0x9e, 0x2d, 0xfa, 0xbc, 0x18, 0x2c,
	0x7f, 0x75, 0xbb, 0xab, 0x4f, 0x44, 0x10, 0xb8, 0x81, 0x2e, 0xa5, 0x38, 0xf4, 0x70, 0x9a, 0x74,
	0xc3, 0xcf, 0xe3, 0xbd, 0x24, 0xb1, 0xfe, 0x8f, 0x7b, 0xba, 0x74, 0xf9, 0x5f, 0xdd, 0x21, 0x58,
	0x3a, 0xba, 0xda, 0x35, 0x31, 0x4f, 0xb7, 0x3a, 0x0a, 0x79, 0xcd, 0x11, 0x8d, 0xd3, 0xa9, 0x4d,
	0xf5, 0x9f, 0xc1, 0x3c, 0x52, 0x47, 0x34, 0x3a, 0xf2, 0xd5, 0x97, 0xe3, 0xf6, 0xea, 0x2e, 0x4a,
	0xe5, 0xaa, 0xab, 0x64, 0x2e, 0xca, 0x49, 0x4e, 0xef, 0xc6, 0xd9, 0xc6, 0x1a, 0x77, 0x7a, 0x5f,
	0x65, 0xca, 0x22, 0x91, 0x1c, 0x91, 0x69, 0x53, 0x6a, 0x04, 0x62, 0x8c, 0xb7, 0xb2, 0xd5, 0x05,
	0xde, 0x60, 0x38, 0xe0, 0xea, 0x69, 0x03, 0x1e, 0x8b, 0x30, 0xdd, 0x02, 0xe0, 0xa1, 0x0f, 0x99,
	0x91, 0x9a, 0x46, 0x19, 0x1b, 0xb5, 0xb0, 0xb3, 0x57, 0x4f, 0xeb, 0x2c, 0x6b, 0x91, 0x1a, 0x08,
	0x1a, 0xd7, 0xdd, 0xcb, 0x74, 0xfd, 0x30, 0xf1, 0x71, 0xe1, 0xc8, 0x6c, 0xbe, 0x7a, 0x5a, 0xbf,
	0x92, 0x3c, 0x35, 0x08, 0x4c, 0x2a, 0x1b, 0x26, 0x5b, 0xd4, 0x37, 0xd4, 0xf2, 0xc5, 0x09, 0x5e,
	0x46, 0xad, 0x8d, 0x6b, 0x67, 0xd9, 0x54, 0xa0, 0x4f, 0xfb, 0x84, 0x8d, 0x7d, 0x5f, 0x9c, 0x68,
	0xea, 0xcd, 0x42, 0x4e, 0x6d, 0x7a, 0x83, 0x35, 0x40, 0x5b, 0x47, 0xd6, 0xec, 0xe0, 0x18, 0x97,
	0xa7, 0x8e, 0x21, 0xe9, 0x4c, 0xd0, 0xef, 0x91, 0x31, 0x57, 0x59, 0x1b, 0x07, 0xb4, 0x03, 0x3f,
	0x76, 0xfd, 0x44, 0x60, 0x18, 0xa1, 0x6a, 0xce, 0x03, 0xb8, 0x23, 0xb1, 0xde, 0x4f, 0x4a, 0xac,
	0xa1, 0x9a, 0xa2, 0xb6, 0x28, 0x62, 0x29, 0x40, 0xa4, 0x78, 0x89, 0x44, 0x4c, 0xf2, 0xe3, 0x45,
	0xfa, 0x16, 0x14, 0x1f, 0x65, 0x19, 0x27, 0x10, 0x31, 0x4a, 0x0f, 0xd9, 0x8e, 0x58, 0xa5, 0x92,
	0xb6, 0x23, 0x16, 0x91, 0x95, 0x18, 0xb8, 0x51, 0x46, 0x3b, 0x6c, 0x16, 0x6e, 0x0f, 0x9c, 0x4e,
	0x0c, 0xf1, 0xf8, 0xa0, 0x16, 0xa9, 0x3b, 0x10, 0x43, 0x3c, 0x88, 0xf4, 0x3e, 0x99, 0xcb, 0xbc,
	0x91, 0xa7, 0xf8, 0xdd, 0xbf, 0xa1, 0xfb, 0xdd, 0x95, 0xfd, 0x97, 0xfa, 0xde, 0x5f, 0x1a, 0xf3,
	0xbd, 0x2b, 0x92, 0x9c, 0xff, 0xfd, 0x95, 0x09, 0xfe, 0x77, 0x45, 0x58, 0xf0, 0xc1, 0x5f, 0x62,
	0x2d, 0xdd, 0xae, 0x25, 0x0b, 0x9d, 0x0d, 0x33, 0x83, 0x76, 0x95, 0x08, 0xc6, 0x2d, 0x73, 0x20,
	0x52, 0x16, 0xec, 0x2f, 0xb2, 0x25, 0x74, 0xb2, 0xe5, 0xec, 0xd7, 0xcc, 0x24, 0x5f, 0xc4, 0x4a,
	0xdd, 0x7a, 0xbd, 0xcc, 0x5a, 0x7a, 0x08, 0x84, 0xc4, 0xa3, 0x0e, 0x4d, 0x0a, 0xfa, 0x35, 0x27,
	0x06, 0xfd, 0x2e, 0xb1, 0x16, 0x59, 0x5c, 0x22, 0x0c, 0x83, 0x50, 0xde, 0xea, 0x18, 0xb8, 0x0b,
	0xdf, 0x06, 0xc4, 0xb0, 0xc6, 0x7c, 0x16, 0x74, 0x28, 0x6f, 0x4d, 0xe0, 0xc2, 0xd7, 0x36, 0xd7,
	0xd7, 0xd7, 0xde, 0xe4, 0x91, 0xb0, 0xf4, 0xe3, 0x71, 0x4a, 0x9c, 0xf0, 0xc3, 0x42, 0x74, 0x81,
	0xce, 0xe6, 0xcd, 0xb3, 0x77, 0x3f, 0x33, 0xde, 0xa0, 0xc7, 0x0f, 0xdb, 0xc5, 0xf8, 0x61, 0xef,
	0xcf, 0xe7, 0xd8, 0x62, 0xf1, 0x64, 0x02, 0x13, 0x65, 0xec, 0x95, 0x32, 0xd1, 0x33, 0x65, 0xb1,
	0x8b, 0xac, 0x11, 0x26, 0x3e, 0x09, 0xf1, 0xcc, 0x05, 0x54, 0x0f, 0x13, 0x1f, 0x85, 0xf8, 0x32,
	0xab, 0x8e, 0x0e, 0x79, 0xa4, 0x14, 0x42, 0x2a, 0x3c, 0x3d, 0x9b, 0xfc, 0x3f, 0x13, 0x9c, 0x85,
	0x09, 0xe0, 0xa6, 0x13, 0xbe, 0x08, 0x0f, 0x1e, 0xa9, 0xc8, 0xe4, 0x42, 0x76, 0xd3, 0x51, 0x05,
	0x85, 0x27, 0x7b, 0xbf, 0x5b, 0x29, 0x84, 0x45, 0x0a, 0x6a, 0x64, 0x69, 0xcc, 0xf8, 0x7a, 0x69,
	0x6c, 0xdd, 0xa4, 0xf7, 0x33, 0x3f, 0x7b, 0x2d, 0xec, 0x35, 0x21, 0x50, 0x92, 0xfa, 0xaf, 0xb4,
	0x60, 0xc9, 0xd6, 0x94, 0x40, 0x59, 0xc6, 0x4c, 0x93, 0x82, 0x65, 0x9a, 0xff, 0xf1, 0x58, 0xa0,
	0xb5, 0x53, 0x1d, 0xf3, 0x3f, 0x3e, 0xc0, 0x8a, 0xbc, 0x6d, 0x51, 0x9b, 0x65, 0x5b, 0xd4, 0x0b,
	0xb6, 0xc5, 0x6a, 0x3e, 0x22, 0xd7, 0x48, 0x47, 0xd0, 0xa2, 0x72, 0x5a, 0x98, 0x86, 0x6e, 0x9a,
	0xa6, 0x1e, 0xa6, 0xa1, 0xcb, 0xa6, 0x18, 0xc9, 0x61, 0x63, 0x91, 0x9c, 0xde, 0x8f, 0xcb, 0xac,
	0xa5, 0x29, 0x14, 0x67, 0x89, 0x42, 0xaf, 0x16, 0x37, 0x9b, 0x36, 0x24, 0xb7, 0xd1, 0xc6, 0x4d,
	0xf6, 0x82, 0x3a, 0x63, 0x2a, 0x18, 0x0d, 0xe6, 0x4c, 0xe2, 0x29, 0x53, 0xe1, 0x79, 0x55, 0x2d,
	0x03, 0xd3, 0x77, 0xb1, 0xd2, 0xf8, 0x36, 0x33, 0x34, 0x21, 0xac, 0x9a, 0x48, 0xd3, 0x59, 0xab,
	0x91, 0xe4, 0x57, 0xd8, 0x3c, 0x1d, 0x3b, 0x49, 0x28, 0xfd, 0x03, 0x88, 0x65, 0x24, 0xb9, 0xa0,
	0x74, 0x6d, 0x2c, 0x28, 0xad, 0x5c, 0x32, 0xf5, 0xd4, 0x25, 0xd3, 0xbb, 0xcd, 0x8c, 0x71, 0xcd,
	0x48, 0x8f, 0xf1, 0x97, 0xa6, 0xc5, 0xf8, 0xcb, 0xb9, 0x18, 0xff, 0x4f, 0x2b, 0xac, 0x53, 0x50,
	0x85, 0x64, 0xc6, 0x05, 0xa7, 0xaf, 0x91, 0xfa, 0x01, 0x06, 0x85, 0xe0, 0x53, 0x2e, 0xb1, 0x56,
	0x90, 0xc4, 0xa3, 0x24, 0x17, 0x71, 0x62, 0x04, 0xa9, 0x88, 0x18, 0x79, 0xfc, 0x84, 0x1e, 0x74,
	0x6a, 0x49, 0x0c, 0x49, 0x56, 0x59, 0x0b, 0x53, 0x3a, 0xe8, 0x20, 0x68, 0x0c, 0xcd, 0x00, 0xa6,
	0x33, 0x90, 0xeb, 0x07, 0x64, 0x68, 0x35, 0xdf, 0x8f, 0x4b, 0x47, 0x4f, 0x91, 0x48, 0x4f, 0x62,
	0x4d, 0x77, 0x4d, 0x0a, 0xe9, 0x49, 0xbc, 0x0a, 0xb6, 0x86, 0xc7, 0x1f, 0x59, 0x12, 0x46, 0x81,
	0x2a, 0x0f, 0x3f, 0x56, 0xec, 0x12, 0x0e, 0x22, 0x7b, 0x74, 0x22, 0xf9, 0x2a, 0xe3, 0xe9, 0xfa,
	0xe8, 0x84, 0xf8, 0xea, 0x02, 0x6b, 0x42, 0x35, 0xf1, 0x3c, 0x71, 0x33, 0xd0, 0xa7, 0xdc, 0x0e,
	0x95, 0xfb, 0x3c, 0x71, 0x70, 0x0c, 0xc9, 0xca, 0xa3, 0x93, 0xe1, 0x9b, 0x12, 0x42, 0xd3, 0x28,
	0xda, 0xba, 0x75, 0x23, 0x23, 0x92, 0xa6, 0x33, 0xa2, 0x29, 0x19, 0x08, 0x33, 0x24, 0xb3, 0x0f,
	0x85, 0x7d, 0x24, 0x4d, 0x68, 0x86, 0xd0, 0x0e, 0x20, 0xfd, 0x3f, 0xd2, 0x0d, 0xd7, 0xc1, 0xfa,
	0x29, 0xe9, 0x49, 0x24, 0x18, 0x51, 0xb7, 0x9c, 0x9e, 0x9e, 0x04, 0xbd, 0xac, 0x99, 0x29, 0x25,
	0x18, 0x85, 0x52, 0xbf, 0xec, 0xfd, 0x45, 0x99, 0xb1, 0xac, 0x86, 0x22, 0x8a, 0x82, 0x87, 0x56,
	0xcc, 0xa3, 0x23, 0x39, 0x5a, 0x13, 0x91, 0xfb, 0x3c, 0x3a, 0x82, 0xe3, 0xa1, 0x24, 0xb1, 0x6f,
	0x0b, 0x3f, 0x0e, 0x79, 0xe6, 0x70, 0x59, 0x92, 0x02, 0x39, 0xab, 0x30, 0x5e, 0x65, 0x4b, 0x87,
	0x3c, 0x74, 0x48, 0x6d, 0xb4, 0x7e, 0xe0, 0x1e, 0xec, 0x0b, 0xc5, 0x31, 0x1d, 0xa8, 0xc0, 0x81,
	0xbf, 0x87, 0x30, 0xd0, 0x46, 0xc1, 0x20, 0xce, 0xd3, 0xd2, 0xc1, 0xeb, 0x40, 0x85, 0x4e, 0x8b,
	0xe6, 0x25, 0x7e, 0x06, 0xb9, 0x39, 0x24, 0xf7, 0xcc, 0xd3, 0x17, 0x10, 0x06, 0xaa, 0xae, 0xeb,
	0xbb, 0xb1, 0xc5, 0x3d, 0x95, 0x26, 0x52, 0x87, 0xf2, 0xb6, 0xe7, 0x65, 0xb3, 0x44, 0x63, 0xae,
	0xae, 0xcd, 0x52, 0xd9, 0xe0, 0x54, 0x8d, 0x6a, 0x72, 0x43, 0xab, 0x06, 0x45, 0xb9, 0xff, 0xb8,
	0xac, 0x6f, 0xd0, 0xf5, 0x59, 0x1b, 0xf4, 0x22, 0x6b, 0x04, 0x23, 0x6d, 0x7b, 0xaa, 0x66, 0x3d,
	0x18, 0x91, 0x62, 0x9f, 0x4b, 0x7c, 0xaa, 0x14, 0x12, 0x9f, 0x2e, 0xb1, 0xd6, 0x20, 0x08, 0x6d,
	0x21, 0x65, 0xeb, 0x9c, 0xcc, 0x40, 0x00, 0x88, 0x44, 0xeb, 0x3b, 0x4a, 0xf0, 0xe4, 0xf2, 0xbc,
	0x26, 0x19, 0x89, 0xf0, 0x81, 0x98, 0x9c, 0x15, 0xa6, 0x77, 0x2b, 0xb6, 0xa4, 0x8b, 0xab, 0x97,
	0xb0, 0x79, 0xbd, 0x12, 0xb8, 0xd8, 0x89, 0x07, 0x41, 0x38, 0xe4, 0xb1, 0xd4, 0x25, 0x68, 0x46,
	0x6d, 0x85, 0x92, 0x3a, 0x51, 0xd0, 0x37, 0xca, 0x63, 0xfa, 0xc6, 0xc5, 0x5c, 0xee, 0x98, 0x74,
	0x4b, 0xa7, 0x79, 0x61, 0xfd, 0x7f, 0x6e, 0xea, 0x6b, 0xb8, 0xf1, 0x94, 0xb6, 0x7f, 0x35, 0x67,
	0xfb, 0xaf, 0x66, 0x76, 0xae, 0xee, 0x04, 0x57, 0x62, 0x97, 0x54, 0x84, 0x33, 0x3a, 0x08, 0xe0,
	0x53, 0x26, 0x3a, 0x08, 0x7e, 0xa5, 0xe0, 0x01, 0xa8, 0x4e, 0xb5, 0x3f, 0xb1, 0x0b, 0x69, 0xf9,
	0x78, 0x22, 0x9c, 0xe0, 0x04, 0xc8, 0x0c, 0xc5, 0x9a, 0x6e, 0x28, 0xf6, 0xfe, 0x3a, 0xe7, 0x26,
	0x92, 0xa6, 0x1a, 0x8e, 0xb6, 0x9c, 0x9a, 0x6a, 0xd8, 0xc1, 0x32, 0xab, 0x92, 0x99, 0x26, 0x1d,
	0xc9, 0x58, 0x80, 0xeb, 0x61, 0x9f, 0x87, 0x76, 0xe0, 0x28, 0xb9, 0xad, 0x8a, 0x98, 0x32, 0x16,
	0x24, 0x69, 0xfc, 0x81, 0x0a, 0x80, 0xea, 0x8e, 0x6f, 0x2a, 0x00, 0x4a, 0xfe, 0x62, 0xa9, 0xb9,
	0x62, 0xc1, 0x78, 0x99, 0x75, 0x48, 0x4b, 0x09, 0x7c, 0x2b, 0xf7, 0xed, 0x6d, 0x84, 0x77, 0x7d,
	0xa9, 0x07, 0x5d, 0x64, 0x0c, 0xd4, 0x62, 0x49, 0x22, 0x4f, 0x56, 0x98, 0xa8, 0xea, 0xf3, 0xac,
	0x26, 0xd5, 0x16, 0x3a, 0x55, 0xb2, 0x54, 0xcc, 0x01, 0x6a, 0x16, 0x73, 0x80, 0x0a, 0xfe, 0x19,
	0x56, 0xf0, 0xcf, 0xf4, 0xfe, 0x7b, 0x8e, 0x75, 0x0a, 0x4b, 0x3e, 0xee, 0xfe, 0x28, 0x4d, 0x71,
	0x7f, 0x9c, 0xea, 0x5c, 0xd2, 0x7a, 0x52, 0xcb, 0x58, 0xec, 0xc9, 0xc4, 0x15, 0xd5, 0x38, 0x51,
	0x5f, 0x59, 0x45, 0x44, 0x31, 0x85, 0x57, 0x19, 0xf9, 0xec, 0xa5, 0xda, 0xa7, 0x2f, 0x76, 0x07,
	0x2b, 0x70, 0xc6, 0xe4, 0x9a, 0x7f, 0x95, 0x91, 0xbf, 0x3e, 0x47, 0x2b, 0x63, 0xdf, 0x58, 0xa1,
	0xd1, 0x4e, 0x53, 0x28, 0xeb, 0x33, 0x15, 0xca, 0x71, 0xfd, 0xb6, 0xf1, 0x34, 0xfa, 0x6d, 0x73,
	0xaa, 0x7e, 0x3b, 0xae, 0xa9, 0xb2, 0x69, 0x9a, 0xea, 0x6a, 0x31, 0x03, 0x6c, 0x92, 0xbe, 0x99,
	0xe7, 0x80, 0xf9, 0xa2, 0x87, 0x2e, 0xa7, 0xed, 0xb6, 0x67, 0x69, 0xbb, 0x0b, 0x05, 0x6d, 0xb7,
	0xa8, 0xc8, 0x76, 0x4e, 0x57, 0x64, 0x17, 0xc7, 0x53, 0x92, 0xfe, 0xea, 0x82, 0x9e, 0x92, 0xb4,
	0x39, 0x4b, 0xa0, 0x69, 0x5c, 0xa2, 0x07, 0xb1, 0xe6, 0xb3, 0x15, 0x0f, 0xe3, 0xb3, 0x09, 0xb5,
	0x0b, 0x45, 0xa1, 0x56, 0xd5, 0x24, 0xd6, 0x03, 0xb6, 0xa4, 0xdf, 0xd2, 0x4a, 0x6c, 0x81, 0xe4,
	0x7b, 0x65, 0x9a, 0x55, 0xb6, 0x53, 0x6c, 0x60, 0x2e, 0xea, 0x7d, 0xa0, 0xf0, 0xf9, 0x80, 0x2d,
	0xed, 0x17, 0x8d, 0x37, 0x74, 0x8b, 0xcc, 0xe8, 0x77, 0xcc, 0xda, 0x33, 0x3b, 0xd0, 0xc7, 0x9e,
	0x26, 0x14, 0xef, 0xb2, 0x85, 0xc4, 0x3f, 0xf2, 0x83, 0x13, 0x45, 0x27, 0x93, 0x8a, 0x5e, 0x9e,
	0xd6, 0xe7, 0x07, 0x39, 0x6a, 0xb3, 0x4d, 0xad, 0x65, 0x97, 0xc6, 0xaf, 0xb2, 0xe7, 0x78, 0x14,
	0xb9, 0xd4, 0x20, 0xfb, 0x4e, 0xca, 0x34, 0xfa, 0xe6, 0xb4, 0x3e, 0xb7, 0xc7, 0x9b, 0x98, 0x4b,
	0xd4, 0x8f, 0xfe, 0xad, 0xf7, 0xc6, 0x73, 0x0f, 0x9a, 0x53, 0xef, 0x03, 0xec, 0x78, 0x2f, 0x4f,
	0x5e, 0x4c, 0x50, 0xd0, 0x45, 0x0c, 0x45, 0xbe, 0xd9, 0x98, 0x88, 0xd9, 0x06, 0xbc, 0xf7, 0x8f,
	0x75, 0xb6, 0x34, 0xb6, 0x4b, 0x78, 0x82, 0x34, 0x0b, 0xb9, 0xa4, 0x9d, 0xa0, 0xcc, 0x4a, 0xde,
	0xcb, 0xc9, 0x66, 0xd2, 0x16, 0xb7, 0xce, 0xcc, 0x09, 0x6b, 0x66, 0xda, 0x56, 0x97, 0xe8, 0x0f,
	0x58, 0x0b, 0xb4, 0x24, 0xd5, 0x6b, 0x05, 0x7b, 0xbd, 0x71, 0xf6, 0x5e, 0xb7, 0xb3, 0xc6, 0x26,
	0x83, 0x9e, 0x64, 0xbf, 0xfb, 0x0c, 0x35, 0xc4, 0x13, 0x1e, 0x8a, 0x2c, 0xd3, 0x06, 0xfa, 0x7e,
	0xfd, 0xec, 0x7d, 0xbf, 0x9b, 0xef, 0xc0, 0x5c, 0x50, 0x3d, 0x66, 0x42, 0x2d, 0xcf, 0x72, 0x39,
	0xf7, 0xbf, 0x91, 0x63, 0x28, 0x5a, 0xc2, 0xa9, 0x71, 0xc4, 0xda, 0xf4, 0x38, 0x62, 0xef, 0x2f,
	0x4b, 0x8c, 0x65, 0x8b, 0x07, 0xd7, 0x74, 0x30, 0x18, 0x60, 0x8c, 0x4c, 0x5a, 0x71, 0xb2, 0x78,
	0x86, 0xb4, 0xd2, 0x34, 0xd6, 0x19, 0xf8, 0x96, 0xf6, 0xf8, 0xa1, 0x25, 0x31, 0x3c, 0xf7, 0x97,
	0x98, 0x6c, 0x61, 0x1d, 0x8c, 0xc2, 0x48, 0xe9, 0x8e, 0x04, 0xbd, 0x33, 0x0a, 0x51, 0xc5, 0x53,
	0xc3, 0x24, 0x71, 0x60, 0x1f, 0x1e, 0xa9, 0x94, 0x0f, 0x39, 0x10, 0x81, 0xbd, 0x9f, 0x94, 0x58,
	0x4b, 0xdb, 0x1d, 0x30, 0xa9, 0x73, 0xf2, 0x04, 0xb7, 0x5d, 0x57, 0x11, 0x9f, 0xd7, 0xab, 0xa1,
	0x25, 0x69, 0x82, 0xdf, 0xca, 0xe2, 0x02, 0x5a, 0x13, 0x9a, 0x9b, 0x72, 0xc2, 0x67, 0xd4, 0xd7,
	0xd8, 0x22, 0xdc, 0x5b, 0x56, 0xe0, 0x07, 0x83, 0x81, 0xa4, 0x95, 0xe1, 0x7b, 0xc0, 0x77, 0x01,
	0x46, 0xca, 0xde, 0xdf, 0x97, 0x58, 0xa7, 0xb0, 0xc3, 0xb0, 0x3c, 0x64, 0x39, 0xe4, 0x3e, 0xac,
	0x45, 0x18, 0x0d, 0xb0, 0xca, 0xda, 0x2a, 0x70, 0xaa, 0x7f, 0xc9, 0xbc, 0x04, 0x53, 0xed, 0x75,
	0x10, 0xf2, 0x61, 0x6e, 0xfc, 0x26, 0x20, 0x54, 0x7d, 0x95, 0x75, 0xb2, 0x28, 0x29, 0xd1, 0xc8,
	0x24, 0xf6, 0x14, 0x9e, 0xa8, 0x26, 0x57, 0x8b, 0x6a, 0x72, 0xef, 0x71, 0x9d, 0x2d, 0x8d, 0x09,
	0xc7, 0xbc, 0x6d, 0x50, 0x2a, 0xd8, 0x06, 0xd6, 0x44, 0x8f, 0xd4, 0x33, 0xf4, 0xe4, 0x15, 0x7c,
	0xd3, 0x95, 0x71, 0xdf, 0x74, 0xd1, 0xd7, 0x37, 0xf7, 0xec, 0x7c, 0x7d, 0x7b, 0xb9, 0xe7, 0x32,
	0xa4, 0x65, 0x6f, 0x3d, 0x6d, 0xc7, 0xc5, 0x07, 0x34, 0x45, 0xaf, 0x52, 0x6d, 0xcc, 0xab, 0xd4,
	0xfb, 0xf7, 0xd2, 0x58, 0x1a, 0xf8, 0xb4, 0x34, 0x98, 0xf3, 0xac, 0xc6, 0x9d, 0xef, 0x27, 0x51,
	0xea, 0x6c, 0xa1, 0x12, 0x8c, 0xa2, 0xf2, 0xcc, 0xb5, 0xf0, 0x6c, 0x4b, 0x62, 0x18, 0x63, 0x79,
	0x91, 0x35, 0xfc, 0x40, 0x9e, 0x6e, 0xe2, 0x98, 0xba, 0x1f, 0xd0, 0xc9, 0x06, 0x53, 0x71, 0x30,
	0xb0, 0x50, 0x2e, 0x54, 0x53, 0xb9, 0x70, 0x47, 0xc9, 0x05, 0x31, 0x0a, 0x03, 0xc5, 0x8f, 0xf2,
	0xf3, 0x09, 0x23, 0x46, 0x2b, 0xf8, 0xad, 0x22, 0xe1, 0x47, 0x41, 0x28, 0xf5, 0x6f, 0xdd, 0x6f,
	0xb5, 0x87, 0x15, 0xbd, 0x1f, 0x96, 0x0a, 0x39, 0xf5, 0xd9, 0xd3, 0x0e, 0x7d, 0xc6, 0xf2, 0x69,
	0xc7, 0x58, 0xda, 0x7d, 0x79, 0x4a, 0xda, 0x7d, 0x65, 0x7a, 0xda, 0xfd, 0x5c, 0x31, 0xed, 0xfe,
	0x67, 0xa5, 0xaf, 0xe3, 0x25, 0x46, 0xe1, 0xed, 0xc4, 0xdc, 0xa9, 0x6f, 0x27, 0xaa, 0x63, 0x6f,
	0x27, 0x0a, 0x4f, 0x1e, 0x6a, 0xc5, 0x27, 0x0f, 0xbd, 0x98, 0x2d, 0xe4, 0x75, 0x91, 0xa2, 0x45,
	0x51, 0x1a, 0xb3, 0x28, 0xce, 0xfa, 0xae, 0x0c, 0xb9, 0x7c, 0xe2, 0xbb, 0xb2, 0xde, 0xcf, 0xca,
	0xec, 0xb9, 0x09, 0xea, 0xca, 0x6c, 0xd9, 0x31, 0x21, 0x9e, 0x50, 0x9e, 0x18, 0x4f, 0xf8, 0x60,
	0xc2, 0xab, 0xb5, 0x9b, 0x4f, 0xa1, 0x35, 0x9d, 0xf1, 0x20, 0xce, 0x8d, 0x1f, 0xc4, 0x51, 0x8e,
	0x2d, 0x0a, 0xe1, 0xb9, 0xd2, 0x58, 0x78, 0xee, 0x52, 0x3e, 0x3c, 0x57, 0x4e, 0x09, 0xd4, 0x4c,
	0x0a, 0x1c, 0x50, 0x19, 0xe3, 0x80, 0xde, 0x6f, 0x97, 0x33, 0x27, 0xe9, 0x28, 0xd5, 0xc7, 0x3a,
	0x91, 0x7b, 0xe0, 0x73, 0xcf, 0x8a, 0xe2, 0x50, 0xf8, 0x07, 0xf1, 0xa1, 0x3c, 0x12, 0x0b, 0x04,
	0xef, 0x49, 0x14, 0xb8, 0x53, 0xe6, 0xdf, 0xa8, 0x53, 0x21, 0x8b, 0x59, 0x08, 0xa8, 0xa2, 0x87,
	0x80, 0xbe, 0xcd, 0x8c, 0x24, 0x12, 0x83, 0xc4, 0xb3, 0x32, 0x5d, 0x21, 0x75, 0x30, 0x53, 0xcd,
	0x4e, 0x56, 0x01, 0xdf, 0xc1, 0xbd, 0x3c, 0x2d, 0x09, 0x87, 0x05, 0xee, 0xe5, 0x08, 0xf3, 0x1c,
	0x55, 0xfb, 0x22, 0x1c, 0xf5, 0x7f, 0xf1, 0x41, 0x58, 0xff, 0xf7, 0xeb, 0xba, 0x23, 0xea, 0xf5,
	0x53, 0x1e, 0x63, 0x68, 0xe9, 0xe1, 0x32, 0x35, 0x27, 0x4b, 0x0d, 0x9f, 0x68, 0x6f, 0x55, 0xbe,
	0xbc, 0xbd, 0xb5, 0xca, 0x5a, 0x28, 0xf6, 0x2d, 0xca, 0x1d, 0xd4, 0xdc, 0xe9, 0x08, 0xef, 0x60,
	0x12, 0xe1, 0xaf, 0x67, 0xf6, 0x39, 0x49, 0x70, 0x79, 0xc9, 0xd0, 0x05, 0xfa, 0xad, 0x49, 0x6e,
	0xaa, 0xf1, 0xf7, 0x9f, 0xd4, 0x26, 0xb5, 0xe6, 0x49, 0xee, 0xd3, 0xed, 0x74, 0x4f, 0xd7, 0x78,
	0xf8, 0x48, 0xbd, 0xcb, 0x99, 0xe2, 0x01, 0x83, 0xae, 0xdf, 0xcc, 0x93, 0x6b, 0xaa, 0xd1, 0x36,
	0x94, 0xc1, 0x8c, 0x44, 0xf7, 0x16, 0x45, 0xdf, 0x42, 0x11, 0xc1, 0x05, 0x52, 0x9f, 0xba, 0x5c,
	0xf4, 0xb9, 0xc5, 0x06, 0x66, 0x27, 0x12, 0xf1, 0x5b, 0x88, 0x98, 0x08, 0xf4, 0xfe, 0xb0, 0xcc,
	0x96, 0x27, 0xcd, 0x6a, 0x92, 0x4c, 0xce, 0xbb, 0x11, 0x8b, 0xfc, 0x5e, 0x1e, 0xe7, 0xf7, 0x71,
	0xd5, 0xab, 0xf2, 0xd5, 0x06, 0x51, 0x9f, 0x9d, 0x62, 0xd5, 0xdb, 0x65, 0x9d, 0xc2, 0x96, 0x00,
	0x43, 0x47, 0xee, 0xd0, 0xf2, 0x93, 0xe1, 0xbe, 0x4c, 0x15, 0xa9, 0x98, 0xcd, 0xc8, 0x1d, 0xbe,
	0x8f, 0x00, 0xba, 0xc1, 0x0f, 0x85, 0x7d, 0x64, 0xa5, 0x2e, 0xc5, 0xa6, 0xd9, 0x44, 0x64, 0x27,
	0x70, 0x44, 0xef, 0x43, 0xb6, 0x34, 0xb6, 0x1f, 0xa7, 0xc7, 0x53, 0x57, 0x29, 0x57, 0x24, 0x4a,
	0x6c, 0x5b, 0x44, 0xfa, 0xc3, 0x14, 0x16, 0x89, 0x78, 0x8f, 0xd0, 0xfe, 0x7f, 0xe9, 0x39, 0xa3,
	0xaf, 0xed, 0x7f, 0x29, 0xef, 0xb0, 0x7a, 0x04, 0x95, 0xcb, 0x8f, 0xa6, 0xec, 0x19, 0xb0, 0xe8,
	0x2c, 0x3d, 0xff, 0x1d, 0x8f, 0x2c, 0xad, 0xf9, 0xc4, 0x2d, 0xdd, 0xc7, 0x30, 0x0a, 0x26, 0x5b,
	0x6b, 0xe7, 0x36, 0xdf, 0x5e, 0xcb, 0x9c, 0x87, 0xe3, 0xdb, 0xfb, 0xd3, 0x0a, 0xbb, 0x7c, 0x5a,
	0x9b, 0x49, 0xe9, 0xf5, 0xa5, 0x89, 0xe9, 0xf5, 0x67, 0x7c, 0x8c, 0x73, 0x91, 0x35, 0x4e, 0x84,
	0x38, 0xb2, 0x22, 0x11, 0x6b, 0xce, 0xca, 0x3a, 0x60, 0x7b, 0x22, 0x9e, 0x94, 0xa4, 0x3f, 0x77,
	0x6a, 0x92, 0x7e, 0xb5, 0x90, 0xa4, 0x7f, 0x5e, 0xbe, 0xa0, 0xa9, 0xa5, 0xfd, 0xd3, 0x2b, 0x1a,
	0x3d, 0x45, 0xbf, 0x9e, 0x4f, 0xd1, 0xb7, 0xb2, 0x14, 0x7d, 0x72, 0xc4, 0xdc, 0xfe, 0xa2, 0xab,
	0x8c, 0x69, 0xfa, 0x29, 0xa4, 0xd2, 0xfc, 0x7b, 0x6f, 0xb0, 0x76, 0xae, 0x02, 0x74, 0xf5, 0x43,
	0xee, 0x3b, 0x9e, 0x62, 0x45, 0x59, 0x4a, 0x13, 0xf2, 0xcb, 0x5a, 0x42, 0xfe, 0x8f, 0xf4, 0x84,
	0xed, 0x81, 0x38, 0xc5, 0x85, 0x97, 0x7d, 0x8f, 0x3d, 0x74, 0x94, 0x11, 0x99, 0x82, 0x3b, 0x43,
	0x07, 0x83, 0x38, 0xa0, 0x09, 0xe7, 0x58, 0x8f, 0x21, 0x44, 0xbc, 0xb7, 0x9a, 0xe7, 0x5d, 0x4d,
	0xb2, 0x67, 0xfc, 0xdb, 0x7f, 0xac, 0x87, 0x03, 0x5f, 0x9b, 0xf9, 0x5f, 0x09, 0x5f, 0xeb, 0x4b,
	0xad, 0xf4, 0x8d, 0x46, 0xad, 0xf8, 0x46, 0x43, 0x67, 0xbe, 0xfa, 0x99, 0x98, 0xaf, 0x31, 0x89,
	0xf9, 0x74, 0x3e, 0x6a, 0x4e, 0x7d, 0xea, 0xc1, 0x66, 0x3d, 0xf5, 0x68, 0x4d, 0x7d, 0xea, 0x01,
	0x0b, 0xf9, 0xf5, 0x3d, 0xf5, 0xf8, 0x9b, 0x9a, 0xbe, 0x87, 0xa7, 0xbd, 0xf5, 0xc8, 0xd6, 0xbc,
	0x3c, 0xe5, 0x75, 0x5c, 0x45, 0x7b, 0xb4, 0x76, 0x81, 0x35, 0xa1, 0x27, 0xfd, 0x7d, 0x2a, 0xac,
	0x1b, 0x71, 0x58, 0x9f, 0xb5, 0xb9, 0xe3, 0xc0, 0x4a, 0x27, 0x23, 0x27, 0x53, 0x1e, 0x5b, 0xdc,
	0x71, 0x76, 0xc3, 0x0f, 0x10, 0x32, 0xbe, 0x37, 0x26, 0x01, 0xc9, 0x99, 0xbb, 0x39, 0x69, 0xd9,
	0xec, 0xa2, 0xd2, 0x32, 0x5b, 0xf8, 0x3d, 0x9e, 0x63, 0x17, 0x66, 0x90, 0x4f, 0xe0, 0xd8, 0xd2,
	0x24, 0x8e, 0xd5, 0x59, 0xa1, 0x9c, 0x67, 0x85, 0x67, 0x26, 0xe9, 0x52, 0x8e, 0xaa, 0x8e, 0x71,
	0xd4, 0xfd, 0x8c, 0xa3, 0x48, 0xe9, 0x79, 0xe3, 0x0b, 0x2c, 0x4d, 0x91, 0xdb, 0x54, 0xaf, 0x5b,
	0xb7, 0x6e, 0x48, 0xb5, 0xe7, 0x0b, 0xf7, 0xba, 0x75, 0xeb, 0x06, 0xf6, 0xba, 0x75, 0xeb, 0xc6,
	0x57, 0xc6, 0xc3, 0xbd, 0x13, 0xea, 0x78, 0xeb, 0xd6, 0x0d, 0xa3, 0xc7, 0x1a, 0x69, 0x8e, 0x83,
	0x4c, 0x20, 0x51, 0x65, 0x7c, 0xe3, 0x82, 0x89, 0x0d, 0xb2, 0x43, 0x2c, 0xa0, 0x5a, 0x00, 0x97,
	0xb0, 0x47, 0xa6, 0x94, 0xca, 0xd6, 0xe7, 0x31, 0xbf, 0x43, 0x66, 0x94, 0x7a, 0x8b, 0x0c, 0xab,
	0x31, 0x87, 0x9a, 0x06, 0xbe, 0x45, 0xde, 0xba, 0x75, 0xa3, 0xff, 0x5b, 0xb9, 0x77, 0x71, 0x83,
	0x67, 0x7a, 0x78, 0xf2, 0x09, 0x14, 0x73, 0x53, 0xad, 0x26, 0x18, 0x76, 0x72, 0x02, 0x85, 0xe6,
	0x25, 0xaa, 0xe6, 0x82, 0xb9, 0xff, 0x54, 0xca, 0x25, 0x56, 0x60, 0xe2, 0x3e, 0x96, 0xec, 0x24,
	0x4b, 0xfa, 0x87, 0x4e, 0xec, 0x84, 0x12, 0xf7, 0xc9, 0x7d, 0x3f, 0x1c, 0x66, 0x49, 0xff, 0xe8,
	0xb9, 0x1f, 0x0e, 0x8d, 0x57, 0xd9, 0x12, 0x66, 0x32, 0x0c, 0xed, 0xc4, 0x52, 0x2e, 0x6c, 0x95,
	0x46, 0x01, 0x15, 0x77, 0xed, 0x44, 0x39, 0x42, 0xd3, 0xac, 0x87, 0x90, 0xa7, 0x1e, 0x26, 0x28,
	0x9b, 0x1c, 0x9f, 0xe7, 0xff, 0x40, 0x84, 0x81, 0x25, 0x44, 0x18, 0x0c, 0x55, 0x8e, 0x3b, 0x20,
	0x6f, 0x03, 0x90, 0x56, 0xeb, 0x2f, 0xbe, 0xb1, 0x1a, 0x45, 0xc9, 0x9b, 0x37, 0x3f, 0xfe, 0x74,
	0xe5, 0xdc, 0x27, 0x9f, 0xae, 0x9c, 0xfb, 0xfc, 0xd3, 0x95, 0xd2, 0x0f, 0x9f, 0xac, 0x94, 0xfe,
	0xec, 0xc9, 0x4a, 0xe9, 0x1f, 0x9e, 0xac, 0x94, 0x3e, 0x7e, 0xb2, 0x52, 0xfa, 0xd7, 0x27, 0x2b,
	0xa5, 0x7f, 0x7b, 0xb2, 0x72, 0xee, 0xf3, 0x27, 0x2b, 0xa5, 0xdf, 0xfb, 0x6c, 0xe5, 0xdc, 0xc7,
	0x9f, 0xad, 0x9c, 0xfb, 0xe4, 0xb3, 0x95, 0x73, 0xef, 0x96, 0xf6, 0x6b, 0xf8, 0xdf, 0x3f, 0x9b,
	0xff, 0x13, 0x00, 0x00, 0xff, 0xff, 0x15, 0x1c, 0x0a, 0x85, 0x11, 0x48, 0x00, 0x00,
}

func (this *WlstSluF400) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSluF400)
	if !ok {
		that2, ok := that.(WlstSluF400)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CmdIdx != that1.CmdIdx {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.Remark != that1.Remark {
		return false
	}
	if this.SluitemAddr != that1.SluitemAddr {
		return false
	}
	return true
}
func (this *WlstSlu_3900) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_3900)
	if !ok {
		that2, ok := that.(WlstSlu_3900)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CmdIdx != that1.CmdIdx {
		return false
	}
	if !this.ModelInfo.Equal(that1.ModelInfo) {
		return false
	}
	if len(this.LightData) != len(that1.LightData) {
		return false
	}
	for i := range this.LightData {
		if !this.LightData[i].Equal(that1.LightData[i]) {
			return false
		}
	}
	if this.LeakageCurrent != that1.LeakageCurrent {
		return false
	}
	if !this.SluitemStatus.Equal(that1.SluitemStatus) {
		return false
	}
	if !this.TimeFault.Equal(that1.TimeFault) {
		return false
	}
	if this.ResetCount != that1.ResetCount {
		return false
	}
	if this.DateTime != that1.DateTime {
		return false
	}
	if !this.SluitemPara.Equal(that1.SluitemPara) {
		return false
	}
	if this.Rsrp != that1.Rsrp {
		return false
	}
	if this.Rssi != that1.Rssi {
		return false
	}
	if this.Snr != that1.Snr {
		return false
	}
	if this.Pci != that1.Pci {
		return false
	}
	if this.Rsrq != that1.Rsrq {
		return false
	}
	if this.Txpower != that1.Txpower {
		return false
	}
	if this.Earfcn != that1.Earfcn {
		return false
	}
	if this.Ecl != that1.Ecl {
		return false
	}
	if this.Csq != that1.Csq {
		return false
	}
	if this.Reson != that1.Reson {
		return false
	}
	if this.Retry != that1.Retry {
		return false
	}
	if this.Sunrise != that1.Sunrise {
		return false
	}
	if this.Sunset != that1.Sunset {
		return false
	}
	return true
}
func (this *WlstSlu_3900_ModelInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_3900_ModelInfo)
	if !ok {
		that2, ok := that.(WlstSlu_3900_ModelInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SluitemLoop != that1.SluitemLoop {
		return false
	}
	if this.PowerSaving != that1.PowerSaving {
		return false
	}
	if this.HasLeakage != that1.HasLeakage {
		return false
	}
	if this.HasTemperature != that1.HasTemperature {
		return false
	}
	if this.HasTimer != that1.HasTimer {
		return false
	}
	if this.Model != that1.Model {
		return false
	}
	if this.SluitemType != that1.SluitemType {
		return false
	}
	return true
}
func (this *WlstSlu_3900_LightData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_3900_LightData)
	if !ok {
		that2, ok := that.(WlstSlu_3900_LightData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Voltage != that1.Voltage {
		return false
	}
	if this.Current != that1.Current {
		return false
	}
	if this.ActivePower != that1.ActivePower {
		return false
	}
	if this.ReactivePower != that1.ReactivePower {
		return false
	}
	if this.ApparentPower != that1.ApparentPower {
		return false
	}
	if this.Electricity != that1.Electricity {
		return false
	}
	if this.ActiveTime != that1.ActiveTime {
		return false
	}
	if !this.LightStatus.Equal(that1.LightStatus) {
		return false
	}
	if this.PowerLevel != that1.PowerLevel {
		return false
	}
	if this.SluitemPowerTurnon != that1.SluitemPowerTurnon {
		return false
	}
	if this.RatedPower != that1.RatedPower {
		return false
	}
	return true
}
func (this *WlstSlu_3900_LightStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_3900_LightStatus)
	if !ok {
		that2, ok := that.(WlstSlu_3900_LightStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Leakage != that1.Leakage {
		return false
	}
	if this.Fault != that1.Fault {
		return false
	}
	if this.WorkingOn != that1.WorkingOn {
		return false
	}
	return true
}
func (this *WlstSlu_3900_SluitemStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_3900_SluitemStatus)
	if !ok {
		that2, ok := that.(WlstSlu_3900_SluitemStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.FlashFault != that1.FlashFault {
		return false
	}
	if this.EnableAlarm != that1.EnableAlarm {
		return false
	}
	return true
}
func (this *WlstSlu_3900_TimeFault) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_3900_TimeFault)
	if !ok {
		that2, ok := that.(WlstSlu_3900_TimeFault)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ClockFault != that1.ClockFault {
		return false
	}
	if this.ClockOutFault != that1.ClockOutFault {
		return false
	}
	if this.ClockOutAlarm != that1.ClockOutAlarm {
		return false
	}
	return true
}
func (this *WlstSlu_3900_SluitemPara) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_3900_SluitemPara)
	if !ok {
		that2, ok := that.(WlstSlu_3900_SluitemPara)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Longitude != that1.Longitude {
		return false
	}
	if this.Latitude != that1.Latitude {
		return false
	}
	if this.HasEnableAlarm != that1.HasEnableAlarm {
		return false
	}
	if this.IsRunning != that1.IsRunning {
		return false
	}
	if this.AlarmInterval != that1.AlarmInterval {
		return false
	}
	if this.UplinkReply != that1.UplinkReply {
		return false
	}
	return true
}
func (this *WlstSlu_7800) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_7800)
	if !ok {
		that2, ok := that.(WlstSlu_7800)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CmdIdx != that1.CmdIdx {
		return false
	}
	if this.EventType != that1.EventType {
		return false
	}
	if this.ClassType != that1.ClassType {
		return false
	}
	if this.RecordCount != that1.RecordCount {
		return false
	}
	if this.DtStart != that1.DtStart {
		return false
	}
	if this.DtEnd != that1.DtEnd {
		return false
	}
	return true
}
func (this *WlstSluF800) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSluF800)
	if !ok {
		that2, ok := that.(WlstSluF800)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CmdIdx != that1.CmdIdx {
		return false
	}
	if this.EventType != that1.EventType {
		return false
	}
	if this.ClassType != that1.ClassType {
		return false
	}
	if this.DataTotal != that1.DataTotal {
		return false
	}
	if this.DataIdx != that1.DataIdx {
		return false
	}
	if this.RecordCount != that1.RecordCount {
		return false
	}
	if len(this.View_0X20) != len(that1.View_0X20) {
		return false
	}
	for i := range this.View_0X20 {
		if !this.View_0X20[i].Equal(that1.View_0X20[i]) {
			return false
		}
	}
	if len(this.View_0X21) != len(that1.View_0X21) {
		return false
	}
	for i := range this.View_0X21 {
		if !this.View_0X21[i].Equal(that1.View_0X21[i]) {
			return false
		}
	}
	if len(this.View_0X22) != len(that1.View_0X22) {
		return false
	}
	for i := range this.View_0X22 {
		if !this.View_0X22[i].Equal(that1.View_0X22[i]) {
			return false
		}
	}
	if len(this.View_0X23) != len(that1.View_0X23) {
		return false
	}
	for i := range this.View_0X23 {
		if !this.View_0X23[i].Equal(that1.View_0X23[i]) {
			return false
		}
	}
	if len(this.View_0X24) != len(that1.View_0X24) {
		return false
	}
	for i := range this.View_0X24 {
		if !this.View_0X24[i].Equal(that1.View_0X24[i]) {
			return false
		}
	}
	if len(this.View_0X25) != len(that1.View_0X25) {
		return false
	}
	for i := range this.View_0X25 {
		if !this.View_0X25[i].Equal(that1.View_0X25[i]) {
			return false
		}
	}
	return true
}
func (this *WlstSluF800_View0X20) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSluF800_View0X20)
	if !ok {
		that2, ok := that.(WlstSluF800_View0X20)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DtHappen != that1.DtHappen {
		return false
	}
	if len(this.Status) != len(that1.Status) {
		return false
	}
	for i := range this.Status {
		if this.Status[i] != that1.Status[i] {
			return false
		}
	}
	return true
}
func (this *WlstSluF800_View0X21) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSluF800_View0X21)
	if !ok {
		that2, ok := that.(WlstSluF800_View0X21)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DtHappen != that1.DtHappen {
		return false
	}
	if this.OperationType != that1.OperationType {
		return false
	}
	if this.OperationOrder != that1.OperationOrder {
		return false
	}
	if this.AddrType != that1.AddrType {
		return false
	}
	if this.Addr != that1.Addr {
		return false
	}
	if this.OperationSource != that1.OperationSource {
		return false
	}
	return true
}
func (this *WlstSluF800_View0X23) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSluF800_View0X23)
	if !ok {
		that2, ok := that.(WlstSluF800_View0X23)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DtHappen != that1.DtHappen {
		return false
	}
	if this.Addr != that1.Addr {
		return false
	}
	if len(this.AlarmType) != len(that1.AlarmType) {
		return false
	}
	for i := range this.AlarmType {
		if this.AlarmType[i] != that1.AlarmType[i] {
			return false
		}
	}
	if len(this.SluitemStatus) != len(that1.SluitemStatus) {
		return false
	}
	for i := range this.SluitemStatus {
		if this.SluitemStatus[i] != that1.SluitemStatus[i] {
			return false
		}
	}
	if this.SluitemVoltage != that1.SluitemVoltage {
		return false
	}
	if len(this.SluitemCurrent) != len(that1.SluitemCurrent) {
		return false
	}
	for i := range this.SluitemCurrent {
		if this.SluitemCurrent[i] != that1.SluitemCurrent[i] {
			return false
		}
	}
	if len(this.SluitemActivePower) != len(that1.SluitemActivePower) {
		return false
	}
	for i := range this.SluitemActivePower {
		if this.SluitemActivePower[i] != that1.SluitemActivePower[i] {
			return false
		}
	}
	if len(this.SluitemReactivePower) != len(that1.SluitemReactivePower) {
		return false
	}
	for i := range this.SluitemReactivePower {
		if this.SluitemReactivePower[i] != that1.SluitemReactivePower[i] {
			return false
		}
	}
	if this.SluitemMaxVoltage != that1.SluitemMaxVoltage {
		return false
	}
	if len(this.SluitemMaxCurrent) != len(that1.SluitemMaxCurrent) {
		return false
	}
	for i := range this.SluitemMaxCurrent {
		if this.SluitemMaxCurrent[i] != that1.SluitemMaxCurrent[i] {
			return false
		}
	}
	if len(this.SluitemElectricity) != len(that1.SluitemElectricity) {
		return false
	}
	for i := range this.SluitemElectricity {
		if this.SluitemElectricity[i] != that1.SluitemElectricity[i] {
			return false
		}
	}
	if len(this.SluitemPhyinfo) != len(that1.SluitemPhyinfo) {
		return false
	}
	for i := range this.SluitemPhyinfo {
		if this.SluitemPhyinfo[i] != that1.SluitemPhyinfo[i] {
			return false
		}
	}
	return true
}
func (this *WlstSluEc00) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSluEc00)
	if !ok {
		that2, ok := that.(WlstSluEc00)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CmdIdx != that1.CmdIdx {
		return false
	}
	if this.StartIdx != that1.StartIdx {
		return false
	}
	if this.ReadCount != that1.ReadCount {
		return false
	}
	if len(this.WlstSlu_6B00) != len(that1.WlstSlu_6B00) {
		return false
	}
	for i := range this.WlstSlu_6B00 {
		if !this.WlstSlu_6B00[i].Equal(that1.WlstSlu_6B00[i]) {
			return false
		}
	}
	return true
}
func (this *WlstSlu_6B00) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_6B00)
	if !ok {
		that2, ok := that.(WlstSlu_6B00)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CmdIdx != that1.CmdIdx {
		return false
	}
	if this.SetIdx != that1.SetIdx {
		return false
	}
	if this.DtStart != that1.DtStart {
		return false
	}
	if this.DtEnd != that1.DtEnd {
		return false
	}
	if this.OperationType != that1.OperationType {
		return false
	}
	if this.OperationOrder != that1.OperationOrder {
		return false
	}
	if this.TimerOrOffset != that1.TimerOrOffset {
		return false
	}
	if this.AddrType != that1.AddrType {
		return false
	}
	if len(this.Addrs) != len(that1.Addrs) {
		return false
	}
	for i := range this.Addrs {
		if this.Addrs[i] != that1.Addrs[i] {
			return false
		}
	}
	if this.CmdType != that1.CmdType {
		return false
	}
	if len(this.CmdMix) != len(that1.CmdMix) {
		return false
	}
	for i := range this.CmdMix {
		if this.CmdMix[i] != that1.CmdMix[i] {
			return false
		}
	}
	if !this.CmdPwm.Equal(that1.CmdPwm) {
		return false
	}
	return true
}
func (this *WlstSlu_6B00_CmdPwm) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_6B00_CmdPwm)
	if !ok {
		that2, ok := that.(WlstSlu_6B00_CmdPwm)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.LoopCanDo) != len(that1.LoopCanDo) {
		return false
	}
	for i := range this.LoopCanDo {
		if this.LoopCanDo[i] != that1.LoopCanDo[i] {
			return false
		}
	}
	if this.Scale != that1.Scale {
		return false
	}
	if this.Rate != that1.Rate {
		return false
	}
	return true
}
func (this *WlstSlu_6C00) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_6C00)
	if !ok {
		that2, ok := that.(WlstSlu_6C00)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CmdIdx != that1.CmdIdx {
		return false
	}
	if this.StartIdx != that1.StartIdx {
		return false
	}
	if this.ReadCount != that1.ReadCount {
		return false
	}
	return true
}
func (this *WlstSluD000) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSluD000)
	if !ok {
		that2, ok := that.(WlstSluD000)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Ver != that1.Ver {
		return false
	}
	return true
}
func (this *WlstSlu_2800) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_2800)
	if !ok {
		that2, ok := that.(WlstSlu_2800)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.Alarm != that1.Alarm {
		return false
	}
	return true
}
func (this *WlstSlu_2400) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_2400)
	if !ok {
		that2, ok := that.(WlstSlu_2400)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DoFlag != that1.DoFlag {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	return true
}
func (this *WlstSlu_6E00) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_6E00)
	if !ok {
		that2, ok := that.(WlstSlu_6E00)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DoFlag != that1.DoFlag {
		return false
	}
	if this.PatrolStart != that1.PatrolStart {
		return false
	}
	if this.PatrolInterval != that1.PatrolInterval {
		return false
	}
	if this.PatrolOrder != that1.PatrolOrder {
		return false
	}
	if this.PatrolCount != that1.PatrolCount {
		return false
	}
	if this.CmdIdx != that1.CmdIdx {
		return false
	}
	return true
}
func (this *WlstSlu_3000) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_3000)
	if !ok {
		that2, ok := that.(WlstSlu_3000)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Ctrls != that1.Ctrls {
		return false
	}
	if this.DomainName != that1.DomainName {
		return false
	}
	if this.UpperVoltageLimit != that1.UpperVoltageLimit {
		return false
	}
	if this.LowerVoltageLimit != that1.LowerVoltageLimit {
		return false
	}
	if this.MacAddr != that1.MacAddr {
		return false
	}
	return true
}
func (this *WlstSlu_9A00) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_9A00)
	if !ok {
		that2, ok := that.(WlstSlu_9A00)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.DomainNameStatus) != len(that1.DomainNameStatus) {
		return false
	}
	for i := range this.DomainNameStatus {
		if this.DomainNameStatus[i] != that1.DomainNameStatus[i] {
			return false
		}
	}
	return true
}
func (this *WlstSluCd00) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSluCd00)
	if !ok {
		that2, ok := that.(WlstSluCd00)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CmdIdx != that1.CmdIdx {
		return false
	}
	if this.CommunicationFailures != that1.CommunicationFailures {
		return false
	}
	if this.PowerFactor != that1.PowerFactor {
		return false
	}
	if this.CommunicationChannel != that1.CommunicationChannel {
		return false
	}
	if this.CurrentRange != that1.CurrentRange {
		return false
	}
	if this.PowerRange != that1.PowerRange {
		return false
	}
	if this.AutoMode != that1.AutoMode {
		return false
	}
	if this.Longitude != that1.Longitude {
		return false
	}
	if this.Latitude != that1.Latitude {
		return false
	}
	if this.CarrierRoutingMode != that1.CarrierRoutingMode {
		return false
	}
	if this.BluetoothPin != that1.BluetoothPin {
		return false
	}
	if this.BluetoothMode != that1.BluetoothMode {
		return false
	}
	if this.Cct != that1.Cct {
		return false
	}
	if this.AlwaysOnline != that1.AlwaysOnline {
		return false
	}
	return true
}
func (this *WlstSlu_1C00) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_1C00)
	if !ok {
		that2, ok := that.(WlstSlu_1C00)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CmdIdx != that1.CmdIdx {
		return false
	}
	if this.SluitemIdx != that1.SluitemIdx {
		return false
	}
	if this.DomainName != that1.DomainName {
		return false
	}
	return true
}
func (this *WlstSlu_1D00) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_1D00)
	if !ok {
		that2, ok := that.(WlstSlu_1D00)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CmdIdx != that1.CmdIdx {
		return false
	}
	if this.SluitemIdx != that1.SluitemIdx {
		return false
	}
	if !this.DataMark.Equal(that1.DataMark) {
		return false
	}
	return true
}
func (this *WlstSlu_1D00_DataMark) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_1D00_DataMark)
	if !ok {
		that2, ok := that.(WlstSlu_1D00_DataMark)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ReadData != that1.ReadData {
		return false
	}
	if this.ReadTimer != that1.ReadTimer {
		return false
	}
	if this.ReadArgs != that1.ReadArgs {
		return false
	}
	if this.ReadGroup != that1.ReadGroup {
		return false
	}
	if this.ReadVer != that1.ReadVer {
		return false
	}
	if this.ReadSunriseset != that1.ReadSunriseset {
		return false
	}
	if this.ReadTimetable != that1.ReadTimetable {
		return false
	}
	if this.ReadCtrldata != that1.ReadCtrldata {
		return false
	}
	return true
}
func (this *WlstSlu_9D00) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_9D00)
	if !ok {
		that2, ok := that.(WlstSlu_9D00)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CmdIdx != that1.CmdIdx {
		return false
	}
	if this.SluitemIdx != that1.SluitemIdx {
		return false
	}
	if !this.DataMark.Equal(that1.DataMark) {
		return false
	}
	if this.LoopCount != that1.LoopCount {
		return false
	}
	if !this.SluitemData.Equal(that1.SluitemData) {
		return false
	}
	if this.SluitemTime != that1.SluitemTime {
		return false
	}
	if !this.SluitemPara.Equal(that1.SluitemPara) {
		return false
	}
	if len(this.SluitemGroup) != len(that1.SluitemGroup) {
		return false
	}
	for i := range this.SluitemGroup {
		if this.SluitemGroup[i] != that1.SluitemGroup[i] {
			return false
		}
	}
	if !this.SluitemVer.Equal(that1.SluitemVer) {
		return false
	}
	if !this.SluitemSunriseset.Equal(that1.SluitemSunriseset) {
		return false
	}
	if len(this.SluitemRuntime) != len(that1.SluitemRuntime) {
		return false
	}
	for i := range this.SluitemRuntime {
		if !this.SluitemRuntime[i].Equal(that1.SluitemRuntime[i]) {
			return false
		}
	}
	if !this.SluitemDataNew.Equal(that1.SluitemDataNew) {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if !this.SetMark.Equal(that1.SetMark) {
		return false
	}
	if this.DataContinue != that1.DataContinue {
		return false
	}
	return true
}
func (this *WlstSlu_9D00_SetMark) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_9D00_SetMark)
	if !ok {
		that2, ok := that.(WlstSlu_9D00_SetMark)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SetTimer != that1.SetTimer {
		return false
	}
	if this.SetArgs != that1.SetArgs {
		return false
	}
	if this.SetGroup != that1.SetGroup {
		return false
	}
	if this.SetReset != that1.SetReset {
		return false
	}
	if this.SetControl != that1.SetControl {
		return false
	}
	return true
}
func (this *WlstSlu_9D00_SluitemData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_9D00_SluitemData)
	if !ok {
		that2, ok := that.(WlstSlu_9D00_SluitemData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Voltage != that1.Voltage {
		return false
	}
	if len(this.Current) != len(that1.Current) {
		return false
	}
	for i := range this.Current {
		if this.Current[i] != that1.Current[i] {
			return false
		}
	}
	if len(this.ActivePower) != len(that1.ActivePower) {
		return false
	}
	for i := range this.ActivePower {
		if this.ActivePower[i] != that1.ActivePower[i] {
			return false
		}
	}
	if len(this.ReactivePower) != len(that1.ReactivePower) {
		return false
	}
	for i := range this.ReactivePower {
		if this.ReactivePower[i] != that1.ReactivePower[i] {
			return false
		}
	}
	if this.MaxVoltage != that1.MaxVoltage {
		return false
	}
	if len(this.MaxCurrent) != len(that1.MaxCurrent) {
		return false
	}
	for i := range this.MaxCurrent {
		if this.MaxCurrent[i] != that1.MaxCurrent[i] {
			return false
		}
	}
	if len(this.TotalElectricity) != len(that1.TotalElectricity) {
		return false
	}
	for i := range this.TotalElectricity {
		if this.TotalElectricity[i] != that1.TotalElectricity[i] {
			return false
		}
	}
	if this.Temperature != that1.Temperature {
		return false
	}
	if this.LeakageCurrent != that1.LeakageCurrent {
		return false
	}
	if this.TimerError != that1.TimerError {
		return false
	}
	if !this.SluitemStatus.Equal(that1.SluitemStatus) {
		return false
	}
	if len(this.LightStatus) != len(that1.LightStatus) {
		return false
	}
	for i := range this.LightStatus {
		if !this.LightStatus[i].Equal(that1.LightStatus[i]) {
			return false
		}
	}
	if this.ResetCount != that1.ResetCount {
		return false
	}
	return true
}
func (this *WlstSlu_9D00_SluitemDataNew) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_9D00_SluitemDataNew)
	if !ok {
		that2, ok := that.(WlstSlu_9D00_SluitemDataNew)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Voltage) != len(that1.Voltage) {
		return false
	}
	for i := range this.Voltage {
		if this.Voltage[i] != that1.Voltage[i] {
			return false
		}
	}
	if len(this.Current) != len(that1.Current) {
		return false
	}
	for i := range this.Current {
		if this.Current[i] != that1.Current[i] {
			return false
		}
	}
	if len(this.ActivePower) != len(that1.ActivePower) {
		return false
	}
	for i := range this.ActivePower {
		if this.ActivePower[i] != that1.ActivePower[i] {
			return false
		}
	}
	if len(this.RunTime) != len(that1.RunTime) {
		return false
	}
	for i := range this.RunTime {
		if this.RunTime[i] != that1.RunTime[i] {
			return false
		}
	}
	if this.Phase != that1.Phase {
		return false
	}
	if len(this.TotalElectricity) != len(that1.TotalElectricity) {
		return false
	}
	for i := range this.TotalElectricity {
		if this.TotalElectricity[i] != that1.TotalElectricity[i] {
			return false
		}
	}
	if this.LeakageCurrent != that1.LeakageCurrent {
		return false
	}
	if this.TimerError != that1.TimerError {
		return false
	}
	if !this.SluitemStatus.Equal(that1.SluitemStatus) {
		return false
	}
	if len(this.LightStatus) != len(that1.LightStatus) {
		return false
	}
	for i := range this.LightStatus {
		if !this.LightStatus[i].Equal(that1.LightStatus[i]) {
			return false
		}
	}
	if this.ResetCount != that1.ResetCount {
		return false
	}
	if len(this.EnergySaving) != len(that1.EnergySaving) {
		return false
	}
	for i := range this.EnergySaving {
		if this.EnergySaving[i] != that1.EnergySaving[i] {
			return false
		}
	}
	return true
}
func (this *WlstSlu_9D00_SluitemPara) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_9D00_SluitemPara)
	if !ok {
		that2, ok := that.(WlstSlu_9D00_SluitemPara)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DomainName != that1.DomainName {
		return false
	}
	if this.SluitemStatus != that1.SluitemStatus {
		return false
	}
	if this.SluitemEnableAlarm != that1.SluitemEnableAlarm {
		return false
	}
	if len(this.SluitemPowerTurnon) != len(that1.SluitemPowerTurnon) {
		return false
	}
	for i := range this.SluitemPowerTurnon {
		if this.SluitemPowerTurnon[i] != that1.SluitemPowerTurnon[i] {
			return false
		}
	}
	if len(this.SluitemVector) != len(that1.SluitemVector) {
		return false
	}
	for i := range this.SluitemVector {
		if this.SluitemVector[i] != that1.SluitemVector[i] {
			return false
		}
	}
	if this.Longitude != that1.Longitude {
		return false
	}
	if this.Latitude != that1.Latitude {
		return false
	}
	if len(this.RatedPower) != len(that1.RatedPower) {
		return false
	}
	for i := range this.RatedPower {
		if this.RatedPower[i] != that1.RatedPower[i] {
			return false
		}
	}
	if this.UplinkTimer != that1.UplinkTimer {
		return false
	}
	if this.UplinkReply != that1.UplinkReply {
		return false
	}
	return true
}
func (this *WlstSlu_9D00_SluitemVer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_9D00_SluitemVer)
	if !ok {
		that2, ok := that.(WlstSlu_9D00_SluitemVer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SluitemLoop != that1.SluitemLoop {
		return false
	}
	if this.EnergySaving != that1.EnergySaving {
		return false
	}
	if this.ElectricLeakageModule != that1.ElectricLeakageModule {
		return false
	}
	if this.TemperatureModule != that1.TemperatureModule {
		return false
	}
	if this.TimerModule != that1.TimerModule {
		return false
	}
	if this.SluitemType != that1.SluitemType {
		return false
	}
	if this.Ver != that1.Ver {
		return false
	}
	return true
}
func (this *WlstSlu_9D00_SluitemSunriseset) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_9D00_SluitemSunriseset)
	if !ok {
		that2, ok := that.(WlstSlu_9D00_SluitemSunriseset)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Sunrise != that1.Sunrise {
		return false
	}
	if this.Sunset != that1.Sunset {
		return false
	}
	return true
}
func (this *WlstSlu_9D00_SluitemRuntime) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_9D00_SluitemRuntime)
	if !ok {
		that2, ok := that.(WlstSlu_9D00_SluitemRuntime)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DataType != that1.DataType {
		return false
	}
	if this.OutputType != that1.OutputType {
		return false
	}
	if this.OperateType != that1.OperateType {
		return false
	}
	if len(this.DateEnable) != len(that1.DateEnable) {
		return false
	}
	for i := range this.DateEnable {
		if this.DateEnable[i] != that1.DateEnable[i] {
			return false
		}
	}
	if this.OperateTime != that1.OperateTime {
		return false
	}
	if this.OperateOffset != that1.OperateOffset {
		return false
	}
	if len(this.RelayOperate) != len(that1.RelayOperate) {
		return false
	}
	for i := range this.RelayOperate {
		if this.RelayOperate[i] != that1.RelayOperate[i] {
			return false
		}
	}
	if len(this.PwmLoop) != len(that1.PwmLoop) {
		return false
	}
	for i := range this.PwmLoop {
		if this.PwmLoop[i] != that1.PwmLoop[i] {
			return false
		}
	}
	if this.PwmPower != that1.PwmPower {
		return false
	}
	if this.PwmBaudrate != that1.PwmBaudrate {
		return false
	}
	if this.Rs485Baudrate != that1.Rs485Baudrate {
		return false
	}
	if this.Rs485Check != that1.Rs485Check {
		return false
	}
	return true
}
func (this *WlstSluF000) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSluF000)
	if !ok {
		that2, ok := that.(WlstSluF000)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CmdIdx != that1.CmdIdx {
		return false
	}
	if !this.ResetMark.Equal(that1.ResetMark) {
		return false
	}
	return true
}
func (this *WlstSluF000_ResetMark) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSluF000_ResetMark)
	if !ok {
		that2, ok := that.(WlstSluF000_ResetMark)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ClearTask != that1.ClearTask {
		return false
	}
	if this.ResetConcentrator != that1.ResetConcentrator {
		return false
	}
	if this.HardResetZigbee != that1.HardResetZigbee {
		return false
	}
	if this.SoftResetZigbee != that1.SoftResetZigbee {
		return false
	}
	if this.ResetCarrier != that1.ResetCarrier {
		return false
	}
	if this.InitAll != that1.InitAll {
		return false
	}
	if this.ClearData != that1.ClearData {
		return false
	}
	if this.ClearArgs != that1.ClearArgs {
		return false
	}
	return true
}
func (this *WlstSluF100) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSluF100)
	if !ok {
		that2, ok := that.(WlstSluF100)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CmdIdx != that1.CmdIdx {
		return false
	}
	if this.OptMark != that1.OptMark {
		return false
	}
	if this.DateTime != that1.DateTime {
		return false
	}
	if this.ForceTimer != that1.ForceTimer {
		return false
	}
	if !this.TimerStatus.Equal(that1.TimerStatus) {
		return false
	}
	return true
}
func (this *WlstSluF100_TimerStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSluF100_TimerStatus)
	if !ok {
		that2, ok := that.(WlstSluF100_TimerStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DtformatError != that1.DtformatError {
		return false
	}
	if this.TimerError != that1.TimerError {
		return false
	}
	if this.TimeFault != that1.TimeFault {
		return false
	}
	return true
}
func (this *WlstSluF200) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSluF200)
	if !ok {
		that2, ok := that.(WlstSluF200)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CmdIdx != that1.CmdIdx {
		return false
	}
	if this.SluitemIdx != that1.SluitemIdx {
		return false
	}
	if this.SluitemCount != that1.SluitemCount {
		return false
	}
	if !this.DataMark.Equal(that1.DataMark) {
		return false
	}
	if len(this.SluitemData) != len(that1.SluitemData) {
		return false
	}
	for i := range this.SluitemData {
		if !this.SluitemData[i].Equal(that1.SluitemData[i]) {
			return false
		}
	}
	if this.Status != that1.Status {
		return false
	}
	return true
}
func (this *WlstSluF200_DataMark) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSluF200_DataMark)
	if !ok {
		that2, ok := that.(WlstSluF200_DataMark)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SetData != that1.SetData {
		return false
	}
	if this.Group != that1.Group {
		return false
	}
	if this.Barcode != that1.Barcode {
		return false
	}
	if this.Route != that1.Route {
		return false
	}
	if this.Order != that1.Order {
		return false
	}
	if this.Limit != that1.Limit {
		return false
	}
	if this.PowerOnStatus != that1.PowerOnStatus {
		return false
	}
	if this.RunStatus != that1.RunStatus {
		return false
	}
	if this.Vector != that1.Vector {
		return false
	}
	if this.RatedPower != that1.RatedPower {
		return false
	}
	if this.LoopCount != that1.LoopCount {
		return false
	}
	return true
}
func (this *WlstSluF200_ControllerData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSluF200_ControllerData)
	if !ok {
		that2, ok := that.(WlstSluF200_ControllerData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.SluitemGroup) != len(that1.SluitemGroup) {
		return false
	}
	for i := range this.SluitemGroup {
		if this.SluitemGroup[i] != that1.SluitemGroup[i] {
			return false
		}
	}
	if this.SluitemIdx != that1.SluitemIdx {
		return false
	}
	if len(this.SluitemRoute) != len(that1.SluitemRoute) {
		return false
	}
	for i := range this.SluitemRoute {
		if this.SluitemRoute[i] != that1.SluitemRoute[i] {
			return false
		}
	}
	if this.SluitemOrder != that1.SluitemOrder {
		return false
	}
	if this.UpperPowerLimit != that1.UpperPowerLimit {
		return false
	}
	if this.LowerPowerLimit != that1.LowerPowerLimit {
		return false
	}
	if len(this.SluitemPowerTurnon) != len(that1.SluitemPowerTurnon) {
		return false
	}
	for i := range this.SluitemPowerTurnon {
		if this.SluitemPowerTurnon[i] != that1.SluitemPowerTurnon[i] {
			return false
		}
	}
	if this.SluitemStatus != that1.SluitemStatus {
		return false
	}
	if this.SluitemEnableAlarm != that1.SluitemEnableAlarm {
		return false
	}
	if len(this.SluitemVector) != len(that1.SluitemVector) {
		return false
	}
	for i := range this.SluitemVector {
		if this.SluitemVector[i] != that1.SluitemVector[i] {
			return false
		}
	}
	if len(this.RatedPower) != len(that1.RatedPower) {
		return false
	}
	for i := range this.RatedPower {
		if this.RatedPower[i] != that1.RatedPower[i] {
			return false
		}
	}
	if this.LoopCount != that1.LoopCount {
		return false
	}
	if this.Longitude != that1.Longitude {
		return false
	}
	if this.Latitude != that1.Latitude {
		return false
	}
	if this.UplinkTimer != that1.UplinkTimer {
		return false
	}
	if this.UplinkReply != that1.UplinkReply {
		return false
	}
	return true
}
func (this *WlstSlu_7300) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_7300)
	if !ok {
		that2, ok := that.(WlstSlu_7300)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CmdIdx != that1.CmdIdx {
		return false
	}
	if this.SluitemStart != that1.SluitemStart {
		return false
	}
	if this.SluitemCount != that1.SluitemCount {
		return false
	}
	if this.DataMark != that1.DataMark {
		return false
	}
	if !this.ConcentratorData.Equal(that1.ConcentratorData) {
		return false
	}
	if len(this.BaseSluitemData) != len(that1.BaseSluitemData) {
		return false
	}
	for i := range this.BaseSluitemData {
		if !this.BaseSluitemData[i].Equal(that1.BaseSluitemData[i]) {
			return false
		}
	}
	if len(this.UnknowSluitem) != len(that1.UnknowSluitem) {
		return false
	}
	for i := range this.UnknowSluitem {
		if !this.UnknowSluitem[i].Equal(that1.UnknowSluitem[i]) {
			return false
		}
	}
	if len(this.AssistSluitemData) != len(that1.AssistSluitemData) {
		return false
	}
	for i := range this.AssistSluitemData {
		if !this.AssistSluitemData[i].Equal(that1.AssistSluitemData[i]) {
			return false
		}
	}
	if len(this.SluitemPhyinfo) != len(that1.SluitemPhyinfo) {
		return false
	}
	for i := range this.SluitemPhyinfo {
		if !this.SluitemPhyinfo[i].Equal(that1.SluitemPhyinfo[i]) {
			return false
		}
	}
	if len(this.SluitemAddrs) != len(that1.SluitemAddrs) {
		return false
	}
	for i := range this.SluitemAddrs {
		if this.SluitemAddrs[i] != that1.SluitemAddrs[i] {
			return false
		}
	}
	return true
}
func (this *WlstSlu_7300_ConcentratorData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_7300_ConcentratorData)
	if !ok {
		that2, ok := that.(WlstSlu_7300_ConcentratorData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ResetCount) != len(that1.ResetCount) {
		return false
	}
	for i := range this.ResetCount {
		if this.ResetCount[i] != that1.ResetCount[i] {
			return false
		}
	}
	if !this.RunStatus.Equal(that1.RunStatus) {
		return false
	}
	if !this.ArgsStatus.Equal(that1.ArgsStatus) {
		return false
	}
	if !this.HardwareStatus.Equal(that1.HardwareStatus) {
		return false
	}
	if this.UnknowSluitemCount != that1.UnknowSluitemCount {
		return false
	}
	if this.CommunicationChannel != that1.CommunicationChannel {
		return false
	}
	return true
}
func (this *WlstSlu_7300_ConcentratorData_RunStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_7300_ConcentratorData_RunStatus)
	if !ok {
		that2, ok := that.(WlstSlu_7300_ConcentratorData_RunStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Offline != that1.Offline {
		return false
	}
	if this.EnableAlarm != that1.EnableAlarm {
		return false
	}
	if this.PoweronMark != that1.PoweronMark {
		return false
	}
	if this.EnableGprs != that1.EnableGprs {
		return false
	}
	if this.EnableAutochk != that1.EnableAutochk {
		return false
	}
	return true
}
func (this *WlstSlu_7300_ConcentratorData_ArgsStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_7300_ConcentratorData_ArgsStatus)
	if !ok {
		that2, ok := that.(WlstSlu_7300_ConcentratorData_ArgsStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ConcentratorArgsError != that1.ConcentratorArgsError {
		return false
	}
	if this.SluitemArgsError != that1.SluitemArgsError {
		return false
	}
	if this.TurnOnoffError != that1.TurnOnoffError {
		return false
	}
	return true
}
func (this *WlstSlu_7300_ConcentratorData_HardwareStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_7300_ConcentratorData_HardwareStatus)
	if !ok {
		that2, ok := that.(WlstSlu_7300_ConcentratorData_HardwareStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ZigbeeError != that1.ZigbeeError {
		return false
	}
	if this.CarrierError != that1.CarrierError {
		return false
	}
	if this.FramError != that1.FramError {
		return false
	}
	if this.BluetoothError != that1.BluetoothError {
		return false
	}
	if this.TimerError != that1.TimerError {
		return false
	}
	return true
}
func (this *WlstSlu_7300_BaseSluitemData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_7300_BaseSluitemData)
	if !ok {
		that2, ok := that.(WlstSlu_7300_BaseSluitemData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DateTime != that1.DateTime {
		return false
	}
	if !this.SluitemStatus.Equal(that1.SluitemStatus) {
		return false
	}
	if this.Temperature != that1.Temperature {
		return false
	}
	if len(this.LightStatus) != len(that1.LightStatus) {
		return false
	}
	for i := range this.LightStatus {
		if !this.LightStatus[i].Equal(that1.LightStatus[i]) {
			return false
		}
	}
	if len(this.LightData) != len(that1.LightData) {
		return false
	}
	for i := range this.LightData {
		if !this.LightData[i].Equal(that1.LightData[i]) {
			return false
		}
	}
	if this.SluitemLoop != that1.SluitemLoop {
		return false
	}
	return true
}
func (this *WlstSlu_7300_BaseSluitemData_SluitemStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_7300_BaseSluitemData_SluitemStatus)
	if !ok {
		that2, ok := that.(WlstSlu_7300_BaseSluitemData_SluitemStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.Adjust != that1.Adjust {
		return false
	}
	if this.WorkingArgs != that1.WorkingArgs {
		return false
	}
	if this.NoAlarm != that1.NoAlarm {
		return false
	}
	if this.OffLine != that1.OffLine {
		return false
	}
	if this.EepromError != that1.EepromError {
		return false
	}
	if this.TemperatureSensor != that1.TemperatureSensor {
		return false
	}
	return true
}
func (this *WlstSlu_7300_BaseSluitemData_LightStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_7300_BaseSluitemData_LightStatus)
	if !ok {
		that2, ok := that.(WlstSlu_7300_BaseSluitemData_LightStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PowerStatus != that1.PowerStatus {
		return false
	}
	if this.Leakage != that1.Leakage {
		return false
	}
	if this.Fault != that1.Fault {
		return false
	}
	if this.WorkingOn != that1.WorkingOn {
		return false
	}
	return true
}
func (this *WlstSlu_7300_BaseSluitemData_LightData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_7300_BaseSluitemData_LightData)
	if !ok {
		that2, ok := that.(WlstSlu_7300_BaseSluitemData_LightData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Voltage != that1.Voltage {
		return false
	}
	if this.Current != that1.Current {
		return false
	}
	if this.ActivePower != that1.ActivePower {
		return false
	}
	if this.Electricity != that1.Electricity {
		return false
	}
	if this.ActiveTime != that1.ActiveTime {
		return false
	}
	if this.PowerLevel != that1.PowerLevel {
		return false
	}
	return true
}
func (this *WlstSlu_7300_UnknowSluitem) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_7300_UnknowSluitem)
	if !ok {
		that2, ok := that.(WlstSlu_7300_UnknowSluitem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SluitemIdx != that1.SluitemIdx {
		return false
	}
	if !this.ModelInfo.Equal(that1.ModelInfo) {
		return false
	}
	return true
}
func (this *WlstSlu_7300_AssistSluitemData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_7300_AssistSluitemData)
	if !ok {
		that2, ok := that.(WlstSlu_7300_AssistSluitemData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DateTime != that1.DateTime {
		return false
	}
	if this.LeakageCurrent != that1.LeakageCurrent {
		return false
	}
	if len(this.LightData) != len(that1.LightData) {
		return false
	}
	for i := range this.LightData {
		if !this.LightData[i].Equal(that1.LightData[i]) {
			return false
		}
	}
	if this.SluitemLoop != that1.SluitemLoop {
		return false
	}
	return true
}
func (this *WlstSlu_7300_AssistSluitemData_LightData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_7300_AssistSluitemData_LightData)
	if !ok {
		that2, ok := that.(WlstSlu_7300_AssistSluitemData_LightData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MaxVoltage != that1.MaxVoltage {
		return false
	}
	if this.MaxCurrent != that1.MaxCurrent {
		return false
	}
	if this.Electricity != that1.Electricity {
		return false
	}
	return true
}
func (this *WlstSlu_7300_SluitemPhyinfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_7300_SluitemPhyinfo)
	if !ok {
		that2, ok := that.(WlstSlu_7300_SluitemPhyinfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SignalStrength != that1.SignalStrength {
		return false
	}
	if this.Routing != that1.Routing {
		return false
	}
	if this.Phase != that1.Phase {
		return false
	}
	if this.UsefulCommunicate != that1.UsefulCommunicate {
		return false
	}
	if this.AllCommunicate != that1.AllCommunicate {
		return false
	}
	if !this.ModelInfo.Equal(that1.ModelInfo) {
		return false
	}
	return true
}
func (this *WlstSlu_7300_ModelInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_7300_ModelInfo)
	if !ok {
		that2, ok := that.(WlstSlu_7300_ModelInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SluitemLoop != that1.SluitemLoop {
		return false
	}
	if this.PowerSaving != that1.PowerSaving {
		return false
	}
	if this.HasLeakage != that1.HasLeakage {
		return false
	}
	if this.HasTemperature != that1.HasTemperature {
		return false
	}
	if this.HasTimer != that1.HasTimer {
		return false
	}
	if this.Model != that1.Model {
		return false
	}
	if this.SluitemType != that1.SluitemType {
		return false
	}
	return true
}
func (this *WlstSluF900) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSluF900)
	if !ok {
		that2, ok := that.(WlstSluF900)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CmdIdx != that1.CmdIdx {
		return false
	}
	if this.AlarmType != that1.AlarmType {
		return false
	}
	if !this.ConcentratorData.Equal(that1.ConcentratorData) {
		return false
	}
	if len(this.ErrorCtrls) != len(that1.ErrorCtrls) {
		return false
	}
	for i := range this.ErrorCtrls {
		if this.ErrorCtrls[i] != that1.ErrorCtrls[i] {
			return false
		}
	}
	if len(this.SluitemStatusAlarm) != len(that1.SluitemStatusAlarm) {
		return false
	}
	for i := range this.SluitemStatusAlarm {
		if !this.SluitemStatusAlarm[i].Equal(that1.SluitemStatusAlarm[i]) {
			return false
		}
	}
	if !this.BluetoothApply.Equal(that1.BluetoothApply) {
		return false
	}
	if !this.SetDomainResult.Equal(that1.SetDomainResult) {
		return false
	}
	return true
}
func (this *WlstSluF900_SluitemStatusAlarm) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSluF900_SluitemStatusAlarm)
	if !ok {
		that2, ok := that.(WlstSluF900_SluitemStatusAlarm)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SluitemIdx != that1.SluitemIdx {
		return false
	}
	if this.SluitemLoop != that1.SluitemLoop {
		return false
	}
	if !this.SluitemStatus.Equal(that1.SluitemStatus) {
		return false
	}
	if len(this.LightStatus) != len(that1.LightStatus) {
		return false
	}
	for i := range this.LightStatus {
		if !this.LightStatus[i].Equal(that1.LightStatus[i]) {
			return false
		}
	}
	return true
}
func (this *WlstSluF900_BluetoothApply) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSluF900_BluetoothApply)
	if !ok {
		that2, ok := that.(WlstSluF900_BluetoothApply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SimNumber != that1.SimNumber {
		return false
	}
	if this.CheckCode != that1.CheckCode {
		return false
	}
	return true
}
func (this *WlstSluF900_SetDomainResult) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSluF900_SetDomainResult)
	if !ok {
		that2, ok := that.(WlstSluF900_SetDomainResult)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DomainName != that1.DomainName {
		return false
	}
	if len(this.SetSuccess) != len(that1.SetSuccess) {
		return false
	}
	for i := range this.SetSuccess {
		if this.SetSuccess[i] != that1.SetSuccess[i] {
			return false
		}
	}
	return true
}
func (this *WlstSlu_7B00) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_7B00)
	if !ok {
		that2, ok := that.(WlstSlu_7B00)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CmdIdx != that1.CmdIdx {
		return false
	}
	if this.SluitemIdx != that1.SluitemIdx {
		return false
	}
	if this.DataCount != that1.DataCount {
		return false
	}
	if len(this.OperationData) != len(that1.OperationData) {
		return false
	}
	for i := range this.OperationData {
		if !this.OperationData[i].Equal(that1.OperationData[i]) {
			return false
		}
	}
	return true
}
func (this *WlstSlu_7B00_ReadConcentratorOperationData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_7B00_ReadConcentratorOperationData)
	if !ok {
		that2, ok := that.(WlstSlu_7B00_ReadConcentratorOperationData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.OperationOrder != that1.OperationOrder {
		return false
	}
	if this.OperationType != that1.OperationType {
		return false
	}
	if len(this.WeekSet) != len(that1.WeekSet) {
		return false
	}
	for i := range this.WeekSet {
		if this.WeekSet[i] != that1.WeekSet[i] {
			return false
		}
	}
	if this.TimerOrOffset != that1.TimerOrOffset {
		return false
	}
	if this.AddrType != that1.AddrType {
		return false
	}
	if len(this.Addr) != len(that1.Addr) {
		return false
	}
	for i := range this.Addr {
		if this.Addr[i] != that1.Addr[i] {
			return false
		}
	}
	if this.CmdType != that1.CmdType {
		return false
	}
	if len(this.CmdMix) != len(that1.CmdMix) {
		return false
	}
	for i := range this.CmdMix {
		if !this.CmdMix[i].Equal(that1.CmdMix[i]) {
			return false
		}
	}
	return true
}
func (this *WlstSlu_7B00_ReadConcentratorOperationData_CmdOperation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_7B00_ReadConcentratorOperationData_CmdOperation)
	if !ok {
		that2, ok := that.(WlstSlu_7B00_ReadConcentratorOperationData_CmdOperation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Handle != that1.Handle {
		return false
	}
	if this.Rate != that1.Rate {
		return false
	}
	return true
}
func (this *WlstSluFe00) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSluFe00)
	if !ok {
		that2, ok := that.(WlstSluFe00)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CmdIdx != that1.CmdIdx {
		return false
	}
	if this.OperationCmd != that1.OperationCmd {
		return false
	}
	if this.FaultCount != that1.FaultCount {
		return false
	}
	if len(this.SluitemIdx) != len(that1.SluitemIdx) {
		return false
	}
	for i := range this.SluitemIdx {
		if this.SluitemIdx[i] != that1.SluitemIdx[i] {
			return false
		}
	}
	return true
}
func (this *WlstSlu_7400) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_7400)
	if !ok {
		that2, ok := that.(WlstSlu_7400)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CmdIdx != that1.CmdIdx {
		return false
	}
	if this.OperationType != that1.OperationType {
		return false
	}
	if this.OperationOrder != that1.OperationOrder {
		return false
	}
	if this.AddrType != that1.AddrType {
		return false
	}
	if len(this.Addrs) != len(that1.Addrs) {
		return false
	}
	for i := range this.Addrs {
		if this.Addrs[i] != that1.Addrs[i] {
			return false
		}
	}
	if len(this.WeekSet) != len(that1.WeekSet) {
		return false
	}
	for i := range this.WeekSet {
		if this.WeekSet[i] != that1.WeekSet[i] {
			return false
		}
	}
	if this.TimerOrOffset != that1.TimerOrOffset {
		return false
	}
	if this.CmdType != that1.CmdType {
		return false
	}
	if len(this.CmdMix) != len(that1.CmdMix) {
		return false
	}
	for i := range this.CmdMix {
		if this.CmdMix[i] != that1.CmdMix[i] {
			return false
		}
	}
	if !this.CmdPwm.Equal(that1.CmdPwm) {
		return false
	}
	return true
}
func (this *WlstSlu_7400_CmdPwm) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_7400_CmdPwm)
	if !ok {
		that2, ok := that.(WlstSlu_7400_CmdPwm)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.LoopCanDo) != len(that1.LoopCanDo) {
		return false
	}
	for i := range this.LoopCanDo {
		if this.LoopCanDo[i] != that1.LoopCanDo[i] {
			return false
		}
	}
	if this.Scale != that1.Scale {
		return false
	}
	if this.Rate != that1.Rate {
		return false
	}
	return true
}
func (this *WlstSlu_7C00) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_7C00)
	if !ok {
		that2, ok := that.(WlstSlu_7C00)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CmdIdx != that1.CmdIdx {
		return false
	}
	if this.AddrType != that1.AddrType {
		return false
	}
	if this.Addr != that1.Addr {
		return false
	}
	if this.CmdCount != that1.CmdCount {
		return false
	}
	if this.AddOrUpdate != that1.AddOrUpdate {
		return false
	}
	if len(this.OperationData) != len(that1.OperationData) {
		return false
	}
	for i := range this.OperationData {
		if !this.OperationData[i].Equal(that1.OperationData[i]) {
			return false
		}
	}
	return true
}
func (this *WlstSlu_7C00_ConcentratorOperationData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_7C00_ConcentratorOperationData)
	if !ok {
		that2, ok := that.(WlstSlu_7C00_ConcentratorOperationData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.OperationType != that1.OperationType {
		return false
	}
	if this.CmdType != that1.CmdType {
		return false
	}
	if len(this.WeekSet) != len(that1.WeekSet) {
		return false
	}
	for i := range this.WeekSet {
		if this.WeekSet[i] != that1.WeekSet[i] {
			return false
		}
	}
	if this.TimerOrOffset != that1.TimerOrOffset {
		return false
	}
	if len(this.CmdMix) != len(that1.CmdMix) {
		return false
	}
	for i := range this.CmdMix {
		if this.CmdMix[i] != that1.CmdMix[i] {
			return false
		}
	}
	if !this.CmdPwm.Equal(that1.CmdPwm) {
		return false
	}
	if !this.Cmd_485.Equal(that1.Cmd_485) {
		return false
	}
	return true
}
func (this *WlstSlu_7C00_ConcentratorOperationData_CmdPwm) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_7C00_ConcentratorOperationData_CmdPwm)
	if !ok {
		that2, ok := that.(WlstSlu_7C00_ConcentratorOperationData_CmdPwm)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.LoopCanDo) != len(that1.LoopCanDo) {
		return false
	}
	for i := range this.LoopCanDo {
		if this.LoopCanDo[i] != that1.LoopCanDo[i] {
			return false
		}
	}
	if this.Scale != that1.Scale {
		return false
	}
	if this.Rate != that1.Rate {
		return false
	}
	return true
}
func (this *WlstSlu_7C00_ConcentratorOperationData_Cmd_485) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_7C00_ConcentratorOperationData_Cmd_485)
	if !ok {
		that2, ok := that.(WlstSlu_7C00_ConcentratorOperationData_Cmd_485)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Baudrate != that1.Baudrate {
		return false
	}
	if this.Check != that1.Check {
		return false
	}
	if this.DataLength != that1.DataLength {
		return false
	}
	if this.Data_485 != that1.Data_485 {
		return false
	}
	return true
}
func (this *WlstSlu_6F00) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_6F00)
	if !ok {
		that2, ok := that.(WlstSlu_6F00)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CmdIdx != that1.CmdIdx {
		return false
	}
	if this.AddrType != that1.AddrType {
		return false
	}
	if this.Addr != that1.Addr {
		return false
	}
	if !this.ResetMark.Equal(that1.ResetMark) {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	return true
}
func (this *WlstSlu_6F00_ResetMark) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WlstSlu_6F00_ResetMark)
	if !ok {
		that2, ok := that.(WlstSlu_6F00_ResetMark)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ResetMcu != that1.ResetMcu {
		return false
	}
	if this.ResetComm != that1.ResetComm {
		return false
	}
	if this.InitMcuHardware != that1.InitMcuHardware {
		return false
	}
	if this.InitRam != that1.InitRam {
		return false
	}
	if this.ZeroEerom != that1.ZeroEerom {
		return false
	}
	if this.ZeroCount != that1.ZeroCount {
		return false
	}
	return true
}
func (this *WlstSluF400) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&wlst_pb2.WlstSluF400{")
	s = append(s, "CmdIdx: "+fmt.Sprintf("%#v", this.CmdIdx)+",\n")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "Remark: "+fmt.Sprintf("%#v", this.Remark)+",\n")
	s = append(s, "SluitemAddr: "+fmt.Sprintf("%#v", this.SluitemAddr)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_3900) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 26)
	s = append(s, "&wlst_pb2.WlstSlu_3900{")
	s = append(s, "CmdIdx: "+fmt.Sprintf("%#v", this.CmdIdx)+",\n")
	if this.ModelInfo != nil {
		s = append(s, "ModelInfo: "+fmt.Sprintf("%#v", this.ModelInfo)+",\n")
	}
	if this.LightData != nil {
		s = append(s, "LightData: "+fmt.Sprintf("%#v", this.LightData)+",\n")
	}
	s = append(s, "LeakageCurrent: "+fmt.Sprintf("%#v", this.LeakageCurrent)+",\n")
	if this.SluitemStatus != nil {
		s = append(s, "SluitemStatus: "+fmt.Sprintf("%#v", this.SluitemStatus)+",\n")
	}
	if this.TimeFault != nil {
		s = append(s, "TimeFault: "+fmt.Sprintf("%#v", this.TimeFault)+",\n")
	}
	s = append(s, "ResetCount: "+fmt.Sprintf("%#v", this.ResetCount)+",\n")
	s = append(s, "DateTime: "+fmt.Sprintf("%#v", this.DateTime)+",\n")
	if this.SluitemPara != nil {
		s = append(s, "SluitemPara: "+fmt.Sprintf("%#v", this.SluitemPara)+",\n")
	}
	s = append(s, "Rsrp: "+fmt.Sprintf("%#v", this.Rsrp)+",\n")
	s = append(s, "Rssi: "+fmt.Sprintf("%#v", this.Rssi)+",\n")
	s = append(s, "Snr: "+fmt.Sprintf("%#v", this.Snr)+",\n")
	s = append(s, "Pci: "+fmt.Sprintf("%#v", this.Pci)+",\n")
	s = append(s, "Rsrq: "+fmt.Sprintf("%#v", this.Rsrq)+",\n")
	s = append(s, "Txpower: "+fmt.Sprintf("%#v", this.Txpower)+",\n")
	s = append(s, "Earfcn: "+fmt.Sprintf("%#v", this.Earfcn)+",\n")
	s = append(s, "Ecl: "+fmt.Sprintf("%#v", this.Ecl)+",\n")
	s = append(s, "Csq: "+fmt.Sprintf("%#v", this.Csq)+",\n")
	s = append(s, "Reson: "+fmt.Sprintf("%#v", this.Reson)+",\n")
	s = append(s, "Retry: "+fmt.Sprintf("%#v", this.Retry)+",\n")
	s = append(s, "Sunrise: "+fmt.Sprintf("%#v", this.Sunrise)+",\n")
	s = append(s, "Sunset: "+fmt.Sprintf("%#v", this.Sunset)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_3900_ModelInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&wlst_pb2.WlstSlu_3900_ModelInfo{")
	s = append(s, "SluitemLoop: "+fmt.Sprintf("%#v", this.SluitemLoop)+",\n")
	s = append(s, "PowerSaving: "+fmt.Sprintf("%#v", this.PowerSaving)+",\n")
	s = append(s, "HasLeakage: "+fmt.Sprintf("%#v", this.HasLeakage)+",\n")
	s = append(s, "HasTemperature: "+fmt.Sprintf("%#v", this.HasTemperature)+",\n")
	s = append(s, "HasTimer: "+fmt.Sprintf("%#v", this.HasTimer)+",\n")
	s = append(s, "Model: "+fmt.Sprintf("%#v", this.Model)+",\n")
	s = append(s, "SluitemType: "+fmt.Sprintf("%#v", this.SluitemType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_3900_LightData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 15)
	s = append(s, "&wlst_pb2.WlstSlu_3900_LightData{")
	s = append(s, "Voltage: "+fmt.Sprintf("%#v", this.Voltage)+",\n")
	s = append(s, "Current: "+fmt.Sprintf("%#v", this.Current)+",\n")
	s = append(s, "ActivePower: "+fmt.Sprintf("%#v", this.ActivePower)+",\n")
	s = append(s, "ReactivePower: "+fmt.Sprintf("%#v", this.ReactivePower)+",\n")
	s = append(s, "ApparentPower: "+fmt.Sprintf("%#v", this.ApparentPower)+",\n")
	s = append(s, "Electricity: "+fmt.Sprintf("%#v", this.Electricity)+",\n")
	s = append(s, "ActiveTime: "+fmt.Sprintf("%#v", this.ActiveTime)+",\n")
	if this.LightStatus != nil {
		s = append(s, "LightStatus: "+fmt.Sprintf("%#v", this.LightStatus)+",\n")
	}
	s = append(s, "PowerLevel: "+fmt.Sprintf("%#v", this.PowerLevel)+",\n")
	s = append(s, "SluitemPowerTurnon: "+fmt.Sprintf("%#v", this.SluitemPowerTurnon)+",\n")
	s = append(s, "RatedPower: "+fmt.Sprintf("%#v", this.RatedPower)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_3900_LightStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&wlst_pb2.WlstSlu_3900_LightStatus{")
	s = append(s, "Leakage: "+fmt.Sprintf("%#v", this.Leakage)+",\n")
	s = append(s, "Fault: "+fmt.Sprintf("%#v", this.Fault)+",\n")
	s = append(s, "WorkingOn: "+fmt.Sprintf("%#v", this.WorkingOn)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_3900_SluitemStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&wlst_pb2.WlstSlu_3900_SluitemStatus{")
	s = append(s, "FlashFault: "+fmt.Sprintf("%#v", this.FlashFault)+",\n")
	s = append(s, "EnableAlarm: "+fmt.Sprintf("%#v", this.EnableAlarm)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_3900_TimeFault) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&wlst_pb2.WlstSlu_3900_TimeFault{")
	s = append(s, "ClockFault: "+fmt.Sprintf("%#v", this.ClockFault)+",\n")
	s = append(s, "ClockOutFault: "+fmt.Sprintf("%#v", this.ClockOutFault)+",\n")
	s = append(s, "ClockOutAlarm: "+fmt.Sprintf("%#v", this.ClockOutAlarm)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_3900_SluitemPara) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&wlst_pb2.WlstSlu_3900_SluitemPara{")
	s = append(s, "Longitude: "+fmt.Sprintf("%#v", this.Longitude)+",\n")
	s = append(s, "Latitude: "+fmt.Sprintf("%#v", this.Latitude)+",\n")
	s = append(s, "HasEnableAlarm: "+fmt.Sprintf("%#v", this.HasEnableAlarm)+",\n")
	s = append(s, "IsRunning: "+fmt.Sprintf("%#v", this.IsRunning)+",\n")
	s = append(s, "AlarmInterval: "+fmt.Sprintf("%#v", this.AlarmInterval)+",\n")
	s = append(s, "UplinkReply: "+fmt.Sprintf("%#v", this.UplinkReply)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_7800) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&wlst_pb2.WlstSlu_7800{")
	s = append(s, "CmdIdx: "+fmt.Sprintf("%#v", this.CmdIdx)+",\n")
	s = append(s, "EventType: "+fmt.Sprintf("%#v", this.EventType)+",\n")
	s = append(s, "ClassType: "+fmt.Sprintf("%#v", this.ClassType)+",\n")
	s = append(s, "RecordCount: "+fmt.Sprintf("%#v", this.RecordCount)+",\n")
	s = append(s, "DtStart: "+fmt.Sprintf("%#v", this.DtStart)+",\n")
	s = append(s, "DtEnd: "+fmt.Sprintf("%#v", this.DtEnd)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSluF800) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 16)
	s = append(s, "&wlst_pb2.WlstSluF800{")
	s = append(s, "CmdIdx: "+fmt.Sprintf("%#v", this.CmdIdx)+",\n")
	s = append(s, "EventType: "+fmt.Sprintf("%#v", this.EventType)+",\n")
	s = append(s, "ClassType: "+fmt.Sprintf("%#v", this.ClassType)+",\n")
	s = append(s, "DataTotal: "+fmt.Sprintf("%#v", this.DataTotal)+",\n")
	s = append(s, "DataIdx: "+fmt.Sprintf("%#v", this.DataIdx)+",\n")
	s = append(s, "RecordCount: "+fmt.Sprintf("%#v", this.RecordCount)+",\n")
	if this.View_0X20 != nil {
		s = append(s, "View_0X20: "+fmt.Sprintf("%#v", this.View_0X20)+",\n")
	}
	if this.View_0X21 != nil {
		s = append(s, "View_0X21: "+fmt.Sprintf("%#v", this.View_0X21)+",\n")
	}
	if this.View_0X22 != nil {
		s = append(s, "View_0X22: "+fmt.Sprintf("%#v", this.View_0X22)+",\n")
	}
	if this.View_0X23 != nil {
		s = append(s, "View_0X23: "+fmt.Sprintf("%#v", this.View_0X23)+",\n")
	}
	if this.View_0X24 != nil {
		s = append(s, "View_0X24: "+fmt.Sprintf("%#v", this.View_0X24)+",\n")
	}
	if this.View_0X25 != nil {
		s = append(s, "View_0X25: "+fmt.Sprintf("%#v", this.View_0X25)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSluF800_View0X20) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&wlst_pb2.WlstSluF800_View0X20{")
	s = append(s, "DtHappen: "+fmt.Sprintf("%#v", this.DtHappen)+",\n")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSluF800_View0X21) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&wlst_pb2.WlstSluF800_View0X21{")
	s = append(s, "DtHappen: "+fmt.Sprintf("%#v", this.DtHappen)+",\n")
	s = append(s, "OperationType: "+fmt.Sprintf("%#v", this.OperationType)+",\n")
	s = append(s, "OperationOrder: "+fmt.Sprintf("%#v", this.OperationOrder)+",\n")
	s = append(s, "AddrType: "+fmt.Sprintf("%#v", this.AddrType)+",\n")
	s = append(s, "Addr: "+fmt.Sprintf("%#v", this.Addr)+",\n")
	s = append(s, "OperationSource: "+fmt.Sprintf("%#v", this.OperationSource)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSluF800_View0X23) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 16)
	s = append(s, "&wlst_pb2.WlstSluF800_View0X23{")
	s = append(s, "DtHappen: "+fmt.Sprintf("%#v", this.DtHappen)+",\n")
	s = append(s, "Addr: "+fmt.Sprintf("%#v", this.Addr)+",\n")
	s = append(s, "AlarmType: "+fmt.Sprintf("%#v", this.AlarmType)+",\n")
	s = append(s, "SluitemStatus: "+fmt.Sprintf("%#v", this.SluitemStatus)+",\n")
	s = append(s, "SluitemVoltage: "+fmt.Sprintf("%#v", this.SluitemVoltage)+",\n")
	s = append(s, "SluitemCurrent: "+fmt.Sprintf("%#v", this.SluitemCurrent)+",\n")
	s = append(s, "SluitemActivePower: "+fmt.Sprintf("%#v", this.SluitemActivePower)+",\n")
	s = append(s, "SluitemReactivePower: "+fmt.Sprintf("%#v", this.SluitemReactivePower)+",\n")
	s = append(s, "SluitemMaxVoltage: "+fmt.Sprintf("%#v", this.SluitemMaxVoltage)+",\n")
	s = append(s, "SluitemMaxCurrent: "+fmt.Sprintf("%#v", this.SluitemMaxCurrent)+",\n")
	s = append(s, "SluitemElectricity: "+fmt.Sprintf("%#v", this.SluitemElectricity)+",\n")
	s = append(s, "SluitemPhyinfo: "+fmt.Sprintf("%#v", this.SluitemPhyinfo)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSluEc00) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&wlst_pb2.WlstSluEc00{")
	s = append(s, "CmdIdx: "+fmt.Sprintf("%#v", this.CmdIdx)+",\n")
	s = append(s, "StartIdx: "+fmt.Sprintf("%#v", this.StartIdx)+",\n")
	s = append(s, "ReadCount: "+fmt.Sprintf("%#v", this.ReadCount)+",\n")
	if this.WlstSlu_6B00 != nil {
		s = append(s, "WlstSlu_6B00: "+fmt.Sprintf("%#v", this.WlstSlu_6B00)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_6B00) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 16)
	s = append(s, "&wlst_pb2.WlstSlu_6B00{")
	s = append(s, "CmdIdx: "+fmt.Sprintf("%#v", this.CmdIdx)+",\n")
	s = append(s, "SetIdx: "+fmt.Sprintf("%#v", this.SetIdx)+",\n")
	s = append(s, "DtStart: "+fmt.Sprintf("%#v", this.DtStart)+",\n")
	s = append(s, "DtEnd: "+fmt.Sprintf("%#v", this.DtEnd)+",\n")
	s = append(s, "OperationType: "+fmt.Sprintf("%#v", this.OperationType)+",\n")
	s = append(s, "OperationOrder: "+fmt.Sprintf("%#v", this.OperationOrder)+",\n")
	s = append(s, "TimerOrOffset: "+fmt.Sprintf("%#v", this.TimerOrOffset)+",\n")
	s = append(s, "AddrType: "+fmt.Sprintf("%#v", this.AddrType)+",\n")
	s = append(s, "Addrs: "+fmt.Sprintf("%#v", this.Addrs)+",\n")
	s = append(s, "CmdType: "+fmt.Sprintf("%#v", this.CmdType)+",\n")
	s = append(s, "CmdMix: "+fmt.Sprintf("%#v", this.CmdMix)+",\n")
	if this.CmdPwm != nil {
		s = append(s, "CmdPwm: "+fmt.Sprintf("%#v", this.CmdPwm)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_6B00_CmdPwm) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&wlst_pb2.WlstSlu_6B00_CmdPwm{")
	s = append(s, "LoopCanDo: "+fmt.Sprintf("%#v", this.LoopCanDo)+",\n")
	s = append(s, "Scale: "+fmt.Sprintf("%#v", this.Scale)+",\n")
	s = append(s, "Rate: "+fmt.Sprintf("%#v", this.Rate)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_6C00) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&wlst_pb2.WlstSlu_6C00{")
	s = append(s, "CmdIdx: "+fmt.Sprintf("%#v", this.CmdIdx)+",\n")
	s = append(s, "StartIdx: "+fmt.Sprintf("%#v", this.StartIdx)+",\n")
	s = append(s, "ReadCount: "+fmt.Sprintf("%#v", this.ReadCount)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSluD000) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&wlst_pb2.WlstSluD000{")
	s = append(s, "Ver: "+fmt.Sprintf("%#v", this.Ver)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_2800) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&wlst_pb2.WlstSlu_2800{")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "Alarm: "+fmt.Sprintf("%#v", this.Alarm)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_2400) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&wlst_pb2.WlstSlu_2400{")
	s = append(s, "DoFlag: "+fmt.Sprintf("%#v", this.DoFlag)+",\n")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_6E00) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&wlst_pb2.WlstSlu_6E00{")
	s = append(s, "DoFlag: "+fmt.Sprintf("%#v", this.DoFlag)+",\n")
	s = append(s, "PatrolStart: "+fmt.Sprintf("%#v", this.PatrolStart)+",\n")
	s = append(s, "PatrolInterval: "+fmt.Sprintf("%#v", this.PatrolInterval)+",\n")
	s = append(s, "PatrolOrder: "+fmt.Sprintf("%#v", this.PatrolOrder)+",\n")
	s = append(s, "PatrolCount: "+fmt.Sprintf("%#v", this.PatrolCount)+",\n")
	s = append(s, "CmdIdx: "+fmt.Sprintf("%#v", this.CmdIdx)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_3000) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&wlst_pb2.WlstSlu_3000{")
	s = append(s, "Ctrls: "+fmt.Sprintf("%#v", this.Ctrls)+",\n")
	s = append(s, "DomainName: "+fmt.Sprintf("%#v", this.DomainName)+",\n")
	s = append(s, "UpperVoltageLimit: "+fmt.Sprintf("%#v", this.UpperVoltageLimit)+",\n")
	s = append(s, "LowerVoltageLimit: "+fmt.Sprintf("%#v", this.LowerVoltageLimit)+",\n")
	s = append(s, "MacAddr: "+fmt.Sprintf("%#v", this.MacAddr)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_9A00) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&wlst_pb2.WlstSlu_9A00{")
	s = append(s, "DomainNameStatus: "+fmt.Sprintf("%#v", this.DomainNameStatus)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSluCd00) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 18)
	s = append(s, "&wlst_pb2.WlstSluCd00{")
	s = append(s, "CmdIdx: "+fmt.Sprintf("%#v", this.CmdIdx)+",\n")
	s = append(s, "CommunicationFailures: "+fmt.Sprintf("%#v", this.CommunicationFailures)+",\n")
	s = append(s, "PowerFactor: "+fmt.Sprintf("%#v", this.PowerFactor)+",\n")
	s = append(s, "CommunicationChannel: "+fmt.Sprintf("%#v", this.CommunicationChannel)+",\n")
	s = append(s, "CurrentRange: "+fmt.Sprintf("%#v", this.CurrentRange)+",\n")
	s = append(s, "PowerRange: "+fmt.Sprintf("%#v", this.PowerRange)+",\n")
	s = append(s, "AutoMode: "+fmt.Sprintf("%#v", this.AutoMode)+",\n")
	s = append(s, "Longitude: "+fmt.Sprintf("%#v", this.Longitude)+",\n")
	s = append(s, "Latitude: "+fmt.Sprintf("%#v", this.Latitude)+",\n")
	s = append(s, "CarrierRoutingMode: "+fmt.Sprintf("%#v", this.CarrierRoutingMode)+",\n")
	s = append(s, "BluetoothPin: "+fmt.Sprintf("%#v", this.BluetoothPin)+",\n")
	s = append(s, "BluetoothMode: "+fmt.Sprintf("%#v", this.BluetoothMode)+",\n")
	s = append(s, "Cct: "+fmt.Sprintf("%#v", this.Cct)+",\n")
	s = append(s, "AlwaysOnline: "+fmt.Sprintf("%#v", this.AlwaysOnline)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_1C00) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&wlst_pb2.WlstSlu_1C00{")
	s = append(s, "CmdIdx: "+fmt.Sprintf("%#v", this.CmdIdx)+",\n")
	s = append(s, "SluitemIdx: "+fmt.Sprintf("%#v", this.SluitemIdx)+",\n")
	s = append(s, "DomainName: "+fmt.Sprintf("%#v", this.DomainName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_1D00) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&wlst_pb2.WlstSlu_1D00{")
	s = append(s, "CmdIdx: "+fmt.Sprintf("%#v", this.CmdIdx)+",\n")
	s = append(s, "SluitemIdx: "+fmt.Sprintf("%#v", this.SluitemIdx)+",\n")
	if this.DataMark != nil {
		s = append(s, "DataMark: "+fmt.Sprintf("%#v", this.DataMark)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_1D00_DataMark) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&wlst_pb2.WlstSlu_1D00_DataMark{")
	s = append(s, "ReadData: "+fmt.Sprintf("%#v", this.ReadData)+",\n")
	s = append(s, "ReadTimer: "+fmt.Sprintf("%#v", this.ReadTimer)+",\n")
	s = append(s, "ReadArgs: "+fmt.Sprintf("%#v", this.ReadArgs)+",\n")
	s = append(s, "ReadGroup: "+fmt.Sprintf("%#v", this.ReadGroup)+",\n")
	s = append(s, "ReadVer: "+fmt.Sprintf("%#v", this.ReadVer)+",\n")
	s = append(s, "ReadSunriseset: "+fmt.Sprintf("%#v", this.ReadSunriseset)+",\n")
	s = append(s, "ReadTimetable: "+fmt.Sprintf("%#v", this.ReadTimetable)+",\n")
	s = append(s, "ReadCtrldata: "+fmt.Sprintf("%#v", this.ReadCtrldata)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_9D00) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 19)
	s = append(s, "&wlst_pb2.WlstSlu_9D00{")
	s = append(s, "CmdIdx: "+fmt.Sprintf("%#v", this.CmdIdx)+",\n")
	s = append(s, "SluitemIdx: "+fmt.Sprintf("%#v", this.SluitemIdx)+",\n")
	if this.DataMark != nil {
		s = append(s, "DataMark: "+fmt.Sprintf("%#v", this.DataMark)+",\n")
	}
	s = append(s, "LoopCount: "+fmt.Sprintf("%#v", this.LoopCount)+",\n")
	if this.SluitemData != nil {
		s = append(s, "SluitemData: "+fmt.Sprintf("%#v", this.SluitemData)+",\n")
	}
	s = append(s, "SluitemTime: "+fmt.Sprintf("%#v", this.SluitemTime)+",\n")
	if this.SluitemPara != nil {
		s = append(s, "SluitemPara: "+fmt.Sprintf("%#v", this.SluitemPara)+",\n")
	}
	s = append(s, "SluitemGroup: "+fmt.Sprintf("%#v", this.SluitemGroup)+",\n")
	if this.SluitemVer != nil {
		s = append(s, "SluitemVer: "+fmt.Sprintf("%#v", this.SluitemVer)+",\n")
	}
	if this.SluitemSunriseset != nil {
		s = append(s, "SluitemSunriseset: "+fmt.Sprintf("%#v", this.SluitemSunriseset)+",\n")
	}
	if this.SluitemRuntime != nil {
		s = append(s, "SluitemRuntime: "+fmt.Sprintf("%#v", this.SluitemRuntime)+",\n")
	}
	if this.SluitemDataNew != nil {
		s = append(s, "SluitemDataNew: "+fmt.Sprintf("%#v", this.SluitemDataNew)+",\n")
	}
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	if this.SetMark != nil {
		s = append(s, "SetMark: "+fmt.Sprintf("%#v", this.SetMark)+",\n")
	}
	s = append(s, "DataContinue: "+fmt.Sprintf("%#v", this.DataContinue)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_9D00_SetMark) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&wlst_pb2.WlstSlu_9D00_SetMark{")
	s = append(s, "SetTimer: "+fmt.Sprintf("%#v", this.SetTimer)+",\n")
	s = append(s, "SetArgs: "+fmt.Sprintf("%#v", this.SetArgs)+",\n")
	s = append(s, "SetGroup: "+fmt.Sprintf("%#v", this.SetGroup)+",\n")
	s = append(s, "SetReset: "+fmt.Sprintf("%#v", this.SetReset)+",\n")
	s = append(s, "SetControl: "+fmt.Sprintf("%#v", this.SetControl)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_9D00_SluitemData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 17)
	s = append(s, "&wlst_pb2.WlstSlu_9D00_SluitemData{")
	s = append(s, "Voltage: "+fmt.Sprintf("%#v", this.Voltage)+",\n")
	s = append(s, "Current: "+fmt.Sprintf("%#v", this.Current)+",\n")
	s = append(s, "ActivePower: "+fmt.Sprintf("%#v", this.ActivePower)+",\n")
	s = append(s, "ReactivePower: "+fmt.Sprintf("%#v", this.ReactivePower)+",\n")
	s = append(s, "MaxVoltage: "+fmt.Sprintf("%#v", this.MaxVoltage)+",\n")
	s = append(s, "MaxCurrent: "+fmt.Sprintf("%#v", this.MaxCurrent)+",\n")
	s = append(s, "TotalElectricity: "+fmt.Sprintf("%#v", this.TotalElectricity)+",\n")
	s = append(s, "Temperature: "+fmt.Sprintf("%#v", this.Temperature)+",\n")
	s = append(s, "LeakageCurrent: "+fmt.Sprintf("%#v", this.LeakageCurrent)+",\n")
	s = append(s, "TimerError: "+fmt.Sprintf("%#v", this.TimerError)+",\n")
	if this.SluitemStatus != nil {
		s = append(s, "SluitemStatus: "+fmt.Sprintf("%#v", this.SluitemStatus)+",\n")
	}
	if this.LightStatus != nil {
		s = append(s, "LightStatus: "+fmt.Sprintf("%#v", this.LightStatus)+",\n")
	}
	s = append(s, "ResetCount: "+fmt.Sprintf("%#v", this.ResetCount)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_9D00_SluitemDataNew) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 16)
	s = append(s, "&wlst_pb2.WlstSlu_9D00_SluitemDataNew{")
	s = append(s, "Voltage: "+fmt.Sprintf("%#v", this.Voltage)+",\n")
	s = append(s, "Current: "+fmt.Sprintf("%#v", this.Current)+",\n")
	s = append(s, "ActivePower: "+fmt.Sprintf("%#v", this.ActivePower)+",\n")
	s = append(s, "RunTime: "+fmt.Sprintf("%#v", this.RunTime)+",\n")
	s = append(s, "Phase: "+fmt.Sprintf("%#v", this.Phase)+",\n")
	s = append(s, "TotalElectricity: "+fmt.Sprintf("%#v", this.TotalElectricity)+",\n")
	s = append(s, "LeakageCurrent: "+fmt.Sprintf("%#v", this.LeakageCurrent)+",\n")
	s = append(s, "TimerError: "+fmt.Sprintf("%#v", this.TimerError)+",\n")
	if this.SluitemStatus != nil {
		s = append(s, "SluitemStatus: "+fmt.Sprintf("%#v", this.SluitemStatus)+",\n")
	}
	if this.LightStatus != nil {
		s = append(s, "LightStatus: "+fmt.Sprintf("%#v", this.LightStatus)+",\n")
	}
	s = append(s, "ResetCount: "+fmt.Sprintf("%#v", this.ResetCount)+",\n")
	s = append(s, "EnergySaving: "+fmt.Sprintf("%#v", this.EnergySaving)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_9D00_SluitemPara) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&wlst_pb2.WlstSlu_9D00_SluitemPara{")
	s = append(s, "DomainName: "+fmt.Sprintf("%#v", this.DomainName)+",\n")
	s = append(s, "SluitemStatus: "+fmt.Sprintf("%#v", this.SluitemStatus)+",\n")
	s = append(s, "SluitemEnableAlarm: "+fmt.Sprintf("%#v", this.SluitemEnableAlarm)+",\n")
	s = append(s, "SluitemPowerTurnon: "+fmt.Sprintf("%#v", this.SluitemPowerTurnon)+",\n")
	s = append(s, "SluitemVector: "+fmt.Sprintf("%#v", this.SluitemVector)+",\n")
	s = append(s, "Longitude: "+fmt.Sprintf("%#v", this.Longitude)+",\n")
	s = append(s, "Latitude: "+fmt.Sprintf("%#v", this.Latitude)+",\n")
	s = append(s, "RatedPower: "+fmt.Sprintf("%#v", this.RatedPower)+",\n")
	s = append(s, "UplinkTimer: "+fmt.Sprintf("%#v", this.UplinkTimer)+",\n")
	s = append(s, "UplinkReply: "+fmt.Sprintf("%#v", this.UplinkReply)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_9D00_SluitemVer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&wlst_pb2.WlstSlu_9D00_SluitemVer{")
	s = append(s, "SluitemLoop: "+fmt.Sprintf("%#v", this.SluitemLoop)+",\n")
	s = append(s, "EnergySaving: "+fmt.Sprintf("%#v", this.EnergySaving)+",\n")
	s = append(s, "ElectricLeakageModule: "+fmt.Sprintf("%#v", this.ElectricLeakageModule)+",\n")
	s = append(s, "TemperatureModule: "+fmt.Sprintf("%#v", this.TemperatureModule)+",\n")
	s = append(s, "TimerModule: "+fmt.Sprintf("%#v", this.TimerModule)+",\n")
	s = append(s, "SluitemType: "+fmt.Sprintf("%#v", this.SluitemType)+",\n")
	s = append(s, "Ver: "+fmt.Sprintf("%#v", this.Ver)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_9D00_SluitemSunriseset) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&wlst_pb2.WlstSlu_9D00_SluitemSunriseset{")
	s = append(s, "Sunrise: "+fmt.Sprintf("%#v", this.Sunrise)+",\n")
	s = append(s, "Sunset: "+fmt.Sprintf("%#v", this.Sunset)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_9D00_SluitemRuntime) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 16)
	s = append(s, "&wlst_pb2.WlstSlu_9D00_SluitemRuntime{")
	s = append(s, "DataType: "+fmt.Sprintf("%#v", this.DataType)+",\n")
	s = append(s, "OutputType: "+fmt.Sprintf("%#v", this.OutputType)+",\n")
	s = append(s, "OperateType: "+fmt.Sprintf("%#v", this.OperateType)+",\n")
	s = append(s, "DateEnable: "+fmt.Sprintf("%#v", this.DateEnable)+",\n")
	s = append(s, "OperateTime: "+fmt.Sprintf("%#v", this.OperateTime)+",\n")
	s = append(s, "OperateOffset: "+fmt.Sprintf("%#v", this.OperateOffset)+",\n")
	s = append(s, "RelayOperate: "+fmt.Sprintf("%#v", this.RelayOperate)+",\n")
	s = append(s, "PwmLoop: "+fmt.Sprintf("%#v", this.PwmLoop)+",\n")
	s = append(s, "PwmPower: "+fmt.Sprintf("%#v", this.PwmPower)+",\n")
	s = append(s, "PwmBaudrate: "+fmt.Sprintf("%#v", this.PwmBaudrate)+",\n")
	s = append(s, "Rs485Baudrate: "+fmt.Sprintf("%#v", this.Rs485Baudrate)+",\n")
	s = append(s, "Rs485Check: "+fmt.Sprintf("%#v", this.Rs485Check)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSluF000) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&wlst_pb2.WlstSluF000{")
	s = append(s, "CmdIdx: "+fmt.Sprintf("%#v", this.CmdIdx)+",\n")
	if this.ResetMark != nil {
		s = append(s, "ResetMark: "+fmt.Sprintf("%#v", this.ResetMark)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSluF000_ResetMark) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&wlst_pb2.WlstSluF000_ResetMark{")
	s = append(s, "ClearTask: "+fmt.Sprintf("%#v", this.ClearTask)+",\n")
	s = append(s, "ResetConcentrator: "+fmt.Sprintf("%#v", this.ResetConcentrator)+",\n")
	s = append(s, "HardResetZigbee: "+fmt.Sprintf("%#v", this.HardResetZigbee)+",\n")
	s = append(s, "SoftResetZigbee: "+fmt.Sprintf("%#v", this.SoftResetZigbee)+",\n")
	s = append(s, "ResetCarrier: "+fmt.Sprintf("%#v", this.ResetCarrier)+",\n")
	s = append(s, "InitAll: "+fmt.Sprintf("%#v", this.InitAll)+",\n")
	s = append(s, "ClearData: "+fmt.Sprintf("%#v", this.ClearData)+",\n")
	s = append(s, "ClearArgs: "+fmt.Sprintf("%#v", this.ClearArgs)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSluF100) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&wlst_pb2.WlstSluF100{")
	s = append(s, "CmdIdx: "+fmt.Sprintf("%#v", this.CmdIdx)+",\n")
	s = append(s, "OptMark: "+fmt.Sprintf("%#v", this.OptMark)+",\n")
	s = append(s, "DateTime: "+fmt.Sprintf("%#v", this.DateTime)+",\n")
	s = append(s, "ForceTimer: "+fmt.Sprintf("%#v", this.ForceTimer)+",\n")
	if this.TimerStatus != nil {
		s = append(s, "TimerStatus: "+fmt.Sprintf("%#v", this.TimerStatus)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSluF100_TimerStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&wlst_pb2.WlstSluF100_TimerStatus{")
	s = append(s, "DtformatError: "+fmt.Sprintf("%#v", this.DtformatError)+",\n")
	s = append(s, "TimerError: "+fmt.Sprintf("%#v", this.TimerError)+",\n")
	s = append(s, "TimeFault: "+fmt.Sprintf("%#v", this.TimeFault)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSluF200) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&wlst_pb2.WlstSluF200{")
	s = append(s, "CmdIdx: "+fmt.Sprintf("%#v", this.CmdIdx)+",\n")
	s = append(s, "SluitemIdx: "+fmt.Sprintf("%#v", this.SluitemIdx)+",\n")
	s = append(s, "SluitemCount: "+fmt.Sprintf("%#v", this.SluitemCount)+",\n")
	if this.DataMark != nil {
		s = append(s, "DataMark: "+fmt.Sprintf("%#v", this.DataMark)+",\n")
	}
	if this.SluitemData != nil {
		s = append(s, "SluitemData: "+fmt.Sprintf("%#v", this.SluitemData)+",\n")
	}
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSluF200_DataMark) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 15)
	s = append(s, "&wlst_pb2.WlstSluF200_DataMark{")
	s = append(s, "SetData: "+fmt.Sprintf("%#v", this.SetData)+",\n")
	s = append(s, "Group: "+fmt.Sprintf("%#v", this.Group)+",\n")
	s = append(s, "Barcode: "+fmt.Sprintf("%#v", this.Barcode)+",\n")
	s = append(s, "Route: "+fmt.Sprintf("%#v", this.Route)+",\n")
	s = append(s, "Order: "+fmt.Sprintf("%#v", this.Order)+",\n")
	s = append(s, "Limit: "+fmt.Sprintf("%#v", this.Limit)+",\n")
	s = append(s, "PowerOnStatus: "+fmt.Sprintf("%#v", this.PowerOnStatus)+",\n")
	s = append(s, "RunStatus: "+fmt.Sprintf("%#v", this.RunStatus)+",\n")
	s = append(s, "Vector: "+fmt.Sprintf("%#v", this.Vector)+",\n")
	s = append(s, "RatedPower: "+fmt.Sprintf("%#v", this.RatedPower)+",\n")
	s = append(s, "LoopCount: "+fmt.Sprintf("%#v", this.LoopCount)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSluF200_ControllerData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 20)
	s = append(s, "&wlst_pb2.WlstSluF200_ControllerData{")
	s = append(s, "SluitemGroup: "+fmt.Sprintf("%#v", this.SluitemGroup)+",\n")
	s = append(s, "SluitemIdx: "+fmt.Sprintf("%#v", this.SluitemIdx)+",\n")
	s = append(s, "SluitemRoute: "+fmt.Sprintf("%#v", this.SluitemRoute)+",\n")
	s = append(s, "SluitemOrder: "+fmt.Sprintf("%#v", this.SluitemOrder)+",\n")
	s = append(s, "UpperPowerLimit: "+fmt.Sprintf("%#v", this.UpperPowerLimit)+",\n")
	s = append(s, "LowerPowerLimit: "+fmt.Sprintf("%#v", this.LowerPowerLimit)+",\n")
	s = append(s, "SluitemPowerTurnon: "+fmt.Sprintf("%#v", this.SluitemPowerTurnon)+",\n")
	s = append(s, "SluitemStatus: "+fmt.Sprintf("%#v", this.SluitemStatus)+",\n")
	s = append(s, "SluitemEnableAlarm: "+fmt.Sprintf("%#v", this.SluitemEnableAlarm)+",\n")
	s = append(s, "SluitemVector: "+fmt.Sprintf("%#v", this.SluitemVector)+",\n")
	s = append(s, "RatedPower: "+fmt.Sprintf("%#v", this.RatedPower)+",\n")
	s = append(s, "LoopCount: "+fmt.Sprintf("%#v", this.LoopCount)+",\n")
	s = append(s, "Longitude: "+fmt.Sprintf("%#v", this.Longitude)+",\n")
	s = append(s, "Latitude: "+fmt.Sprintf("%#v", this.Latitude)+",\n")
	s = append(s, "UplinkTimer: "+fmt.Sprintf("%#v", this.UplinkTimer)+",\n")
	s = append(s, "UplinkReply: "+fmt.Sprintf("%#v", this.UplinkReply)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_7300) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&wlst_pb2.WlstSlu_7300{")
	s = append(s, "CmdIdx: "+fmt.Sprintf("%#v", this.CmdIdx)+",\n")
	s = append(s, "SluitemStart: "+fmt.Sprintf("%#v", this.SluitemStart)+",\n")
	s = append(s, "SluitemCount: "+fmt.Sprintf("%#v", this.SluitemCount)+",\n")
	s = append(s, "DataMark: "+fmt.Sprintf("%#v", this.DataMark)+",\n")
	if this.ConcentratorData != nil {
		s = append(s, "ConcentratorData: "+fmt.Sprintf("%#v", this.ConcentratorData)+",\n")
	}
	if this.BaseSluitemData != nil {
		s = append(s, "BaseSluitemData: "+fmt.Sprintf("%#v", this.BaseSluitemData)+",\n")
	}
	if this.UnknowSluitem != nil {
		s = append(s, "UnknowSluitem: "+fmt.Sprintf("%#v", this.UnknowSluitem)+",\n")
	}
	if this.AssistSluitemData != nil {
		s = append(s, "AssistSluitemData: "+fmt.Sprintf("%#v", this.AssistSluitemData)+",\n")
	}
	if this.SluitemPhyinfo != nil {
		s = append(s, "SluitemPhyinfo: "+fmt.Sprintf("%#v", this.SluitemPhyinfo)+",\n")
	}
	s = append(s, "SluitemAddrs: "+fmt.Sprintf("%#v", this.SluitemAddrs)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_7300_ConcentratorData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&wlst_pb2.WlstSlu_7300_ConcentratorData{")
	s = append(s, "ResetCount: "+fmt.Sprintf("%#v", this.ResetCount)+",\n")
	if this.RunStatus != nil {
		s = append(s, "RunStatus: "+fmt.Sprintf("%#v", this.RunStatus)+",\n")
	}
	if this.ArgsStatus != nil {
		s = append(s, "ArgsStatus: "+fmt.Sprintf("%#v", this.ArgsStatus)+",\n")
	}
	if this.HardwareStatus != nil {
		s = append(s, "HardwareStatus: "+fmt.Sprintf("%#v", this.HardwareStatus)+",\n")
	}
	s = append(s, "UnknowSluitemCount: "+fmt.Sprintf("%#v", this.UnknowSluitemCount)+",\n")
	s = append(s, "CommunicationChannel: "+fmt.Sprintf("%#v", this.CommunicationChannel)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_7300_ConcentratorData_RunStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&wlst_pb2.WlstSlu_7300_ConcentratorData_RunStatus{")
	s = append(s, "Offline: "+fmt.Sprintf("%#v", this.Offline)+",\n")
	s = append(s, "EnableAlarm: "+fmt.Sprintf("%#v", this.EnableAlarm)+",\n")
	s = append(s, "PoweronMark: "+fmt.Sprintf("%#v", this.PoweronMark)+",\n")
	s = append(s, "EnableGprs: "+fmt.Sprintf("%#v", this.EnableGprs)+",\n")
	s = append(s, "EnableAutochk: "+fmt.Sprintf("%#v", this.EnableAutochk)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_7300_ConcentratorData_ArgsStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&wlst_pb2.WlstSlu_7300_ConcentratorData_ArgsStatus{")
	s = append(s, "ConcentratorArgsError: "+fmt.Sprintf("%#v", this.ConcentratorArgsError)+",\n")
	s = append(s, "SluitemArgsError: "+fmt.Sprintf("%#v", this.SluitemArgsError)+",\n")
	s = append(s, "TurnOnoffError: "+fmt.Sprintf("%#v", this.TurnOnoffError)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_7300_ConcentratorData_HardwareStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&wlst_pb2.WlstSlu_7300_ConcentratorData_HardwareStatus{")
	s = append(s, "ZigbeeError: "+fmt.Sprintf("%#v", this.ZigbeeError)+",\n")
	s = append(s, "CarrierError: "+fmt.Sprintf("%#v", this.CarrierError)+",\n")
	s = append(s, "FramError: "+fmt.Sprintf("%#v", this.FramError)+",\n")
	s = append(s, "BluetoothError: "+fmt.Sprintf("%#v", this.BluetoothError)+",\n")
	s = append(s, "TimerError: "+fmt.Sprintf("%#v", this.TimerError)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_7300_BaseSluitemData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&wlst_pb2.WlstSlu_7300_BaseSluitemData{")
	s = append(s, "DateTime: "+fmt.Sprintf("%#v", this.DateTime)+",\n")
	if this.SluitemStatus != nil {
		s = append(s, "SluitemStatus: "+fmt.Sprintf("%#v", this.SluitemStatus)+",\n")
	}
	s = append(s, "Temperature: "+fmt.Sprintf("%#v", this.Temperature)+",\n")
	if this.LightStatus != nil {
		s = append(s, "LightStatus: "+fmt.Sprintf("%#v", this.LightStatus)+",\n")
	}
	if this.LightData != nil {
		s = append(s, "LightData: "+fmt.Sprintf("%#v", this.LightData)+",\n")
	}
	s = append(s, "SluitemLoop: "+fmt.Sprintf("%#v", this.SluitemLoop)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_7300_BaseSluitemData_SluitemStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&wlst_pb2.WlstSlu_7300_BaseSluitemData_SluitemStatus{")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "Adjust: "+fmt.Sprintf("%#v", this.Adjust)+",\n")
	s = append(s, "WorkingArgs: "+fmt.Sprintf("%#v", this.WorkingArgs)+",\n")
	s = append(s, "NoAlarm: "+fmt.Sprintf("%#v", this.NoAlarm)+",\n")
	s = append(s, "OffLine: "+fmt.Sprintf("%#v", this.OffLine)+",\n")
	s = append(s, "EepromError: "+fmt.Sprintf("%#v", this.EepromError)+",\n")
	s = append(s, "TemperatureSensor: "+fmt.Sprintf("%#v", this.TemperatureSensor)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_7300_BaseSluitemData_LightStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&wlst_pb2.WlstSlu_7300_BaseSluitemData_LightStatus{")
	s = append(s, "PowerStatus: "+fmt.Sprintf("%#v", this.PowerStatus)+",\n")
	s = append(s, "Leakage: "+fmt.Sprintf("%#v", this.Leakage)+",\n")
	s = append(s, "Fault: "+fmt.Sprintf("%#v", this.Fault)+",\n")
	s = append(s, "WorkingOn: "+fmt.Sprintf("%#v", this.WorkingOn)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_7300_BaseSluitemData_LightData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&wlst_pb2.WlstSlu_7300_BaseSluitemData_LightData{")
	s = append(s, "Voltage: "+fmt.Sprintf("%#v", this.Voltage)+",\n")
	s = append(s, "Current: "+fmt.Sprintf("%#v", this.Current)+",\n")
	s = append(s, "ActivePower: "+fmt.Sprintf("%#v", this.ActivePower)+",\n")
	s = append(s, "Electricity: "+fmt.Sprintf("%#v", this.Electricity)+",\n")
	s = append(s, "ActiveTime: "+fmt.Sprintf("%#v", this.ActiveTime)+",\n")
	s = append(s, "PowerLevel: "+fmt.Sprintf("%#v", this.PowerLevel)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_7300_UnknowSluitem) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&wlst_pb2.WlstSlu_7300_UnknowSluitem{")
	s = append(s, "SluitemIdx: "+fmt.Sprintf("%#v", this.SluitemIdx)+",\n")
	if this.ModelInfo != nil {
		s = append(s, "ModelInfo: "+fmt.Sprintf("%#v", this.ModelInfo)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_7300_AssistSluitemData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&wlst_pb2.WlstSlu_7300_AssistSluitemData{")
	s = append(s, "DateTime: "+fmt.Sprintf("%#v", this.DateTime)+",\n")
	s = append(s, "LeakageCurrent: "+fmt.Sprintf("%#v", this.LeakageCurrent)+",\n")
	if this.LightData != nil {
		s = append(s, "LightData: "+fmt.Sprintf("%#v", this.LightData)+",\n")
	}
	s = append(s, "SluitemLoop: "+fmt.Sprintf("%#v", this.SluitemLoop)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_7300_AssistSluitemData_LightData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&wlst_pb2.WlstSlu_7300_AssistSluitemData_LightData{")
	s = append(s, "MaxVoltage: "+fmt.Sprintf("%#v", this.MaxVoltage)+",\n")
	s = append(s, "MaxCurrent: "+fmt.Sprintf("%#v", this.MaxCurrent)+",\n")
	s = append(s, "Electricity: "+fmt.Sprintf("%#v", this.Electricity)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_7300_SluitemPhyinfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&wlst_pb2.WlstSlu_7300_SluitemPhyinfo{")
	s = append(s, "SignalStrength: "+fmt.Sprintf("%#v", this.SignalStrength)+",\n")
	s = append(s, "Routing: "+fmt.Sprintf("%#v", this.Routing)+",\n")
	s = append(s, "Phase: "+fmt.Sprintf("%#v", this.Phase)+",\n")
	s = append(s, "UsefulCommunicate: "+fmt.Sprintf("%#v", this.UsefulCommunicate)+",\n")
	s = append(s, "AllCommunicate: "+fmt.Sprintf("%#v", this.AllCommunicate)+",\n")
	if this.ModelInfo != nil {
		s = append(s, "ModelInfo: "+fmt.Sprintf("%#v", this.ModelInfo)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_7300_ModelInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&wlst_pb2.WlstSlu_7300_ModelInfo{")
	s = append(s, "SluitemLoop: "+fmt.Sprintf("%#v", this.SluitemLoop)+",\n")
	s = append(s, "PowerSaving: "+fmt.Sprintf("%#v", this.PowerSaving)+",\n")
	s = append(s, "HasLeakage: "+fmt.Sprintf("%#v", this.HasLeakage)+",\n")
	s = append(s, "HasTemperature: "+fmt.Sprintf("%#v", this.HasTemperature)+",\n")
	s = append(s, "HasTimer: "+fmt.Sprintf("%#v", this.HasTimer)+",\n")
	s = append(s, "Model: "+fmt.Sprintf("%#v", this.Model)+",\n")
	s = append(s, "SluitemType: "+fmt.Sprintf("%#v", this.SluitemType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSluF900) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&wlst_pb2.WlstSluF900{")
	s = append(s, "CmdIdx: "+fmt.Sprintf("%#v", this.CmdIdx)+",\n")
	s = append(s, "AlarmType: "+fmt.Sprintf("%#v", this.AlarmType)+",\n")
	if this.ConcentratorData != nil {
		s = append(s, "ConcentratorData: "+fmt.Sprintf("%#v", this.ConcentratorData)+",\n")
	}
	s = append(s, "ErrorCtrls: "+fmt.Sprintf("%#v", this.ErrorCtrls)+",\n")
	if this.SluitemStatusAlarm != nil {
		s = append(s, "SluitemStatusAlarm: "+fmt.Sprintf("%#v", this.SluitemStatusAlarm)+",\n")
	}
	if this.BluetoothApply != nil {
		s = append(s, "BluetoothApply: "+fmt.Sprintf("%#v", this.BluetoothApply)+",\n")
	}
	if this.SetDomainResult != nil {
		s = append(s, "SetDomainResult: "+fmt.Sprintf("%#v", this.SetDomainResult)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSluF900_SluitemStatusAlarm) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&wlst_pb2.WlstSluF900_SluitemStatusAlarm{")
	s = append(s, "SluitemIdx: "+fmt.Sprintf("%#v", this.SluitemIdx)+",\n")
	s = append(s, "SluitemLoop: "+fmt.Sprintf("%#v", this.SluitemLoop)+",\n")
	if this.SluitemStatus != nil {
		s = append(s, "SluitemStatus: "+fmt.Sprintf("%#v", this.SluitemStatus)+",\n")
	}
	if this.LightStatus != nil {
		s = append(s, "LightStatus: "+fmt.Sprintf("%#v", this.LightStatus)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSluF900_BluetoothApply) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&wlst_pb2.WlstSluF900_BluetoothApply{")
	s = append(s, "SimNumber: "+fmt.Sprintf("%#v", this.SimNumber)+",\n")
	s = append(s, "CheckCode: "+fmt.Sprintf("%#v", this.CheckCode)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSluF900_SetDomainResult) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&wlst_pb2.WlstSluF900_SetDomainResult{")
	s = append(s, "DomainName: "+fmt.Sprintf("%#v", this.DomainName)+",\n")
	s = append(s, "SetSuccess: "+fmt.Sprintf("%#v", this.SetSuccess)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_7B00) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&wlst_pb2.WlstSlu_7B00{")
	s = append(s, "CmdIdx: "+fmt.Sprintf("%#v", this.CmdIdx)+",\n")
	s = append(s, "SluitemIdx: "+fmt.Sprintf("%#v", this.SluitemIdx)+",\n")
	s = append(s, "DataCount: "+fmt.Sprintf("%#v", this.DataCount)+",\n")
	if this.OperationData != nil {
		s = append(s, "OperationData: "+fmt.Sprintf("%#v", this.OperationData)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_7B00_ReadConcentratorOperationData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&wlst_pb2.WlstSlu_7B00_ReadConcentratorOperationData{")
	s = append(s, "OperationOrder: "+fmt.Sprintf("%#v", this.OperationOrder)+",\n")
	s = append(s, "OperationType: "+fmt.Sprintf("%#v", this.OperationType)+",\n")
	s = append(s, "WeekSet: "+fmt.Sprintf("%#v", this.WeekSet)+",\n")
	s = append(s, "TimerOrOffset: "+fmt.Sprintf("%#v", this.TimerOrOffset)+",\n")
	s = append(s, "AddrType: "+fmt.Sprintf("%#v", this.AddrType)+",\n")
	s = append(s, "Addr: "+fmt.Sprintf("%#v", this.Addr)+",\n")
	s = append(s, "CmdType: "+fmt.Sprintf("%#v", this.CmdType)+",\n")
	if this.CmdMix != nil {
		s = append(s, "CmdMix: "+fmt.Sprintf("%#v", this.CmdMix)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_7B00_ReadConcentratorOperationData_CmdOperation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&wlst_pb2.WlstSlu_7B00_ReadConcentratorOperationData_CmdOperation{")
	s = append(s, "Handle: "+fmt.Sprintf("%#v", this.Handle)+",\n")
	s = append(s, "Rate: "+fmt.Sprintf("%#v", this.Rate)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSluFe00) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&wlst_pb2.WlstSluFe00{")
	s = append(s, "CmdIdx: "+fmt.Sprintf("%#v", this.CmdIdx)+",\n")
	s = append(s, "OperationCmd: "+fmt.Sprintf("%#v", this.OperationCmd)+",\n")
	s = append(s, "FaultCount: "+fmt.Sprintf("%#v", this.FaultCount)+",\n")
	s = append(s, "SluitemIdx: "+fmt.Sprintf("%#v", this.SluitemIdx)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_7400) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&wlst_pb2.WlstSlu_7400{")
	s = append(s, "CmdIdx: "+fmt.Sprintf("%#v", this.CmdIdx)+",\n")
	s = append(s, "OperationType: "+fmt.Sprintf("%#v", this.OperationType)+",\n")
	s = append(s, "OperationOrder: "+fmt.Sprintf("%#v", this.OperationOrder)+",\n")
	s = append(s, "AddrType: "+fmt.Sprintf("%#v", this.AddrType)+",\n")
	s = append(s, "Addrs: "+fmt.Sprintf("%#v", this.Addrs)+",\n")
	s = append(s, "WeekSet: "+fmt.Sprintf("%#v", this.WeekSet)+",\n")
	s = append(s, "TimerOrOffset: "+fmt.Sprintf("%#v", this.TimerOrOffset)+",\n")
	s = append(s, "CmdType: "+fmt.Sprintf("%#v", this.CmdType)+",\n")
	s = append(s, "CmdMix: "+fmt.Sprintf("%#v", this.CmdMix)+",\n")
	if this.CmdPwm != nil {
		s = append(s, "CmdPwm: "+fmt.Sprintf("%#v", this.CmdPwm)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_7400_CmdPwm) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&wlst_pb2.WlstSlu_7400_CmdPwm{")
	s = append(s, "LoopCanDo: "+fmt.Sprintf("%#v", this.LoopCanDo)+",\n")
	s = append(s, "Scale: "+fmt.Sprintf("%#v", this.Scale)+",\n")
	s = append(s, "Rate: "+fmt.Sprintf("%#v", this.Rate)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_7C00) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&wlst_pb2.WlstSlu_7C00{")
	s = append(s, "CmdIdx: "+fmt.Sprintf("%#v", this.CmdIdx)+",\n")
	s = append(s, "AddrType: "+fmt.Sprintf("%#v", this.AddrType)+",\n")
	s = append(s, "Addr: "+fmt.Sprintf("%#v", this.Addr)+",\n")
	s = append(s, "CmdCount: "+fmt.Sprintf("%#v", this.CmdCount)+",\n")
	s = append(s, "AddOrUpdate: "+fmt.Sprintf("%#v", this.AddOrUpdate)+",\n")
	if this.OperationData != nil {
		s = append(s, "OperationData: "+fmt.Sprintf("%#v", this.OperationData)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_7C00_ConcentratorOperationData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&wlst_pb2.WlstSlu_7C00_ConcentratorOperationData{")
	s = append(s, "OperationType: "+fmt.Sprintf("%#v", this.OperationType)+",\n")
	s = append(s, "CmdType: "+fmt.Sprintf("%#v", this.CmdType)+",\n")
	s = append(s, "WeekSet: "+fmt.Sprintf("%#v", this.WeekSet)+",\n")
	s = append(s, "TimerOrOffset: "+fmt.Sprintf("%#v", this.TimerOrOffset)+",\n")
	s = append(s, "CmdMix: "+fmt.Sprintf("%#v", this.CmdMix)+",\n")
	if this.CmdPwm != nil {
		s = append(s, "CmdPwm: "+fmt.Sprintf("%#v", this.CmdPwm)+",\n")
	}
	if this.Cmd_485 != nil {
		s = append(s, "Cmd_485: "+fmt.Sprintf("%#v", this.Cmd_485)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_7C00_ConcentratorOperationData_CmdPwm) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&wlst_pb2.WlstSlu_7C00_ConcentratorOperationData_CmdPwm{")
	s = append(s, "LoopCanDo: "+fmt.Sprintf("%#v", this.LoopCanDo)+",\n")
	s = append(s, "Scale: "+fmt.Sprintf("%#v", this.Scale)+",\n")
	s = append(s, "Rate: "+fmt.Sprintf("%#v", this.Rate)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_7C00_ConcentratorOperationData_Cmd_485) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&wlst_pb2.WlstSlu_7C00_ConcentratorOperationData_Cmd_485{")
	s = append(s, "Baudrate: "+fmt.Sprintf("%#v", this.Baudrate)+",\n")
	s = append(s, "Check: "+fmt.Sprintf("%#v", this.Check)+",\n")
	s = append(s, "DataLength: "+fmt.Sprintf("%#v", this.DataLength)+",\n")
	s = append(s, "Data_485: "+fmt.Sprintf("%#v", this.Data_485)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_6F00) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&wlst_pb2.WlstSlu_6F00{")
	s = append(s, "CmdIdx: "+fmt.Sprintf("%#v", this.CmdIdx)+",\n")
	s = append(s, "AddrType: "+fmt.Sprintf("%#v", this.AddrType)+",\n")
	s = append(s, "Addr: "+fmt.Sprintf("%#v", this.Addr)+",\n")
	if this.ResetMark != nil {
		s = append(s, "ResetMark: "+fmt.Sprintf("%#v", this.ResetMark)+",\n")
	}
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WlstSlu_6F00_ResetMark) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&wlst_pb2.WlstSlu_6F00_ResetMark{")
	s = append(s, "ResetMcu: "+fmt.Sprintf("%#v", this.ResetMcu)+",\n")
	s = append(s, "ResetComm: "+fmt.Sprintf("%#v", this.ResetComm)+",\n")
	s = append(s, "InitMcuHardware: "+fmt.Sprintf("%#v", this.InitMcuHardware)+",\n")
	s = append(s, "InitRam: "+fmt.Sprintf("%#v", this.InitRam)+",\n")
	s = append(s, "ZeroEerom: "+fmt.Sprintf("%#v", this.ZeroEerom)+",\n")
	s = append(s, "ZeroCount: "+fmt.Sprintf("%#v", this.ZeroCount)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringProtocolSlu(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *WlstSluF400) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSluF400) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSluF400) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SluitemAddr != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.SluitemAddr))
		i--
		dAtA[i] = 0x20
	}
	if m.Remark != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Remark))
		i--
		dAtA[i] = 0x18
	}
	if m.Status != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_3900) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_3900) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_3900) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sunset != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Sunset))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.Sunrise != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Sunrise))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.Retry != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Retry))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.Reson != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Reson))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.Csq != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Csq))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.Ecl != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Ecl))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.Earfcn != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Earfcn))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.Txpower != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Txpower))
		i--
		dAtA[i] = 0x78
	}
	if m.Rsrq != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Rsrq))
		i--
		dAtA[i] = 0x70
	}
	if m.Pci != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Pci))
		i--
		dAtA[i] = 0x68
	}
	if m.Snr != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Snr))
		i--
		dAtA[i] = 0x60
	}
	if m.Rssi != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Rssi))
		i--
		dAtA[i] = 0x58
	}
	if m.Rsrp != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Rsrp))
		i--
		dAtA[i] = 0x50
	}
	if m.SluitemPara != nil {
		{
			size, err := m.SluitemPara.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.DateTime != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.DateTime))
		i--
		dAtA[i] = 0x40
	}
	if m.ResetCount != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.ResetCount))
		i--
		dAtA[i] = 0x38
	}
	if m.TimeFault != nil {
		{
			size, err := m.TimeFault.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.SluitemStatus != nil {
		{
			size, err := m.SluitemStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.LeakageCurrent != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.LeakageCurrent))))
		i--
		dAtA[i] = 0x21
	}
	if len(m.LightData) > 0 {
		for iNdEx := len(m.LightData) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LightData[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.ModelInfo != nil {
		{
			size, err := m.ModelInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.CmdIdx != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_3900_ModelInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_3900_ModelInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_3900_ModelInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SluitemType) > 0 {
		i -= len(m.SluitemType)
		copy(dAtA[i:], m.SluitemType)
		i = encodeVarintProtocolSlu(dAtA, i, uint64(len(m.SluitemType)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Model != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Model))
		i--
		dAtA[i] = 0x30
	}
	if m.HasTimer != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.HasTimer))
		i--
		dAtA[i] = 0x28
	}
	if m.HasTemperature != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.HasTemperature))
		i--
		dAtA[i] = 0x20
	}
	if m.HasLeakage != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.HasLeakage))
		i--
		dAtA[i] = 0x18
	}
	if m.PowerSaving != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.PowerSaving))
		i--
		dAtA[i] = 0x10
	}
	if m.SluitemLoop != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.SluitemLoop))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_3900_LightData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_3900_LightData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_3900_LightData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RatedPower != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.RatedPower))
		i--
		dAtA[i] = 0x58
	}
	if m.SluitemPowerTurnon != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.SluitemPowerTurnon))
		i--
		dAtA[i] = 0x50
	}
	if m.PowerLevel != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.PowerLevel))
		i--
		dAtA[i] = 0x48
	}
	if m.LightStatus != nil {
		{
			size, err := m.LightStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.ActiveTime != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ActiveTime))))
		i--
		dAtA[i] = 0x39
	}
	if m.Electricity != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Electricity))))
		i--
		dAtA[i] = 0x31
	}
	if m.ApparentPower != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ApparentPower))))
		i--
		dAtA[i] = 0x29
	}
	if m.ReactivePower != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ReactivePower))))
		i--
		dAtA[i] = 0x21
	}
	if m.ActivePower != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ActivePower))))
		i--
		dAtA[i] = 0x19
	}
	if m.Current != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Current))))
		i--
		dAtA[i] = 0x11
	}
	if m.Voltage != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Voltage))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_3900_LightStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_3900_LightStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_3900_LightStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WorkingOn != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.WorkingOn))
		i--
		dAtA[i] = 0x18
	}
	if m.Fault != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Fault))
		i--
		dAtA[i] = 0x10
	}
	if m.Leakage != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Leakage))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_3900_SluitemStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_3900_SluitemStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_3900_SluitemStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EnableAlarm != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.EnableAlarm))
		i--
		dAtA[i] = 0x10
	}
	if m.FlashFault != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.FlashFault))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_3900_TimeFault) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_3900_TimeFault) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_3900_TimeFault) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ClockOutAlarm != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.ClockOutAlarm))
		i--
		dAtA[i] = 0x18
	}
	if m.ClockOutFault != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.ClockOutFault))
		i--
		dAtA[i] = 0x10
	}
	if m.ClockFault != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.ClockFault))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_3900_SluitemPara) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_3900_SluitemPara) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_3900_SluitemPara) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UplinkReply != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.UplinkReply))
		i--
		dAtA[i] = 0x30
	}
	if m.AlarmInterval != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.AlarmInterval))
		i--
		dAtA[i] = 0x28
	}
	if m.IsRunning != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.IsRunning))
		i--
		dAtA[i] = 0x20
	}
	if m.HasEnableAlarm != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.HasEnableAlarm))
		i--
		dAtA[i] = 0x18
	}
	if m.Latitude != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Latitude))))
		i--
		dAtA[i] = 0x11
	}
	if m.Longitude != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Longitude))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_7800) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_7800) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_7800) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DtEnd != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.DtEnd))
		i--
		dAtA[i] = 0x30
	}
	if m.DtStart != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.DtStart))
		i--
		dAtA[i] = 0x28
	}
	if m.RecordCount != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.RecordCount))
		i--
		dAtA[i] = 0x20
	}
	if m.ClassType != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.ClassType))
		i--
		dAtA[i] = 0x18
	}
	if m.EventType != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.EventType))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSluF800) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSluF800) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSluF800) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.View_0X25) > 0 {
		for iNdEx := len(m.View_0X25) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.View_0X25[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.View_0X24) > 0 {
		for iNdEx := len(m.View_0X24) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.View_0X24[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.View_0X23) > 0 {
		for iNdEx := len(m.View_0X23) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.View_0X23[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.View_0X22) > 0 {
		for iNdEx := len(m.View_0X22) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.View_0X22[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.View_0X21) > 0 {
		for iNdEx := len(m.View_0X21) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.View_0X21[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.View_0X20) > 0 {
		for iNdEx := len(m.View_0X20) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.View_0X20[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.RecordCount != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.RecordCount))
		i--
		dAtA[i] = 0x30
	}
	if m.DataIdx != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.DataIdx))
		i--
		dAtA[i] = 0x28
	}
	if m.DataTotal != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.DataTotal))
		i--
		dAtA[i] = 0x20
	}
	if m.ClassType != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.ClassType))
		i--
		dAtA[i] = 0x18
	}
	if m.EventType != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.EventType))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSluF800_View0X20) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSluF800_View0X20) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSluF800_View0X20) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Status) > 0 {
		dAtA7 := make([]byte, len(m.Status)*10)
		var j6 int
		for _, num1 := range m.Status {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		i -= j6
		copy(dAtA[i:], dAtA7[:j6])
		i = encodeVarintProtocolSlu(dAtA, i, uint64(j6))
		i--
		dAtA[i] = 0x12
	}
	if m.DtHappen != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.DtHappen))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSluF800_View0X21) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSluF800_View0X21) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSluF800_View0X21) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OperationSource != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.OperationSource))
		i--
		dAtA[i] = 0x30
	}
	if m.Addr != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Addr))
		i--
		dAtA[i] = 0x28
	}
	if m.AddrType != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.AddrType))
		i--
		dAtA[i] = 0x20
	}
	if m.OperationOrder != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.OperationOrder))
		i--
		dAtA[i] = 0x18
	}
	if m.OperationType != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.OperationType))
		i--
		dAtA[i] = 0x10
	}
	if m.DtHappen != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.DtHappen))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSluF800_View0X23) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSluF800_View0X23) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSluF800_View0X23) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SluitemPhyinfo) > 0 {
		dAtA9 := make([]byte, len(m.SluitemPhyinfo)*10)
		var j8 int
		for _, num1 := range m.SluitemPhyinfo {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		i -= j8
		copy(dAtA[i:], dAtA9[:j8])
		i = encodeVarintProtocolSlu(dAtA, i, uint64(j8))
		i--
		dAtA[i] = 0x62
	}
	if len(m.SluitemElectricity) > 0 {
		for iNdEx := len(m.SluitemElectricity) - 1; iNdEx >= 0; iNdEx-- {
			f10 := math.Float64bits(float64(m.SluitemElectricity[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f10))
		}
		i = encodeVarintProtocolSlu(dAtA, i, uint64(len(m.SluitemElectricity)*8))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.SluitemMaxCurrent) > 0 {
		for iNdEx := len(m.SluitemMaxCurrent) - 1; iNdEx >= 0; iNdEx-- {
			f11 := math.Float64bits(float64(m.SluitemMaxCurrent[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f11))
		}
		i = encodeVarintProtocolSlu(dAtA, i, uint64(len(m.SluitemMaxCurrent)*8))
		i--
		dAtA[i] = 0x52
	}
	if m.SluitemMaxVoltage != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.SluitemMaxVoltage))))
		i--
		dAtA[i] = 0x49
	}
	if len(m.SluitemReactivePower) > 0 {
		for iNdEx := len(m.SluitemReactivePower) - 1; iNdEx >= 0; iNdEx-- {
			f12 := math.Float64bits(float64(m.SluitemReactivePower[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f12))
		}
		i = encodeVarintProtocolSlu(dAtA, i, uint64(len(m.SluitemReactivePower)*8))
		i--
		dAtA[i] = 0x42
	}
	if len(m.SluitemActivePower) > 0 {
		for iNdEx := len(m.SluitemActivePower) - 1; iNdEx >= 0; iNdEx-- {
			f13 := math.Float64bits(float64(m.SluitemActivePower[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f13))
		}
		i = encodeVarintProtocolSlu(dAtA, i, uint64(len(m.SluitemActivePower)*8))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.SluitemCurrent) > 0 {
		for iNdEx := len(m.SluitemCurrent) - 1; iNdEx >= 0; iNdEx-- {
			f14 := math.Float64bits(float64(m.SluitemCurrent[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f14))
		}
		i = encodeVarintProtocolSlu(dAtA, i, uint64(len(m.SluitemCurrent)*8))
		i--
		dAtA[i] = 0x32
	}
	if m.SluitemVoltage != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.SluitemVoltage))))
		i--
		dAtA[i] = 0x29
	}
	if len(m.SluitemStatus) > 0 {
		dAtA16 := make([]byte, len(m.SluitemStatus)*10)
		var j15 int
		for _, num1 := range m.SluitemStatus {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA16[j15] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j15++
			}
			dAtA16[j15] = uint8(num)
			j15++
		}
		i -= j15
		copy(dAtA[i:], dAtA16[:j15])
		i = encodeVarintProtocolSlu(dAtA, i, uint64(j15))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AlarmType) > 0 {
		dAtA18 := make([]byte, len(m.AlarmType)*10)
		var j17 int
		for _, num1 := range m.AlarmType {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA18[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA18[j17] = uint8(num)
			j17++
		}
		i -= j17
		copy(dAtA[i:], dAtA18[:j17])
		i = encodeVarintProtocolSlu(dAtA, i, uint64(j17))
		i--
		dAtA[i] = 0x1a
	}
	if m.Addr != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Addr))
		i--
		dAtA[i] = 0x10
	}
	if m.DtHappen != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.DtHappen))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSluEc00) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSluEc00) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSluEc00) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.WlstSlu_6B00) > 0 {
		for iNdEx := len(m.WlstSlu_6B00) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.WlstSlu_6B00[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.ReadCount != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.ReadCount))
		i--
		dAtA[i] = 0x18
	}
	if m.StartIdx != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.StartIdx))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_6B00) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_6B00) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_6B00) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CmdPwm != nil {
		{
			size, err := m.CmdPwm.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if len(m.CmdMix) > 0 {
		dAtA21 := make([]byte, len(m.CmdMix)*10)
		var j20 int
		for _, num1 := range m.CmdMix {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA21[j20] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j20++
			}
			dAtA21[j20] = uint8(num)
			j20++
		}
		i -= j20
		copy(dAtA[i:], dAtA21[:j20])
		i = encodeVarintProtocolSlu(dAtA, i, uint64(j20))
		i--
		dAtA[i] = 0x5a
	}
	if m.CmdType != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.CmdType))
		i--
		dAtA[i] = 0x50
	}
	if len(m.Addrs) > 0 {
		dAtA23 := make([]byte, len(m.Addrs)*10)
		var j22 int
		for _, num1 := range m.Addrs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA23[j22] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j22++
			}
			dAtA23[j22] = uint8(num)
			j22++
		}
		i -= j22
		copy(dAtA[i:], dAtA23[:j22])
		i = encodeVarintProtocolSlu(dAtA, i, uint64(j22))
		i--
		dAtA[i] = 0x4a
	}
	if m.AddrType != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.AddrType))
		i--
		dAtA[i] = 0x40
	}
	if m.TimerOrOffset != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.TimerOrOffset))
		i--
		dAtA[i] = 0x38
	}
	if m.OperationOrder != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.OperationOrder))
		i--
		dAtA[i] = 0x30
	}
	if m.OperationType != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.OperationType))
		i--
		dAtA[i] = 0x28
	}
	if m.DtEnd != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.DtEnd))
		i--
		dAtA[i] = 0x20
	}
	if m.DtStart != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.DtStart))
		i--
		dAtA[i] = 0x18
	}
	if m.SetIdx != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.SetIdx))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_6B00_CmdPwm) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_6B00_CmdPwm) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_6B00_CmdPwm) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Rate != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Rate))
		i--
		dAtA[i] = 0x18
	}
	if m.Scale != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Scale))
		i--
		dAtA[i] = 0x10
	}
	if len(m.LoopCanDo) > 0 {
		dAtA25 := make([]byte, len(m.LoopCanDo)*10)
		var j24 int
		for _, num1 := range m.LoopCanDo {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA25[j24] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j24++
			}
			dAtA25[j24] = uint8(num)
			j24++
		}
		i -= j24
		copy(dAtA[i:], dAtA25[:j24])
		i = encodeVarintProtocolSlu(dAtA, i, uint64(j24))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_6C00) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_6C00) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_6C00) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReadCount != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.ReadCount))
		i--
		dAtA[i] = 0x18
	}
	if m.StartIdx != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.StartIdx))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSluD000) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSluD000) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSluD000) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ver) > 0 {
		i -= len(m.Ver)
		copy(dAtA[i:], m.Ver)
		i = encodeVarintProtocolSlu(dAtA, i, uint64(len(m.Ver)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_2800) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_2800) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_2800) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Alarm != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Alarm))
		i--
		dAtA[i] = 0x10
	}
	if m.Status != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_2400) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_2400) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_2400) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.DoFlag != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.DoFlag))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_6E00) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_6E00) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_6E00) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CmdIdx != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x30
	}
	if m.PatrolCount != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.PatrolCount))
		i--
		dAtA[i] = 0x28
	}
	if m.PatrolOrder != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.PatrolOrder))
		i--
		dAtA[i] = 0x20
	}
	if m.PatrolInterval != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.PatrolInterval))
		i--
		dAtA[i] = 0x18
	}
	if m.PatrolStart != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.PatrolStart))
		i--
		dAtA[i] = 0x10
	}
	if m.DoFlag != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.DoFlag))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_3000) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_3000) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_3000) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MacAddr != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.MacAddr))
		i--
		dAtA[i] = 0x28
	}
	if m.LowerVoltageLimit != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.LowerVoltageLimit))
		i--
		dAtA[i] = 0x20
	}
	if m.UpperVoltageLimit != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.UpperVoltageLimit))
		i--
		dAtA[i] = 0x18
	}
	if m.DomainName != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.DomainName))
		i--
		dAtA[i] = 0x10
	}
	if m.Ctrls != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Ctrls))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_9A00) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_9A00) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_9A00) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DomainNameStatus) > 0 {
		dAtA27 := make([]byte, len(m.DomainNameStatus)*10)
		var j26 int
		for _, num1 := range m.DomainNameStatus {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA27[j26] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j26++
			}
			dAtA27[j26] = uint8(num)
			j26++
		}
		i -= j26
		copy(dAtA[i:], dAtA27[:j26])
		i = encodeVarintProtocolSlu(dAtA, i, uint64(j26))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WlstSluCd00) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSluCd00) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSluCd00) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AlwaysOnline != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.AlwaysOnline))
		i--
		dAtA[i] = 0x70
	}
	if m.CmdIdx != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x68
	}
	if m.Cct != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Cct))
		i--
		dAtA[i] = 0x60
	}
	if m.BluetoothMode != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.BluetoothMode))
		i--
		dAtA[i] = 0x58
	}
	if m.BluetoothPin != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.BluetoothPin))
		i--
		dAtA[i] = 0x50
	}
	if m.CarrierRoutingMode != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.CarrierRoutingMode))
		i--
		dAtA[i] = 0x48
	}
	if m.Latitude != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Latitude))))
		i--
		dAtA[i] = 0x41
	}
	if m.Longitude != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Longitude))))
		i--
		dAtA[i] = 0x39
	}
	if m.AutoMode != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.AutoMode))
		i--
		dAtA[i] = 0x30
	}
	if m.PowerRange != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.PowerRange))
		i--
		dAtA[i] = 0x28
	}
	if m.CurrentRange != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CurrentRange))))
		i--
		dAtA[i] = 0x21
	}
	if m.CommunicationChannel != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.CommunicationChannel))
		i--
		dAtA[i] = 0x18
	}
	if m.PowerFactor != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.PowerFactor))
		i--
		dAtA[i] = 0x10
	}
	if m.CommunicationFailures != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.CommunicationFailures))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_1C00) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_1C00) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_1C00) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DomainName != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.DomainName))
		i--
		dAtA[i] = 0x18
	}
	if m.SluitemIdx != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.SluitemIdx))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_1D00) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_1D00) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_1D00) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DataMark != nil {
		{
			size, err := m.DataMark.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.SluitemIdx != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.SluitemIdx))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_1D00_DataMark) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_1D00_DataMark) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_1D00_DataMark) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReadCtrldata != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.ReadCtrldata))
		i--
		dAtA[i] = 0x40
	}
	if m.ReadTimetable != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.ReadTimetable))
		i--
		dAtA[i] = 0x38
	}
	if m.ReadSunriseset != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.ReadSunriseset))
		i--
		dAtA[i] = 0x30
	}
	if m.ReadVer != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.ReadVer))
		i--
		dAtA[i] = 0x28
	}
	if m.ReadGroup != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.ReadGroup))
		i--
		dAtA[i] = 0x20
	}
	if m.ReadArgs != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.ReadArgs))
		i--
		dAtA[i] = 0x18
	}
	if m.ReadTimer != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.ReadTimer))
		i--
		dAtA[i] = 0x10
	}
	if m.ReadData != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.ReadData))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_9D00) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_9D00) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_9D00) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DataContinue != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.DataContinue))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.SetMark != nil {
		{
			size, err := m.SetMark.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.Status != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x70
	}
	if m.SluitemDataNew != nil {
		{
			size, err := m.SluitemDataNew.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if len(m.SluitemRuntime) > 0 {
		for iNdEx := len(m.SluitemRuntime) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SluitemRuntime[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if m.SluitemSunriseset != nil {
		{
			size, err := m.SluitemSunriseset.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.SluitemVer != nil {
		{
			size, err := m.SluitemVer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.SluitemGroup) > 0 {
		dAtA34 := make([]byte, len(m.SluitemGroup)*10)
		var j33 int
		for _, num1 := range m.SluitemGroup {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA34[j33] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j33++
			}
			dAtA34[j33] = uint8(num)
			j33++
		}
		i -= j33
		copy(dAtA[i:], dAtA34[:j33])
		i = encodeVarintProtocolSlu(dAtA, i, uint64(j33))
		i--
		dAtA[i] = 0x4a
	}
	if m.SluitemPara != nil {
		{
			size, err := m.SluitemPara.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.SluitemTime != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.SluitemTime))
		i--
		dAtA[i] = 0x38
	}
	if m.SluitemData != nil {
		{
			size, err := m.SluitemData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.LoopCount != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.LoopCount))
		i--
		dAtA[i] = 0x28
	}
	if m.DataMark != nil {
		{
			size, err := m.DataMark.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.SluitemIdx != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.SluitemIdx))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_9D00_SetMark) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_9D00_SetMark) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_9D00_SetMark) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SetControl != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.SetControl))
		i--
		dAtA[i] = 0x28
	}
	if m.SetReset != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.SetReset))
		i--
		dAtA[i] = 0x20
	}
	if m.SetGroup != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.SetGroup))
		i--
		dAtA[i] = 0x18
	}
	if m.SetArgs != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.SetArgs))
		i--
		dAtA[i] = 0x10
	}
	if m.SetTimer != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.SetTimer))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_9D00_SluitemData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_9D00_SluitemData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_9D00_SluitemData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ResetCount != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.ResetCount))
		i--
		dAtA[i] = 0x68
	}
	if len(m.LightStatus) > 0 {
		for iNdEx := len(m.LightStatus) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LightStatus[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if m.SluitemStatus != nil {
		{
			size, err := m.SluitemStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.TimerError != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.TimerError))
		i--
		dAtA[i] = 0x50
	}
	if m.LeakageCurrent != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.LeakageCurrent))))
		i--
		dAtA[i] = 0x49
	}
	if m.Temperature != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Temperature))
		i--
		dAtA[i] = 0x40
	}
	if len(m.TotalElectricity) > 0 {
		for iNdEx := len(m.TotalElectricity) - 1; iNdEx >= 0; iNdEx-- {
			f39 := math.Float64bits(float64(m.TotalElectricity[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f39))
		}
		i = encodeVarintProtocolSlu(dAtA, i, uint64(len(m.TotalElectricity)*8))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.MaxCurrent) > 0 {
		for iNdEx := len(m.MaxCurrent) - 1; iNdEx >= 0; iNdEx-- {
			f40 := math.Float64bits(float64(m.MaxCurrent[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f40))
		}
		i = encodeVarintProtocolSlu(dAtA, i, uint64(len(m.MaxCurrent)*8))
		i--
		dAtA[i] = 0x32
	}
	if m.MaxVoltage != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MaxVoltage))))
		i--
		dAtA[i] = 0x29
	}
	if len(m.ReactivePower) > 0 {
		for iNdEx := len(m.ReactivePower) - 1; iNdEx >= 0; iNdEx-- {
			f41 := math.Float64bits(float64(m.ReactivePower[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f41))
		}
		i = encodeVarintProtocolSlu(dAtA, i, uint64(len(m.ReactivePower)*8))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ActivePower) > 0 {
		for iNdEx := len(m.ActivePower) - 1; iNdEx >= 0; iNdEx-- {
			f42 := math.Float64bits(float64(m.ActivePower[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f42))
		}
		i = encodeVarintProtocolSlu(dAtA, i, uint64(len(m.ActivePower)*8))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Current) > 0 {
		for iNdEx := len(m.Current) - 1; iNdEx >= 0; iNdEx-- {
			f43 := math.Float64bits(float64(m.Current[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f43))
		}
		i = encodeVarintProtocolSlu(dAtA, i, uint64(len(m.Current)*8))
		i--
		dAtA[i] = 0x12
	}
	if m.Voltage != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Voltage))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_9D00_SluitemDataNew) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_9D00_SluitemDataNew) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_9D00_SluitemDataNew) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EnergySaving) > 0 {
		dAtA45 := make([]byte, len(m.EnergySaving)*10)
		var j44 int
		for _, num1 := range m.EnergySaving {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA45[j44] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j44++
			}
			dAtA45[j44] = uint8(num)
			j44++
		}
		i -= j44
		copy(dAtA[i:], dAtA45[:j44])
		i = encodeVarintProtocolSlu(dAtA, i, uint64(j44))
		i--
		dAtA[i] = 0x72
	}
	if m.ResetCount != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.ResetCount))
		i--
		dAtA[i] = 0x68
	}
	if len(m.LightStatus) > 0 {
		for iNdEx := len(m.LightStatus) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LightStatus[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if m.SluitemStatus != nil {
		{
			size, err := m.SluitemStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.TimerError != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.TimerError))
		i--
		dAtA[i] = 0x50
	}
	if m.LeakageCurrent != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.LeakageCurrent))))
		i--
		dAtA[i] = 0x49
	}
	if len(m.TotalElectricity) > 0 {
		for iNdEx := len(m.TotalElectricity) - 1; iNdEx >= 0; iNdEx-- {
			f47 := math.Float64bits(float64(m.TotalElectricity[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f47))
		}
		i = encodeVarintProtocolSlu(dAtA, i, uint64(len(m.TotalElectricity)*8))
		i--
		dAtA[i] = 0x3a
	}
	if m.Phase != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Phase))
		i--
		dAtA[i] = 0x28
	}
	if len(m.RunTime) > 0 {
		dAtA49 := make([]byte, len(m.RunTime)*10)
		var j48 int
		for _, num1 := range m.RunTime {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA49[j48] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j48++
			}
			dAtA49[j48] = uint8(num)
			j48++
		}
		i -= j48
		copy(dAtA[i:], dAtA49[:j48])
		i = encodeVarintProtocolSlu(dAtA, i, uint64(j48))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ActivePower) > 0 {
		for iNdEx := len(m.ActivePower) - 1; iNdEx >= 0; iNdEx-- {
			f50 := math.Float64bits(float64(m.ActivePower[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f50))
		}
		i = encodeVarintProtocolSlu(dAtA, i, uint64(len(m.ActivePower)*8))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Current) > 0 {
		for iNdEx := len(m.Current) - 1; iNdEx >= 0; iNdEx-- {
			f51 := math.Float64bits(float64(m.Current[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f51))
		}
		i = encodeVarintProtocolSlu(dAtA, i, uint64(len(m.Current)*8))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Voltage) > 0 {
		for iNdEx := len(m.Voltage) - 1; iNdEx >= 0; iNdEx-- {
			f52 := math.Float64bits(float64(m.Voltage[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f52))
		}
		i = encodeVarintProtocolSlu(dAtA, i, uint64(len(m.Voltage)*8))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_9D00_SluitemPara) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_9D00_SluitemPara) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_9D00_SluitemPara) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UplinkReply != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.UplinkReply))
		i--
		dAtA[i] = 0x50
	}
	if m.UplinkTimer != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.UplinkTimer))
		i--
		dAtA[i] = 0x48
	}
	if len(m.RatedPower) > 0 {
		dAtA54 := make([]byte, len(m.RatedPower)*10)
		var j53 int
		for _, num1 := range m.RatedPower {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA54[j53] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j53++
			}
			dAtA54[j53] = uint8(num)
			j53++
		}
		i -= j53
		copy(dAtA[i:], dAtA54[:j53])
		i = encodeVarintProtocolSlu(dAtA, i, uint64(j53))
		i--
		dAtA[i] = 0x42
	}
	if m.Latitude != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Latitude))))
		i--
		dAtA[i] = 0x39
	}
	if m.Longitude != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Longitude))))
		i--
		dAtA[i] = 0x31
	}
	if len(m.SluitemVector) > 0 {
		dAtA56 := make([]byte, len(m.SluitemVector)*10)
		var j55 int
		for _, num1 := range m.SluitemVector {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA56[j55] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j55++
			}
			dAtA56[j55] = uint8(num)
			j55++
		}
		i -= j55
		copy(dAtA[i:], dAtA56[:j55])
		i = encodeVarintProtocolSlu(dAtA, i, uint64(j55))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SluitemPowerTurnon) > 0 {
		dAtA58 := make([]byte, len(m.SluitemPowerTurnon)*10)
		var j57 int
		for _, num1 := range m.SluitemPowerTurnon {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA58[j57] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j57++
			}
			dAtA58[j57] = uint8(num)
			j57++
		}
		i -= j57
		copy(dAtA[i:], dAtA58[:j57])
		i = encodeVarintProtocolSlu(dAtA, i, uint64(j57))
		i--
		dAtA[i] = 0x22
	}
	if m.SluitemEnableAlarm != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.SluitemEnableAlarm))
		i--
		dAtA[i] = 0x18
	}
	if m.SluitemStatus != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.SluitemStatus))
		i--
		dAtA[i] = 0x10
	}
	if m.DomainName != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.DomainName))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_9D00_SluitemVer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_9D00_SluitemVer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_9D00_SluitemVer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ver) > 0 {
		i -= len(m.Ver)
		copy(dAtA[i:], m.Ver)
		i = encodeVarintProtocolSlu(dAtA, i, uint64(len(m.Ver)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.SluitemType) > 0 {
		i -= len(m.SluitemType)
		copy(dAtA[i:], m.SluitemType)
		i = encodeVarintProtocolSlu(dAtA, i, uint64(len(m.SluitemType)))
		i--
		dAtA[i] = 0x32
	}
	if m.TimerModule != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.TimerModule))
		i--
		dAtA[i] = 0x28
	}
	if m.TemperatureModule != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.TemperatureModule))
		i--
		dAtA[i] = 0x20
	}
	if m.ElectricLeakageModule != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.ElectricLeakageModule))
		i--
		dAtA[i] = 0x18
	}
	if m.EnergySaving != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.EnergySaving))
		i--
		dAtA[i] = 0x10
	}
	if m.SluitemLoop != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.SluitemLoop))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_9D00_SluitemSunriseset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_9D00_SluitemSunriseset) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_9D00_SluitemSunriseset) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sunset != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Sunset))
		i--
		dAtA[i] = 0x10
	}
	if m.Sunrise != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Sunrise))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_9D00_SluitemRuntime) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_9D00_SluitemRuntime) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_9D00_SluitemRuntime) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Rs485Check != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Rs485Check))
		i--
		dAtA[i] = 0x60
	}
	if m.Rs485Baudrate != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Rs485Baudrate))
		i--
		dAtA[i] = 0x58
	}
	if m.PwmBaudrate != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.PwmBaudrate))
		i--
		dAtA[i] = 0x50
	}
	if m.PwmPower != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.PwmPower))
		i--
		dAtA[i] = 0x48
	}
	if len(m.PwmLoop) > 0 {
		dAtA60 := make([]byte, len(m.PwmLoop)*10)
		var j59 int
		for _, num1 := range m.PwmLoop {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA60[j59] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j59++
			}
			dAtA60[j59] = uint8(num)
			j59++
		}
		i -= j59
		copy(dAtA[i:], dAtA60[:j59])
		i = encodeVarintProtocolSlu(dAtA, i, uint64(j59))
		i--
		dAtA[i] = 0x42
	}
	if len(m.RelayOperate) > 0 {
		dAtA62 := make([]byte, len(m.RelayOperate)*10)
		var j61 int
		for _, num1 := range m.RelayOperate {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA62[j61] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j61++
			}
			dAtA62[j61] = uint8(num)
			j61++
		}
		i -= j61
		copy(dAtA[i:], dAtA62[:j61])
		i = encodeVarintProtocolSlu(dAtA, i, uint64(j61))
		i--
		dAtA[i] = 0x3a
	}
	if m.OperateOffset != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.OperateOffset))
		i--
		dAtA[i] = 0x30
	}
	if m.OperateTime != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.OperateTime))
		i--
		dAtA[i] = 0x28
	}
	if len(m.DateEnable) > 0 {
		dAtA64 := make([]byte, len(m.DateEnable)*10)
		var j63 int
		for _, num1 := range m.DateEnable {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA64[j63] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j63++
			}
			dAtA64[j63] = uint8(num)
			j63++
		}
		i -= j63
		copy(dAtA[i:], dAtA64[:j63])
		i = encodeVarintProtocolSlu(dAtA, i, uint64(j63))
		i--
		dAtA[i] = 0x22
	}
	if m.OperateType != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.OperateType))
		i--
		dAtA[i] = 0x18
	}
	if m.OutputType != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.OutputType))
		i--
		dAtA[i] = 0x10
	}
	if m.DataType != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.DataType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSluF000) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSluF000) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSluF000) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ResetMark != nil {
		{
			size, err := m.ResetMark.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.CmdIdx != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSluF000_ResetMark) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSluF000_ResetMark) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSluF000_ResetMark) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ClearArgs != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.ClearArgs))
		i--
		dAtA[i] = 0x40
	}
	if m.ClearData != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.ClearData))
		i--
		dAtA[i] = 0x38
	}
	if m.InitAll != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.InitAll))
		i--
		dAtA[i] = 0x30
	}
	if m.ResetCarrier != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.ResetCarrier))
		i--
		dAtA[i] = 0x28
	}
	if m.SoftResetZigbee != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.SoftResetZigbee))
		i--
		dAtA[i] = 0x20
	}
	if m.HardResetZigbee != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.HardResetZigbee))
		i--
		dAtA[i] = 0x18
	}
	if m.ResetConcentrator != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.ResetConcentrator))
		i--
		dAtA[i] = 0x10
	}
	if m.ClearTask != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.ClearTask))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSluF100) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSluF100) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSluF100) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TimerStatus != nil {
		{
			size, err := m.TimerStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.ForceTimer != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.ForceTimer))
		i--
		dAtA[i] = 0x20
	}
	if m.DateTime != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.DateTime))
		i--
		dAtA[i] = 0x18
	}
	if m.OptMark != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.OptMark))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSluF100_TimerStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSluF100_TimerStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSluF100_TimerStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TimeFault != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.TimeFault))
		i--
		dAtA[i] = 0x18
	}
	if m.TimerError != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.TimerError))
		i--
		dAtA[i] = 0x10
	}
	if m.DtformatError != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.DtformatError))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSluF200) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSluF200) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSluF200) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x30
	}
	if len(m.SluitemData) > 0 {
		for iNdEx := len(m.SluitemData) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SluitemData[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.DataMark != nil {
		{
			size, err := m.DataMark.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.SluitemCount != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.SluitemCount))
		i--
		dAtA[i] = 0x18
	}
	if m.SluitemIdx != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.SluitemIdx))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSluF200_DataMark) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSluF200_DataMark) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSluF200_DataMark) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SetData != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.SetData))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.LoopCount != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.LoopCount))
		i--
		dAtA[i] = 0x50
	}
	if m.RatedPower != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.RatedPower))
		i--
		dAtA[i] = 0x48
	}
	if m.Vector != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Vector))
		i--
		dAtA[i] = 0x40
	}
	if m.RunStatus != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.RunStatus))
		i--
		dAtA[i] = 0x38
	}
	if m.PowerOnStatus != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.PowerOnStatus))
		i--
		dAtA[i] = 0x30
	}
	if m.Limit != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x28
	}
	if m.Order != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Order))
		i--
		dAtA[i] = 0x20
	}
	if m.Route != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Route))
		i--
		dAtA[i] = 0x18
	}
	if m.Barcode != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Barcode))
		i--
		dAtA[i] = 0x10
	}
	if m.Group != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Group))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSluF200_ControllerData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSluF200_ControllerData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSluF200_ControllerData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UplinkReply != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.UplinkReply))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.UplinkTimer != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.UplinkTimer))
		i--
		dAtA[i] = 0x78
	}
	if m.Latitude != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Latitude))))
		i--
		dAtA[i] = 0x71
	}
	if m.Longitude != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Longitude))))
		i--
		dAtA[i] = 0x69
	}
	if m.LoopCount != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.LoopCount))
		i--
		dAtA[i] = 0x60
	}
	if len(m.RatedPower) > 0 {
		dAtA69 := make([]byte, len(m.RatedPower)*10)
		var j68 int
		for _, num1 := range m.RatedPower {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA69[j68] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j68++
			}
			dAtA69[j68] = uint8(num)
			j68++
		}
		i -= j68
		copy(dAtA[i:], dAtA69[:j68])
		i = encodeVarintProtocolSlu(dAtA, i, uint64(j68))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.SluitemVector) > 0 {
		dAtA71 := make([]byte, len(m.SluitemVector)*10)
		var j70 int
		for _, num1 := range m.SluitemVector {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA71[j70] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j70++
			}
			dAtA71[j70] = uint8(num)
			j70++
		}
		i -= j70
		copy(dAtA[i:], dAtA71[:j70])
		i = encodeVarintProtocolSlu(dAtA, i, uint64(j70))
		i--
		dAtA[i] = 0x52
	}
	if m.SluitemEnableAlarm != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.SluitemEnableAlarm))
		i--
		dAtA[i] = 0x48
	}
	if m.SluitemStatus != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.SluitemStatus))
		i--
		dAtA[i] = 0x40
	}
	if len(m.SluitemPowerTurnon) > 0 {
		dAtA73 := make([]byte, len(m.SluitemPowerTurnon)*10)
		var j72 int
		for _, num1 := range m.SluitemPowerTurnon {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA73[j72] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j72++
			}
			dAtA73[j72] = uint8(num)
			j72++
		}
		i -= j72
		copy(dAtA[i:], dAtA73[:j72])
		i = encodeVarintProtocolSlu(dAtA, i, uint64(j72))
		i--
		dAtA[i] = 0x3a
	}
	if m.LowerPowerLimit != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.LowerPowerLimit))
		i--
		dAtA[i] = 0x30
	}
	if m.UpperPowerLimit != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.UpperPowerLimit))
		i--
		dAtA[i] = 0x28
	}
	if m.SluitemOrder != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.SluitemOrder))
		i--
		dAtA[i] = 0x20
	}
	if len(m.SluitemRoute) > 0 {
		dAtA75 := make([]byte, len(m.SluitemRoute)*10)
		var j74 int
		for _, num1 := range m.SluitemRoute {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA75[j74] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j74++
			}
			dAtA75[j74] = uint8(num)
			j74++
		}
		i -= j74
		copy(dAtA[i:], dAtA75[:j74])
		i = encodeVarintProtocolSlu(dAtA, i, uint64(j74))
		i--
		dAtA[i] = 0x1a
	}
	if m.SluitemIdx != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.SluitemIdx))
		i--
		dAtA[i] = 0x10
	}
	if len(m.SluitemGroup) > 0 {
		dAtA77 := make([]byte, len(m.SluitemGroup)*10)
		var j76 int
		for _, num1 := range m.SluitemGroup {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA77[j76] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j76++
			}
			dAtA77[j76] = uint8(num)
			j76++
		}
		i -= j76
		copy(dAtA[i:], dAtA77[:j76])
		i = encodeVarintProtocolSlu(dAtA, i, uint64(j76))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_7300) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_7300) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_7300) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SluitemAddrs) > 0 {
		dAtA79 := make([]byte, len(m.SluitemAddrs)*10)
		var j78 int
		for _, num1 := range m.SluitemAddrs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA79[j78] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j78++
			}
			dAtA79[j78] = uint8(num)
			j78++
		}
		i -= j78
		copy(dAtA[i:], dAtA79[:j78])
		i = encodeVarintProtocolSlu(dAtA, i, uint64(j78))
		i--
		dAtA[i] = 0x52
	}
	if len(m.SluitemPhyinfo) > 0 {
		for iNdEx := len(m.SluitemPhyinfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SluitemPhyinfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.AssistSluitemData) > 0 {
		for iNdEx := len(m.AssistSluitemData) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AssistSluitemData[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.UnknowSluitem) > 0 {
		for iNdEx := len(m.UnknowSluitem) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UnknowSluitem[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.BaseSluitemData) > 0 {
		for iNdEx := len(m.BaseSluitemData) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BaseSluitemData[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.ConcentratorData != nil {
		{
			size, err := m.ConcentratorData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.DataMark != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.DataMark))
		i--
		dAtA[i] = 0x20
	}
	if m.SluitemCount != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.SluitemCount))
		i--
		dAtA[i] = 0x18
	}
	if m.SluitemStart != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.SluitemStart))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_7300_ConcentratorData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_7300_ConcentratorData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_7300_ConcentratorData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CommunicationChannel != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.CommunicationChannel))
		i--
		dAtA[i] = 0x30
	}
	if m.UnknowSluitemCount != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.UnknowSluitemCount))
		i--
		dAtA[i] = 0x28
	}
	if m.HardwareStatus != nil {
		{
			size, err := m.HardwareStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.ArgsStatus != nil {
		{
			size, err := m.ArgsStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.RunStatus != nil {
		{
			size, err := m.RunStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ResetCount) > 0 {
		dAtA85 := make([]byte, len(m.ResetCount)*10)
		var j84 int
		for _, num1 := range m.ResetCount {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA85[j84] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j84++
			}
			dAtA85[j84] = uint8(num)
			j84++
		}
		i -= j84
		copy(dAtA[i:], dAtA85[:j84])
		i = encodeVarintProtocolSlu(dAtA, i, uint64(j84))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_7300_ConcentratorData_RunStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_7300_ConcentratorData_RunStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_7300_ConcentratorData_RunStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EnableAutochk != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.EnableAutochk))
		i--
		dAtA[i] = 0x28
	}
	if m.EnableGprs != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.EnableGprs))
		i--
		dAtA[i] = 0x20
	}
	if m.PoweronMark != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.PoweronMark))
		i--
		dAtA[i] = 0x18
	}
	if m.EnableAlarm != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.EnableAlarm))
		i--
		dAtA[i] = 0x10
	}
	if m.Offline != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Offline))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_7300_ConcentratorData_ArgsStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_7300_ConcentratorData_ArgsStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_7300_ConcentratorData_ArgsStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TurnOnoffError != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.TurnOnoffError))
		i--
		dAtA[i] = 0x18
	}
	if m.SluitemArgsError != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.SluitemArgsError))
		i--
		dAtA[i] = 0x10
	}
	if m.ConcentratorArgsError != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.ConcentratorArgsError))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_7300_ConcentratorData_HardwareStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_7300_ConcentratorData_HardwareStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_7300_ConcentratorData_HardwareStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TimerError != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.TimerError))
		i--
		dAtA[i] = 0x28
	}
	if m.BluetoothError != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.BluetoothError))
		i--
		dAtA[i] = 0x20
	}
	if m.FramError != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.FramError))
		i--
		dAtA[i] = 0x18
	}
	if m.CarrierError != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.CarrierError))
		i--
		dAtA[i] = 0x10
	}
	if m.ZigbeeError != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.ZigbeeError))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_7300_BaseSluitemData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_7300_BaseSluitemData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_7300_BaseSluitemData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SluitemLoop != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.SluitemLoop))
		i--
		dAtA[i] = 0x30
	}
	if len(m.LightData) > 0 {
		for iNdEx := len(m.LightData) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LightData[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.LightStatus) > 0 {
		for iNdEx := len(m.LightStatus) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LightStatus[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Temperature != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Temperature))
		i--
		dAtA[i] = 0x18
	}
	if m.SluitemStatus != nil {
		{
			size, err := m.SluitemStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.DateTime != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.DateTime))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_7300_BaseSluitemData_SluitemStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_7300_BaseSluitemData_SluitemStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_7300_BaseSluitemData_SluitemStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TemperatureSensor != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.TemperatureSensor))
		i--
		dAtA[i] = 0x38
	}
	if m.EepromError != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.EepromError))
		i--
		dAtA[i] = 0x30
	}
	if m.OffLine != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.OffLine))
		i--
		dAtA[i] = 0x28
	}
	if m.NoAlarm != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.NoAlarm))
		i--
		dAtA[i] = 0x20
	}
	if m.WorkingArgs != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.WorkingArgs))
		i--
		dAtA[i] = 0x18
	}
	if m.Adjust != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Adjust))
		i--
		dAtA[i] = 0x10
	}
	if m.Status != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_7300_BaseSluitemData_LightStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_7300_BaseSluitemData_LightStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_7300_BaseSluitemData_LightStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WorkingOn != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.WorkingOn))
		i--
		dAtA[i] = 0x20
	}
	if m.Fault != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Fault))
		i--
		dAtA[i] = 0x18
	}
	if m.Leakage != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Leakage))
		i--
		dAtA[i] = 0x10
	}
	if m.PowerStatus != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.PowerStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_7300_BaseSluitemData_LightData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_7300_BaseSluitemData_LightData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_7300_BaseSluitemData_LightData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PowerLevel != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.PowerLevel))
		i--
		dAtA[i] = 0x30
	}
	if m.ActiveTime != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ActiveTime))))
		i--
		dAtA[i] = 0x29
	}
	if m.Electricity != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Electricity))))
		i--
		dAtA[i] = 0x21
	}
	if m.ActivePower != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ActivePower))))
		i--
		dAtA[i] = 0x19
	}
	if m.Current != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Current))))
		i--
		dAtA[i] = 0x11
	}
	if m.Voltage != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Voltage))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_7300_UnknowSluitem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_7300_UnknowSluitem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_7300_UnknowSluitem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ModelInfo != nil {
		{
			size, err := m.ModelInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.SluitemIdx != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.SluitemIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_7300_AssistSluitemData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_7300_AssistSluitemData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_7300_AssistSluitemData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SluitemLoop != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.SluitemLoop))
		i--
		dAtA[i] = 0x20
	}
	if len(m.LightData) > 0 {
		for iNdEx := len(m.LightData) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LightData[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.LeakageCurrent != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.LeakageCurrent))))
		i--
		dAtA[i] = 0x11
	}
	if m.DateTime != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.DateTime))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_7300_AssistSluitemData_LightData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_7300_AssistSluitemData_LightData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_7300_AssistSluitemData_LightData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Electricity != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Electricity))))
		i--
		dAtA[i] = 0x19
	}
	if m.MaxCurrent != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MaxCurrent))))
		i--
		dAtA[i] = 0x11
	}
	if m.MaxVoltage != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MaxVoltage))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_7300_SluitemPhyinfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_7300_SluitemPhyinfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_7300_SluitemPhyinfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ModelInfo != nil {
		{
			size, err := m.ModelInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.AllCommunicate != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.AllCommunicate))
		i--
		dAtA[i] = 0x28
	}
	if m.UsefulCommunicate != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.UsefulCommunicate))
		i--
		dAtA[i] = 0x20
	}
	if m.Phase != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Phase))
		i--
		dAtA[i] = 0x18
	}
	if m.Routing != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Routing))
		i--
		dAtA[i] = 0x10
	}
	if m.SignalStrength != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.SignalStrength))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_7300_ModelInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_7300_ModelInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_7300_ModelInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SluitemType) > 0 {
		i -= len(m.SluitemType)
		copy(dAtA[i:], m.SluitemType)
		i = encodeVarintProtocolSlu(dAtA, i, uint64(len(m.SluitemType)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Model != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Model))
		i--
		dAtA[i] = 0x30
	}
	if m.HasTimer != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.HasTimer))
		i--
		dAtA[i] = 0x28
	}
	if m.HasTemperature != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.HasTemperature))
		i--
		dAtA[i] = 0x20
	}
	if m.HasLeakage != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.HasLeakage))
		i--
		dAtA[i] = 0x18
	}
	if m.PowerSaving != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.PowerSaving))
		i--
		dAtA[i] = 0x10
	}
	if m.SluitemLoop != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.SluitemLoop))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSluF900) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSluF900) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSluF900) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SetDomainResult != nil {
		{
			size, err := m.SetDomainResult.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.BluetoothApply != nil {
		{
			size, err := m.BluetoothApply.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.SluitemStatusAlarm) > 0 {
		for iNdEx := len(m.SluitemStatusAlarm) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SluitemStatusAlarm[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.ErrorCtrls) > 0 {
		dAtA92 := make([]byte, len(m.ErrorCtrls)*10)
		var j91 int
		for _, num1 := range m.ErrorCtrls {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA92[j91] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j91++
			}
			dAtA92[j91] = uint8(num)
			j91++
		}
		i -= j91
		copy(dAtA[i:], dAtA92[:j91])
		i = encodeVarintProtocolSlu(dAtA, i, uint64(j91))
		i--
		dAtA[i] = 0x22
	}
	if m.ConcentratorData != nil {
		{
			size, err := m.ConcentratorData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.AlarmType != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.AlarmType))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSluF900_SluitemStatusAlarm) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSluF900_SluitemStatusAlarm) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSluF900_SluitemStatusAlarm) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LightStatus) > 0 {
		for iNdEx := len(m.LightStatus) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LightStatus[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.SluitemStatus != nil {
		{
			size, err := m.SluitemStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.SluitemLoop != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.SluitemLoop))
		i--
		dAtA[i] = 0x10
	}
	if m.SluitemIdx != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.SluitemIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSluF900_BluetoothApply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSluF900_BluetoothApply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSluF900_BluetoothApply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CheckCode) > 0 {
		i -= len(m.CheckCode)
		copy(dAtA[i:], m.CheckCode)
		i = encodeVarintProtocolSlu(dAtA, i, uint64(len(m.CheckCode)))
		i--
		dAtA[i] = 0x12
	}
	if m.SimNumber != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.SimNumber))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSluF900_SetDomainResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSluF900_SetDomainResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSluF900_SetDomainResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SetSuccess) > 0 {
		dAtA96 := make([]byte, len(m.SetSuccess)*10)
		var j95 int
		for _, num1 := range m.SetSuccess {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA96[j95] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j95++
			}
			dAtA96[j95] = uint8(num)
			j95++
		}
		i -= j95
		copy(dAtA[i:], dAtA96[:j95])
		i = encodeVarintProtocolSlu(dAtA, i, uint64(j95))
		i--
		dAtA[i] = 0x12
	}
	if m.DomainName != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.DomainName))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_7B00) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_7B00) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_7B00) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OperationData) > 0 {
		for iNdEx := len(m.OperationData) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OperationData[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.DataCount != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.DataCount))
		i--
		dAtA[i] = 0x18
	}
	if m.SluitemIdx != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.SluitemIdx))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_7B00_ReadConcentratorOperationData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_7B00_ReadConcentratorOperationData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_7B00_ReadConcentratorOperationData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CmdMix) > 0 {
		for iNdEx := len(m.CmdMix) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CmdMix[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.CmdType != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.CmdType))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Addr) > 0 {
		dAtA98 := make([]byte, len(m.Addr)*10)
		var j97 int
		for _, num1 := range m.Addr {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA98[j97] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j97++
			}
			dAtA98[j97] = uint8(num)
			j97++
		}
		i -= j97
		copy(dAtA[i:], dAtA98[:j97])
		i = encodeVarintProtocolSlu(dAtA, i, uint64(j97))
		i--
		dAtA[i] = 0x32
	}
	if m.AddrType != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.AddrType))
		i--
		dAtA[i] = 0x28
	}
	if m.TimerOrOffset != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.TimerOrOffset))
		i--
		dAtA[i] = 0x20
	}
	if len(m.WeekSet) > 0 {
		dAtA100 := make([]byte, len(m.WeekSet)*10)
		var j99 int
		for _, num1 := range m.WeekSet {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA100[j99] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j99++
			}
			dAtA100[j99] = uint8(num)
			j99++
		}
		i -= j99
		copy(dAtA[i:], dAtA100[:j99])
		i = encodeVarintProtocolSlu(dAtA, i, uint64(j99))
		i--
		dAtA[i] = 0x1a
	}
	if m.OperationType != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.OperationType))
		i--
		dAtA[i] = 0x10
	}
	if m.OperationOrder != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.OperationOrder))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_7B00_ReadConcentratorOperationData_CmdOperation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_7B00_ReadConcentratorOperationData_CmdOperation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_7B00_ReadConcentratorOperationData_CmdOperation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Rate != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Rate))
		i--
		dAtA[i] = 0x10
	}
	if m.Handle != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Handle))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSluFe00) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSluFe00) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSluFe00) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SluitemIdx) > 0 {
		dAtA102 := make([]byte, len(m.SluitemIdx)*10)
		var j101 int
		for _, num1 := range m.SluitemIdx {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA102[j101] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j101++
			}
			dAtA102[j101] = uint8(num)
			j101++
		}
		i -= j101
		copy(dAtA[i:], dAtA102[:j101])
		i = encodeVarintProtocolSlu(dAtA, i, uint64(j101))
		i--
		dAtA[i] = 0x22
	}
	if m.FaultCount != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.FaultCount))
		i--
		dAtA[i] = 0x18
	}
	if m.OperationCmd != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.OperationCmd))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_7400) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_7400) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_7400) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CmdPwm != nil {
		{
			size, err := m.CmdPwm.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if len(m.CmdMix) > 0 {
		dAtA105 := make([]byte, len(m.CmdMix)*10)
		var j104 int
		for _, num1 := range m.CmdMix {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA105[j104] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j104++
			}
			dAtA105[j104] = uint8(num)
			j104++
		}
		i -= j104
		copy(dAtA[i:], dAtA105[:j104])
		i = encodeVarintProtocolSlu(dAtA, i, uint64(j104))
		i--
		dAtA[i] = 0x52
	}
	if m.CmdType != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.CmdType))
		i--
		dAtA[i] = 0x48
	}
	if m.TimerOrOffset != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.TimerOrOffset))
		i--
		dAtA[i] = 0x40
	}
	if len(m.WeekSet) > 0 {
		dAtA107 := make([]byte, len(m.WeekSet)*10)
		var j106 int
		for _, num1 := range m.WeekSet {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA107[j106] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j106++
			}
			dAtA107[j106] = uint8(num)
			j106++
		}
		i -= j106
		copy(dAtA[i:], dAtA107[:j106])
		i = encodeVarintProtocolSlu(dAtA, i, uint64(j106))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Addrs) > 0 {
		dAtA109 := make([]byte, len(m.Addrs)*10)
		var j108 int
		for _, num1 := range m.Addrs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA109[j108] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j108++
			}
			dAtA109[j108] = uint8(num)
			j108++
		}
		i -= j108
		copy(dAtA[i:], dAtA109[:j108])
		i = encodeVarintProtocolSlu(dAtA, i, uint64(j108))
		i--
		dAtA[i] = 0x32
	}
	if m.AddrType != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.AddrType))
		i--
		dAtA[i] = 0x20
	}
	if m.OperationOrder != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.OperationOrder))
		i--
		dAtA[i] = 0x18
	}
	if m.OperationType != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.OperationType))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_7400_CmdPwm) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_7400_CmdPwm) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_7400_CmdPwm) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Rate != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Rate))
		i--
		dAtA[i] = 0x18
	}
	if m.Scale != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Scale))
		i--
		dAtA[i] = 0x10
	}
	if len(m.LoopCanDo) > 0 {
		dAtA111 := make([]byte, len(m.LoopCanDo)*10)
		var j110 int
		for _, num1 := range m.LoopCanDo {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA111[j110] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j110++
			}
			dAtA111[j110] = uint8(num)
			j110++
		}
		i -= j110
		copy(dAtA[i:], dAtA111[:j110])
		i = encodeVarintProtocolSlu(dAtA, i, uint64(j110))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_7C00) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_7C00) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_7C00) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OperationData) > 0 {
		for iNdEx := len(m.OperationData) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OperationData[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.AddOrUpdate != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.AddOrUpdate))
		i--
		dAtA[i] = 0x28
	}
	if m.CmdCount != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.CmdCount))
		i--
		dAtA[i] = 0x20
	}
	if m.Addr != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Addr))
		i--
		dAtA[i] = 0x18
	}
	if m.AddrType != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.AddrType))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_7C00_ConcentratorOperationData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_7C00_ConcentratorOperationData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_7C00_ConcentratorOperationData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Cmd_485 != nil {
		{
			size, err := m.Cmd_485.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.CmdPwm != nil {
		{
			size, err := m.CmdPwm.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.CmdMix) > 0 {
		dAtA115 := make([]byte, len(m.CmdMix)*10)
		var j114 int
		for _, num1 := range m.CmdMix {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA115[j114] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j114++
			}
			dAtA115[j114] = uint8(num)
			j114++
		}
		i -= j114
		copy(dAtA[i:], dAtA115[:j114])
		i = encodeVarintProtocolSlu(dAtA, i, uint64(j114))
		i--
		dAtA[i] = 0x2a
	}
	if m.TimerOrOffset != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.TimerOrOffset))
		i--
		dAtA[i] = 0x20
	}
	if len(m.WeekSet) > 0 {
		dAtA117 := make([]byte, len(m.WeekSet)*10)
		var j116 int
		for _, num1 := range m.WeekSet {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA117[j116] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j116++
			}
			dAtA117[j116] = uint8(num)
			j116++
		}
		i -= j116
		copy(dAtA[i:], dAtA117[:j116])
		i = encodeVarintProtocolSlu(dAtA, i, uint64(j116))
		i--
		dAtA[i] = 0x1a
	}
	if m.CmdType != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.CmdType))
		i--
		dAtA[i] = 0x10
	}
	if m.OperationType != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.OperationType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_7C00_ConcentratorOperationData_CmdPwm) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_7C00_ConcentratorOperationData_CmdPwm) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_7C00_ConcentratorOperationData_CmdPwm) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Rate != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Rate))
		i--
		dAtA[i] = 0x18
	}
	if m.Scale != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Scale))
		i--
		dAtA[i] = 0x10
	}
	if len(m.LoopCanDo) > 0 {
		dAtA119 := make([]byte, len(m.LoopCanDo)*10)
		var j118 int
		for _, num1 := range m.LoopCanDo {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA119[j118] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j118++
			}
			dAtA119[j118] = uint8(num)
			j118++
		}
		i -= j118
		copy(dAtA[i:], dAtA119[:j118])
		i = encodeVarintProtocolSlu(dAtA, i, uint64(j118))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_7C00_ConcentratorOperationData_Cmd_485) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_7C00_ConcentratorOperationData_Cmd_485) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_7C00_ConcentratorOperationData_Cmd_485) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data_485) > 0 {
		i -= len(m.Data_485)
		copy(dAtA[i:], m.Data_485)
		i = encodeVarintProtocolSlu(dAtA, i, uint64(len(m.Data_485)))
		i--
		dAtA[i] = 0x22
	}
	if m.DataLength != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.DataLength))
		i--
		dAtA[i] = 0x18
	}
	if m.Check != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Check))
		i--
		dAtA[i] = 0x10
	}
	if m.Baudrate != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Baudrate))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_6F00) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_6F00) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_6F00) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x28
	}
	if m.ResetMark != nil {
		{
			size, err := m.ResetMark.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProtocolSlu(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Addr != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.Addr))
		i--
		dAtA[i] = 0x18
	}
	if m.AddrType != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.AddrType))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdIdx != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.CmdIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstSlu_6F00_ResetMark) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstSlu_6F00_ResetMark) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstSlu_6F00_ResetMark) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ZeroCount != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.ZeroCount))
		i--
		dAtA[i] = 0x30
	}
	if m.ZeroEerom != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.ZeroEerom))
		i--
		dAtA[i] = 0x28
	}
	if m.InitRam != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.InitRam))
		i--
		dAtA[i] = 0x20
	}
	if m.InitMcuHardware != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.InitMcuHardware))
		i--
		dAtA[i] = 0x18
	}
	if m.ResetComm != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.ResetComm))
		i--
		dAtA[i] = 0x10
	}
	if m.ResetMcu != 0 {
		i = encodeVarintProtocolSlu(dAtA, i, uint64(m.ResetMcu))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintProtocolSlu(dAtA []byte, offset int, v uint64) int {
	offset -= sovProtocolSlu(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *WlstSluF400) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovProtocolSlu(uint64(m.CmdIdx))
	}
	if m.Status != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Status))
	}
	if m.Remark != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Remark))
	}
	if m.SluitemAddr != 0 {
		n += 1 + sovProtocolSlu(uint64(m.SluitemAddr))
	}
	return n
}

func (m *WlstSlu_3900) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovProtocolSlu(uint64(m.CmdIdx))
	}
	if m.ModelInfo != nil {
		l = m.ModelInfo.Size()
		n += 1 + l + sovProtocolSlu(uint64(l))
	}
	if len(m.LightData) > 0 {
		for _, e := range m.LightData {
			l = e.Size()
			n += 1 + l + sovProtocolSlu(uint64(l))
		}
	}
	if m.LeakageCurrent != 0 {
		n += 9
	}
	if m.SluitemStatus != nil {
		l = m.SluitemStatus.Size()
		n += 1 + l + sovProtocolSlu(uint64(l))
	}
	if m.TimeFault != nil {
		l = m.TimeFault.Size()
		n += 1 + l + sovProtocolSlu(uint64(l))
	}
	if m.ResetCount != 0 {
		n += 1 + sovProtocolSlu(uint64(m.ResetCount))
	}
	if m.DateTime != 0 {
		n += 1 + sovProtocolSlu(uint64(m.DateTime))
	}
	if m.SluitemPara != nil {
		l = m.SluitemPara.Size()
		n += 1 + l + sovProtocolSlu(uint64(l))
	}
	if m.Rsrp != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Rsrp))
	}
	if m.Rssi != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Rssi))
	}
	if m.Snr != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Snr))
	}
	if m.Pci != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Pci))
	}
	if m.Rsrq != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Rsrq))
	}
	if m.Txpower != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Txpower))
	}
	if m.Earfcn != 0 {
		n += 2 + sovProtocolSlu(uint64(m.Earfcn))
	}
	if m.Ecl != 0 {
		n += 2 + sovProtocolSlu(uint64(m.Ecl))
	}
	if m.Csq != 0 {
		n += 2 + sovProtocolSlu(uint64(m.Csq))
	}
	if m.Reson != 0 {
		n += 2 + sovProtocolSlu(uint64(m.Reson))
	}
	if m.Retry != 0 {
		n += 2 + sovProtocolSlu(uint64(m.Retry))
	}
	if m.Sunrise != 0 {
		n += 2 + sovProtocolSlu(uint64(m.Sunrise))
	}
	if m.Sunset != 0 {
		n += 2 + sovProtocolSlu(uint64(m.Sunset))
	}
	return n
}

func (m *WlstSlu_3900_ModelInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SluitemLoop != 0 {
		n += 1 + sovProtocolSlu(uint64(m.SluitemLoop))
	}
	if m.PowerSaving != 0 {
		n += 1 + sovProtocolSlu(uint64(m.PowerSaving))
	}
	if m.HasLeakage != 0 {
		n += 1 + sovProtocolSlu(uint64(m.HasLeakage))
	}
	if m.HasTemperature != 0 {
		n += 1 + sovProtocolSlu(uint64(m.HasTemperature))
	}
	if m.HasTimer != 0 {
		n += 1 + sovProtocolSlu(uint64(m.HasTimer))
	}
	if m.Model != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Model))
	}
	l = len(m.SluitemType)
	if l > 0 {
		n += 1 + l + sovProtocolSlu(uint64(l))
	}
	return n
}

func (m *WlstSlu_3900_LightData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Voltage != 0 {
		n += 9
	}
	if m.Current != 0 {
		n += 9
	}
	if m.ActivePower != 0 {
		n += 9
	}
	if m.ReactivePower != 0 {
		n += 9
	}
	if m.ApparentPower != 0 {
		n += 9
	}
	if m.Electricity != 0 {
		n += 9
	}
	if m.ActiveTime != 0 {
		n += 9
	}
	if m.LightStatus != nil {
		l = m.LightStatus.Size()
		n += 1 + l + sovProtocolSlu(uint64(l))
	}
	if m.PowerLevel != 0 {
		n += 1 + sovProtocolSlu(uint64(m.PowerLevel))
	}
	if m.SluitemPowerTurnon != 0 {
		n += 1 + sovProtocolSlu(uint64(m.SluitemPowerTurnon))
	}
	if m.RatedPower != 0 {
		n += 1 + sovProtocolSlu(uint64(m.RatedPower))
	}
	return n
}

func (m *WlstSlu_3900_LightStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Leakage != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Leakage))
	}
	if m.Fault != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Fault))
	}
	if m.WorkingOn != 0 {
		n += 1 + sovProtocolSlu(uint64(m.WorkingOn))
	}
	return n
}

func (m *WlstSlu_3900_SluitemStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FlashFault != 0 {
		n += 1 + sovProtocolSlu(uint64(m.FlashFault))
	}
	if m.EnableAlarm != 0 {
		n += 1 + sovProtocolSlu(uint64(m.EnableAlarm))
	}
	return n
}

func (m *WlstSlu_3900_TimeFault) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClockFault != 0 {
		n += 1 + sovProtocolSlu(uint64(m.ClockFault))
	}
	if m.ClockOutFault != 0 {
		n += 1 + sovProtocolSlu(uint64(m.ClockOutFault))
	}
	if m.ClockOutAlarm != 0 {
		n += 1 + sovProtocolSlu(uint64(m.ClockOutAlarm))
	}
	return n
}

func (m *WlstSlu_3900_SluitemPara) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Longitude != 0 {
		n += 9
	}
	if m.Latitude != 0 {
		n += 9
	}
	if m.HasEnableAlarm != 0 {
		n += 1 + sovProtocolSlu(uint64(m.HasEnableAlarm))
	}
	if m.IsRunning != 0 {
		n += 1 + sovProtocolSlu(uint64(m.IsRunning))
	}
	if m.AlarmInterval != 0 {
		n += 1 + sovProtocolSlu(uint64(m.AlarmInterval))
	}
	if m.UplinkReply != 0 {
		n += 1 + sovProtocolSlu(uint64(m.UplinkReply))
	}
	return n
}

func (m *WlstSlu_7800) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovProtocolSlu(uint64(m.CmdIdx))
	}
	if m.EventType != 0 {
		n += 1 + sovProtocolSlu(uint64(m.EventType))
	}
	if m.ClassType != 0 {
		n += 1 + sovProtocolSlu(uint64(m.ClassType))
	}
	if m.RecordCount != 0 {
		n += 1 + sovProtocolSlu(uint64(m.RecordCount))
	}
	if m.DtStart != 0 {
		n += 1 + sovProtocolSlu(uint64(m.DtStart))
	}
	if m.DtEnd != 0 {
		n += 1 + sovProtocolSlu(uint64(m.DtEnd))
	}
	return n
}

func (m *WlstSluF800) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovProtocolSlu(uint64(m.CmdIdx))
	}
	if m.EventType != 0 {
		n += 1 + sovProtocolSlu(uint64(m.EventType))
	}
	if m.ClassType != 0 {
		n += 1 + sovProtocolSlu(uint64(m.ClassType))
	}
	if m.DataTotal != 0 {
		n += 1 + sovProtocolSlu(uint64(m.DataTotal))
	}
	if m.DataIdx != 0 {
		n += 1 + sovProtocolSlu(uint64(m.DataIdx))
	}
	if m.RecordCount != 0 {
		n += 1 + sovProtocolSlu(uint64(m.RecordCount))
	}
	if len(m.View_0X20) > 0 {
		for _, e := range m.View_0X20 {
			l = e.Size()
			n += 1 + l + sovProtocolSlu(uint64(l))
		}
	}
	if len(m.View_0X21) > 0 {
		for _, e := range m.View_0X21 {
			l = e.Size()
			n += 1 + l + sovProtocolSlu(uint64(l))
		}
	}
	if len(m.View_0X22) > 0 {
		for _, e := range m.View_0X22 {
			l = e.Size()
			n += 1 + l + sovProtocolSlu(uint64(l))
		}
	}
	if len(m.View_0X23) > 0 {
		for _, e := range m.View_0X23 {
			l = e.Size()
			n += 1 + l + sovProtocolSlu(uint64(l))
		}
	}
	if len(m.View_0X24) > 0 {
		for _, e := range m.View_0X24 {
			l = e.Size()
			n += 1 + l + sovProtocolSlu(uint64(l))
		}
	}
	if len(m.View_0X25) > 0 {
		for _, e := range m.View_0X25 {
			l = e.Size()
			n += 1 + l + sovProtocolSlu(uint64(l))
		}
	}
	return n
}

func (m *WlstSluF800_View0X20) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DtHappen != 0 {
		n += 1 + sovProtocolSlu(uint64(m.DtHappen))
	}
	if len(m.Status) > 0 {
		l = 0
		for _, e := range m.Status {
			l += sovProtocolSlu(uint64(e))
		}
		n += 1 + sovProtocolSlu(uint64(l)) + l
	}
	return n
}

func (m *WlstSluF800_View0X21) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DtHappen != 0 {
		n += 1 + sovProtocolSlu(uint64(m.DtHappen))
	}
	if m.OperationType != 0 {
		n += 1 + sovProtocolSlu(uint64(m.OperationType))
	}
	if m.OperationOrder != 0 {
		n += 1 + sovProtocolSlu(uint64(m.OperationOrder))
	}
	if m.AddrType != 0 {
		n += 1 + sovProtocolSlu(uint64(m.AddrType))
	}
	if m.Addr != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Addr))
	}
	if m.OperationSource != 0 {
		n += 1 + sovProtocolSlu(uint64(m.OperationSource))
	}
	return n
}

func (m *WlstSluF800_View0X23) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DtHappen != 0 {
		n += 1 + sovProtocolSlu(uint64(m.DtHappen))
	}
	if m.Addr != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Addr))
	}
	if len(m.AlarmType) > 0 {
		l = 0
		for _, e := range m.AlarmType {
			l += sovProtocolSlu(uint64(e))
		}
		n += 1 + sovProtocolSlu(uint64(l)) + l
	}
	if len(m.SluitemStatus) > 0 {
		l = 0
		for _, e := range m.SluitemStatus {
			l += sovProtocolSlu(uint64(e))
		}
		n += 1 + sovProtocolSlu(uint64(l)) + l
	}
	if m.SluitemVoltage != 0 {
		n += 9
	}
	if len(m.SluitemCurrent) > 0 {
		n += 1 + sovProtocolSlu(uint64(len(m.SluitemCurrent)*8)) + len(m.SluitemCurrent)*8
	}
	if len(m.SluitemActivePower) > 0 {
		n += 1 + sovProtocolSlu(uint64(len(m.SluitemActivePower)*8)) + len(m.SluitemActivePower)*8
	}
	if len(m.SluitemReactivePower) > 0 {
		n += 1 + sovProtocolSlu(uint64(len(m.SluitemReactivePower)*8)) + len(m.SluitemReactivePower)*8
	}
	if m.SluitemMaxVoltage != 0 {
		n += 9
	}
	if len(m.SluitemMaxCurrent) > 0 {
		n += 1 + sovProtocolSlu(uint64(len(m.SluitemMaxCurrent)*8)) + len(m.SluitemMaxCurrent)*8
	}
	if len(m.SluitemElectricity) > 0 {
		n += 1 + sovProtocolSlu(uint64(len(m.SluitemElectricity)*8)) + len(m.SluitemElectricity)*8
	}
	if len(m.SluitemPhyinfo) > 0 {
		l = 0
		for _, e := range m.SluitemPhyinfo {
			l += sovProtocolSlu(uint64(e))
		}
		n += 1 + sovProtocolSlu(uint64(l)) + l
	}
	return n
}

func (m *WlstSluEc00) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovProtocolSlu(uint64(m.CmdIdx))
	}
	if m.StartIdx != 0 {
		n += 1 + sovProtocolSlu(uint64(m.StartIdx))
	}
	if m.ReadCount != 0 {
		n += 1 + sovProtocolSlu(uint64(m.ReadCount))
	}
	if len(m.WlstSlu_6B00) > 0 {
		for _, e := range m.WlstSlu_6B00 {
			l = e.Size()
			n += 1 + l + sovProtocolSlu(uint64(l))
		}
	}
	return n
}

func (m *WlstSlu_6B00) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovProtocolSlu(uint64(m.CmdIdx))
	}
	if m.SetIdx != 0 {
		n += 1 + sovProtocolSlu(uint64(m.SetIdx))
	}
	if m.DtStart != 0 {
		n += 1 + sovProtocolSlu(uint64(m.DtStart))
	}
	if m.DtEnd != 0 {
		n += 1 + sovProtocolSlu(uint64(m.DtEnd))
	}
	if m.OperationType != 0 {
		n += 1 + sovProtocolSlu(uint64(m.OperationType))
	}
	if m.OperationOrder != 0 {
		n += 1 + sovProtocolSlu(uint64(m.OperationOrder))
	}
	if m.TimerOrOffset != 0 {
		n += 1 + sovProtocolSlu(uint64(m.TimerOrOffset))
	}
	if m.AddrType != 0 {
		n += 1 + sovProtocolSlu(uint64(m.AddrType))
	}
	if len(m.Addrs) > 0 {
		l = 0
		for _, e := range m.Addrs {
			l += sovProtocolSlu(uint64(e))
		}
		n += 1 + sovProtocolSlu(uint64(l)) + l
	}
	if m.CmdType != 0 {
		n += 1 + sovProtocolSlu(uint64(m.CmdType))
	}
	if len(m.CmdMix) > 0 {
		l = 0
		for _, e := range m.CmdMix {
			l += sovProtocolSlu(uint64(e))
		}
		n += 1 + sovProtocolSlu(uint64(l)) + l
	}
	if m.CmdPwm != nil {
		l = m.CmdPwm.Size()
		n += 1 + l + sovProtocolSlu(uint64(l))
	}
	return n
}

func (m *WlstSlu_6B00_CmdPwm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.LoopCanDo) > 0 {
		l = 0
		for _, e := range m.LoopCanDo {
			l += sovProtocolSlu(uint64(e))
		}
		n += 1 + sovProtocolSlu(uint64(l)) + l
	}
	if m.Scale != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Scale))
	}
	if m.Rate != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Rate))
	}
	return n
}

func (m *WlstSlu_6C00) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovProtocolSlu(uint64(m.CmdIdx))
	}
	if m.StartIdx != 0 {
		n += 1 + sovProtocolSlu(uint64(m.StartIdx))
	}
	if m.ReadCount != 0 {
		n += 1 + sovProtocolSlu(uint64(m.ReadCount))
	}
	return n
}

func (m *WlstSluD000) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Ver)
	if l > 0 {
		n += 1 + l + sovProtocolSlu(uint64(l))
	}
	return n
}

func (m *WlstSlu_2800) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Status))
	}
	if m.Alarm != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Alarm))
	}
	return n
}

func (m *WlstSlu_2400) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DoFlag != 0 {
		n += 1 + sovProtocolSlu(uint64(m.DoFlag))
	}
	if m.Status != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Status))
	}
	return n
}

func (m *WlstSlu_6E00) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DoFlag != 0 {
		n += 1 + sovProtocolSlu(uint64(m.DoFlag))
	}
	if m.PatrolStart != 0 {
		n += 1 + sovProtocolSlu(uint64(m.PatrolStart))
	}
	if m.PatrolInterval != 0 {
		n += 1 + sovProtocolSlu(uint64(m.PatrolInterval))
	}
	if m.PatrolOrder != 0 {
		n += 1 + sovProtocolSlu(uint64(m.PatrolOrder))
	}
	if m.PatrolCount != 0 {
		n += 1 + sovProtocolSlu(uint64(m.PatrolCount))
	}
	if m.CmdIdx != 0 {
		n += 1 + sovProtocolSlu(uint64(m.CmdIdx))
	}
	return n
}

func (m *WlstSlu_3000) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ctrls != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Ctrls))
	}
	if m.DomainName != 0 {
		n += 1 + sovProtocolSlu(uint64(m.DomainName))
	}
	if m.UpperVoltageLimit != 0 {
		n += 1 + sovProtocolSlu(uint64(m.UpperVoltageLimit))
	}
	if m.LowerVoltageLimit != 0 {
		n += 1 + sovProtocolSlu(uint64(m.LowerVoltageLimit))
	}
	if m.MacAddr != 0 {
		n += 1 + sovProtocolSlu(uint64(m.MacAddr))
	}
	return n
}

func (m *WlstSlu_9A00) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DomainNameStatus) > 0 {
		l = 0
		for _, e := range m.DomainNameStatus {
			l += sovProtocolSlu(uint64(e))
		}
		n += 1 + sovProtocolSlu(uint64(l)) + l
	}
	return n
}

func (m *WlstSluCd00) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CommunicationFailures != 0 {
		n += 1 + sovProtocolSlu(uint64(m.CommunicationFailures))
	}
	if m.PowerFactor != 0 {
		n += 1 + sovProtocolSlu(uint64(m.PowerFactor))
	}
	if m.CommunicationChannel != 0 {
		n += 1 + sovProtocolSlu(uint64(m.CommunicationChannel))
	}
	if m.CurrentRange != 0 {
		n += 9
	}
	if m.PowerRange != 0 {
		n += 1 + sovProtocolSlu(uint64(m.PowerRange))
	}
	if m.AutoMode != 0 {
		n += 1 + sovProtocolSlu(uint64(m.AutoMode))
	}
	if m.Longitude != 0 {
		n += 9
	}
	if m.Latitude != 0 {
		n += 9
	}
	if m.CarrierRoutingMode != 0 {
		n += 1 + sovProtocolSlu(uint64(m.CarrierRoutingMode))
	}
	if m.BluetoothPin != 0 {
		n += 1 + sovProtocolSlu(uint64(m.BluetoothPin))
	}
	if m.BluetoothMode != 0 {
		n += 1 + sovProtocolSlu(uint64(m.BluetoothMode))
	}
	if m.Cct != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Cct))
	}
	if m.CmdIdx != 0 {
		n += 1 + sovProtocolSlu(uint64(m.CmdIdx))
	}
	if m.AlwaysOnline != 0 {
		n += 1 + sovProtocolSlu(uint64(m.AlwaysOnline))
	}
	return n
}

func (m *WlstSlu_1C00) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovProtocolSlu(uint64(m.CmdIdx))
	}
	if m.SluitemIdx != 0 {
		n += 1 + sovProtocolSlu(uint64(m.SluitemIdx))
	}
	if m.DomainName != 0 {
		n += 1 + sovProtocolSlu(uint64(m.DomainName))
	}
	return n
}

func (m *WlstSlu_1D00) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovProtocolSlu(uint64(m.CmdIdx))
	}
	if m.SluitemIdx != 0 {
		n += 1 + sovProtocolSlu(uint64(m.SluitemIdx))
	}
	if m.DataMark != nil {
		l = m.DataMark.Size()
		n += 1 + l + sovProtocolSlu(uint64(l))
	}
	return n
}

func (m *WlstSlu_1D00_DataMark) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReadData != 0 {
		n += 1 + sovProtocolSlu(uint64(m.ReadData))
	}
	if m.ReadTimer != 0 {
		n += 1 + sovProtocolSlu(uint64(m.ReadTimer))
	}
	if m.ReadArgs != 0 {
		n += 1 + sovProtocolSlu(uint64(m.ReadArgs))
	}
	if m.ReadGroup != 0 {
		n += 1 + sovProtocolSlu(uint64(m.ReadGroup))
	}
	if m.ReadVer != 0 {
		n += 1 + sovProtocolSlu(uint64(m.ReadVer))
	}
	if m.ReadSunriseset != 0 {
		n += 1 + sovProtocolSlu(uint64(m.ReadSunriseset))
	}
	if m.ReadTimetable != 0 {
		n += 1 + sovProtocolSlu(uint64(m.ReadTimetable))
	}
	if m.ReadCtrldata != 0 {
		n += 1 + sovProtocolSlu(uint64(m.ReadCtrldata))
	}
	return n
}

func (m *WlstSlu_9D00) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovProtocolSlu(uint64(m.CmdIdx))
	}
	if m.SluitemIdx != 0 {
		n += 1 + sovProtocolSlu(uint64(m.SluitemIdx))
	}
	if m.DataMark != nil {
		l = m.DataMark.Size()
		n += 1 + l + sovProtocolSlu(uint64(l))
	}
	if m.LoopCount != 0 {
		n += 1 + sovProtocolSlu(uint64(m.LoopCount))
	}
	if m.SluitemData != nil {
		l = m.SluitemData.Size()
		n += 1 + l + sovProtocolSlu(uint64(l))
	}
	if m.SluitemTime != 0 {
		n += 1 + sovProtocolSlu(uint64(m.SluitemTime))
	}
	if m.SluitemPara != nil {
		l = m.SluitemPara.Size()
		n += 1 + l + sovProtocolSlu(uint64(l))
	}
	if len(m.SluitemGroup) > 0 {
		l = 0
		for _, e := range m.SluitemGroup {
			l += sovProtocolSlu(uint64(e))
		}
		n += 1 + sovProtocolSlu(uint64(l)) + l
	}
	if m.SluitemVer != nil {
		l = m.SluitemVer.Size()
		n += 1 + l + sovProtocolSlu(uint64(l))
	}
	if m.SluitemSunriseset != nil {
		l = m.SluitemSunriseset.Size()
		n += 1 + l + sovProtocolSlu(uint64(l))
	}
	if len(m.SluitemRuntime) > 0 {
		for _, e := range m.SluitemRuntime {
			l = e.Size()
			n += 1 + l + sovProtocolSlu(uint64(l))
		}
	}
	if m.SluitemDataNew != nil {
		l = m.SluitemDataNew.Size()
		n += 1 + l + sovProtocolSlu(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Status))
	}
	if m.SetMark != nil {
		l = m.SetMark.Size()
		n += 1 + l + sovProtocolSlu(uint64(l))
	}
	if m.DataContinue != 0 {
		n += 2 + sovProtocolSlu(uint64(m.DataContinue))
	}
	return n
}

func (m *WlstSlu_9D00_SetMark) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SetTimer != 0 {
		n += 1 + sovProtocolSlu(uint64(m.SetTimer))
	}
	if m.SetArgs != 0 {
		n += 1 + sovProtocolSlu(uint64(m.SetArgs))
	}
	if m.SetGroup != 0 {
		n += 1 + sovProtocolSlu(uint64(m.SetGroup))
	}
	if m.SetReset != 0 {
		n += 1 + sovProtocolSlu(uint64(m.SetReset))
	}
	if m.SetControl != 0 {
		n += 1 + sovProtocolSlu(uint64(m.SetControl))
	}
	return n
}

func (m *WlstSlu_9D00_SluitemData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Voltage != 0 {
		n += 9
	}
	if len(m.Current) > 0 {
		n += 1 + sovProtocolSlu(uint64(len(m.Current)*8)) + len(m.Current)*8
	}
	if len(m.ActivePower) > 0 {
		n += 1 + sovProtocolSlu(uint64(len(m.ActivePower)*8)) + len(m.ActivePower)*8
	}
	if len(m.ReactivePower) > 0 {
		n += 1 + sovProtocolSlu(uint64(len(m.ReactivePower)*8)) + len(m.ReactivePower)*8
	}
	if m.MaxVoltage != 0 {
		n += 9
	}
	if len(m.MaxCurrent) > 0 {
		n += 1 + sovProtocolSlu(uint64(len(m.MaxCurrent)*8)) + len(m.MaxCurrent)*8
	}
	if len(m.TotalElectricity) > 0 {
		n += 1 + sovProtocolSlu(uint64(len(m.TotalElectricity)*8)) + len(m.TotalElectricity)*8
	}
	if m.Temperature != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Temperature))
	}
	if m.LeakageCurrent != 0 {
		n += 9
	}
	if m.TimerError != 0 {
		n += 1 + sovProtocolSlu(uint64(m.TimerError))
	}
	if m.SluitemStatus != nil {
		l = m.SluitemStatus.Size()
		n += 1 + l + sovProtocolSlu(uint64(l))
	}
	if len(m.LightStatus) > 0 {
		for _, e := range m.LightStatus {
			l = e.Size()
			n += 1 + l + sovProtocolSlu(uint64(l))
		}
	}
	if m.ResetCount != 0 {
		n += 1 + sovProtocolSlu(uint64(m.ResetCount))
	}
	return n
}

func (m *WlstSlu_9D00_SluitemDataNew) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Voltage) > 0 {
		n += 1 + sovProtocolSlu(uint64(len(m.Voltage)*8)) + len(m.Voltage)*8
	}
	if len(m.Current) > 0 {
		n += 1 + sovProtocolSlu(uint64(len(m.Current)*8)) + len(m.Current)*8
	}
	if len(m.ActivePower) > 0 {
		n += 1 + sovProtocolSlu(uint64(len(m.ActivePower)*8)) + len(m.ActivePower)*8
	}
	if len(m.RunTime) > 0 {
		l = 0
		for _, e := range m.RunTime {
			l += sovProtocolSlu(uint64(e))
		}
		n += 1 + sovProtocolSlu(uint64(l)) + l
	}
	if m.Phase != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Phase))
	}
	if len(m.TotalElectricity) > 0 {
		n += 1 + sovProtocolSlu(uint64(len(m.TotalElectricity)*8)) + len(m.TotalElectricity)*8
	}
	if m.LeakageCurrent != 0 {
		n += 9
	}
	if m.TimerError != 0 {
		n += 1 + sovProtocolSlu(uint64(m.TimerError))
	}
	if m.SluitemStatus != nil {
		l = m.SluitemStatus.Size()
		n += 1 + l + sovProtocolSlu(uint64(l))
	}
	if len(m.LightStatus) > 0 {
		for _, e := range m.LightStatus {
			l = e.Size()
			n += 1 + l + sovProtocolSlu(uint64(l))
		}
	}
	if m.ResetCount != 0 {
		n += 1 + sovProtocolSlu(uint64(m.ResetCount))
	}
	if len(m.EnergySaving) > 0 {
		l = 0
		for _, e := range m.EnergySaving {
			l += sovProtocolSlu(uint64(e))
		}
		n += 1 + sovProtocolSlu(uint64(l)) + l
	}
	return n
}

func (m *WlstSlu_9D00_SluitemPara) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DomainName != 0 {
		n += 1 + sovProtocolSlu(uint64(m.DomainName))
	}
	if m.SluitemStatus != 0 {
		n += 1 + sovProtocolSlu(uint64(m.SluitemStatus))
	}
	if m.SluitemEnableAlarm != 0 {
		n += 1 + sovProtocolSlu(uint64(m.SluitemEnableAlarm))
	}
	if len(m.SluitemPowerTurnon) > 0 {
		l = 0
		for _, e := range m.SluitemPowerTurnon {
			l += sovProtocolSlu(uint64(e))
		}
		n += 1 + sovProtocolSlu(uint64(l)) + l
	}
	if len(m.SluitemVector) > 0 {
		l = 0
		for _, e := range m.SluitemVector {
			l += sovProtocolSlu(uint64(e))
		}
		n += 1 + sovProtocolSlu(uint64(l)) + l
	}
	if m.Longitude != 0 {
		n += 9
	}
	if m.Latitude != 0 {
		n += 9
	}
	if len(m.RatedPower) > 0 {
		l = 0
		for _, e := range m.RatedPower {
			l += sovProtocolSlu(uint64(e))
		}
		n += 1 + sovProtocolSlu(uint64(l)) + l
	}
	if m.UplinkTimer != 0 {
		n += 1 + sovProtocolSlu(uint64(m.UplinkTimer))
	}
	if m.UplinkReply != 0 {
		n += 1 + sovProtocolSlu(uint64(m.UplinkReply))
	}
	return n
}

func (m *WlstSlu_9D00_SluitemVer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SluitemLoop != 0 {
		n += 1 + sovProtocolSlu(uint64(m.SluitemLoop))
	}
	if m.EnergySaving != 0 {
		n += 1 + sovProtocolSlu(uint64(m.EnergySaving))
	}
	if m.ElectricLeakageModule != 0 {
		n += 1 + sovProtocolSlu(uint64(m.ElectricLeakageModule))
	}
	if m.TemperatureModule != 0 {
		n += 1 + sovProtocolSlu(uint64(m.TemperatureModule))
	}
	if m.TimerModule != 0 {
		n += 1 + sovProtocolSlu(uint64(m.TimerModule))
	}
	l = len(m.SluitemType)
	if l > 0 {
		n += 1 + l + sovProtocolSlu(uint64(l))
	}
	l = len(m.Ver)
	if l > 0 {
		n += 1 + l + sovProtocolSlu(uint64(l))
	}
	return n
}

func (m *WlstSlu_9D00_SluitemSunriseset) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sunrise != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Sunrise))
	}
	if m.Sunset != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Sunset))
	}
	return n
}

func (m *WlstSlu_9D00_SluitemRuntime) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DataType != 0 {
		n += 1 + sovProtocolSlu(uint64(m.DataType))
	}
	if m.OutputType != 0 {
		n += 1 + sovProtocolSlu(uint64(m.OutputType))
	}
	if m.OperateType != 0 {
		n += 1 + sovProtocolSlu(uint64(m.OperateType))
	}
	if len(m.DateEnable) > 0 {
		l = 0
		for _, e := range m.DateEnable {
			l += sovProtocolSlu(uint64(e))
		}
		n += 1 + sovProtocolSlu(uint64(l)) + l
	}
	if m.OperateTime != 0 {
		n += 1 + sovProtocolSlu(uint64(m.OperateTime))
	}
	if m.OperateOffset != 0 {
		n += 1 + sovProtocolSlu(uint64(m.OperateOffset))
	}
	if len(m.RelayOperate) > 0 {
		l = 0
		for _, e := range m.RelayOperate {
			l += sovProtocolSlu(uint64(e))
		}
		n += 1 + sovProtocolSlu(uint64(l)) + l
	}
	if len(m.PwmLoop) > 0 {
		l = 0
		for _, e := range m.PwmLoop {
			l += sovProtocolSlu(uint64(e))
		}
		n += 1 + sovProtocolSlu(uint64(l)) + l
	}
	if m.PwmPower != 0 {
		n += 1 + sovProtocolSlu(uint64(m.PwmPower))
	}
	if m.PwmBaudrate != 0 {
		n += 1 + sovProtocolSlu(uint64(m.PwmBaudrate))
	}
	if m.Rs485Baudrate != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Rs485Baudrate))
	}
	if m.Rs485Check != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Rs485Check))
	}
	return n
}

func (m *WlstSluF000) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovProtocolSlu(uint64(m.CmdIdx))
	}
	if m.ResetMark != nil {
		l = m.ResetMark.Size()
		n += 1 + l + sovProtocolSlu(uint64(l))
	}
	return n
}

func (m *WlstSluF000_ResetMark) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClearTask != 0 {
		n += 1 + sovProtocolSlu(uint64(m.ClearTask))
	}
	if m.ResetConcentrator != 0 {
		n += 1 + sovProtocolSlu(uint64(m.ResetConcentrator))
	}
	if m.HardResetZigbee != 0 {
		n += 1 + sovProtocolSlu(uint64(m.HardResetZigbee))
	}
	if m.SoftResetZigbee != 0 {
		n += 1 + sovProtocolSlu(uint64(m.SoftResetZigbee))
	}
	if m.ResetCarrier != 0 {
		n += 1 + sovProtocolSlu(uint64(m.ResetCarrier))
	}
	if m.InitAll != 0 {
		n += 1 + sovProtocolSlu(uint64(m.InitAll))
	}
	if m.ClearData != 0 {
		n += 1 + sovProtocolSlu(uint64(m.ClearData))
	}
	if m.ClearArgs != 0 {
		n += 1 + sovProtocolSlu(uint64(m.ClearArgs))
	}
	return n
}

func (m *WlstSluF100) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovProtocolSlu(uint64(m.CmdIdx))
	}
	if m.OptMark != 0 {
		n += 1 + sovProtocolSlu(uint64(m.OptMark))
	}
	if m.DateTime != 0 {
		n += 1 + sovProtocolSlu(uint64(m.DateTime))
	}
	if m.ForceTimer != 0 {
		n += 1 + sovProtocolSlu(uint64(m.ForceTimer))
	}
	if m.TimerStatus != nil {
		l = m.TimerStatus.Size()
		n += 1 + l + sovProtocolSlu(uint64(l))
	}
	return n
}

func (m *WlstSluF100_TimerStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DtformatError != 0 {
		n += 1 + sovProtocolSlu(uint64(m.DtformatError))
	}
	if m.TimerError != 0 {
		n += 1 + sovProtocolSlu(uint64(m.TimerError))
	}
	if m.TimeFault != 0 {
		n += 1 + sovProtocolSlu(uint64(m.TimeFault))
	}
	return n
}

func (m *WlstSluF200) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovProtocolSlu(uint64(m.CmdIdx))
	}
	if m.SluitemIdx != 0 {
		n += 1 + sovProtocolSlu(uint64(m.SluitemIdx))
	}
	if m.SluitemCount != 0 {
		n += 1 + sovProtocolSlu(uint64(m.SluitemCount))
	}
	if m.DataMark != nil {
		l = m.DataMark.Size()
		n += 1 + l + sovProtocolSlu(uint64(l))
	}
	if len(m.SluitemData) > 0 {
		for _, e := range m.SluitemData {
			l = e.Size()
			n += 1 + l + sovProtocolSlu(uint64(l))
		}
	}
	if m.Status != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Status))
	}
	return n
}

func (m *WlstSluF200_DataMark) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Group != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Group))
	}
	if m.Barcode != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Barcode))
	}
	if m.Route != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Route))
	}
	if m.Order != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Order))
	}
	if m.Limit != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Limit))
	}
	if m.PowerOnStatus != 0 {
		n += 1 + sovProtocolSlu(uint64(m.PowerOnStatus))
	}
	if m.RunStatus != 0 {
		n += 1 + sovProtocolSlu(uint64(m.RunStatus))
	}
	if m.Vector != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Vector))
	}
	if m.RatedPower != 0 {
		n += 1 + sovProtocolSlu(uint64(m.RatedPower))
	}
	if m.LoopCount != 0 {
		n += 1 + sovProtocolSlu(uint64(m.LoopCount))
	}
	if m.SetData != 0 {
		n += 2 + sovProtocolSlu(uint64(m.SetData))
	}
	return n
}

func (m *WlstSluF200_ControllerData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SluitemGroup) > 0 {
		l = 0
		for _, e := range m.SluitemGroup {
			l += sovProtocolSlu(uint64(e))
		}
		n += 1 + sovProtocolSlu(uint64(l)) + l
	}
	if m.SluitemIdx != 0 {
		n += 1 + sovProtocolSlu(uint64(m.SluitemIdx))
	}
	if len(m.SluitemRoute) > 0 {
		l = 0
		for _, e := range m.SluitemRoute {
			l += sovProtocolSlu(uint64(e))
		}
		n += 1 + sovProtocolSlu(uint64(l)) + l
	}
	if m.SluitemOrder != 0 {
		n += 1 + sovProtocolSlu(uint64(m.SluitemOrder))
	}
	if m.UpperPowerLimit != 0 {
		n += 1 + sovProtocolSlu(uint64(m.UpperPowerLimit))
	}
	if m.LowerPowerLimit != 0 {
		n += 1 + sovProtocolSlu(uint64(m.LowerPowerLimit))
	}
	if len(m.SluitemPowerTurnon) > 0 {
		l = 0
		for _, e := range m.SluitemPowerTurnon {
			l += sovProtocolSlu(uint64(e))
		}
		n += 1 + sovProtocolSlu(uint64(l)) + l
	}
	if m.SluitemStatus != 0 {
		n += 1 + sovProtocolSlu(uint64(m.SluitemStatus))
	}
	if m.SluitemEnableAlarm != 0 {
		n += 1 + sovProtocolSlu(uint64(m.SluitemEnableAlarm))
	}
	if len(m.SluitemVector) > 0 {
		l = 0
		for _, e := range m.SluitemVector {
			l += sovProtocolSlu(uint64(e))
		}
		n += 1 + sovProtocolSlu(uint64(l)) + l
	}
	if len(m.RatedPower) > 0 {
		l = 0
		for _, e := range m.RatedPower {
			l += sovProtocolSlu(uint64(e))
		}
		n += 1 + sovProtocolSlu(uint64(l)) + l
	}
	if m.LoopCount != 0 {
		n += 1 + sovProtocolSlu(uint64(m.LoopCount))
	}
	if m.Longitude != 0 {
		n += 9
	}
	if m.Latitude != 0 {
		n += 9
	}
	if m.UplinkTimer != 0 {
		n += 1 + sovProtocolSlu(uint64(m.UplinkTimer))
	}
	if m.UplinkReply != 0 {
		n += 2 + sovProtocolSlu(uint64(m.UplinkReply))
	}
	return n
}

func (m *WlstSlu_7300) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovProtocolSlu(uint64(m.CmdIdx))
	}
	if m.SluitemStart != 0 {
		n += 1 + sovProtocolSlu(uint64(m.SluitemStart))
	}
	if m.SluitemCount != 0 {
		n += 1 + sovProtocolSlu(uint64(m.SluitemCount))
	}
	if m.DataMark != 0 {
		n += 1 + sovProtocolSlu(uint64(m.DataMark))
	}
	if m.ConcentratorData != nil {
		l = m.ConcentratorData.Size()
		n += 1 + l + sovProtocolSlu(uint64(l))
	}
	if len(m.BaseSluitemData) > 0 {
		for _, e := range m.BaseSluitemData {
			l = e.Size()
			n += 1 + l + sovProtocolSlu(uint64(l))
		}
	}
	if len(m.UnknowSluitem) > 0 {
		for _, e := range m.UnknowSluitem {
			l = e.Size()
			n += 1 + l + sovProtocolSlu(uint64(l))
		}
	}
	if len(m.AssistSluitemData) > 0 {
		for _, e := range m.AssistSluitemData {
			l = e.Size()
			n += 1 + l + sovProtocolSlu(uint64(l))
		}
	}
	if len(m.SluitemPhyinfo) > 0 {
		for _, e := range m.SluitemPhyinfo {
			l = e.Size()
			n += 1 + l + sovProtocolSlu(uint64(l))
		}
	}
	if len(m.SluitemAddrs) > 0 {
		l = 0
		for _, e := range m.SluitemAddrs {
			l += sovProtocolSlu(uint64(e))
		}
		n += 1 + sovProtocolSlu(uint64(l)) + l
	}
	return n
}

func (m *WlstSlu_7300_ConcentratorData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ResetCount) > 0 {
		l = 0
		for _, e := range m.ResetCount {
			l += sovProtocolSlu(uint64(e))
		}
		n += 1 + sovProtocolSlu(uint64(l)) + l
	}
	if m.RunStatus != nil {
		l = m.RunStatus.Size()
		n += 1 + l + sovProtocolSlu(uint64(l))
	}
	if m.ArgsStatus != nil {
		l = m.ArgsStatus.Size()
		n += 1 + l + sovProtocolSlu(uint64(l))
	}
	if m.HardwareStatus != nil {
		l = m.HardwareStatus.Size()
		n += 1 + l + sovProtocolSlu(uint64(l))
	}
	if m.UnknowSluitemCount != 0 {
		n += 1 + sovProtocolSlu(uint64(m.UnknowSluitemCount))
	}
	if m.CommunicationChannel != 0 {
		n += 1 + sovProtocolSlu(uint64(m.CommunicationChannel))
	}
	return n
}

func (m *WlstSlu_7300_ConcentratorData_RunStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Offline != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Offline))
	}
	if m.EnableAlarm != 0 {
		n += 1 + sovProtocolSlu(uint64(m.EnableAlarm))
	}
	if m.PoweronMark != 0 {
		n += 1 + sovProtocolSlu(uint64(m.PoweronMark))
	}
	if m.EnableGprs != 0 {
		n += 1 + sovProtocolSlu(uint64(m.EnableGprs))
	}
	if m.EnableAutochk != 0 {
		n += 1 + sovProtocolSlu(uint64(m.EnableAutochk))
	}
	return n
}

func (m *WlstSlu_7300_ConcentratorData_ArgsStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConcentratorArgsError != 0 {
		n += 1 + sovProtocolSlu(uint64(m.ConcentratorArgsError))
	}
	if m.SluitemArgsError != 0 {
		n += 1 + sovProtocolSlu(uint64(m.SluitemArgsError))
	}
	if m.TurnOnoffError != 0 {
		n += 1 + sovProtocolSlu(uint64(m.TurnOnoffError))
	}
	return n
}

func (m *WlstSlu_7300_ConcentratorData_HardwareStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ZigbeeError != 0 {
		n += 1 + sovProtocolSlu(uint64(m.ZigbeeError))
	}
	if m.CarrierError != 0 {
		n += 1 + sovProtocolSlu(uint64(m.CarrierError))
	}
	if m.FramError != 0 {
		n += 1 + sovProtocolSlu(uint64(m.FramError))
	}
	if m.BluetoothError != 0 {
		n += 1 + sovProtocolSlu(uint64(m.BluetoothError))
	}
	if m.TimerError != 0 {
		n += 1 + sovProtocolSlu(uint64(m.TimerError))
	}
	return n
}

func (m *WlstSlu_7300_BaseSluitemData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DateTime != 0 {
		n += 1 + sovProtocolSlu(uint64(m.DateTime))
	}
	if m.SluitemStatus != nil {
		l = m.SluitemStatus.Size()
		n += 1 + l + sovProtocolSlu(uint64(l))
	}
	if m.Temperature != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Temperature))
	}
	if len(m.LightStatus) > 0 {
		for _, e := range m.LightStatus {
			l = e.Size()
			n += 1 + l + sovProtocolSlu(uint64(l))
		}
	}
	if len(m.LightData) > 0 {
		for _, e := range m.LightData {
			l = e.Size()
			n += 1 + l + sovProtocolSlu(uint64(l))
		}
	}
	if m.SluitemLoop != 0 {
		n += 1 + sovProtocolSlu(uint64(m.SluitemLoop))
	}
	return n
}

func (m *WlstSlu_7300_BaseSluitemData_SluitemStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Status))
	}
	if m.Adjust != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Adjust))
	}
	if m.WorkingArgs != 0 {
		n += 1 + sovProtocolSlu(uint64(m.WorkingArgs))
	}
	if m.NoAlarm != 0 {
		n += 1 + sovProtocolSlu(uint64(m.NoAlarm))
	}
	if m.OffLine != 0 {
		n += 1 + sovProtocolSlu(uint64(m.OffLine))
	}
	if m.EepromError != 0 {
		n += 1 + sovProtocolSlu(uint64(m.EepromError))
	}
	if m.TemperatureSensor != 0 {
		n += 1 + sovProtocolSlu(uint64(m.TemperatureSensor))
	}
	return n
}

func (m *WlstSlu_7300_BaseSluitemData_LightStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PowerStatus != 0 {
		n += 1 + sovProtocolSlu(uint64(m.PowerStatus))
	}
	if m.Leakage != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Leakage))
	}
	if m.Fault != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Fault))
	}
	if m.WorkingOn != 0 {
		n += 1 + sovProtocolSlu(uint64(m.WorkingOn))
	}
	return n
}

func (m *WlstSlu_7300_BaseSluitemData_LightData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Voltage != 0 {
		n += 9
	}
	if m.Current != 0 {
		n += 9
	}
	if m.ActivePower != 0 {
		n += 9
	}
	if m.Electricity != 0 {
		n += 9
	}
	if m.ActiveTime != 0 {
		n += 9
	}
	if m.PowerLevel != 0 {
		n += 1 + sovProtocolSlu(uint64(m.PowerLevel))
	}
	return n
}

func (m *WlstSlu_7300_UnknowSluitem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SluitemIdx != 0 {
		n += 1 + sovProtocolSlu(uint64(m.SluitemIdx))
	}
	if m.ModelInfo != nil {
		l = m.ModelInfo.Size()
		n += 1 + l + sovProtocolSlu(uint64(l))
	}
	return n
}

func (m *WlstSlu_7300_AssistSluitemData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DateTime != 0 {
		n += 1 + sovProtocolSlu(uint64(m.DateTime))
	}
	if m.LeakageCurrent != 0 {
		n += 9
	}
	if len(m.LightData) > 0 {
		for _, e := range m.LightData {
			l = e.Size()
			n += 1 + l + sovProtocolSlu(uint64(l))
		}
	}
	if m.SluitemLoop != 0 {
		n += 1 + sovProtocolSlu(uint64(m.SluitemLoop))
	}
	return n
}

func (m *WlstSlu_7300_AssistSluitemData_LightData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxVoltage != 0 {
		n += 9
	}
	if m.MaxCurrent != 0 {
		n += 9
	}
	if m.Electricity != 0 {
		n += 9
	}
	return n
}

func (m *WlstSlu_7300_SluitemPhyinfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SignalStrength != 0 {
		n += 1 + sovProtocolSlu(uint64(m.SignalStrength))
	}
	if m.Routing != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Routing))
	}
	if m.Phase != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Phase))
	}
	if m.UsefulCommunicate != 0 {
		n += 1 + sovProtocolSlu(uint64(m.UsefulCommunicate))
	}
	if m.AllCommunicate != 0 {
		n += 1 + sovProtocolSlu(uint64(m.AllCommunicate))
	}
	if m.ModelInfo != nil {
		l = m.ModelInfo.Size()
		n += 1 + l + sovProtocolSlu(uint64(l))
	}
	return n
}

func (m *WlstSlu_7300_ModelInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SluitemLoop != 0 {
		n += 1 + sovProtocolSlu(uint64(m.SluitemLoop))
	}
	if m.PowerSaving != 0 {
		n += 1 + sovProtocolSlu(uint64(m.PowerSaving))
	}
	if m.HasLeakage != 0 {
		n += 1 + sovProtocolSlu(uint64(m.HasLeakage))
	}
	if m.HasTemperature != 0 {
		n += 1 + sovProtocolSlu(uint64(m.HasTemperature))
	}
	if m.HasTimer != 0 {
		n += 1 + sovProtocolSlu(uint64(m.HasTimer))
	}
	if m.Model != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Model))
	}
	l = len(m.SluitemType)
	if l > 0 {
		n += 1 + l + sovProtocolSlu(uint64(l))
	}
	return n
}

func (m *WlstSluF900) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovProtocolSlu(uint64(m.CmdIdx))
	}
	if m.AlarmType != 0 {
		n += 1 + sovProtocolSlu(uint64(m.AlarmType))
	}
	if m.ConcentratorData != nil {
		l = m.ConcentratorData.Size()
		n += 1 + l + sovProtocolSlu(uint64(l))
	}
	if len(m.ErrorCtrls) > 0 {
		l = 0
		for _, e := range m.ErrorCtrls {
			l += sovProtocolSlu(uint64(e))
		}
		n += 1 + sovProtocolSlu(uint64(l)) + l
	}
	if len(m.SluitemStatusAlarm) > 0 {
		for _, e := range m.SluitemStatusAlarm {
			l = e.Size()
			n += 1 + l + sovProtocolSlu(uint64(l))
		}
	}
	if m.BluetoothApply != nil {
		l = m.BluetoothApply.Size()
		n += 1 + l + sovProtocolSlu(uint64(l))
	}
	if m.SetDomainResult != nil {
		l = m.SetDomainResult.Size()
		n += 1 + l + sovProtocolSlu(uint64(l))
	}
	return n
}

func (m *WlstSluF900_SluitemStatusAlarm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SluitemIdx != 0 {
		n += 1 + sovProtocolSlu(uint64(m.SluitemIdx))
	}
	if m.SluitemLoop != 0 {
		n += 1 + sovProtocolSlu(uint64(m.SluitemLoop))
	}
	if m.SluitemStatus != nil {
		l = m.SluitemStatus.Size()
		n += 1 + l + sovProtocolSlu(uint64(l))
	}
	if len(m.LightStatus) > 0 {
		for _, e := range m.LightStatus {
			l = e.Size()
			n += 1 + l + sovProtocolSlu(uint64(l))
		}
	}
	return n
}

func (m *WlstSluF900_BluetoothApply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SimNumber != 0 {
		n += 1 + sovProtocolSlu(uint64(m.SimNumber))
	}
	l = len(m.CheckCode)
	if l > 0 {
		n += 1 + l + sovProtocolSlu(uint64(l))
	}
	return n
}

func (m *WlstSluF900_SetDomainResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DomainName != 0 {
		n += 1 + sovProtocolSlu(uint64(m.DomainName))
	}
	if len(m.SetSuccess) > 0 {
		l = 0
		for _, e := range m.SetSuccess {
			l += sovProtocolSlu(uint64(e))
		}
		n += 1 + sovProtocolSlu(uint64(l)) + l
	}
	return n
}

func (m *WlstSlu_7B00) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovProtocolSlu(uint64(m.CmdIdx))
	}
	if m.SluitemIdx != 0 {
		n += 1 + sovProtocolSlu(uint64(m.SluitemIdx))
	}
	if m.DataCount != 0 {
		n += 1 + sovProtocolSlu(uint64(m.DataCount))
	}
	if len(m.OperationData) > 0 {
		for _, e := range m.OperationData {
			l = e.Size()
			n += 1 + l + sovProtocolSlu(uint64(l))
		}
	}
	return n
}

func (m *WlstSlu_7B00_ReadConcentratorOperationData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OperationOrder != 0 {
		n += 1 + sovProtocolSlu(uint64(m.OperationOrder))
	}
	if m.OperationType != 0 {
		n += 1 + sovProtocolSlu(uint64(m.OperationType))
	}
	if len(m.WeekSet) > 0 {
		l = 0
		for _, e := range m.WeekSet {
			l += sovProtocolSlu(uint64(e))
		}
		n += 1 + sovProtocolSlu(uint64(l)) + l
	}
	if m.TimerOrOffset != 0 {
		n += 1 + sovProtocolSlu(uint64(m.TimerOrOffset))
	}
	if m.AddrType != 0 {
		n += 1 + sovProtocolSlu(uint64(m.AddrType))
	}
	if len(m.Addr) > 0 {
		l = 0
		for _, e := range m.Addr {
			l += sovProtocolSlu(uint64(e))
		}
		n += 1 + sovProtocolSlu(uint64(l)) + l
	}
	if m.CmdType != 0 {
		n += 1 + sovProtocolSlu(uint64(m.CmdType))
	}
	if len(m.CmdMix) > 0 {
		for _, e := range m.CmdMix {
			l = e.Size()
			n += 1 + l + sovProtocolSlu(uint64(l))
		}
	}
	return n
}

func (m *WlstSlu_7B00_ReadConcentratorOperationData_CmdOperation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Handle != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Handle))
	}
	if m.Rate != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Rate))
	}
	return n
}

func (m *WlstSluFe00) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovProtocolSlu(uint64(m.CmdIdx))
	}
	if m.OperationCmd != 0 {
		n += 1 + sovProtocolSlu(uint64(m.OperationCmd))
	}
	if m.FaultCount != 0 {
		n += 1 + sovProtocolSlu(uint64(m.FaultCount))
	}
	if len(m.SluitemIdx) > 0 {
		l = 0
		for _, e := range m.SluitemIdx {
			l += sovProtocolSlu(uint64(e))
		}
		n += 1 + sovProtocolSlu(uint64(l)) + l
	}
	return n
}

func (m *WlstSlu_7400) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovProtocolSlu(uint64(m.CmdIdx))
	}
	if m.OperationType != 0 {
		n += 1 + sovProtocolSlu(uint64(m.OperationType))
	}
	if m.OperationOrder != 0 {
		n += 1 + sovProtocolSlu(uint64(m.OperationOrder))
	}
	if m.AddrType != 0 {
		n += 1 + sovProtocolSlu(uint64(m.AddrType))
	}
	if len(m.Addrs) > 0 {
		l = 0
		for _, e := range m.Addrs {
			l += sovProtocolSlu(uint64(e))
		}
		n += 1 + sovProtocolSlu(uint64(l)) + l
	}
	if len(m.WeekSet) > 0 {
		l = 0
		for _, e := range m.WeekSet {
			l += sovProtocolSlu(uint64(e))
		}
		n += 1 + sovProtocolSlu(uint64(l)) + l
	}
	if m.TimerOrOffset != 0 {
		n += 1 + sovProtocolSlu(uint64(m.TimerOrOffset))
	}
	if m.CmdType != 0 {
		n += 1 + sovProtocolSlu(uint64(m.CmdType))
	}
	if len(m.CmdMix) > 0 {
		l = 0
		for _, e := range m.CmdMix {
			l += sovProtocolSlu(uint64(e))
		}
		n += 1 + sovProtocolSlu(uint64(l)) + l
	}
	if m.CmdPwm != nil {
		l = m.CmdPwm.Size()
		n += 1 + l + sovProtocolSlu(uint64(l))
	}
	return n
}

func (m *WlstSlu_7400_CmdPwm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.LoopCanDo) > 0 {
		l = 0
		for _, e := range m.LoopCanDo {
			l += sovProtocolSlu(uint64(e))
		}
		n += 1 + sovProtocolSlu(uint64(l)) + l
	}
	if m.Scale != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Scale))
	}
	if m.Rate != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Rate))
	}
	return n
}

func (m *WlstSlu_7C00) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovProtocolSlu(uint64(m.CmdIdx))
	}
	if m.AddrType != 0 {
		n += 1 + sovProtocolSlu(uint64(m.AddrType))
	}
	if m.Addr != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Addr))
	}
	if m.CmdCount != 0 {
		n += 1 + sovProtocolSlu(uint64(m.CmdCount))
	}
	if m.AddOrUpdate != 0 {
		n += 1 + sovProtocolSlu(uint64(m.AddOrUpdate))
	}
	if len(m.OperationData) > 0 {
		for _, e := range m.OperationData {
			l = e.Size()
			n += 1 + l + sovProtocolSlu(uint64(l))
		}
	}
	return n
}

func (m *WlstSlu_7C00_ConcentratorOperationData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OperationType != 0 {
		n += 1 + sovProtocolSlu(uint64(m.OperationType))
	}
	if m.CmdType != 0 {
		n += 1 + sovProtocolSlu(uint64(m.CmdType))
	}
	if len(m.WeekSet) > 0 {
		l = 0
		for _, e := range m.WeekSet {
			l += sovProtocolSlu(uint64(e))
		}
		n += 1 + sovProtocolSlu(uint64(l)) + l
	}
	if m.TimerOrOffset != 0 {
		n += 1 + sovProtocolSlu(uint64(m.TimerOrOffset))
	}
	if len(m.CmdMix) > 0 {
		l = 0
		for _, e := range m.CmdMix {
			l += sovProtocolSlu(uint64(e))
		}
		n += 1 + sovProtocolSlu(uint64(l)) + l
	}
	if m.CmdPwm != nil {
		l = m.CmdPwm.Size()
		n += 1 + l + sovProtocolSlu(uint64(l))
	}
	if m.Cmd_485 != nil {
		l = m.Cmd_485.Size()
		n += 1 + l + sovProtocolSlu(uint64(l))
	}
	return n
}

func (m *WlstSlu_7C00_ConcentratorOperationData_CmdPwm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.LoopCanDo) > 0 {
		l = 0
		for _, e := range m.LoopCanDo {
			l += sovProtocolSlu(uint64(e))
		}
		n += 1 + sovProtocolSlu(uint64(l)) + l
	}
	if m.Scale != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Scale))
	}
	if m.Rate != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Rate))
	}
	return n
}

func (m *WlstSlu_7C00_ConcentratorOperationData_Cmd_485) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Baudrate != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Baudrate))
	}
	if m.Check != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Check))
	}
	if m.DataLength != 0 {
		n += 1 + sovProtocolSlu(uint64(m.DataLength))
	}
	l = len(m.Data_485)
	if l > 0 {
		n += 1 + l + sovProtocolSlu(uint64(l))
	}
	return n
}

func (m *WlstSlu_6F00) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdIdx != 0 {
		n += 1 + sovProtocolSlu(uint64(m.CmdIdx))
	}
	if m.AddrType != 0 {
		n += 1 + sovProtocolSlu(uint64(m.AddrType))
	}
	if m.Addr != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Addr))
	}
	if m.ResetMark != nil {
		l = m.ResetMark.Size()
		n += 1 + l + sovProtocolSlu(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovProtocolSlu(uint64(m.Status))
	}
	return n
}

func (m *WlstSlu_6F00_ResetMark) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResetMcu != 0 {
		n += 1 + sovProtocolSlu(uint64(m.ResetMcu))
	}
	if m.ResetComm != 0 {
		n += 1 + sovProtocolSlu(uint64(m.ResetComm))
	}
	if m.InitMcuHardware != 0 {
		n += 1 + sovProtocolSlu(uint64(m.InitMcuHardware))
	}
	if m.InitRam != 0 {
		n += 1 + sovProtocolSlu(uint64(m.InitRam))
	}
	if m.ZeroEerom != 0 {
		n += 1 + sovProtocolSlu(uint64(m.ZeroEerom))
	}
	if m.ZeroCount != 0 {
		n += 1 + sovProtocolSlu(uint64(m.ZeroCount))
	}
	return n
}

func sovProtocolSlu(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozProtocolSlu(x uint64) (n int) {
	return sovProtocolSlu(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *WlstSluF400) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSluF400{`,
		`CmdIdx:` + fmt.Sprintf("%v", this.CmdIdx) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`Remark:` + fmt.Sprintf("%v", this.Remark) + `,`,
		`SluitemAddr:` + fmt.Sprintf("%v", this.SluitemAddr) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_3900) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForLightData := "[]*WlstSlu_3900_LightData{"
	for _, f := range this.LightData {
		repeatedStringForLightData += strings.Replace(fmt.Sprintf("%v", f), "WlstSlu_3900_LightData", "WlstSlu_3900_LightData", 1) + ","
	}
	repeatedStringForLightData += "}"
	s := strings.Join([]string{`&WlstSlu_3900{`,
		`CmdIdx:` + fmt.Sprintf("%v", this.CmdIdx) + `,`,
		`ModelInfo:` + strings.Replace(fmt.Sprintf("%v", this.ModelInfo), "WlstSlu_3900_ModelInfo", "WlstSlu_3900_ModelInfo", 1) + `,`,
		`LightData:` + repeatedStringForLightData + `,`,
		`LeakageCurrent:` + fmt.Sprintf("%v", this.LeakageCurrent) + `,`,
		`SluitemStatus:` + strings.Replace(fmt.Sprintf("%v", this.SluitemStatus), "WlstSlu_3900_SluitemStatus", "WlstSlu_3900_SluitemStatus", 1) + `,`,
		`TimeFault:` + strings.Replace(fmt.Sprintf("%v", this.TimeFault), "WlstSlu_3900_TimeFault", "WlstSlu_3900_TimeFault", 1) + `,`,
		`ResetCount:` + fmt.Sprintf("%v", this.ResetCount) + `,`,
		`DateTime:` + fmt.Sprintf("%v", this.DateTime) + `,`,
		`SluitemPara:` + strings.Replace(fmt.Sprintf("%v", this.SluitemPara), "WlstSlu_3900_SluitemPara", "WlstSlu_3900_SluitemPara", 1) + `,`,
		`Rsrp:` + fmt.Sprintf("%v", this.Rsrp) + `,`,
		`Rssi:` + fmt.Sprintf("%v", this.Rssi) + `,`,
		`Snr:` + fmt.Sprintf("%v", this.Snr) + `,`,
		`Pci:` + fmt.Sprintf("%v", this.Pci) + `,`,
		`Rsrq:` + fmt.Sprintf("%v", this.Rsrq) + `,`,
		`Txpower:` + fmt.Sprintf("%v", this.Txpower) + `,`,
		`Earfcn:` + fmt.Sprintf("%v", this.Earfcn) + `,`,
		`Ecl:` + fmt.Sprintf("%v", this.Ecl) + `,`,
		`Csq:` + fmt.Sprintf("%v", this.Csq) + `,`,
		`Reson:` + fmt.Sprintf("%v", this.Reson) + `,`,
		`Retry:` + fmt.Sprintf("%v", this.Retry) + `,`,
		`Sunrise:` + fmt.Sprintf("%v", this.Sunrise) + `,`,
		`Sunset:` + fmt.Sprintf("%v", this.Sunset) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_3900_ModelInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSlu_3900_ModelInfo{`,
		`SluitemLoop:` + fmt.Sprintf("%v", this.SluitemLoop) + `,`,
		`PowerSaving:` + fmt.Sprintf("%v", this.PowerSaving) + `,`,
		`HasLeakage:` + fmt.Sprintf("%v", this.HasLeakage) + `,`,
		`HasTemperature:` + fmt.Sprintf("%v", this.HasTemperature) + `,`,
		`HasTimer:` + fmt.Sprintf("%v", this.HasTimer) + `,`,
		`Model:` + fmt.Sprintf("%v", this.Model) + `,`,
		`SluitemType:` + fmt.Sprintf("%v", this.SluitemType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_3900_LightData) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSlu_3900_LightData{`,
		`Voltage:` + fmt.Sprintf("%v", this.Voltage) + `,`,
		`Current:` + fmt.Sprintf("%v", this.Current) + `,`,
		`ActivePower:` + fmt.Sprintf("%v", this.ActivePower) + `,`,
		`ReactivePower:` + fmt.Sprintf("%v", this.ReactivePower) + `,`,
		`ApparentPower:` + fmt.Sprintf("%v", this.ApparentPower) + `,`,
		`Electricity:` + fmt.Sprintf("%v", this.Electricity) + `,`,
		`ActiveTime:` + fmt.Sprintf("%v", this.ActiveTime) + `,`,
		`LightStatus:` + strings.Replace(fmt.Sprintf("%v", this.LightStatus), "WlstSlu_3900_LightStatus", "WlstSlu_3900_LightStatus", 1) + `,`,
		`PowerLevel:` + fmt.Sprintf("%v", this.PowerLevel) + `,`,
		`SluitemPowerTurnon:` + fmt.Sprintf("%v", this.SluitemPowerTurnon) + `,`,
		`RatedPower:` + fmt.Sprintf("%v", this.RatedPower) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_3900_LightStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSlu_3900_LightStatus{`,
		`Leakage:` + fmt.Sprintf("%v", this.Leakage) + `,`,
		`Fault:` + fmt.Sprintf("%v", this.Fault) + `,`,
		`WorkingOn:` + fmt.Sprintf("%v", this.WorkingOn) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_3900_SluitemStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSlu_3900_SluitemStatus{`,
		`FlashFault:` + fmt.Sprintf("%v", this.FlashFault) + `,`,
		`EnableAlarm:` + fmt.Sprintf("%v", this.EnableAlarm) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_3900_TimeFault) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSlu_3900_TimeFault{`,
		`ClockFault:` + fmt.Sprintf("%v", this.ClockFault) + `,`,
		`ClockOutFault:` + fmt.Sprintf("%v", this.ClockOutFault) + `,`,
		`ClockOutAlarm:` + fmt.Sprintf("%v", this.ClockOutAlarm) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_3900_SluitemPara) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSlu_3900_SluitemPara{`,
		`Longitude:` + fmt.Sprintf("%v", this.Longitude) + `,`,
		`Latitude:` + fmt.Sprintf("%v", this.Latitude) + `,`,
		`HasEnableAlarm:` + fmt.Sprintf("%v", this.HasEnableAlarm) + `,`,
		`IsRunning:` + fmt.Sprintf("%v", this.IsRunning) + `,`,
		`AlarmInterval:` + fmt.Sprintf("%v", this.AlarmInterval) + `,`,
		`UplinkReply:` + fmt.Sprintf("%v", this.UplinkReply) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_7800) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSlu_7800{`,
		`CmdIdx:` + fmt.Sprintf("%v", this.CmdIdx) + `,`,
		`EventType:` + fmt.Sprintf("%v", this.EventType) + `,`,
		`ClassType:` + fmt.Sprintf("%v", this.ClassType) + `,`,
		`RecordCount:` + fmt.Sprintf("%v", this.RecordCount) + `,`,
		`DtStart:` + fmt.Sprintf("%v", this.DtStart) + `,`,
		`DtEnd:` + fmt.Sprintf("%v", this.DtEnd) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSluF800) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForView_0X20 := "[]*WlstSluF800_View0X20{"
	for _, f := range this.View_0X20 {
		repeatedStringForView_0X20 += strings.Replace(fmt.Sprintf("%v", f), "WlstSluF800_View0X20", "WlstSluF800_View0X20", 1) + ","
	}
	repeatedStringForView_0X20 += "}"
	repeatedStringForView_0X21 := "[]*WlstSluF800_View0X21{"
	for _, f := range this.View_0X21 {
		repeatedStringForView_0X21 += strings.Replace(fmt.Sprintf("%v", f), "WlstSluF800_View0X21", "WlstSluF800_View0X21", 1) + ","
	}
	repeatedStringForView_0X21 += "}"
	repeatedStringForView_0X22 := "[]*WlstSluF800_View0X20{"
	for _, f := range this.View_0X22 {
		repeatedStringForView_0X22 += strings.Replace(fmt.Sprintf("%v", f), "WlstSluF800_View0X20", "WlstSluF800_View0X20", 1) + ","
	}
	repeatedStringForView_0X22 += "}"
	repeatedStringForView_0X23 := "[]*WlstSluF800_View0X23{"
	for _, f := range this.View_0X23 {
		repeatedStringForView_0X23 += strings.Replace(fmt.Sprintf("%v", f), "WlstSluF800_View0X23", "WlstSluF800_View0X23", 1) + ","
	}
	repeatedStringForView_0X23 += "}"
	repeatedStringForView_0X24 := "[]*WlstSluF800_View0X20{"
	for _, f := range this.View_0X24 {
		repeatedStringForView_0X24 += strings.Replace(fmt.Sprintf("%v", f), "WlstSluF800_View0X20", "WlstSluF800_View0X20", 1) + ","
	}
	repeatedStringForView_0X24 += "}"
	repeatedStringForView_0X25 := "[]*WlstSluF800_View0X20{"
	for _, f := range this.View_0X25 {
		repeatedStringForView_0X25 += strings.Replace(fmt.Sprintf("%v", f), "WlstSluF800_View0X20", "WlstSluF800_View0X20", 1) + ","
	}
	repeatedStringForView_0X25 += "}"
	s := strings.Join([]string{`&WlstSluF800{`,
		`CmdIdx:` + fmt.Sprintf("%v", this.CmdIdx) + `,`,
		`EventType:` + fmt.Sprintf("%v", this.EventType) + `,`,
		`ClassType:` + fmt.Sprintf("%v", this.ClassType) + `,`,
		`DataTotal:` + fmt.Sprintf("%v", this.DataTotal) + `,`,
		`DataIdx:` + fmt.Sprintf("%v", this.DataIdx) + `,`,
		`RecordCount:` + fmt.Sprintf("%v", this.RecordCount) + `,`,
		`View_0X20:` + repeatedStringForView_0X20 + `,`,
		`View_0X21:` + repeatedStringForView_0X21 + `,`,
		`View_0X22:` + repeatedStringForView_0X22 + `,`,
		`View_0X23:` + repeatedStringForView_0X23 + `,`,
		`View_0X24:` + repeatedStringForView_0X24 + `,`,
		`View_0X25:` + repeatedStringForView_0X25 + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSluF800_View0X20) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSluF800_View0X20{`,
		`DtHappen:` + fmt.Sprintf("%v", this.DtHappen) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSluF800_View0X21) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSluF800_View0X21{`,
		`DtHappen:` + fmt.Sprintf("%v", this.DtHappen) + `,`,
		`OperationType:` + fmt.Sprintf("%v", this.OperationType) + `,`,
		`OperationOrder:` + fmt.Sprintf("%v", this.OperationOrder) + `,`,
		`AddrType:` + fmt.Sprintf("%v", this.AddrType) + `,`,
		`Addr:` + fmt.Sprintf("%v", this.Addr) + `,`,
		`OperationSource:` + fmt.Sprintf("%v", this.OperationSource) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSluF800_View0X23) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSluF800_View0X23{`,
		`DtHappen:` + fmt.Sprintf("%v", this.DtHappen) + `,`,
		`Addr:` + fmt.Sprintf("%v", this.Addr) + `,`,
		`AlarmType:` + fmt.Sprintf("%v", this.AlarmType) + `,`,
		`SluitemStatus:` + fmt.Sprintf("%v", this.SluitemStatus) + `,`,
		`SluitemVoltage:` + fmt.Sprintf("%v", this.SluitemVoltage) + `,`,
		`SluitemCurrent:` + fmt.Sprintf("%v", this.SluitemCurrent) + `,`,
		`SluitemActivePower:` + fmt.Sprintf("%v", this.SluitemActivePower) + `,`,
		`SluitemReactivePower:` + fmt.Sprintf("%v", this.SluitemReactivePower) + `,`,
		`SluitemMaxVoltage:` + fmt.Sprintf("%v", this.SluitemMaxVoltage) + `,`,
		`SluitemMaxCurrent:` + fmt.Sprintf("%v", this.SluitemMaxCurrent) + `,`,
		`SluitemElectricity:` + fmt.Sprintf("%v", this.SluitemElectricity) + `,`,
		`SluitemPhyinfo:` + fmt.Sprintf("%v", this.SluitemPhyinfo) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSluEc00) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForWlstSlu_6B00 := "[]*WlstSlu_6B00{"
	for _, f := range this.WlstSlu_6B00 {
		repeatedStringForWlstSlu_6B00 += strings.Replace(fmt.Sprintf("%v", f), "WlstSlu_6B00", "WlstSlu_6B00", 1) + ","
	}
	repeatedStringForWlstSlu_6B00 += "}"
	s := strings.Join([]string{`&WlstSluEc00{`,
		`CmdIdx:` + fmt.Sprintf("%v", this.CmdIdx) + `,`,
		`StartIdx:` + fmt.Sprintf("%v", this.StartIdx) + `,`,
		`ReadCount:` + fmt.Sprintf("%v", this.ReadCount) + `,`,
		`WlstSlu_6B00:` + repeatedStringForWlstSlu_6B00 + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_6B00) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSlu_6B00{`,
		`CmdIdx:` + fmt.Sprintf("%v", this.CmdIdx) + `,`,
		`SetIdx:` + fmt.Sprintf("%v", this.SetIdx) + `,`,
		`DtStart:` + fmt.Sprintf("%v", this.DtStart) + `,`,
		`DtEnd:` + fmt.Sprintf("%v", this.DtEnd) + `,`,
		`OperationType:` + fmt.Sprintf("%v", this.OperationType) + `,`,
		`OperationOrder:` + fmt.Sprintf("%v", this.OperationOrder) + `,`,
		`TimerOrOffset:` + fmt.Sprintf("%v", this.TimerOrOffset) + `,`,
		`AddrType:` + fmt.Sprintf("%v", this.AddrType) + `,`,
		`Addrs:` + fmt.Sprintf("%v", this.Addrs) + `,`,
		`CmdType:` + fmt.Sprintf("%v", this.CmdType) + `,`,
		`CmdMix:` + fmt.Sprintf("%v", this.CmdMix) + `,`,
		`CmdPwm:` + strings.Replace(fmt.Sprintf("%v", this.CmdPwm), "WlstSlu_6B00_CmdPwm", "WlstSlu_6B00_CmdPwm", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_6B00_CmdPwm) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSlu_6B00_CmdPwm{`,
		`LoopCanDo:` + fmt.Sprintf("%v", this.LoopCanDo) + `,`,
		`Scale:` + fmt.Sprintf("%v", this.Scale) + `,`,
		`Rate:` + fmt.Sprintf("%v", this.Rate) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_6C00) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSlu_6C00{`,
		`CmdIdx:` + fmt.Sprintf("%v", this.CmdIdx) + `,`,
		`StartIdx:` + fmt.Sprintf("%v", this.StartIdx) + `,`,
		`ReadCount:` + fmt.Sprintf("%v", this.ReadCount) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSluD000) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSluD000{`,
		`Ver:` + fmt.Sprintf("%v", this.Ver) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_2800) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSlu_2800{`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`Alarm:` + fmt.Sprintf("%v", this.Alarm) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_2400) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSlu_2400{`,
		`DoFlag:` + fmt.Sprintf("%v", this.DoFlag) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_6E00) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSlu_6E00{`,
		`DoFlag:` + fmt.Sprintf("%v", this.DoFlag) + `,`,
		`PatrolStart:` + fmt.Sprintf("%v", this.PatrolStart) + `,`,
		`PatrolInterval:` + fmt.Sprintf("%v", this.PatrolInterval) + `,`,
		`PatrolOrder:` + fmt.Sprintf("%v", this.PatrolOrder) + `,`,
		`PatrolCount:` + fmt.Sprintf("%v", this.PatrolCount) + `,`,
		`CmdIdx:` + fmt.Sprintf("%v", this.CmdIdx) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_3000) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSlu_3000{`,
		`Ctrls:` + fmt.Sprintf("%v", this.Ctrls) + `,`,
		`DomainName:` + fmt.Sprintf("%v", this.DomainName) + `,`,
		`UpperVoltageLimit:` + fmt.Sprintf("%v", this.UpperVoltageLimit) + `,`,
		`LowerVoltageLimit:` + fmt.Sprintf("%v", this.LowerVoltageLimit) + `,`,
		`MacAddr:` + fmt.Sprintf("%v", this.MacAddr) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_9A00) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSlu_9A00{`,
		`DomainNameStatus:` + fmt.Sprintf("%v", this.DomainNameStatus) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSluCd00) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSluCd00{`,
		`CommunicationFailures:` + fmt.Sprintf("%v", this.CommunicationFailures) + `,`,
		`PowerFactor:` + fmt.Sprintf("%v", this.PowerFactor) + `,`,
		`CommunicationChannel:` + fmt.Sprintf("%v", this.CommunicationChannel) + `,`,
		`CurrentRange:` + fmt.Sprintf("%v", this.CurrentRange) + `,`,
		`PowerRange:` + fmt.Sprintf("%v", this.PowerRange) + `,`,
		`AutoMode:` + fmt.Sprintf("%v", this.AutoMode) + `,`,
		`Longitude:` + fmt.Sprintf("%v", this.Longitude) + `,`,
		`Latitude:` + fmt.Sprintf("%v", this.Latitude) + `,`,
		`CarrierRoutingMode:` + fmt.Sprintf("%v", this.CarrierRoutingMode) + `,`,
		`BluetoothPin:` + fmt.Sprintf("%v", this.BluetoothPin) + `,`,
		`BluetoothMode:` + fmt.Sprintf("%v", this.BluetoothMode) + `,`,
		`Cct:` + fmt.Sprintf("%v", this.Cct) + `,`,
		`CmdIdx:` + fmt.Sprintf("%v", this.CmdIdx) + `,`,
		`AlwaysOnline:` + fmt.Sprintf("%v", this.AlwaysOnline) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_1C00) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSlu_1C00{`,
		`CmdIdx:` + fmt.Sprintf("%v", this.CmdIdx) + `,`,
		`SluitemIdx:` + fmt.Sprintf("%v", this.SluitemIdx) + `,`,
		`DomainName:` + fmt.Sprintf("%v", this.DomainName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_1D00) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSlu_1D00{`,
		`CmdIdx:` + fmt.Sprintf("%v", this.CmdIdx) + `,`,
		`SluitemIdx:` + fmt.Sprintf("%v", this.SluitemIdx) + `,`,
		`DataMark:` + strings.Replace(fmt.Sprintf("%v", this.DataMark), "WlstSlu_1D00_DataMark", "WlstSlu_1D00_DataMark", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_1D00_DataMark) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSlu_1D00_DataMark{`,
		`ReadData:` + fmt.Sprintf("%v", this.ReadData) + `,`,
		`ReadTimer:` + fmt.Sprintf("%v", this.ReadTimer) + `,`,
		`ReadArgs:` + fmt.Sprintf("%v", this.ReadArgs) + `,`,
		`ReadGroup:` + fmt.Sprintf("%v", this.ReadGroup) + `,`,
		`ReadVer:` + fmt.Sprintf("%v", this.ReadVer) + `,`,
		`ReadSunriseset:` + fmt.Sprintf("%v", this.ReadSunriseset) + `,`,
		`ReadTimetable:` + fmt.Sprintf("%v", this.ReadTimetable) + `,`,
		`ReadCtrldata:` + fmt.Sprintf("%v", this.ReadCtrldata) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_9D00) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSluitemRuntime := "[]*WlstSlu_9D00_SluitemRuntime{"
	for _, f := range this.SluitemRuntime {
		repeatedStringForSluitemRuntime += strings.Replace(fmt.Sprintf("%v", f), "WlstSlu_9D00_SluitemRuntime", "WlstSlu_9D00_SluitemRuntime", 1) + ","
	}
	repeatedStringForSluitemRuntime += "}"
	s := strings.Join([]string{`&WlstSlu_9D00{`,
		`CmdIdx:` + fmt.Sprintf("%v", this.CmdIdx) + `,`,
		`SluitemIdx:` + fmt.Sprintf("%v", this.SluitemIdx) + `,`,
		`DataMark:` + strings.Replace(fmt.Sprintf("%v", this.DataMark), "WlstSlu_1D00_DataMark", "WlstSlu_1D00_DataMark", 1) + `,`,
		`LoopCount:` + fmt.Sprintf("%v", this.LoopCount) + `,`,
		`SluitemData:` + strings.Replace(fmt.Sprintf("%v", this.SluitemData), "WlstSlu_9D00_SluitemData", "WlstSlu_9D00_SluitemData", 1) + `,`,
		`SluitemTime:` + fmt.Sprintf("%v", this.SluitemTime) + `,`,
		`SluitemPara:` + strings.Replace(fmt.Sprintf("%v", this.SluitemPara), "WlstSlu_9D00_SluitemPara", "WlstSlu_9D00_SluitemPara", 1) + `,`,
		`SluitemGroup:` + fmt.Sprintf("%v", this.SluitemGroup) + `,`,
		`SluitemVer:` + strings.Replace(fmt.Sprintf("%v", this.SluitemVer), "WlstSlu_9D00_SluitemVer", "WlstSlu_9D00_SluitemVer", 1) + `,`,
		`SluitemSunriseset:` + strings.Replace(fmt.Sprintf("%v", this.SluitemSunriseset), "WlstSlu_9D00_SluitemSunriseset", "WlstSlu_9D00_SluitemSunriseset", 1) + `,`,
		`SluitemRuntime:` + repeatedStringForSluitemRuntime + `,`,
		`SluitemDataNew:` + strings.Replace(fmt.Sprintf("%v", this.SluitemDataNew), "WlstSlu_9D00_SluitemDataNew", "WlstSlu_9D00_SluitemDataNew", 1) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`SetMark:` + strings.Replace(fmt.Sprintf("%v", this.SetMark), "WlstSlu_9D00_SetMark", "WlstSlu_9D00_SetMark", 1) + `,`,
		`DataContinue:` + fmt.Sprintf("%v", this.DataContinue) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_9D00_SetMark) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSlu_9D00_SetMark{`,
		`SetTimer:` + fmt.Sprintf("%v", this.SetTimer) + `,`,
		`SetArgs:` + fmt.Sprintf("%v", this.SetArgs) + `,`,
		`SetGroup:` + fmt.Sprintf("%v", this.SetGroup) + `,`,
		`SetReset:` + fmt.Sprintf("%v", this.SetReset) + `,`,
		`SetControl:` + fmt.Sprintf("%v", this.SetControl) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_9D00_SluitemData) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForLightStatus := "[]*WlstSlu_7300_BaseSluitemData_LightStatus{"
	for _, f := range this.LightStatus {
		repeatedStringForLightStatus += strings.Replace(fmt.Sprintf("%v", f), "WlstSlu_7300_BaseSluitemData_LightStatus", "WlstSlu_7300_BaseSluitemData_LightStatus", 1) + ","
	}
	repeatedStringForLightStatus += "}"
	s := strings.Join([]string{`&WlstSlu_9D00_SluitemData{`,
		`Voltage:` + fmt.Sprintf("%v", this.Voltage) + `,`,
		`Current:` + fmt.Sprintf("%v", this.Current) + `,`,
		`ActivePower:` + fmt.Sprintf("%v", this.ActivePower) + `,`,
		`ReactivePower:` + fmt.Sprintf("%v", this.ReactivePower) + `,`,
		`MaxVoltage:` + fmt.Sprintf("%v", this.MaxVoltage) + `,`,
		`MaxCurrent:` + fmt.Sprintf("%v", this.MaxCurrent) + `,`,
		`TotalElectricity:` + fmt.Sprintf("%v", this.TotalElectricity) + `,`,
		`Temperature:` + fmt.Sprintf("%v", this.Temperature) + `,`,
		`LeakageCurrent:` + fmt.Sprintf("%v", this.LeakageCurrent) + `,`,
		`TimerError:` + fmt.Sprintf("%v", this.TimerError) + `,`,
		`SluitemStatus:` + strings.Replace(fmt.Sprintf("%v", this.SluitemStatus), "WlstSlu_7300_BaseSluitemData_SluitemStatus", "WlstSlu_7300_BaseSluitemData_SluitemStatus", 1) + `,`,
		`LightStatus:` + repeatedStringForLightStatus + `,`,
		`ResetCount:` + fmt.Sprintf("%v", this.ResetCount) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_9D00_SluitemDataNew) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForLightStatus := "[]*WlstSlu_7300_BaseSluitemData_LightStatus{"
	for _, f := range this.LightStatus {
		repeatedStringForLightStatus += strings.Replace(fmt.Sprintf("%v", f), "WlstSlu_7300_BaseSluitemData_LightStatus", "WlstSlu_7300_BaseSluitemData_LightStatus", 1) + ","
	}
	repeatedStringForLightStatus += "}"
	s := strings.Join([]string{`&WlstSlu_9D00_SluitemDataNew{`,
		`Voltage:` + fmt.Sprintf("%v", this.Voltage) + `,`,
		`Current:` + fmt.Sprintf("%v", this.Current) + `,`,
		`ActivePower:` + fmt.Sprintf("%v", this.ActivePower) + `,`,
		`RunTime:` + fmt.Sprintf("%v", this.RunTime) + `,`,
		`Phase:` + fmt.Sprintf("%v", this.Phase) + `,`,
		`TotalElectricity:` + fmt.Sprintf("%v", this.TotalElectricity) + `,`,
		`LeakageCurrent:` + fmt.Sprintf("%v", this.LeakageCurrent) + `,`,
		`TimerError:` + fmt.Sprintf("%v", this.TimerError) + `,`,
		`SluitemStatus:` + strings.Replace(fmt.Sprintf("%v", this.SluitemStatus), "WlstSlu_7300_BaseSluitemData_SluitemStatus", "WlstSlu_7300_BaseSluitemData_SluitemStatus", 1) + `,`,
		`LightStatus:` + repeatedStringForLightStatus + `,`,
		`ResetCount:` + fmt.Sprintf("%v", this.ResetCount) + `,`,
		`EnergySaving:` + fmt.Sprintf("%v", this.EnergySaving) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_9D00_SluitemPara) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSlu_9D00_SluitemPara{`,
		`DomainName:` + fmt.Sprintf("%v", this.DomainName) + `,`,
		`SluitemStatus:` + fmt.Sprintf("%v", this.SluitemStatus) + `,`,
		`SluitemEnableAlarm:` + fmt.Sprintf("%v", this.SluitemEnableAlarm) + `,`,
		`SluitemPowerTurnon:` + fmt.Sprintf("%v", this.SluitemPowerTurnon) + `,`,
		`SluitemVector:` + fmt.Sprintf("%v", this.SluitemVector) + `,`,
		`Longitude:` + fmt.Sprintf("%v", this.Longitude) + `,`,
		`Latitude:` + fmt.Sprintf("%v", this.Latitude) + `,`,
		`RatedPower:` + fmt.Sprintf("%v", this.RatedPower) + `,`,
		`UplinkTimer:` + fmt.Sprintf("%v", this.UplinkTimer) + `,`,
		`UplinkReply:` + fmt.Sprintf("%v", this.UplinkReply) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_9D00_SluitemVer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSlu_9D00_SluitemVer{`,
		`SluitemLoop:` + fmt.Sprintf("%v", this.SluitemLoop) + `,`,
		`EnergySaving:` + fmt.Sprintf("%v", this.EnergySaving) + `,`,
		`ElectricLeakageModule:` + fmt.Sprintf("%v", this.ElectricLeakageModule) + `,`,
		`TemperatureModule:` + fmt.Sprintf("%v", this.TemperatureModule) + `,`,
		`TimerModule:` + fmt.Sprintf("%v", this.TimerModule) + `,`,
		`SluitemType:` + fmt.Sprintf("%v", this.SluitemType) + `,`,
		`Ver:` + fmt.Sprintf("%v", this.Ver) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_9D00_SluitemSunriseset) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSlu_9D00_SluitemSunriseset{`,
		`Sunrise:` + fmt.Sprintf("%v", this.Sunrise) + `,`,
		`Sunset:` + fmt.Sprintf("%v", this.Sunset) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_9D00_SluitemRuntime) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSlu_9D00_SluitemRuntime{`,
		`DataType:` + fmt.Sprintf("%v", this.DataType) + `,`,
		`OutputType:` + fmt.Sprintf("%v", this.OutputType) + `,`,
		`OperateType:` + fmt.Sprintf("%v", this.OperateType) + `,`,
		`DateEnable:` + fmt.Sprintf("%v", this.DateEnable) + `,`,
		`OperateTime:` + fmt.Sprintf("%v", this.OperateTime) + `,`,
		`OperateOffset:` + fmt.Sprintf("%v", this.OperateOffset) + `,`,
		`RelayOperate:` + fmt.Sprintf("%v", this.RelayOperate) + `,`,
		`PwmLoop:` + fmt.Sprintf("%v", this.PwmLoop) + `,`,
		`PwmPower:` + fmt.Sprintf("%v", this.PwmPower) + `,`,
		`PwmBaudrate:` + fmt.Sprintf("%v", this.PwmBaudrate) + `,`,
		`Rs485Baudrate:` + fmt.Sprintf("%v", this.Rs485Baudrate) + `,`,
		`Rs485Check:` + fmt.Sprintf("%v", this.Rs485Check) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSluF000) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSluF000{`,
		`CmdIdx:` + fmt.Sprintf("%v", this.CmdIdx) + `,`,
		`ResetMark:` + strings.Replace(fmt.Sprintf("%v", this.ResetMark), "WlstSluF000_ResetMark", "WlstSluF000_ResetMark", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSluF000_ResetMark) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSluF000_ResetMark{`,
		`ClearTask:` + fmt.Sprintf("%v", this.ClearTask) + `,`,
		`ResetConcentrator:` + fmt.Sprintf("%v", this.ResetConcentrator) + `,`,
		`HardResetZigbee:` + fmt.Sprintf("%v", this.HardResetZigbee) + `,`,
		`SoftResetZigbee:` + fmt.Sprintf("%v", this.SoftResetZigbee) + `,`,
		`ResetCarrier:` + fmt.Sprintf("%v", this.ResetCarrier) + `,`,
		`InitAll:` + fmt.Sprintf("%v", this.InitAll) + `,`,
		`ClearData:` + fmt.Sprintf("%v", this.ClearData) + `,`,
		`ClearArgs:` + fmt.Sprintf("%v", this.ClearArgs) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSluF100) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSluF100{`,
		`CmdIdx:` + fmt.Sprintf("%v", this.CmdIdx) + `,`,
		`OptMark:` + fmt.Sprintf("%v", this.OptMark) + `,`,
		`DateTime:` + fmt.Sprintf("%v", this.DateTime) + `,`,
		`ForceTimer:` + fmt.Sprintf("%v", this.ForceTimer) + `,`,
		`TimerStatus:` + strings.Replace(fmt.Sprintf("%v", this.TimerStatus), "WlstSluF100_TimerStatus", "WlstSluF100_TimerStatus", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSluF100_TimerStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSluF100_TimerStatus{`,
		`DtformatError:` + fmt.Sprintf("%v", this.DtformatError) + `,`,
		`TimerError:` + fmt.Sprintf("%v", this.TimerError) + `,`,
		`TimeFault:` + fmt.Sprintf("%v", this.TimeFault) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSluF200) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSluitemData := "[]*WlstSluF200_ControllerData{"
	for _, f := range this.SluitemData {
		repeatedStringForSluitemData += strings.Replace(fmt.Sprintf("%v", f), "WlstSluF200_ControllerData", "WlstSluF200_ControllerData", 1) + ","
	}
	repeatedStringForSluitemData += "}"
	s := strings.Join([]string{`&WlstSluF200{`,
		`CmdIdx:` + fmt.Sprintf("%v", this.CmdIdx) + `,`,
		`SluitemIdx:` + fmt.Sprintf("%v", this.SluitemIdx) + `,`,
		`SluitemCount:` + fmt.Sprintf("%v", this.SluitemCount) + `,`,
		`DataMark:` + strings.Replace(fmt.Sprintf("%v", this.DataMark), "WlstSluF200_DataMark", "WlstSluF200_DataMark", 1) + `,`,
		`SluitemData:` + repeatedStringForSluitemData + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSluF200_DataMark) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSluF200_DataMark{`,
		`Group:` + fmt.Sprintf("%v", this.Group) + `,`,
		`Barcode:` + fmt.Sprintf("%v", this.Barcode) + `,`,
		`Route:` + fmt.Sprintf("%v", this.Route) + `,`,
		`Order:` + fmt.Sprintf("%v", this.Order) + `,`,
		`Limit:` + fmt.Sprintf("%v", this.Limit) + `,`,
		`PowerOnStatus:` + fmt.Sprintf("%v", this.PowerOnStatus) + `,`,
		`RunStatus:` + fmt.Sprintf("%v", this.RunStatus) + `,`,
		`Vector:` + fmt.Sprintf("%v", this.Vector) + `,`,
		`RatedPower:` + fmt.Sprintf("%v", this.RatedPower) + `,`,
		`LoopCount:` + fmt.Sprintf("%v", this.LoopCount) + `,`,
		`SetData:` + fmt.Sprintf("%v", this.SetData) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSluF200_ControllerData) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSluF200_ControllerData{`,
		`SluitemGroup:` + fmt.Sprintf("%v", this.SluitemGroup) + `,`,
		`SluitemIdx:` + fmt.Sprintf("%v", this.SluitemIdx) + `,`,
		`SluitemRoute:` + fmt.Sprintf("%v", this.SluitemRoute) + `,`,
		`SluitemOrder:` + fmt.Sprintf("%v", this.SluitemOrder) + `,`,
		`UpperPowerLimit:` + fmt.Sprintf("%v", this.UpperPowerLimit) + `,`,
		`LowerPowerLimit:` + fmt.Sprintf("%v", this.LowerPowerLimit) + `,`,
		`SluitemPowerTurnon:` + fmt.Sprintf("%v", this.SluitemPowerTurnon) + `,`,
		`SluitemStatus:` + fmt.Sprintf("%v", this.SluitemStatus) + `,`,
		`SluitemEnableAlarm:` + fmt.Sprintf("%v", this.SluitemEnableAlarm) + `,`,
		`SluitemVector:` + fmt.Sprintf("%v", this.SluitemVector) + `,`,
		`RatedPower:` + fmt.Sprintf("%v", this.RatedPower) + `,`,
		`LoopCount:` + fmt.Sprintf("%v", this.LoopCount) + `,`,
		`Longitude:` + fmt.Sprintf("%v", this.Longitude) + `,`,
		`Latitude:` + fmt.Sprintf("%v", this.Latitude) + `,`,
		`UplinkTimer:` + fmt.Sprintf("%v", this.UplinkTimer) + `,`,
		`UplinkReply:` + fmt.Sprintf("%v", this.UplinkReply) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_7300) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForBaseSluitemData := "[]*WlstSlu_7300_BaseSluitemData{"
	for _, f := range this.BaseSluitemData {
		repeatedStringForBaseSluitemData += strings.Replace(fmt.Sprintf("%v", f), "WlstSlu_7300_BaseSluitemData", "WlstSlu_7300_BaseSluitemData", 1) + ","
	}
	repeatedStringForBaseSluitemData += "}"
	repeatedStringForUnknowSluitem := "[]*WlstSlu_7300_UnknowSluitem{"
	for _, f := range this.UnknowSluitem {
		repeatedStringForUnknowSluitem += strings.Replace(fmt.Sprintf("%v", f), "WlstSlu_7300_UnknowSluitem", "WlstSlu_7300_UnknowSluitem", 1) + ","
	}
	repeatedStringForUnknowSluitem += "}"
	repeatedStringForAssistSluitemData := "[]*WlstSlu_7300_AssistSluitemData{"
	for _, f := range this.AssistSluitemData {
		repeatedStringForAssistSluitemData += strings.Replace(fmt.Sprintf("%v", f), "WlstSlu_7300_AssistSluitemData", "WlstSlu_7300_AssistSluitemData", 1) + ","
	}
	repeatedStringForAssistSluitemData += "}"
	repeatedStringForSluitemPhyinfo := "[]*WlstSlu_7300_SluitemPhyinfo{"
	for _, f := range this.SluitemPhyinfo {
		repeatedStringForSluitemPhyinfo += strings.Replace(fmt.Sprintf("%v", f), "WlstSlu_7300_SluitemPhyinfo", "WlstSlu_7300_SluitemPhyinfo", 1) + ","
	}
	repeatedStringForSluitemPhyinfo += "}"
	s := strings.Join([]string{`&WlstSlu_7300{`,
		`CmdIdx:` + fmt.Sprintf("%v", this.CmdIdx) + `,`,
		`SluitemStart:` + fmt.Sprintf("%v", this.SluitemStart) + `,`,
		`SluitemCount:` + fmt.Sprintf("%v", this.SluitemCount) + `,`,
		`DataMark:` + fmt.Sprintf("%v", this.DataMark) + `,`,
		`ConcentratorData:` + strings.Replace(fmt.Sprintf("%v", this.ConcentratorData), "WlstSlu_7300_ConcentratorData", "WlstSlu_7300_ConcentratorData", 1) + `,`,
		`BaseSluitemData:` + repeatedStringForBaseSluitemData + `,`,
		`UnknowSluitem:` + repeatedStringForUnknowSluitem + `,`,
		`AssistSluitemData:` + repeatedStringForAssistSluitemData + `,`,
		`SluitemPhyinfo:` + repeatedStringForSluitemPhyinfo + `,`,
		`SluitemAddrs:` + fmt.Sprintf("%v", this.SluitemAddrs) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_7300_ConcentratorData) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSlu_7300_ConcentratorData{`,
		`ResetCount:` + fmt.Sprintf("%v", this.ResetCount) + `,`,
		`RunStatus:` + strings.Replace(fmt.Sprintf("%v", this.RunStatus), "WlstSlu_7300_ConcentratorData_RunStatus", "WlstSlu_7300_ConcentratorData_RunStatus", 1) + `,`,
		`ArgsStatus:` + strings.Replace(fmt.Sprintf("%v", this.ArgsStatus), "WlstSlu_7300_ConcentratorData_ArgsStatus", "WlstSlu_7300_ConcentratorData_ArgsStatus", 1) + `,`,
		`HardwareStatus:` + strings.Replace(fmt.Sprintf("%v", this.HardwareStatus), "WlstSlu_7300_ConcentratorData_HardwareStatus", "WlstSlu_7300_ConcentratorData_HardwareStatus", 1) + `,`,
		`UnknowSluitemCount:` + fmt.Sprintf("%v", this.UnknowSluitemCount) + `,`,
		`CommunicationChannel:` + fmt.Sprintf("%v", this.CommunicationChannel) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_7300_ConcentratorData_RunStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSlu_7300_ConcentratorData_RunStatus{`,
		`Offline:` + fmt.Sprintf("%v", this.Offline) + `,`,
		`EnableAlarm:` + fmt.Sprintf("%v", this.EnableAlarm) + `,`,
		`PoweronMark:` + fmt.Sprintf("%v", this.PoweronMark) + `,`,
		`EnableGprs:` + fmt.Sprintf("%v", this.EnableGprs) + `,`,
		`EnableAutochk:` + fmt.Sprintf("%v", this.EnableAutochk) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_7300_ConcentratorData_ArgsStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSlu_7300_ConcentratorData_ArgsStatus{`,
		`ConcentratorArgsError:` + fmt.Sprintf("%v", this.ConcentratorArgsError) + `,`,
		`SluitemArgsError:` + fmt.Sprintf("%v", this.SluitemArgsError) + `,`,
		`TurnOnoffError:` + fmt.Sprintf("%v", this.TurnOnoffError) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_7300_ConcentratorData_HardwareStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSlu_7300_ConcentratorData_HardwareStatus{`,
		`ZigbeeError:` + fmt.Sprintf("%v", this.ZigbeeError) + `,`,
		`CarrierError:` + fmt.Sprintf("%v", this.CarrierError) + `,`,
		`FramError:` + fmt.Sprintf("%v", this.FramError) + `,`,
		`BluetoothError:` + fmt.Sprintf("%v", this.BluetoothError) + `,`,
		`TimerError:` + fmt.Sprintf("%v", this.TimerError) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_7300_BaseSluitemData) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForLightStatus := "[]*WlstSlu_7300_BaseSluitemData_LightStatus{"
	for _, f := range this.LightStatus {
		repeatedStringForLightStatus += strings.Replace(fmt.Sprintf("%v", f), "WlstSlu_7300_BaseSluitemData_LightStatus", "WlstSlu_7300_BaseSluitemData_LightStatus", 1) + ","
	}
	repeatedStringForLightStatus += "}"
	repeatedStringForLightData := "[]*WlstSlu_7300_BaseSluitemData_LightData{"
	for _, f := range this.LightData {
		repeatedStringForLightData += strings.Replace(fmt.Sprintf("%v", f), "WlstSlu_7300_BaseSluitemData_LightData", "WlstSlu_7300_BaseSluitemData_LightData", 1) + ","
	}
	repeatedStringForLightData += "}"
	s := strings.Join([]string{`&WlstSlu_7300_BaseSluitemData{`,
		`DateTime:` + fmt.Sprintf("%v", this.DateTime) + `,`,
		`SluitemStatus:` + strings.Replace(fmt.Sprintf("%v", this.SluitemStatus), "WlstSlu_7300_BaseSluitemData_SluitemStatus", "WlstSlu_7300_BaseSluitemData_SluitemStatus", 1) + `,`,
		`Temperature:` + fmt.Sprintf("%v", this.Temperature) + `,`,
		`LightStatus:` + repeatedStringForLightStatus + `,`,
		`LightData:` + repeatedStringForLightData + `,`,
		`SluitemLoop:` + fmt.Sprintf("%v", this.SluitemLoop) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_7300_BaseSluitemData_SluitemStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSlu_7300_BaseSluitemData_SluitemStatus{`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`Adjust:` + fmt.Sprintf("%v", this.Adjust) + `,`,
		`WorkingArgs:` + fmt.Sprintf("%v", this.WorkingArgs) + `,`,
		`NoAlarm:` + fmt.Sprintf("%v", this.NoAlarm) + `,`,
		`OffLine:` + fmt.Sprintf("%v", this.OffLine) + `,`,
		`EepromError:` + fmt.Sprintf("%v", this.EepromError) + `,`,
		`TemperatureSensor:` + fmt.Sprintf("%v", this.TemperatureSensor) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_7300_BaseSluitemData_LightStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSlu_7300_BaseSluitemData_LightStatus{`,
		`PowerStatus:` + fmt.Sprintf("%v", this.PowerStatus) + `,`,
		`Leakage:` + fmt.Sprintf("%v", this.Leakage) + `,`,
		`Fault:` + fmt.Sprintf("%v", this.Fault) + `,`,
		`WorkingOn:` + fmt.Sprintf("%v", this.WorkingOn) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_7300_BaseSluitemData_LightData) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSlu_7300_BaseSluitemData_LightData{`,
		`Voltage:` + fmt.Sprintf("%v", this.Voltage) + `,`,
		`Current:` + fmt.Sprintf("%v", this.Current) + `,`,
		`ActivePower:` + fmt.Sprintf("%v", this.ActivePower) + `,`,
		`Electricity:` + fmt.Sprintf("%v", this.Electricity) + `,`,
		`ActiveTime:` + fmt.Sprintf("%v", this.ActiveTime) + `,`,
		`PowerLevel:` + fmt.Sprintf("%v", this.PowerLevel) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_7300_UnknowSluitem) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSlu_7300_UnknowSluitem{`,
		`SluitemIdx:` + fmt.Sprintf("%v", this.SluitemIdx) + `,`,
		`ModelInfo:` + strings.Replace(fmt.Sprintf("%v", this.ModelInfo), "WlstSlu_7300_ModelInfo", "WlstSlu_7300_ModelInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_7300_AssistSluitemData) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForLightData := "[]*WlstSlu_7300_AssistSluitemData_LightData{"
	for _, f := range this.LightData {
		repeatedStringForLightData += strings.Replace(fmt.Sprintf("%v", f), "WlstSlu_7300_AssistSluitemData_LightData", "WlstSlu_7300_AssistSluitemData_LightData", 1) + ","
	}
	repeatedStringForLightData += "}"
	s := strings.Join([]string{`&WlstSlu_7300_AssistSluitemData{`,
		`DateTime:` + fmt.Sprintf("%v", this.DateTime) + `,`,
		`LeakageCurrent:` + fmt.Sprintf("%v", this.LeakageCurrent) + `,`,
		`LightData:` + repeatedStringForLightData + `,`,
		`SluitemLoop:` + fmt.Sprintf("%v", this.SluitemLoop) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_7300_AssistSluitemData_LightData) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSlu_7300_AssistSluitemData_LightData{`,
		`MaxVoltage:` + fmt.Sprintf("%v", this.MaxVoltage) + `,`,
		`MaxCurrent:` + fmt.Sprintf("%v", this.MaxCurrent) + `,`,
		`Electricity:` + fmt.Sprintf("%v", this.Electricity) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_7300_SluitemPhyinfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSlu_7300_SluitemPhyinfo{`,
		`SignalStrength:` + fmt.Sprintf("%v", this.SignalStrength) + `,`,
		`Routing:` + fmt.Sprintf("%v", this.Routing) + `,`,
		`Phase:` + fmt.Sprintf("%v", this.Phase) + `,`,
		`UsefulCommunicate:` + fmt.Sprintf("%v", this.UsefulCommunicate) + `,`,
		`AllCommunicate:` + fmt.Sprintf("%v", this.AllCommunicate) + `,`,
		`ModelInfo:` + strings.Replace(fmt.Sprintf("%v", this.ModelInfo), "WlstSlu_7300_ModelInfo", "WlstSlu_7300_ModelInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_7300_ModelInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSlu_7300_ModelInfo{`,
		`SluitemLoop:` + fmt.Sprintf("%v", this.SluitemLoop) + `,`,
		`PowerSaving:` + fmt.Sprintf("%v", this.PowerSaving) + `,`,
		`HasLeakage:` + fmt.Sprintf("%v", this.HasLeakage) + `,`,
		`HasTemperature:` + fmt.Sprintf("%v", this.HasTemperature) + `,`,
		`HasTimer:` + fmt.Sprintf("%v", this.HasTimer) + `,`,
		`Model:` + fmt.Sprintf("%v", this.Model) + `,`,
		`SluitemType:` + fmt.Sprintf("%v", this.SluitemType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSluF900) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSluitemStatusAlarm := "[]*WlstSluF900_SluitemStatusAlarm{"
	for _, f := range this.SluitemStatusAlarm {
		repeatedStringForSluitemStatusAlarm += strings.Replace(fmt.Sprintf("%v", f), "WlstSluF900_SluitemStatusAlarm", "WlstSluF900_SluitemStatusAlarm", 1) + ","
	}
	repeatedStringForSluitemStatusAlarm += "}"
	s := strings.Join([]string{`&WlstSluF900{`,
		`CmdIdx:` + fmt.Sprintf("%v", this.CmdIdx) + `,`,
		`AlarmType:` + fmt.Sprintf("%v", this.AlarmType) + `,`,
		`ConcentratorData:` + strings.Replace(fmt.Sprintf("%v", this.ConcentratorData), "WlstSlu_7300_ConcentratorData", "WlstSlu_7300_ConcentratorData", 1) + `,`,
		`ErrorCtrls:` + fmt.Sprintf("%v", this.ErrorCtrls) + `,`,
		`SluitemStatusAlarm:` + repeatedStringForSluitemStatusAlarm + `,`,
		`BluetoothApply:` + strings.Replace(fmt.Sprintf("%v", this.BluetoothApply), "WlstSluF900_BluetoothApply", "WlstSluF900_BluetoothApply", 1) + `,`,
		`SetDomainResult:` + strings.Replace(fmt.Sprintf("%v", this.SetDomainResult), "WlstSluF900_SetDomainResult", "WlstSluF900_SetDomainResult", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSluF900_SluitemStatusAlarm) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForLightStatus := "[]*WlstSlu_7300_BaseSluitemData_LightStatus{"
	for _, f := range this.LightStatus {
		repeatedStringForLightStatus += strings.Replace(fmt.Sprintf("%v", f), "WlstSlu_7300_BaseSluitemData_LightStatus", "WlstSlu_7300_BaseSluitemData_LightStatus", 1) + ","
	}
	repeatedStringForLightStatus += "}"
	s := strings.Join([]string{`&WlstSluF900_SluitemStatusAlarm{`,
		`SluitemIdx:` + fmt.Sprintf("%v", this.SluitemIdx) + `,`,
		`SluitemLoop:` + fmt.Sprintf("%v", this.SluitemLoop) + `,`,
		`SluitemStatus:` + strings.Replace(fmt.Sprintf("%v", this.SluitemStatus), "WlstSlu_7300_BaseSluitemData_SluitemStatus", "WlstSlu_7300_BaseSluitemData_SluitemStatus", 1) + `,`,
		`LightStatus:` + repeatedStringForLightStatus + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSluF900_BluetoothApply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSluF900_BluetoothApply{`,
		`SimNumber:` + fmt.Sprintf("%v", this.SimNumber) + `,`,
		`CheckCode:` + fmt.Sprintf("%v", this.CheckCode) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSluF900_SetDomainResult) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSluF900_SetDomainResult{`,
		`DomainName:` + fmt.Sprintf("%v", this.DomainName) + `,`,
		`SetSuccess:` + fmt.Sprintf("%v", this.SetSuccess) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_7B00) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForOperationData := "[]*WlstSlu_7B00_ReadConcentratorOperationData{"
	for _, f := range this.OperationData {
		repeatedStringForOperationData += strings.Replace(fmt.Sprintf("%v", f), "WlstSlu_7B00_ReadConcentratorOperationData", "WlstSlu_7B00_ReadConcentratorOperationData", 1) + ","
	}
	repeatedStringForOperationData += "}"
	s := strings.Join([]string{`&WlstSlu_7B00{`,
		`CmdIdx:` + fmt.Sprintf("%v", this.CmdIdx) + `,`,
		`SluitemIdx:` + fmt.Sprintf("%v", this.SluitemIdx) + `,`,
		`DataCount:` + fmt.Sprintf("%v", this.DataCount) + `,`,
		`OperationData:` + repeatedStringForOperationData + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_7B00_ReadConcentratorOperationData) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForCmdMix := "[]*WlstSlu_7B00_ReadConcentratorOperationData_CmdOperation{"
	for _, f := range this.CmdMix {
		repeatedStringForCmdMix += strings.Replace(fmt.Sprintf("%v", f), "WlstSlu_7B00_ReadConcentratorOperationData_CmdOperation", "WlstSlu_7B00_ReadConcentratorOperationData_CmdOperation", 1) + ","
	}
	repeatedStringForCmdMix += "}"
	s := strings.Join([]string{`&WlstSlu_7B00_ReadConcentratorOperationData{`,
		`OperationOrder:` + fmt.Sprintf("%v", this.OperationOrder) + `,`,
		`OperationType:` + fmt.Sprintf("%v", this.OperationType) + `,`,
		`WeekSet:` + fmt.Sprintf("%v", this.WeekSet) + `,`,
		`TimerOrOffset:` + fmt.Sprintf("%v", this.TimerOrOffset) + `,`,
		`AddrType:` + fmt.Sprintf("%v", this.AddrType) + `,`,
		`Addr:` + fmt.Sprintf("%v", this.Addr) + `,`,
		`CmdType:` + fmt.Sprintf("%v", this.CmdType) + `,`,
		`CmdMix:` + repeatedStringForCmdMix + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_7B00_ReadConcentratorOperationData_CmdOperation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSlu_7B00_ReadConcentratorOperationData_CmdOperation{`,
		`Handle:` + fmt.Sprintf("%v", this.Handle) + `,`,
		`Rate:` + fmt.Sprintf("%v", this.Rate) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSluFe00) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSluFe00{`,
		`CmdIdx:` + fmt.Sprintf("%v", this.CmdIdx) + `,`,
		`OperationCmd:` + fmt.Sprintf("%v", this.OperationCmd) + `,`,
		`FaultCount:` + fmt.Sprintf("%v", this.FaultCount) + `,`,
		`SluitemIdx:` + fmt.Sprintf("%v", this.SluitemIdx) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_7400) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSlu_7400{`,
		`CmdIdx:` + fmt.Sprintf("%v", this.CmdIdx) + `,`,
		`OperationType:` + fmt.Sprintf("%v", this.OperationType) + `,`,
		`OperationOrder:` + fmt.Sprintf("%v", this.OperationOrder) + `,`,
		`AddrType:` + fmt.Sprintf("%v", this.AddrType) + `,`,
		`Addrs:` + fmt.Sprintf("%v", this.Addrs) + `,`,
		`WeekSet:` + fmt.Sprintf("%v", this.WeekSet) + `,`,
		`TimerOrOffset:` + fmt.Sprintf("%v", this.TimerOrOffset) + `,`,
		`CmdType:` + fmt.Sprintf("%v", this.CmdType) + `,`,
		`CmdMix:` + fmt.Sprintf("%v", this.CmdMix) + `,`,
		`CmdPwm:` + strings.Replace(fmt.Sprintf("%v", this.CmdPwm), "WlstSlu_7400_CmdPwm", "WlstSlu_7400_CmdPwm", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_7400_CmdPwm) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSlu_7400_CmdPwm{`,
		`LoopCanDo:` + fmt.Sprintf("%v", this.LoopCanDo) + `,`,
		`Scale:` + fmt.Sprintf("%v", this.Scale) + `,`,
		`Rate:` + fmt.Sprintf("%v", this.Rate) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_7C00) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForOperationData := "[]*WlstSlu_7C00_ConcentratorOperationData{"
	for _, f := range this.OperationData {
		repeatedStringForOperationData += strings.Replace(fmt.Sprintf("%v", f), "WlstSlu_7C00_ConcentratorOperationData", "WlstSlu_7C00_ConcentratorOperationData", 1) + ","
	}
	repeatedStringForOperationData += "}"
	s := strings.Join([]string{`&WlstSlu_7C00{`,
		`CmdIdx:` + fmt.Sprintf("%v", this.CmdIdx) + `,`,
		`AddrType:` + fmt.Sprintf("%v", this.AddrType) + `,`,
		`Addr:` + fmt.Sprintf("%v", this.Addr) + `,`,
		`CmdCount:` + fmt.Sprintf("%v", this.CmdCount) + `,`,
		`AddOrUpdate:` + fmt.Sprintf("%v", this.AddOrUpdate) + `,`,
		`OperationData:` + repeatedStringForOperationData + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_7C00_ConcentratorOperationData) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSlu_7C00_ConcentratorOperationData{`,
		`OperationType:` + fmt.Sprintf("%v", this.OperationType) + `,`,
		`CmdType:` + fmt.Sprintf("%v", this.CmdType) + `,`,
		`WeekSet:` + fmt.Sprintf("%v", this.WeekSet) + `,`,
		`TimerOrOffset:` + fmt.Sprintf("%v", this.TimerOrOffset) + `,`,
		`CmdMix:` + fmt.Sprintf("%v", this.CmdMix) + `,`,
		`CmdPwm:` + strings.Replace(fmt.Sprintf("%v", this.CmdPwm), "WlstSlu_7C00_ConcentratorOperationData_CmdPwm", "WlstSlu_7C00_ConcentratorOperationData_CmdPwm", 1) + `,`,
		`Cmd_485:` + strings.Replace(fmt.Sprintf("%v", this.Cmd_485), "WlstSlu_7C00_ConcentratorOperationData_Cmd_485", "WlstSlu_7C00_ConcentratorOperationData_Cmd_485", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_7C00_ConcentratorOperationData_CmdPwm) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSlu_7C00_ConcentratorOperationData_CmdPwm{`,
		`LoopCanDo:` + fmt.Sprintf("%v", this.LoopCanDo) + `,`,
		`Scale:` + fmt.Sprintf("%v", this.Scale) + `,`,
		`Rate:` + fmt.Sprintf("%v", this.Rate) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_7C00_ConcentratorOperationData_Cmd_485) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSlu_7C00_ConcentratorOperationData_Cmd_485{`,
		`Baudrate:` + fmt.Sprintf("%v", this.Baudrate) + `,`,
		`Check:` + fmt.Sprintf("%v", this.Check) + `,`,
		`DataLength:` + fmt.Sprintf("%v", this.DataLength) + `,`,
		`Data_485:` + fmt.Sprintf("%v", this.Data_485) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_6F00) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSlu_6F00{`,
		`CmdIdx:` + fmt.Sprintf("%v", this.CmdIdx) + `,`,
		`AddrType:` + fmt.Sprintf("%v", this.AddrType) + `,`,
		`Addr:` + fmt.Sprintf("%v", this.Addr) + `,`,
		`ResetMark:` + strings.Replace(fmt.Sprintf("%v", this.ResetMark), "WlstSlu_6F00_ResetMark", "WlstSlu_6F00_ResetMark", 1) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WlstSlu_6F00_ResetMark) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WlstSlu_6F00_ResetMark{`,
		`ResetMcu:` + fmt.Sprintf("%v", this.ResetMcu) + `,`,
		`ResetComm:` + fmt.Sprintf("%v", this.ResetComm) + `,`,
		`InitMcuHardware:` + fmt.Sprintf("%v", this.InitMcuHardware) + `,`,
		`InitRam:` + fmt.Sprintf("%v", this.InitRam) + `,`,
		`ZeroEerom:` + fmt.Sprintf("%v", this.ZeroEerom) + `,`,
		`ZeroCount:` + fmt.Sprintf("%v", this.ZeroCount) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringProtocolSlu(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *WlstSluF400) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_slu_f400: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_slu_f400: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remark", wireType)
			}
			m.Remark = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Remark |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemAddr", wireType)
			}
			m.SluitemAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemAddr |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_3900) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_slu_3900: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_slu_3900: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ModelInfo == nil {
				m.ModelInfo = &WlstSlu_3900_ModelInfo{}
			}
			if err := m.ModelInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LightData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LightData = append(m.LightData, &WlstSlu_3900_LightData{})
			if err := m.LightData[len(m.LightData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeakageCurrent", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.LeakageCurrent = float64(math.Float64frombits(v))
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SluitemStatus == nil {
				m.SluitemStatus = &WlstSlu_3900_SluitemStatus{}
			}
			if err := m.SluitemStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeFault", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TimeFault == nil {
				m.TimeFault = &WlstSlu_3900_TimeFault{}
			}
			if err := m.TimeFault.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResetCount", wireType)
			}
			m.ResetCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResetCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateTime", wireType)
			}
			m.DateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DateTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemPara", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SluitemPara == nil {
				m.SluitemPara = &WlstSlu_3900_SluitemPara{}
			}
			if err := m.SluitemPara.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rsrp", wireType)
			}
			m.Rsrp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rsrp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rssi", wireType)
			}
			m.Rssi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rssi |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snr", wireType)
			}
			m.Snr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Snr |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pci", wireType)
			}
			m.Pci = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pci |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rsrq", wireType)
			}
			m.Rsrq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rsrq |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txpower", wireType)
			}
			m.Txpower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Txpower |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Earfcn", wireType)
			}
			m.Earfcn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Earfcn |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecl", wireType)
			}
			m.Ecl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ecl |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Csq", wireType)
			}
			m.Csq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Csq |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reson", wireType)
			}
			m.Reson = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reson |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Retry", wireType)
			}
			m.Retry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Retry |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sunrise", wireType)
			}
			m.Sunrise = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sunrise |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sunset", wireType)
			}
			m.Sunset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sunset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_3900_ModelInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Model_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Model_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemLoop", wireType)
			}
			m.SluitemLoop = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemLoop |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PowerSaving", wireType)
			}
			m.PowerSaving = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PowerSaving |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasLeakage", wireType)
			}
			m.HasLeakage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HasLeakage |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasTemperature", wireType)
			}
			m.HasTemperature = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HasTemperature |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasTimer", wireType)
			}
			m.HasTimer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HasTimer |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			m.Model = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Model |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SluitemType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_3900_LightData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Light_data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Light_data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voltage", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Voltage = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Current", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Current = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivePower", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ActivePower = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReactivePower", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ReactivePower = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApparentPower", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ApparentPower = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Electricity", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Electricity = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveTime", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ActiveTime = float64(math.Float64frombits(v))
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LightStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LightStatus == nil {
				m.LightStatus = &WlstSlu_3900_LightStatus{}
			}
			if err := m.LightStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PowerLevel", wireType)
			}
			m.PowerLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PowerLevel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemPowerTurnon", wireType)
			}
			m.SluitemPowerTurnon = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemPowerTurnon |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RatedPower", wireType)
			}
			m.RatedPower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RatedPower |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_3900_LightStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Light_status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Light_status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leakage", wireType)
			}
			m.Leakage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Leakage |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fault", wireType)
			}
			m.Fault = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fault |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkingOn", wireType)
			}
			m.WorkingOn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkingOn |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_3900_SluitemStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sluitem_status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sluitem_status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlashFault", wireType)
			}
			m.FlashFault = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FlashFault |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableAlarm", wireType)
			}
			m.EnableAlarm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EnableAlarm |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_3900_TimeFault) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Time_fault: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Time_fault: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClockFault", wireType)
			}
			m.ClockFault = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClockFault |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClockOutFault", wireType)
			}
			m.ClockOutFault = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClockOutFault |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClockOutAlarm", wireType)
			}
			m.ClockOutAlarm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClockOutAlarm |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_3900_SluitemPara) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sluitem_para: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sluitem_para: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longitude", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Longitude = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latitude", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Latitude = float64(math.Float64frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasEnableAlarm", wireType)
			}
			m.HasEnableAlarm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HasEnableAlarm |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRunning", wireType)
			}
			m.IsRunning = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsRunning |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlarmInterval", wireType)
			}
			m.AlarmInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlarmInterval |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UplinkReply", wireType)
			}
			m.UplinkReply = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UplinkReply |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_7800) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_slu_7800: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_slu_7800: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassType", wireType)
			}
			m.ClassType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClassType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordCount", wireType)
			}
			m.RecordCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecordCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DtStart", wireType)
			}
			m.DtStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DtStart |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DtEnd", wireType)
			}
			m.DtEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DtEnd |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSluF800) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_slu_f800: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_slu_f800: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassType", wireType)
			}
			m.ClassType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClassType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataTotal", wireType)
			}
			m.DataTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataTotal |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataIdx", wireType)
			}
			m.DataIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordCount", wireType)
			}
			m.RecordCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecordCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field View_0X20", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.View_0X20 = append(m.View_0X20, &WlstSluF800_View0X20{})
			if err := m.View_0X20[len(m.View_0X20)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field View_0X21", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.View_0X21 = append(m.View_0X21, &WlstSluF800_View0X21{})
			if err := m.View_0X21[len(m.View_0X21)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field View_0X22", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.View_0X22 = append(m.View_0X22, &WlstSluF800_View0X20{})
			if err := m.View_0X22[len(m.View_0X22)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field View_0X23", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.View_0X23 = append(m.View_0X23, &WlstSluF800_View0X23{})
			if err := m.View_0X23[len(m.View_0X23)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field View_0X24", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.View_0X24 = append(m.View_0X24, &WlstSluF800_View0X20{})
			if err := m.View_0X24[len(m.View_0X24)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field View_0X25", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.View_0X25 = append(m.View_0X25, &WlstSluF800_View0X20{})
			if err := m.View_0X25[len(m.View_0X25)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSluF800_View0X20) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: View0x20: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: View0x20: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DtHappen", wireType)
			}
			m.DtHappen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DtHappen |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Status = append(m.Status, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Status) == 0 {
					m.Status = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolSlu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Status = append(m.Status, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSluF800_View0X21) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: View0x21: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: View0x21: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DtHappen", wireType)
			}
			m.DtHappen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DtHappen |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationType", wireType)
			}
			m.OperationType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperationType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationOrder", wireType)
			}
			m.OperationOrder = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperationOrder |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddrType", wireType)
			}
			m.AddrType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddrType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			m.Addr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Addr |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationSource", wireType)
			}
			m.OperationSource = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperationSource |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSluF800_View0X23) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: View0x23: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: View0x23: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DtHappen", wireType)
			}
			m.DtHappen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DtHappen |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			m.Addr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Addr |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AlarmType = append(m.AlarmType, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AlarmType) == 0 {
					m.AlarmType = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolSlu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AlarmType = append(m.AlarmType, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AlarmType", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SluitemStatus = append(m.SluitemStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SluitemStatus) == 0 {
					m.SluitemStatus = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolSlu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SluitemStatus = append(m.SluitemStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemStatus", wireType)
			}
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemVoltage", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.SluitemVoltage = float64(math.Float64frombits(v))
		case 6:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.SluitemCurrent = append(m.SluitemCurrent, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.SluitemCurrent) == 0 {
					m.SluitemCurrent = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.SluitemCurrent = append(m.SluitemCurrent, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemCurrent", wireType)
			}
		case 7:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.SluitemActivePower = append(m.SluitemActivePower, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.SluitemActivePower) == 0 {
					m.SluitemActivePower = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.SluitemActivePower = append(m.SluitemActivePower, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemActivePower", wireType)
			}
		case 8:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.SluitemReactivePower = append(m.SluitemReactivePower, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.SluitemReactivePower) == 0 {
					m.SluitemReactivePower = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.SluitemReactivePower = append(m.SluitemReactivePower, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemReactivePower", wireType)
			}
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemMaxVoltage", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.SluitemMaxVoltage = float64(math.Float64frombits(v))
		case 10:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.SluitemMaxCurrent = append(m.SluitemMaxCurrent, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.SluitemMaxCurrent) == 0 {
					m.SluitemMaxCurrent = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.SluitemMaxCurrent = append(m.SluitemMaxCurrent, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemMaxCurrent", wireType)
			}
		case 11:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.SluitemElectricity = append(m.SluitemElectricity, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.SluitemElectricity) == 0 {
					m.SluitemElectricity = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.SluitemElectricity = append(m.SluitemElectricity, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemElectricity", wireType)
			}
		case 12:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SluitemPhyinfo = append(m.SluitemPhyinfo, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SluitemPhyinfo) == 0 {
					m.SluitemPhyinfo = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolSlu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SluitemPhyinfo = append(m.SluitemPhyinfo, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemPhyinfo", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSluEc00) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_slu_ec00: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_slu_ec00: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartIdx", wireType)
			}
			m.StartIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadCount", wireType)
			}
			m.ReadCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WlstSlu_6B00", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WlstSlu_6B00 = append(m.WlstSlu_6B00, &WlstSlu_6B00{})
			if err := m.WlstSlu_6B00[len(m.WlstSlu_6B00)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_6B00) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_slu_6b00: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_slu_6b00: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetIdx", wireType)
			}
			m.SetIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SetIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DtStart", wireType)
			}
			m.DtStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DtStart |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DtEnd", wireType)
			}
			m.DtEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DtEnd |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationType", wireType)
			}
			m.OperationType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperationType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationOrder", wireType)
			}
			m.OperationOrder = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperationOrder |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimerOrOffset", wireType)
			}
			m.TimerOrOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimerOrOffset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddrType", wireType)
			}
			m.AddrType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddrType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Addrs = append(m.Addrs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Addrs) == 0 {
					m.Addrs = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolSlu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Addrs = append(m.Addrs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Addrs", wireType)
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdType", wireType)
			}
			m.CmdType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CmdMix = append(m.CmdMix, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.CmdMix) == 0 {
					m.CmdMix = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolSlu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CmdMix = append(m.CmdMix, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdMix", wireType)
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdPwm", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CmdPwm == nil {
				m.CmdPwm = &WlstSlu_6B00_CmdPwm{}
			}
			if err := m.CmdPwm.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_6B00_CmdPwm) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cmd_pwm: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cmd_pwm: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.LoopCanDo = append(m.LoopCanDo, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.LoopCanDo) == 0 {
					m.LoopCanDo = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolSlu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.LoopCanDo = append(m.LoopCanDo, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field LoopCanDo", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale", wireType)
			}
			m.Scale = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Scale |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rate", wireType)
			}
			m.Rate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_6C00) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_slu_6c00: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_slu_6c00: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartIdx", wireType)
			}
			m.StartIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadCount", wireType)
			}
			m.ReadCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSluD000) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_slu_d000: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_slu_d000: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_2800) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_slu_2800: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_slu_2800: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alarm", wireType)
			}
			m.Alarm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Alarm |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_2400) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_slu_2400: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_slu_2400: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoFlag", wireType)
			}
			m.DoFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DoFlag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_6E00) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_slu_6e00: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_slu_6e00: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoFlag", wireType)
			}
			m.DoFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DoFlag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PatrolStart", wireType)
			}
			m.PatrolStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PatrolStart |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PatrolInterval", wireType)
			}
			m.PatrolInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PatrolInterval |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PatrolOrder", wireType)
			}
			m.PatrolOrder = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PatrolOrder |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PatrolCount", wireType)
			}
			m.PatrolCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PatrolCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_3000) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_slu_3000: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_slu_3000: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctrls", wireType)
			}
			m.Ctrls = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ctrls |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainName", wireType)
			}
			m.DomainName = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DomainName |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpperVoltageLimit", wireType)
			}
			m.UpperVoltageLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpperVoltageLimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowerVoltageLimit", wireType)
			}
			m.LowerVoltageLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LowerVoltageLimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddr", wireType)
			}
			m.MacAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MacAddr |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_9A00) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_slu_9a00: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_slu_9a00: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DomainNameStatus = append(m.DomainNameStatus, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DomainNameStatus) == 0 {
					m.DomainNameStatus = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolSlu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DomainNameStatus = append(m.DomainNameStatus, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainNameStatus", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSluCd00) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_slu_cd00: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_slu_cd00: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommunicationFailures", wireType)
			}
			m.CommunicationFailures = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommunicationFailures |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PowerFactor", wireType)
			}
			m.PowerFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PowerFactor |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommunicationChannel", wireType)
			}
			m.CommunicationChannel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommunicationChannel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentRange", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CurrentRange = float64(math.Float64frombits(v))
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PowerRange", wireType)
			}
			m.PowerRange = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PowerRange |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoMode", wireType)
			}
			m.AutoMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoMode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longitude", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Longitude = float64(math.Float64frombits(v))
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latitude", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Latitude = float64(math.Float64frombits(v))
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierRoutingMode", wireType)
			}
			m.CarrierRoutingMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CarrierRoutingMode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BluetoothPin", wireType)
			}
			m.BluetoothPin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BluetoothPin |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BluetoothMode", wireType)
			}
			m.BluetoothMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BluetoothMode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cct", wireType)
			}
			m.Cct = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cct |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlwaysOnline", wireType)
			}
			m.AlwaysOnline = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlwaysOnline |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_1C00) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_slu_1c00: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_slu_1c00: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemIdx", wireType)
			}
			m.SluitemIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemIdx |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainName", wireType)
			}
			m.DomainName = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DomainName |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_1D00) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_slu_1d00: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_slu_1d00: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemIdx", wireType)
			}
			m.SluitemIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemIdx |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataMark", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DataMark == nil {
				m.DataMark = &WlstSlu_1D00_DataMark{}
			}
			if err := m.DataMark.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_1D00_DataMark) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Data_mark: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Data_mark: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadData", wireType)
			}
			m.ReadData = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadData |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadTimer", wireType)
			}
			m.ReadTimer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadTimer |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadArgs", wireType)
			}
			m.ReadArgs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadArgs |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadGroup", wireType)
			}
			m.ReadGroup = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadGroup |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadVer", wireType)
			}
			m.ReadVer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadVer |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadSunriseset", wireType)
			}
			m.ReadSunriseset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadSunriseset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadTimetable", wireType)
			}
			m.ReadTimetable = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadTimetable |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadCtrldata", wireType)
			}
			m.ReadCtrldata = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadCtrldata |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_9D00) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_slu_9d00: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_slu_9d00: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemIdx", wireType)
			}
			m.SluitemIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemIdx |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataMark", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DataMark == nil {
				m.DataMark = &WlstSlu_1D00_DataMark{}
			}
			if err := m.DataMark.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoopCount", wireType)
			}
			m.LoopCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoopCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SluitemData == nil {
				m.SluitemData = &WlstSlu_9D00_SluitemData{}
			}
			if err := m.SluitemData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemTime", wireType)
			}
			m.SluitemTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemPara", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SluitemPara == nil {
				m.SluitemPara = &WlstSlu_9D00_SluitemPara{}
			}
			if err := m.SluitemPara.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SluitemGroup = append(m.SluitemGroup, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SluitemGroup) == 0 {
					m.SluitemGroup = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolSlu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SluitemGroup = append(m.SluitemGroup, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemGroup", wireType)
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemVer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SluitemVer == nil {
				m.SluitemVer = &WlstSlu_9D00_SluitemVer{}
			}
			if err := m.SluitemVer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemSunriseset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SluitemSunriseset == nil {
				m.SluitemSunriseset = &WlstSlu_9D00_SluitemSunriseset{}
			}
			if err := m.SluitemSunriseset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemRuntime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SluitemRuntime = append(m.SluitemRuntime, &WlstSlu_9D00_SluitemRuntime{})
			if err := m.SluitemRuntime[len(m.SluitemRuntime)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemDataNew", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SluitemDataNew == nil {
				m.SluitemDataNew = &WlstSlu_9D00_SluitemDataNew{}
			}
			if err := m.SluitemDataNew.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetMark", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SetMark == nil {
				m.SetMark = &WlstSlu_9D00_SetMark{}
			}
			if err := m.SetMark.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataContinue", wireType)
			}
			m.DataContinue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataContinue |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_9D00_SetMark) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Set_mark: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Set_mark: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetTimer", wireType)
			}
			m.SetTimer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SetTimer |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetArgs", wireType)
			}
			m.SetArgs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SetArgs |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetGroup", wireType)
			}
			m.SetGroup = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SetGroup |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetReset", wireType)
			}
			m.SetReset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SetReset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetControl", wireType)
			}
			m.SetControl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SetControl |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_9D00_SluitemData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sluitem_data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sluitem_data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voltage", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Voltage = float64(math.Float64frombits(v))
		case 2:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.Current = append(m.Current, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.Current) == 0 {
					m.Current = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.Current = append(m.Current, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Current", wireType)
			}
		case 3:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.ActivePower = append(m.ActivePower, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.ActivePower) == 0 {
					m.ActivePower = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.ActivePower = append(m.ActivePower, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivePower", wireType)
			}
		case 4:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.ReactivePower = append(m.ReactivePower, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.ReactivePower) == 0 {
					m.ReactivePower = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.ReactivePower = append(m.ReactivePower, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ReactivePower", wireType)
			}
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxVoltage", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MaxVoltage = float64(math.Float64frombits(v))
		case 6:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.MaxCurrent = append(m.MaxCurrent, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.MaxCurrent) == 0 {
					m.MaxCurrent = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.MaxCurrent = append(m.MaxCurrent, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxCurrent", wireType)
			}
		case 7:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.TotalElectricity = append(m.TotalElectricity, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.TotalElectricity) == 0 {
					m.TotalElectricity = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.TotalElectricity = append(m.TotalElectricity, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalElectricity", wireType)
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Temperature", wireType)
			}
			m.Temperature = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Temperature |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeakageCurrent", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.LeakageCurrent = float64(math.Float64frombits(v))
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimerError", wireType)
			}
			m.TimerError = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimerError |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SluitemStatus == nil {
				m.SluitemStatus = &WlstSlu_7300_BaseSluitemData_SluitemStatus{}
			}
			if err := m.SluitemStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LightStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LightStatus = append(m.LightStatus, &WlstSlu_7300_BaseSluitemData_LightStatus{})
			if err := m.LightStatus[len(m.LightStatus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResetCount", wireType)
			}
			m.ResetCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResetCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_9D00_SluitemDataNew) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sluitem_data_new: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sluitem_data_new: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.Voltage = append(m.Voltage, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.Voltage) == 0 {
					m.Voltage = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.Voltage = append(m.Voltage, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Voltage", wireType)
			}
		case 2:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.Current = append(m.Current, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.Current) == 0 {
					m.Current = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.Current = append(m.Current, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Current", wireType)
			}
		case 3:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.ActivePower = append(m.ActivePower, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.ActivePower) == 0 {
					m.ActivePower = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.ActivePower = append(m.ActivePower, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivePower", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RunTime = append(m.RunTime, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RunTime) == 0 {
					m.RunTime = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolSlu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RunTime = append(m.RunTime, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RunTime", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			m.Phase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Phase |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.TotalElectricity = append(m.TotalElectricity, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.TotalElectricity) == 0 {
					m.TotalElectricity = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.TotalElectricity = append(m.TotalElectricity, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalElectricity", wireType)
			}
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeakageCurrent", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.LeakageCurrent = float64(math.Float64frombits(v))
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimerError", wireType)
			}
			m.TimerError = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimerError |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SluitemStatus == nil {
				m.SluitemStatus = &WlstSlu_7300_BaseSluitemData_SluitemStatus{}
			}
			if err := m.SluitemStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LightStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LightStatus = append(m.LightStatus, &WlstSlu_7300_BaseSluitemData_LightStatus{})
			if err := m.LightStatus[len(m.LightStatus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResetCount", wireType)
			}
			m.ResetCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResetCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.EnergySaving = append(m.EnergySaving, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.EnergySaving) == 0 {
					m.EnergySaving = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolSlu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.EnergySaving = append(m.EnergySaving, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field EnergySaving", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_9D00_SluitemPara) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sluitem_para: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sluitem_para: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainName", wireType)
			}
			m.DomainName = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DomainName |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemStatus", wireType)
			}
			m.SluitemStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemStatus |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemEnableAlarm", wireType)
			}
			m.SluitemEnableAlarm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemEnableAlarm |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SluitemPowerTurnon = append(m.SluitemPowerTurnon, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SluitemPowerTurnon) == 0 {
					m.SluitemPowerTurnon = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolSlu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SluitemPowerTurnon = append(m.SluitemPowerTurnon, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemPowerTurnon", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SluitemVector = append(m.SluitemVector, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SluitemVector) == 0 {
					m.SluitemVector = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolSlu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SluitemVector = append(m.SluitemVector, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemVector", wireType)
			}
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longitude", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Longitude = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latitude", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Latitude = float64(math.Float64frombits(v))
		case 8:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RatedPower = append(m.RatedPower, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RatedPower) == 0 {
					m.RatedPower = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolSlu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RatedPower = append(m.RatedPower, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RatedPower", wireType)
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UplinkTimer", wireType)
			}
			m.UplinkTimer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UplinkTimer |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UplinkReply", wireType)
			}
			m.UplinkReply = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UplinkReply |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_9D00_SluitemVer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sluitem_ver: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sluitem_ver: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemLoop", wireType)
			}
			m.SluitemLoop = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemLoop |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnergySaving", wireType)
			}
			m.EnergySaving = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EnergySaving |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElectricLeakageModule", wireType)
			}
			m.ElectricLeakageModule = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ElectricLeakageModule |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemperatureModule", wireType)
			}
			m.TemperatureModule = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TemperatureModule |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimerModule", wireType)
			}
			m.TimerModule = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimerModule |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SluitemType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_9D00_SluitemSunriseset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sluitem_sunriseset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sluitem_sunriseset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sunrise", wireType)
			}
			m.Sunrise = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sunrise |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sunset", wireType)
			}
			m.Sunset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sunset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_9D00_SluitemRuntime) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sluitem_runtime: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sluitem_runtime: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataType", wireType)
			}
			m.DataType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputType", wireType)
			}
			m.OutputType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperateType", wireType)
			}
			m.OperateType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperateType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DateEnable = append(m.DateEnable, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DateEnable) == 0 {
					m.DateEnable = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolSlu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DateEnable = append(m.DateEnable, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DateEnable", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperateTime", wireType)
			}
			m.OperateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperateTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperateOffset", wireType)
			}
			m.OperateOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperateOffset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RelayOperate = append(m.RelayOperate, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RelayOperate) == 0 {
					m.RelayOperate = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolSlu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RelayOperate = append(m.RelayOperate, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayOperate", wireType)
			}
		case 8:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PwmLoop = append(m.PwmLoop, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PwmLoop) == 0 {
					m.PwmLoop = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolSlu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PwmLoop = append(m.PwmLoop, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PwmLoop", wireType)
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PwmPower", wireType)
			}
			m.PwmPower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PwmPower |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PwmBaudrate", wireType)
			}
			m.PwmBaudrate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PwmBaudrate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rs485Baudrate", wireType)
			}
			m.Rs485Baudrate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rs485Baudrate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rs485Check", wireType)
			}
			m.Rs485Check = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rs485Check |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSluF000) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_slu_f000: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_slu_f000: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResetMark", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResetMark == nil {
				m.ResetMark = &WlstSluF000_ResetMark{}
			}
			if err := m.ResetMark.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSluF000_ResetMark) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Reset_mark: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Reset_mark: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClearTask", wireType)
			}
			m.ClearTask = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClearTask |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResetConcentrator", wireType)
			}
			m.ResetConcentrator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResetConcentrator |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HardResetZigbee", wireType)
			}
			m.HardResetZigbee = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HardResetZigbee |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SoftResetZigbee", wireType)
			}
			m.SoftResetZigbee = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SoftResetZigbee |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResetCarrier", wireType)
			}
			m.ResetCarrier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResetCarrier |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitAll", wireType)
			}
			m.InitAll = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitAll |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClearData", wireType)
			}
			m.ClearData = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClearData |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClearArgs", wireType)
			}
			m.ClearArgs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClearArgs |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSluF100) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_slu_f100: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_slu_f100: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptMark", wireType)
			}
			m.OptMark = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptMark |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateTime", wireType)
			}
			m.DateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DateTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceTimer", wireType)
			}
			m.ForceTimer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForceTimer |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimerStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TimerStatus == nil {
				m.TimerStatus = &WlstSluF100_TimerStatus{}
			}
			if err := m.TimerStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSluF100_TimerStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Timer_status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Timer_status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DtformatError", wireType)
			}
			m.DtformatError = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DtformatError |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimerError", wireType)
			}
			m.TimerError = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimerError |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeFault", wireType)
			}
			m.TimeFault = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeFault |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSluF200) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_slu_f200: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_slu_f200: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemIdx", wireType)
			}
			m.SluitemIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemCount", wireType)
			}
			m.SluitemCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataMark", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DataMark == nil {
				m.DataMark = &WlstSluF200_DataMark{}
			}
			if err := m.DataMark.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SluitemData = append(m.SluitemData, &WlstSluF200_ControllerData{})
			if err := m.SluitemData[len(m.SluitemData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSluF200_DataMark) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Data_mark: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Data_mark: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			m.Group = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Group |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Barcode", wireType)
			}
			m.Barcode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Barcode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Route", wireType)
			}
			m.Route = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Route |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			m.Order = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Order |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PowerOnStatus", wireType)
			}
			m.PowerOnStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PowerOnStatus |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunStatus", wireType)
			}
			m.RunStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RunStatus |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vector", wireType)
			}
			m.Vector = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vector |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RatedPower", wireType)
			}
			m.RatedPower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RatedPower |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoopCount", wireType)
			}
			m.LoopCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoopCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetData", wireType)
			}
			m.SetData = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SetData |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSluF200_ControllerData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Controller_data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Controller_data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SluitemGroup = append(m.SluitemGroup, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SluitemGroup) == 0 {
					m.SluitemGroup = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolSlu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SluitemGroup = append(m.SluitemGroup, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemGroup", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemIdx", wireType)
			}
			m.SluitemIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemIdx |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SluitemRoute = append(m.SluitemRoute, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SluitemRoute) == 0 {
					m.SluitemRoute = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolSlu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SluitemRoute = append(m.SluitemRoute, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemRoute", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemOrder", wireType)
			}
			m.SluitemOrder = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemOrder |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpperPowerLimit", wireType)
			}
			m.UpperPowerLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpperPowerLimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowerPowerLimit", wireType)
			}
			m.LowerPowerLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LowerPowerLimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SluitemPowerTurnon = append(m.SluitemPowerTurnon, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SluitemPowerTurnon) == 0 {
					m.SluitemPowerTurnon = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolSlu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SluitemPowerTurnon = append(m.SluitemPowerTurnon, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemPowerTurnon", wireType)
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemStatus", wireType)
			}
			m.SluitemStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemStatus |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemEnableAlarm", wireType)
			}
			m.SluitemEnableAlarm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemEnableAlarm |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SluitemVector = append(m.SluitemVector, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SluitemVector) == 0 {
					m.SluitemVector = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolSlu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SluitemVector = append(m.SluitemVector, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemVector", wireType)
			}
		case 11:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RatedPower = append(m.RatedPower, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RatedPower) == 0 {
					m.RatedPower = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolSlu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RatedPower = append(m.RatedPower, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RatedPower", wireType)
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoopCount", wireType)
			}
			m.LoopCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoopCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longitude", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Longitude = float64(math.Float64frombits(v))
		case 14:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latitude", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Latitude = float64(math.Float64frombits(v))
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UplinkTimer", wireType)
			}
			m.UplinkTimer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UplinkTimer |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UplinkReply", wireType)
			}
			m.UplinkReply = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UplinkReply |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_7300) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_slu_7300: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_slu_7300: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemStart", wireType)
			}
			m.SluitemStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemStart |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemCount", wireType)
			}
			m.SluitemCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataMark", wireType)
			}
			m.DataMark = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataMark |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConcentratorData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConcentratorData == nil {
				m.ConcentratorData = &WlstSlu_7300_ConcentratorData{}
			}
			if err := m.ConcentratorData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseSluitemData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseSluitemData = append(m.BaseSluitemData, &WlstSlu_7300_BaseSluitemData{})
			if err := m.BaseSluitemData[len(m.BaseSluitemData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnknowSluitem", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnknowSluitem = append(m.UnknowSluitem, &WlstSlu_7300_UnknowSluitem{})
			if err := m.UnknowSluitem[len(m.UnknowSluitem)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssistSluitemData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssistSluitemData = append(m.AssistSluitemData, &WlstSlu_7300_AssistSluitemData{})
			if err := m.AssistSluitemData[len(m.AssistSluitemData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemPhyinfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SluitemPhyinfo = append(m.SluitemPhyinfo, &WlstSlu_7300_SluitemPhyinfo{})
			if err := m.SluitemPhyinfo[len(m.SluitemPhyinfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SluitemAddrs = append(m.SluitemAddrs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SluitemAddrs) == 0 {
					m.SluitemAddrs = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolSlu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SluitemAddrs = append(m.SluitemAddrs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemAddrs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_7300_ConcentratorData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Concentrator_data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Concentrator_data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ResetCount = append(m.ResetCount, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ResetCount) == 0 {
					m.ResetCount = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolSlu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ResetCount = append(m.ResetCount, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ResetCount", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RunStatus == nil {
				m.RunStatus = &WlstSlu_7300_ConcentratorData_RunStatus{}
			}
			if err := m.RunStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArgsStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ArgsStatus == nil {
				m.ArgsStatus = &WlstSlu_7300_ConcentratorData_ArgsStatus{}
			}
			if err := m.ArgsStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HardwareStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HardwareStatus == nil {
				m.HardwareStatus = &WlstSlu_7300_ConcentratorData_HardwareStatus{}
			}
			if err := m.HardwareStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnknowSluitemCount", wireType)
			}
			m.UnknowSluitemCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnknowSluitemCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommunicationChannel", wireType)
			}
			m.CommunicationChannel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommunicationChannel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_7300_ConcentratorData_RunStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Run_status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Run_status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offline", wireType)
			}
			m.Offline = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offline |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableAlarm", wireType)
			}
			m.EnableAlarm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EnableAlarm |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoweronMark", wireType)
			}
			m.PoweronMark = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoweronMark |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableGprs", wireType)
			}
			m.EnableGprs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EnableGprs |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableAutochk", wireType)
			}
			m.EnableAutochk = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EnableAutochk |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_7300_ConcentratorData_ArgsStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Args_status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Args_status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConcentratorArgsError", wireType)
			}
			m.ConcentratorArgsError = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConcentratorArgsError |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemArgsError", wireType)
			}
			m.SluitemArgsError = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemArgsError |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TurnOnoffError", wireType)
			}
			m.TurnOnoffError = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TurnOnoffError |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_7300_ConcentratorData_HardwareStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Hardware_status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Hardware_status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZigbeeError", wireType)
			}
			m.ZigbeeError = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ZigbeeError |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CarrierError", wireType)
			}
			m.CarrierError = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CarrierError |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FramError", wireType)
			}
			m.FramError = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FramError |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BluetoothError", wireType)
			}
			m.BluetoothError = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BluetoothError |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimerError", wireType)
			}
			m.TimerError = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimerError |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_7300_BaseSluitemData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Base_sluitem_data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Base_sluitem_data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateTime", wireType)
			}
			m.DateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DateTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SluitemStatus == nil {
				m.SluitemStatus = &WlstSlu_7300_BaseSluitemData_SluitemStatus{}
			}
			if err := m.SluitemStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Temperature", wireType)
			}
			m.Temperature = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Temperature |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LightStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LightStatus = append(m.LightStatus, &WlstSlu_7300_BaseSluitemData_LightStatus{})
			if err := m.LightStatus[len(m.LightStatus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LightData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LightData = append(m.LightData, &WlstSlu_7300_BaseSluitemData_LightData{})
			if err := m.LightData[len(m.LightData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemLoop", wireType)
			}
			m.SluitemLoop = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemLoop |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_7300_BaseSluitemData_SluitemStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sluitem_status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sluitem_status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Adjust", wireType)
			}
			m.Adjust = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Adjust |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkingArgs", wireType)
			}
			m.WorkingArgs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkingArgs |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoAlarm", wireType)
			}
			m.NoAlarm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NoAlarm |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffLine", wireType)
			}
			m.OffLine = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OffLine |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EepromError", wireType)
			}
			m.EepromError = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EepromError |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemperatureSensor", wireType)
			}
			m.TemperatureSensor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TemperatureSensor |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_7300_BaseSluitemData_LightStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Light_status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Light_status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PowerStatus", wireType)
			}
			m.PowerStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PowerStatus |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leakage", wireType)
			}
			m.Leakage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Leakage |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fault", wireType)
			}
			m.Fault = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fault |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkingOn", wireType)
			}
			m.WorkingOn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkingOn |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_7300_BaseSluitemData_LightData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Light_data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Light_data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voltage", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Voltage = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Current", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Current = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivePower", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ActivePower = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Electricity", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Electricity = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveTime", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ActiveTime = float64(math.Float64frombits(v))
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PowerLevel", wireType)
			}
			m.PowerLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PowerLevel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_7300_UnknowSluitem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Unknow_sluitem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Unknow_sluitem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemIdx", wireType)
			}
			m.SluitemIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemIdx |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ModelInfo == nil {
				m.ModelInfo = &WlstSlu_7300_ModelInfo{}
			}
			if err := m.ModelInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_7300_AssistSluitemData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Assist_sluitem_data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Assist_sluitem_data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateTime", wireType)
			}
			m.DateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DateTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeakageCurrent", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.LeakageCurrent = float64(math.Float64frombits(v))
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LightData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LightData = append(m.LightData, &WlstSlu_7300_AssistSluitemData_LightData{})
			if err := m.LightData[len(m.LightData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemLoop", wireType)
			}
			m.SluitemLoop = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemLoop |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_7300_AssistSluitemData_LightData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Light_data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Light_data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxVoltage", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MaxVoltage = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxCurrent", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MaxCurrent = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Electricity", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Electricity = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_7300_SluitemPhyinfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sluitem_phyinfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sluitem_phyinfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignalStrength", wireType)
			}
			m.SignalStrength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SignalStrength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routing", wireType)
			}
			m.Routing = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Routing |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			m.Phase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Phase |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsefulCommunicate", wireType)
			}
			m.UsefulCommunicate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsefulCommunicate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllCommunicate", wireType)
			}
			m.AllCommunicate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AllCommunicate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ModelInfo == nil {
				m.ModelInfo = &WlstSlu_7300_ModelInfo{}
			}
			if err := m.ModelInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_7300_ModelInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Model_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Model_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemLoop", wireType)
			}
			m.SluitemLoop = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemLoop |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PowerSaving", wireType)
			}
			m.PowerSaving = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PowerSaving |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasLeakage", wireType)
			}
			m.HasLeakage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HasLeakage |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasTemperature", wireType)
			}
			m.HasTemperature = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HasTemperature |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasTimer", wireType)
			}
			m.HasTimer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HasTimer |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			m.Model = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Model |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SluitemType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSluF900) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_slu_f900: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_slu_f900: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlarmType", wireType)
			}
			m.AlarmType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlarmType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConcentratorData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConcentratorData == nil {
				m.ConcentratorData = &WlstSlu_7300_ConcentratorData{}
			}
			if err := m.ConcentratorData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ErrorCtrls = append(m.ErrorCtrls, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ErrorCtrls) == 0 {
					m.ErrorCtrls = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolSlu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ErrorCtrls = append(m.ErrorCtrls, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCtrls", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemStatusAlarm", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SluitemStatusAlarm = append(m.SluitemStatusAlarm, &WlstSluF900_SluitemStatusAlarm{})
			if err := m.SluitemStatusAlarm[len(m.SluitemStatusAlarm)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BluetoothApply", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BluetoothApply == nil {
				m.BluetoothApply = &WlstSluF900_BluetoothApply{}
			}
			if err := m.BluetoothApply.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetDomainResult", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SetDomainResult == nil {
				m.SetDomainResult = &WlstSluF900_SetDomainResult{}
			}
			if err := m.SetDomainResult.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSluF900_SluitemStatusAlarm) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sluitem_status_alarm: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sluitem_status_alarm: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemIdx", wireType)
			}
			m.SluitemIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemLoop", wireType)
			}
			m.SluitemLoop = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemLoop |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SluitemStatus == nil {
				m.SluitemStatus = &WlstSlu_7300_BaseSluitemData_SluitemStatus{}
			}
			if err := m.SluitemStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LightStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LightStatus = append(m.LightStatus, &WlstSlu_7300_BaseSluitemData_LightStatus{})
			if err := m.LightStatus[len(m.LightStatus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSluF900_BluetoothApply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Bluetooth_apply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Bluetooth_apply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SimNumber", wireType)
			}
			m.SimNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SimNumber |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CheckCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSluF900_SetDomainResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Set_domain_result: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Set_domain_result: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainName", wireType)
			}
			m.DomainName = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DomainName |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SetSuccess = append(m.SetSuccess, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SetSuccess) == 0 {
					m.SetSuccess = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolSlu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SetSuccess = append(m.SetSuccess, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SetSuccess", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_7B00) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_slu_7b00: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_slu_7b00: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemIdx", wireType)
			}
			m.SluitemIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SluitemIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataCount", wireType)
			}
			m.DataCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperationData = append(m.OperationData, &WlstSlu_7B00_ReadConcentratorOperationData{})
			if err := m.OperationData[len(m.OperationData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_7B00_ReadConcentratorOperationData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Read_concentrator_operation_data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Read_concentrator_operation_data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationOrder", wireType)
			}
			m.OperationOrder = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperationOrder |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationType", wireType)
			}
			m.OperationType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperationType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.WeekSet = append(m.WeekSet, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.WeekSet) == 0 {
					m.WeekSet = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolSlu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.WeekSet = append(m.WeekSet, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field WeekSet", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimerOrOffset", wireType)
			}
			m.TimerOrOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimerOrOffset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddrType", wireType)
			}
			m.AddrType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddrType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Addr = append(m.Addr, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Addr) == 0 {
					m.Addr = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolSlu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Addr = append(m.Addr, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdType", wireType)
			}
			m.CmdType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdMix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CmdMix = append(m.CmdMix, &WlstSlu_7B00_ReadConcentratorOperationData_CmdOperation{})
			if err := m.CmdMix[len(m.CmdMix)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_7B00_ReadConcentratorOperationData_CmdOperation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cmd_operation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cmd_operation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Handle", wireType)
			}
			m.Handle = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Handle |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rate", wireType)
			}
			m.Rate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSluFe00) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_slu_fe00: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_slu_fe00: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationCmd", wireType)
			}
			m.OperationCmd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperationCmd |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FaultCount", wireType)
			}
			m.FaultCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FaultCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SluitemIdx = append(m.SluitemIdx, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SluitemIdx) == 0 {
					m.SluitemIdx = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolSlu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SluitemIdx = append(m.SluitemIdx, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SluitemIdx", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_7400) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_slu_7400: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_slu_7400: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationType", wireType)
			}
			m.OperationType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperationType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationOrder", wireType)
			}
			m.OperationOrder = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperationOrder |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddrType", wireType)
			}
			m.AddrType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddrType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Addrs = append(m.Addrs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Addrs) == 0 {
					m.Addrs = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolSlu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Addrs = append(m.Addrs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Addrs", wireType)
			}
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.WeekSet = append(m.WeekSet, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.WeekSet) == 0 {
					m.WeekSet = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolSlu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.WeekSet = append(m.WeekSet, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field WeekSet", wireType)
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimerOrOffset", wireType)
			}
			m.TimerOrOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimerOrOffset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdType", wireType)
			}
			m.CmdType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CmdMix = append(m.CmdMix, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.CmdMix) == 0 {
					m.CmdMix = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolSlu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CmdMix = append(m.CmdMix, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdMix", wireType)
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdPwm", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CmdPwm == nil {
				m.CmdPwm = &WlstSlu_7400_CmdPwm{}
			}
			if err := m.CmdPwm.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_7400_CmdPwm) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cmd_pwm: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cmd_pwm: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.LoopCanDo = append(m.LoopCanDo, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.LoopCanDo) == 0 {
					m.LoopCanDo = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolSlu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.LoopCanDo = append(m.LoopCanDo, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field LoopCanDo", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale", wireType)
			}
			m.Scale = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Scale |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rate", wireType)
			}
			m.Rate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_7C00) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_slu_7c00: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_slu_7c00: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddrType", wireType)
			}
			m.AddrType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddrType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			m.Addr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Addr |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdCount", wireType)
			}
			m.CmdCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddOrUpdate", wireType)
			}
			m.AddOrUpdate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddOrUpdate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperationData = append(m.OperationData, &WlstSlu_7C00_ConcentratorOperationData{})
			if err := m.OperationData[len(m.OperationData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_7C00_ConcentratorOperationData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Concentrator_operation_data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Concentrator_operation_data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationType", wireType)
			}
			m.OperationType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperationType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdType", wireType)
			}
			m.CmdType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.WeekSet = append(m.WeekSet, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.WeekSet) == 0 {
					m.WeekSet = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolSlu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.WeekSet = append(m.WeekSet, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field WeekSet", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimerOrOffset", wireType)
			}
			m.TimerOrOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimerOrOffset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CmdMix = append(m.CmdMix, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.CmdMix) == 0 {
					m.CmdMix = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolSlu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CmdMix = append(m.CmdMix, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdMix", wireType)
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdPwm", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CmdPwm == nil {
				m.CmdPwm = &WlstSlu_7C00_ConcentratorOperationData_CmdPwm{}
			}
			if err := m.CmdPwm.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd_485", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cmd_485 == nil {
				m.Cmd_485 = &WlstSlu_7C00_ConcentratorOperationData_Cmd_485{}
			}
			if err := m.Cmd_485.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_7C00_ConcentratorOperationData_CmdPwm) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cmd_pwm: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cmd_pwm: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.LoopCanDo = append(m.LoopCanDo, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolSlu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.LoopCanDo) == 0 {
					m.LoopCanDo = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolSlu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.LoopCanDo = append(m.LoopCanDo, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field LoopCanDo", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale", wireType)
			}
			m.Scale = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Scale |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rate", wireType)
			}
			m.Rate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_7C00_ConcentratorOperationData_Cmd_485) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cmd_485: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cmd_485: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Baudrate", wireType)
			}
			m.Baudrate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Baudrate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Check", wireType)
			}
			m.Check = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Check |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataLength", wireType)
			}
			m.DataLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataLength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data_485", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data_485 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_6F00) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_slu_6f00: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_slu_6f00: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdIdx", wireType)
			}
			m.CmdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddrType", wireType)
			}
			m.AddrType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddrType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			m.Addr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Addr |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResetMark", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResetMark == nil {
				m.ResetMark = &WlstSlu_6F00_ResetMark{}
			}
			if err := m.ResetMark.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstSlu_6F00_ResetMark) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Reset_mark: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Reset_mark: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResetMcu", wireType)
			}
			m.ResetMcu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResetMcu |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResetComm", wireType)
			}
			m.ResetComm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResetComm |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitMcuHardware", wireType)
			}
			m.InitMcuHardware = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitMcuHardware |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitRam", wireType)
			}
			m.InitRam = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitRam |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZeroEerom", wireType)
			}
			m.ZeroEerom = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ZeroEerom |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZeroCount", wireType)
			}
			m.ZeroCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ZeroCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolSlu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolSlu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipProtocolSlu(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProtocolSlu
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProtocolSlu
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthProtocolSlu
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthProtocolSlu
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowProtocolSlu
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipProtocolSlu(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthProtocolSlu
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthProtocolSlu = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProtocolSlu   = fmt.Errorf("proto: integer overflow")
)
