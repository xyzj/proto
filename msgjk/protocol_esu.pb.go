// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: protocol_esu.proto

package wlst_pb2

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

//Wlst_esu_9100_9900_9d00_a500
type WlstEsu_9000 struct {
	//1-成功，0-失败
	Status int32 `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *WlstEsu_9000) Reset()         { *m = WlstEsu_9000{} }
func (m *WlstEsu_9000) String() string { return proto.CompactTextString(m) }
func (*WlstEsu_9000) ProtoMessage()    {}
func (*WlstEsu_9000) Descriptor() ([]byte, []int) {
	return fileDescriptor_cdb47e59a3bfe786, []int{0}
}
func (m *WlstEsu_9000) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstEsu_9000) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstEsu_9000.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstEsu_9000) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstEsu_9000.Merge(m, src)
}
func (m *WlstEsu_9000) XXX_Size() int {
	return m.Size()
}
func (m *WlstEsu_9000) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstEsu_9000.DiscardUnknown(m)
}

var xxx_messageInfo_WlstEsu_9000 proto.InternalMessageInfo

func (m *WlstEsu_9000) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

type WlstEsu_9400 struct {
	//二进制转int
	Status int32 `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *WlstEsu_9400) Reset()         { *m = WlstEsu_9400{} }
func (m *WlstEsu_9400) String() string { return proto.CompactTextString(m) }
func (*WlstEsu_9400) ProtoMessage()    {}
func (*WlstEsu_9400) Descriptor() ([]byte, []int) {
	return fileDescriptor_cdb47e59a3bfe786, []int{1}
}
func (m *WlstEsu_9400) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstEsu_9400) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstEsu_9400.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstEsu_9400) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstEsu_9400.Merge(m, src)
}
func (m *WlstEsu_9400) XXX_Size() int {
	return m.Size()
}
func (m *WlstEsu_9400) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstEsu_9400.DiscardUnknown(m)
}

var xxx_messageInfo_WlstEsu_9400 proto.InternalMessageInfo

func (m *WlstEsu_9400) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

//Wlst_esu_1100
type WlstEsu_9200 struct {
	//预热时间，2-30,默认10
	WarmupTime int32 `protobuf:"varint,1,opt,name=warmup_time,json=warmupTime,proto3" json:"warmup_time,omitempty"`
	//开机时间，hh*60+mm
	OnTime int32 `protobuf:"varint,2,opt,name=on_time,json=onTime,proto3" json:"on_time,omitempty"`
	//开机时间，hh*60+mm
	OffTime int32 `protobuf:"varint,3,opt,name=off_time,json=offTime,proto3" json:"off_time,omitempty"`
	//风机启动温度
	FanStartTemperature int32 `protobuf:"varint,4,opt,name=fan_start_temperature,json=fanStartTemperature,proto3" json:"fan_start_temperature,omitempty"`
	//退出节能温度
	StopSaver int32 `protobuf:"varint,5,opt,name=stop_saver,json=stopSaver,proto3" json:"stop_saver,omitempty"`
	//强制保护温度
	ProtectionTemperature int32 `protobuf:"varint,6,opt,name=protection_temperature,json=protectionTemperature,proto3" json:"protection_temperature,omitempty"`
	//输入过压门限值
	InputOvervoltage int32 `protobuf:"varint,7,opt,name=input_overvoltage,json=inputOvervoltage,proto3" json:"input_overvoltage,omitempty"`
	//输入欠压门限值
	InputUndervoltage int32 `protobuf:"varint,8,opt,name=input_undervoltage,json=inputUndervoltage,proto3" json:"input_undervoltage,omitempty"`
	//输出过载门限值
	OutputOverload int32 `protobuf:"varint,9,opt,name=output_overload,json=outputOverload,proto3" json:"output_overload,omitempty"`
	//供电相数
	PhaseCount int32 `protobuf:"varint,10,opt,name=phase_count,json=phaseCount,proto3" json:"phase_count,omitempty"`
}

func (m *WlstEsu_9200) Reset()         { *m = WlstEsu_9200{} }
func (m *WlstEsu_9200) String() string { return proto.CompactTextString(m) }
func (*WlstEsu_9200) ProtoMessage()    {}
func (*WlstEsu_9200) Descriptor() ([]byte, []int) {
	return fileDescriptor_cdb47e59a3bfe786, []int{2}
}
func (m *WlstEsu_9200) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstEsu_9200) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstEsu_9200.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstEsu_9200) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstEsu_9200.Merge(m, src)
}
func (m *WlstEsu_9200) XXX_Size() int {
	return m.Size()
}
func (m *WlstEsu_9200) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstEsu_9200.DiscardUnknown(m)
}

var xxx_messageInfo_WlstEsu_9200 proto.InternalMessageInfo

func (m *WlstEsu_9200) GetWarmupTime() int32 {
	if m != nil {
		return m.WarmupTime
	}
	return 0
}

func (m *WlstEsu_9200) GetOnTime() int32 {
	if m != nil {
		return m.OnTime
	}
	return 0
}

func (m *WlstEsu_9200) GetOffTime() int32 {
	if m != nil {
		return m.OffTime
	}
	return 0
}

func (m *WlstEsu_9200) GetFanStartTemperature() int32 {
	if m != nil {
		return m.FanStartTemperature
	}
	return 0
}

func (m *WlstEsu_9200) GetStopSaver() int32 {
	if m != nil {
		return m.StopSaver
	}
	return 0
}

func (m *WlstEsu_9200) GetProtectionTemperature() int32 {
	if m != nil {
		return m.ProtectionTemperature
	}
	return 0
}

func (m *WlstEsu_9200) GetInputOvervoltage() int32 {
	if m != nil {
		return m.InputOvervoltage
	}
	return 0
}

func (m *WlstEsu_9200) GetInputUndervoltage() int32 {
	if m != nil {
		return m.InputUndervoltage
	}
	return 0
}

func (m *WlstEsu_9200) GetOutputOverload() int32 {
	if m != nil {
		return m.OutputOverload
	}
	return 0
}

func (m *WlstEsu_9200) GetPhaseCount() int32 {
	if m != nil {
		return m.PhaseCount
	}
	return 0
}

//Wlst_esu_9300
type WlstEsu_9F00 struct {
	//时间,yyyy-mm-dd hh:mm:ss
	DateTime string `protobuf:"bytes,1,opt,name=date_time,json=dateTime,proto3" json:"date_time,omitempty"`
	//温度  （1字节）
	Temperature int32 `protobuf:"varint,2,opt,name=temperature,proto3" json:"temperature,omitempty"`
	//A相输入电压
	APhaseInputVoltage float64 `protobuf:"fixed64,3,opt,name=a_phase_input_voltage,json=aPhaseInputVoltage,proto3" json:"a_phase_input_voltage,omitempty"`
	//B相输入电压
	BPhaseInputVoltage float64 `protobuf:"fixed64,4,opt,name=b_phase_input_voltage,json=bPhaseInputVoltage,proto3" json:"b_phase_input_voltage,omitempty"`
	//C相输入电压
	CPhaseInputVoltage float64 `protobuf:"fixed64,5,opt,name=c_phase_input_voltage,json=cPhaseInputVoltage,proto3" json:"c_phase_input_voltage,omitempty"`
	//A相输出电压
	APhaseOutputVoltage float64 `protobuf:"fixed64,6,opt,name=a_phase_output_voltage,json=aPhaseOutputVoltage,proto3" json:"a_phase_output_voltage,omitempty"`
	//B相输出电压
	BPhaseOutputVoltage float64 `protobuf:"fixed64,7,opt,name=b_phase_output_voltage,json=bPhaseOutputVoltage,proto3" json:"b_phase_output_voltage,omitempty"`
	//C相输出电压
	CPhaseOutputVoltage float64 `protobuf:"fixed64,8,opt,name=c_phase_output_voltage,json=cPhaseOutputVoltage,proto3" json:"c_phase_output_voltage,omitempty"`
	//A相输出电流
	APhaseOutputCurrent float64 `protobuf:"fixed64,9,opt,name=a_phase_output_current,json=aPhaseOutputCurrent,proto3" json:"a_phase_output_current,omitempty"`
	//B相输出电流
	BPhaseOutputCurrent float64 `protobuf:"fixed64,10,opt,name=b_phase_output_current,json=bPhaseOutputCurrent,proto3" json:"b_phase_output_current,omitempty"`
	//C相输出电流
	CPhaseOutputCurrent float64 `protobuf:"fixed64,11,opt,name=c_phase_output_current,json=cPhaseOutputCurrent,proto3" json:"c_phase_output_current,omitempty"`
	//A相输出功率
	APhaseOutputPower float64 `protobuf:"fixed64,12,opt,name=a_phase_output_power,json=aPhaseOutputPower,proto3" json:"a_phase_output_power,omitempty"`
	//B相输出功率
	BPhaseOutputPower float64 `protobuf:"fixed64,13,opt,name=b_phase_output_power,json=bPhaseOutputPower,proto3" json:"b_phase_output_power,omitempty"`
	//C相输出功率
	CPhaseOutputPower float64 `protobuf:"fixed64,14,opt,name=c_phase_output_power,json=cPhaseOutputPower,proto3" json:"c_phase_output_power,omitempty"`
	//风机状态（1字节）
	FanStatus int32 `protobuf:"varint,15,opt,name=fan_status,json=fanStatus,proto3" json:"fan_status,omitempty"`
	//节电器工作状态（1字节）
	SaverStatus int32 `protobuf:"varint,16,opt,name=saver_status,json=saverStatus,proto3" json:"saver_status,omitempty"`
	//开机运行时间，hh*60+mm
	RunTime int32 `protobuf:"varint,17,opt,name=run_time,json=runTime,proto3" json:"run_time,omitempty"`
	//节能运行时间，hh*60+mm
	SaverTime int32 `protobuf:"varint,18,opt,name=saver_time,json=saverTime,proto3" json:"saver_time,omitempty"`
	//当前目标调压值
	AdjustValue float64 `protobuf:"fixed64,19,opt,name=adjust_value,json=adjustValue,proto3" json:"adjust_value,omitempty"`
	//现存故障
	ExistingFault int32 `protobuf:"varint,20,opt,name=existing_fault,json=existingFault,proto3" json:"existing_fault,omitempty"`
	//今天复位次数(1字节)
	ResetDay0 int32 `protobuf:"varint,21,opt,name=reset_day0,json=resetDay0,proto3" json:"reset_day0,omitempty"`
	//昨天复位次数(1字节)
	ResetDay1 int32 `protobuf:"varint,22,opt,name=reset_day1,json=resetDay1,proto3" json:"reset_day1,omitempty"`
	//前天复位次数(1字节)
	ResetDay2 int32 `protobuf:"varint,23,opt,name=reset_day2,json=resetDay2,proto3" json:"reset_day2,omitempty"`
	//大前天复位次数(1字节)
	ResetDay3 int32 `protobuf:"varint,24,opt,name=reset_day3,json=resetDay3,proto3" json:"reset_day3,omitempty"`
	//参数状态(4字节=>%d)
	ArgsStatus int64 `protobuf:"varint,25,opt,name=args_status,json=argsStatus,proto3" json:"args_status,omitempty"`
	//节能模式（1字节）接触器=1，IGBT=0
	SaverMode int32 `protobuf:"varint,26,opt,name=saver_mode,json=saverMode,proto3" json:"saver_mode,omitempty"`
	//当前调压档位值（1字节）
	AdjustStalls int32 `protobuf:"varint,27,opt,name=adjust_stalls,json=adjustStalls,proto3" json:"adjust_stalls,omitempty"`
	//调压等待时间（1字节）
	AdjustTime int32 `protobuf:"varint,28,opt,name=adjust_time,json=adjustTime,proto3" json:"adjust_time,omitempty"`
	//a相电压调节位置（1字节）
	AdjustA int32 `protobuf:"varint,29,opt,name=adjust_a,json=adjustA,proto3" json:"adjust_a,omitempty"`
	//b相电压调节位置（1字节）
	AdjustB int32 `protobuf:"varint,30,opt,name=adjust_b,json=adjustB,proto3" json:"adjust_b,omitempty"`
	//C相电压调节位置（1字节）
	AdjustC int32 `protobuf:"varint,31,opt,name=adjust_c,json=adjustC,proto3" json:"adjust_c,omitempty"`
	//IGBT状态（1字节）
	IgbtStatus int32 `protobuf:"varint,32,opt,name=igbt_status,json=igbtStatus,proto3" json:"igbt_status,omitempty"`
	//IGBT温度（1字节）
	IgbtTemperature int32 `protobuf:"varint,33,opt,name=igbt_temperature,json=igbtTemperature,proto3" json:"igbt_temperature,omitempty"`
	//事件记录序号（1字节）
	EventNo int32 `protobuf:"varint,34,opt,name=event_no,json=eventNo,proto3" json:"event_no,omitempty"`
	//开关量输出状态（1字节）
	SwitchOutStatus int32 `protobuf:"varint,35,opt,name=switch_out_status,json=switchOutStatus,proto3" json:"switch_out_status,omitempty"`
	//开关量输入状态（1字节）
	SwitchInStatus int32 `protobuf:"varint,36,opt,name=switch_in_status,json=switchInStatus,proto3" json:"switch_in_status,omitempty"`
	//投运/停运状态(1字节)
	RunStatus int32 `protobuf:"varint,37,opt,name=run_status,json=runStatus,proto3" json:"run_status,omitempty"`
}

func (m *WlstEsu_9F00) Reset()         { *m = WlstEsu_9F00{} }
func (m *WlstEsu_9F00) String() string { return proto.CompactTextString(m) }
func (*WlstEsu_9F00) ProtoMessage()    {}
func (*WlstEsu_9F00) Descriptor() ([]byte, []int) {
	return fileDescriptor_cdb47e59a3bfe786, []int{3}
}
func (m *WlstEsu_9F00) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstEsu_9F00) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstEsu_9F00.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstEsu_9F00) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstEsu_9F00.Merge(m, src)
}
func (m *WlstEsu_9F00) XXX_Size() int {
	return m.Size()
}
func (m *WlstEsu_9F00) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstEsu_9F00.DiscardUnknown(m)
}

var xxx_messageInfo_WlstEsu_9F00 proto.InternalMessageInfo

func (m *WlstEsu_9F00) GetDateTime() string {
	if m != nil {
		return m.DateTime
	}
	return ""
}

func (m *WlstEsu_9F00) GetTemperature() int32 {
	if m != nil {
		return m.Temperature
	}
	return 0
}

func (m *WlstEsu_9F00) GetAPhaseInputVoltage() float64 {
	if m != nil {
		return m.APhaseInputVoltage
	}
	return 0
}

func (m *WlstEsu_9F00) GetBPhaseInputVoltage() float64 {
	if m != nil {
		return m.BPhaseInputVoltage
	}
	return 0
}

func (m *WlstEsu_9F00) GetCPhaseInputVoltage() float64 {
	if m != nil {
		return m.CPhaseInputVoltage
	}
	return 0
}

func (m *WlstEsu_9F00) GetAPhaseOutputVoltage() float64 {
	if m != nil {
		return m.APhaseOutputVoltage
	}
	return 0
}

func (m *WlstEsu_9F00) GetBPhaseOutputVoltage() float64 {
	if m != nil {
		return m.BPhaseOutputVoltage
	}
	return 0
}

func (m *WlstEsu_9F00) GetCPhaseOutputVoltage() float64 {
	if m != nil {
		return m.CPhaseOutputVoltage
	}
	return 0
}

func (m *WlstEsu_9F00) GetAPhaseOutputCurrent() float64 {
	if m != nil {
		return m.APhaseOutputCurrent
	}
	return 0
}

func (m *WlstEsu_9F00) GetBPhaseOutputCurrent() float64 {
	if m != nil {
		return m.BPhaseOutputCurrent
	}
	return 0
}

func (m *WlstEsu_9F00) GetCPhaseOutputCurrent() float64 {
	if m != nil {
		return m.CPhaseOutputCurrent
	}
	return 0
}

func (m *WlstEsu_9F00) GetAPhaseOutputPower() float64 {
	if m != nil {
		return m.APhaseOutputPower
	}
	return 0
}

func (m *WlstEsu_9F00) GetBPhaseOutputPower() float64 {
	if m != nil {
		return m.BPhaseOutputPower
	}
	return 0
}

func (m *WlstEsu_9F00) GetCPhaseOutputPower() float64 {
	if m != nil {
		return m.CPhaseOutputPower
	}
	return 0
}

func (m *WlstEsu_9F00) GetFanStatus() int32 {
	if m != nil {
		return m.FanStatus
	}
	return 0
}

func (m *WlstEsu_9F00) GetSaverStatus() int32 {
	if m != nil {
		return m.SaverStatus
	}
	return 0
}

func (m *WlstEsu_9F00) GetRunTime() int32 {
	if m != nil {
		return m.RunTime
	}
	return 0
}

func (m *WlstEsu_9F00) GetSaverTime() int32 {
	if m != nil {
		return m.SaverTime
	}
	return 0
}

func (m *WlstEsu_9F00) GetAdjustValue() float64 {
	if m != nil {
		return m.AdjustValue
	}
	return 0
}

func (m *WlstEsu_9F00) GetExistingFault() int32 {
	if m != nil {
		return m.ExistingFault
	}
	return 0
}

func (m *WlstEsu_9F00) GetResetDay0() int32 {
	if m != nil {
		return m.ResetDay0
	}
	return 0
}

func (m *WlstEsu_9F00) GetResetDay1() int32 {
	if m != nil {
		return m.ResetDay1
	}
	return 0
}

func (m *WlstEsu_9F00) GetResetDay2() int32 {
	if m != nil {
		return m.ResetDay2
	}
	return 0
}

func (m *WlstEsu_9F00) GetResetDay3() int32 {
	if m != nil {
		return m.ResetDay3
	}
	return 0
}

func (m *WlstEsu_9F00) GetArgsStatus() int64 {
	if m != nil {
		return m.ArgsStatus
	}
	return 0
}

func (m *WlstEsu_9F00) GetSaverMode() int32 {
	if m != nil {
		return m.SaverMode
	}
	return 0
}

func (m *WlstEsu_9F00) GetAdjustStalls() int32 {
	if m != nil {
		return m.AdjustStalls
	}
	return 0
}

func (m *WlstEsu_9F00) GetAdjustTime() int32 {
	if m != nil {
		return m.AdjustTime
	}
	return 0
}

func (m *WlstEsu_9F00) GetAdjustA() int32 {
	if m != nil {
		return m.AdjustA
	}
	return 0
}

func (m *WlstEsu_9F00) GetAdjustB() int32 {
	if m != nil {
		return m.AdjustB
	}
	return 0
}

func (m *WlstEsu_9F00) GetAdjustC() int32 {
	if m != nil {
		return m.AdjustC
	}
	return 0
}

func (m *WlstEsu_9F00) GetIgbtStatus() int32 {
	if m != nil {
		return m.IgbtStatus
	}
	return 0
}

func (m *WlstEsu_9F00) GetIgbtTemperature() int32 {
	if m != nil {
		return m.IgbtTemperature
	}
	return 0
}

func (m *WlstEsu_9F00) GetEventNo() int32 {
	if m != nil {
		return m.EventNo
	}
	return 0
}

func (m *WlstEsu_9F00) GetSwitchOutStatus() int32 {
	if m != nil {
		return m.SwitchOutStatus
	}
	return 0
}

func (m *WlstEsu_9F00) GetSwitchInStatus() int32 {
	if m != nil {
		return m.SwitchInStatus
	}
	return 0
}

func (m *WlstEsu_9F00) GetRunStatus() int32 {
	if m != nil {
		return m.RunStatus
	}
	return 0
}

type WlstEsu_1600 struct {
	//时间 yyyy-mm-dd hh:mm:ss
	DateTime string `protobuf:"bytes,1,opt,name=date_time,json=dateTime,proto3" json:"date_time,omitempty"`
}

func (m *WlstEsu_1600) Reset()         { *m = WlstEsu_1600{} }
func (m *WlstEsu_1600) String() string { return proto.CompactTextString(m) }
func (*WlstEsu_1600) ProtoMessage()    {}
func (*WlstEsu_1600) Descriptor() ([]byte, []int) {
	return fileDescriptor_cdb47e59a3bfe786, []int{4}
}
func (m *WlstEsu_1600) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstEsu_1600) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstEsu_1600.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstEsu_1600) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstEsu_1600.Merge(m, src)
}
func (m *WlstEsu_1600) XXX_Size() int {
	return m.Size()
}
func (m *WlstEsu_1600) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstEsu_1600.DiscardUnknown(m)
}

var xxx_messageInfo_WlstEsu_1600 proto.InternalMessageInfo

func (m *WlstEsu_1600) GetDateTime() string {
	if m != nil {
		return m.DateTime
	}
	return ""
}

//Wlst_esu_1400
type WlstEsu_9500 struct {
	//调压时间x，hh*60+mm
	XAdjustTime []int32 `protobuf:"varint,1,rep,packed,name=x_adjust_time,json=xAdjustTime,proto3" json:"x_adjust_time,omitempty"`
	//调压值x
	XAdjustValue []int32 `protobuf:"varint,2,rep,packed,name=x_adjust_value,json=xAdjustValue,proto3" json:"x_adjust_value,omitempty"`
}

func (m *WlstEsu_9500) Reset()         { *m = WlstEsu_9500{} }
func (m *WlstEsu_9500) String() string { return proto.CompactTextString(m) }
func (*WlstEsu_9500) ProtoMessage()    {}
func (*WlstEsu_9500) Descriptor() ([]byte, []int) {
	return fileDescriptor_cdb47e59a3bfe786, []int{5}
}
func (m *WlstEsu_9500) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstEsu_9500) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstEsu_9500.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstEsu_9500) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstEsu_9500.Merge(m, src)
}
func (m *WlstEsu_9500) XXX_Size() int {
	return m.Size()
}
func (m *WlstEsu_9500) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstEsu_9500.DiscardUnknown(m)
}

var xxx_messageInfo_WlstEsu_9500 proto.InternalMessageInfo

func (m *WlstEsu_9500) GetXAdjustTime() []int32 {
	if m != nil {
		return m.XAdjustTime
	}
	return nil
}

func (m *WlstEsu_9500) GetXAdjustValue() []int32 {
	if m != nil {
		return m.XAdjustValue
	}
	return nil
}

//Wlst_esu_1700_1a00
type WlstEsu_9700 struct {
	//记录序号
	No int32 `protobuf:"varint,1,opt,name=no,proto3" json:"no,omitempty"`
	//时间（yyyy-mm-dd hh:mm:ss）
	DateTime string `protobuf:"bytes,2,opt,name=date_time,json=dateTime,proto3" json:"date_time,omitempty"`
	//目标调压值（2字节）
	AdjustValue float64 `protobuf:"fixed64,3,opt,name=adjust_value,json=adjustValue,proto3" json:"adjust_value,omitempty"`
	//A相输入电压
	APhaseInputVoltage float64 `protobuf:"fixed64,4,opt,name=a_phase_input_voltage,json=aPhaseInputVoltage,proto3" json:"a_phase_input_voltage,omitempty"`
	//B相输入电压
	BPhaseInputVoltage float64 `protobuf:"fixed64,5,opt,name=b_phase_input_voltage,json=bPhaseInputVoltage,proto3" json:"b_phase_input_voltage,omitempty"`
	//C相输入电压
	CPhaseInputVoltage float64 `protobuf:"fixed64,6,opt,name=c_phase_input_voltage,json=cPhaseInputVoltage,proto3" json:"c_phase_input_voltage,omitempty"`
	//A相输出电压
	APhaseOutputVoltage float64 `protobuf:"fixed64,7,opt,name=a_phase_output_voltage,json=aPhaseOutputVoltage,proto3" json:"a_phase_output_voltage,omitempty"`
	//B相输出电压
	BPhaseOutputVoltage float64 `protobuf:"fixed64,8,opt,name=b_phase_output_voltage,json=bPhaseOutputVoltage,proto3" json:"b_phase_output_voltage,omitempty"`
	//C相输出电压
	CPhaseOutputVoltage float64 `protobuf:"fixed64,9,opt,name=c_phase_output_voltage,json=cPhaseOutputVoltage,proto3" json:"c_phase_output_voltage,omitempty"`
	//A相输出电流
	APhaseOutputCurrent float64 `protobuf:"fixed64,10,opt,name=a_phase_output_current,json=aPhaseOutputCurrent,proto3" json:"a_phase_output_current,omitempty"`
	//B相输出电流
	BPhaseOutputCurrent float64 `protobuf:"fixed64,11,opt,name=b_phase_output_current,json=bPhaseOutputCurrent,proto3" json:"b_phase_output_current,omitempty"`
	//C相输出电流
	CPhaseOutputCurrent float64 `protobuf:"fixed64,12,opt,name=c_phase_output_current,json=cPhaseOutputCurrent,proto3" json:"c_phase_output_current,omitempty"`
	//节能运行时间，hh*60+mm
	SaverTime int32 `protobuf:"varint,13,opt,name=saver_time,json=saverTime,proto3" json:"saver_time,omitempty"`
	//节电器工作状态（1字节）
	SaverStatus int32 `protobuf:"varint,14,opt,name=saver_status,json=saverStatus,proto3" json:"saver_status,omitempty"`
	//温度  （1字节）
	Temperature int32 `protobuf:"varint,15,opt,name=temperature,proto3" json:"temperature,omitempty"`
	//事件类型（1字节）
	EventType int32 `protobuf:"varint,16,opt,name=event_type,json=eventType,proto3" json:"event_type,omitempty"`
	//信息码（1字节）
	InfoNumber int32 `protobuf:"varint,17,opt,name=info_number,json=infoNumber,proto3" json:"info_number,omitempty"`
	//开机运行时间，hh*60+mm
	RunTime int32 `protobuf:"varint,18,opt,name=run_time,json=runTime,proto3" json:"run_time,omitempty"`
}

func (m *WlstEsu_9700) Reset()         { *m = WlstEsu_9700{} }
func (m *WlstEsu_9700) String() string { return proto.CompactTextString(m) }
func (*WlstEsu_9700) ProtoMessage()    {}
func (*WlstEsu_9700) Descriptor() ([]byte, []int) {
	return fileDescriptor_cdb47e59a3bfe786, []int{6}
}
func (m *WlstEsu_9700) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstEsu_9700) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstEsu_9700.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstEsu_9700) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstEsu_9700.Merge(m, src)
}
func (m *WlstEsu_9700) XXX_Size() int {
	return m.Size()
}
func (m *WlstEsu_9700) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstEsu_9700.DiscardUnknown(m)
}

var xxx_messageInfo_WlstEsu_9700 proto.InternalMessageInfo

func (m *WlstEsu_9700) GetNo() int32 {
	if m != nil {
		return m.No
	}
	return 0
}

func (m *WlstEsu_9700) GetDateTime() string {
	if m != nil {
		return m.DateTime
	}
	return ""
}

func (m *WlstEsu_9700) GetAdjustValue() float64 {
	if m != nil {
		return m.AdjustValue
	}
	return 0
}

func (m *WlstEsu_9700) GetAPhaseInputVoltage() float64 {
	if m != nil {
		return m.APhaseInputVoltage
	}
	return 0
}

func (m *WlstEsu_9700) GetBPhaseInputVoltage() float64 {
	if m != nil {
		return m.BPhaseInputVoltage
	}
	return 0
}

func (m *WlstEsu_9700) GetCPhaseInputVoltage() float64 {
	if m != nil {
		return m.CPhaseInputVoltage
	}
	return 0
}

func (m *WlstEsu_9700) GetAPhaseOutputVoltage() float64 {
	if m != nil {
		return m.APhaseOutputVoltage
	}
	return 0
}

func (m *WlstEsu_9700) GetBPhaseOutputVoltage() float64 {
	if m != nil {
		return m.BPhaseOutputVoltage
	}
	return 0
}

func (m *WlstEsu_9700) GetCPhaseOutputVoltage() float64 {
	if m != nil {
		return m.CPhaseOutputVoltage
	}
	return 0
}

func (m *WlstEsu_9700) GetAPhaseOutputCurrent() float64 {
	if m != nil {
		return m.APhaseOutputCurrent
	}
	return 0
}

func (m *WlstEsu_9700) GetBPhaseOutputCurrent() float64 {
	if m != nil {
		return m.BPhaseOutputCurrent
	}
	return 0
}

func (m *WlstEsu_9700) GetCPhaseOutputCurrent() float64 {
	if m != nil {
		return m.CPhaseOutputCurrent
	}
	return 0
}

func (m *WlstEsu_9700) GetSaverTime() int32 {
	if m != nil {
		return m.SaverTime
	}
	return 0
}

func (m *WlstEsu_9700) GetSaverStatus() int32 {
	if m != nil {
		return m.SaverStatus
	}
	return 0
}

func (m *WlstEsu_9700) GetTemperature() int32 {
	if m != nil {
		return m.Temperature
	}
	return 0
}

func (m *WlstEsu_9700) GetEventType() int32 {
	if m != nil {
		return m.EventType
	}
	return 0
}

func (m *WlstEsu_9700) GetInfoNumber() int32 {
	if m != nil {
		return m.InfoNumber
	}
	return 0
}

func (m *WlstEsu_9700) GetRunTime() int32 {
	if m != nil {
		return m.RunTime
	}
	return 0
}

type WlstEsu_1800 struct {
	//目标调压值（2字节）
	AdjustValue int32 `protobuf:"varint,1,opt,name=adjust_value,json=adjustValue,proto3" json:"adjust_value,omitempty"`
}

func (m *WlstEsu_1800) Reset()         { *m = WlstEsu_1800{} }
func (m *WlstEsu_1800) String() string { return proto.CompactTextString(m) }
func (*WlstEsu_1800) ProtoMessage()    {}
func (*WlstEsu_1800) Descriptor() ([]byte, []int) {
	return fileDescriptor_cdb47e59a3bfe786, []int{7}
}
func (m *WlstEsu_1800) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstEsu_1800) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstEsu_1800.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstEsu_1800) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstEsu_1800.Merge(m, src)
}
func (m *WlstEsu_1800) XXX_Size() int {
	return m.Size()
}
func (m *WlstEsu_1800) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstEsu_1800.DiscardUnknown(m)
}

var xxx_messageInfo_WlstEsu_1800 proto.InternalMessageInfo

func (m *WlstEsu_1800) GetAdjustValue() int32 {
	if m != nil {
		return m.AdjustValue
	}
	return 0
}

//Wlst_esu_2500
type WlstEsu_1900 struct {
	//1900->手动开关机，0-关机，1-开机.2500->0-停运，1-投运
	ManualControl int32 `protobuf:"varint,1,opt,name=manual_control,json=manualControl,proto3" json:"manual_control,omitempty"`
}

func (m *WlstEsu_1900) Reset()         { *m = WlstEsu_1900{} }
func (m *WlstEsu_1900) String() string { return proto.CompactTextString(m) }
func (*WlstEsu_1900) ProtoMessage()    {}
func (*WlstEsu_1900) Descriptor() ([]byte, []int) {
	return fileDescriptor_cdb47e59a3bfe786, []int{8}
}
func (m *WlstEsu_1900) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstEsu_1900) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstEsu_1900.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstEsu_1900) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstEsu_1900.Merge(m, src)
}
func (m *WlstEsu_1900) XXX_Size() int {
	return m.Size()
}
func (m *WlstEsu_1900) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstEsu_1900.DiscardUnknown(m)
}

var xxx_messageInfo_WlstEsu_1900 proto.InternalMessageInfo

func (m *WlstEsu_1900) GetManualControl() int32 {
	if m != nil {
		return m.ManualControl
	}
	return 0
}

type WlstEsu_9A00 struct {
	//记录序号
	No int32 `protobuf:"varint,1,opt,name=no,proto3" json:"no,omitempty"`
	//时间（yyyy-mm-dd）
	DateTime string `protobuf:"bytes,2,opt,name=date_time,json=dateTime,proto3" json:"date_time,omitempty"`
	//开机运行时间，hh*60+mm
	RunTime int32 `protobuf:"varint,3,opt,name=run_time,json=runTime,proto3" json:"run_time,omitempty"`
	//节能运行时间，hh*60+mm
	SaverTime int32 `protobuf:"varint,4,opt,name=saver_time,json=saverTime,proto3" json:"saver_time,omitempty"`
}

func (m *WlstEsu_9A00) Reset()         { *m = WlstEsu_9A00{} }
func (m *WlstEsu_9A00) String() string { return proto.CompactTextString(m) }
func (*WlstEsu_9A00) ProtoMessage()    {}
func (*WlstEsu_9A00) Descriptor() ([]byte, []int) {
	return fileDescriptor_cdb47e59a3bfe786, []int{9}
}
func (m *WlstEsu_9A00) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstEsu_9A00) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstEsu_9A00.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstEsu_9A00) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstEsu_9A00.Merge(m, src)
}
func (m *WlstEsu_9A00) XXX_Size() int {
	return m.Size()
}
func (m *WlstEsu_9A00) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstEsu_9A00.DiscardUnknown(m)
}

var xxx_messageInfo_WlstEsu_9A00 proto.InternalMessageInfo

func (m *WlstEsu_9A00) GetNo() int32 {
	if m != nil {
		return m.No
	}
	return 0
}

func (m *WlstEsu_9A00) GetDateTime() string {
	if m != nil {
		return m.DateTime
	}
	return ""
}

func (m *WlstEsu_9A00) GetRunTime() int32 {
	if m != nil {
		return m.RunTime
	}
	return 0
}

func (m *WlstEsu_9A00) GetSaverTime() int32 {
	if m != nil {
		return m.SaverTime
	}
	return 0
}

//Wlst_esu_1d00
type WlstEsu_9E00 struct {
	//预热时间，2-30,默认10
	WarmupTime int32 `protobuf:"varint,1,opt,name=warmup_time,json=warmupTime,proto3" json:"warmup_time,omitempty"`
	//开机时间，hh*60+mm
	OnTime int32 `protobuf:"varint,2,opt,name=on_time,json=onTime,proto3" json:"on_time,omitempty"`
	//关机时间，hh*60+mm
	OffTime int32 `protobuf:"varint,3,opt,name=off_time,json=offTime,proto3" json:"off_time,omitempty"`
	//A相变比
	TransformerA int32 `protobuf:"varint,4,opt,name=transformer_a,json=transformerA,proto3" json:"transformer_a,omitempty"`
	//B相变比
	TransformerB int32 `protobuf:"varint,5,opt,name=transformer_b,json=transformerB,proto3" json:"transformer_b,omitempty"`
	//C相变比
	TransformerC int32 `protobuf:"varint,6,opt,name=transformer_c,json=transformerC,proto3" json:"transformer_c,omitempty"`
	//时间模式
	TimeMode int32 `protobuf:"varint,7,opt,name=time_mode,json=timeMode,proto3" json:"time_mode,omitempty"`
	//运行模式
	RunMode int32 `protobuf:"varint,8,opt,name=run_mode,json=runMode,proto3" json:"run_mode,omitempty"`
	//风机启动温度
	FanStartTemperature int32 `protobuf:"varint,9,opt,name=fan_start_temperature,json=fanStartTemperature,proto3" json:"fan_start_temperature,omitempty"`
	//风机关闭温度
	FanStopTemperature int32 `protobuf:"varint,10,opt,name=fan_stop_temperature,json=fanStopTemperature,proto3" json:"fan_stop_temperature,omitempty"`
	//节能停止温度
	SaverStopTemperature int32 `protobuf:"varint,11,opt,name=saver_stop_temperature,json=saverStopTemperature,proto3" json:"saver_stop_temperature,omitempty"`
	//节能恢复温度
	SaverRecoverTemperature int32 `protobuf:"varint,12,opt,name=saver_recover_temperature,json=saverRecoverTemperature,proto3" json:"saver_recover_temperature,omitempty"`
	//强制保护温度
	ProtectionTemperature int32 `protobuf:"varint,13,opt,name=protection_temperature,json=protectionTemperature,proto3" json:"protection_temperature,omitempty"`
	//输入过压门限值
	InputOvervoltage int32 `protobuf:"varint,14,opt,name=input_overvoltage,json=inputOvervoltage,proto3" json:"input_overvoltage,omitempty"`
	//输入欠压门限值
	InputUndervoltage int32 `protobuf:"varint,15,opt,name=input_undervoltage,json=inputUndervoltage,proto3" json:"input_undervoltage,omitempty"`
	//输出过载门限值
	OutputOverload int32 `protobuf:"varint,16,opt,name=output_overload,json=outputOverload,proto3" json:"output_overload,omitempty"`
	//输出欠压门限值
	OutputUndervoltage int32 `protobuf:"varint,17,opt,name=output_undervoltage,json=outputUndervoltage,proto3" json:"output_undervoltage,omitempty"`
	//调压速度
	AdjustSpeed int32 `protobuf:"varint,18,opt,name=adjust_speed,json=adjustSpeed,proto3" json:"adjust_speed,omitempty"`
	//供电相数
	PhaseCount int32 `protobuf:"varint,19,opt,name=phase_count,json=phaseCount,proto3" json:"phase_count,omitempty"`
	//通信模式 1=通过照明终端实现与主站通信， 0=带地址
	CommunicateMode int32 `protobuf:"varint,20,opt,name=communicate_mode,json=communicateMode,proto3" json:"communicate_mode,omitempty"`
	//工作模式（1字节）通用模式=1 ，特殊模式=0
	WorkMode int32 `protobuf:"varint,21,opt,name=work_mode,json=workMode,proto3" json:"work_mode,omitempty"`
	//主动报警（1字节）主动报警=1，禁止主动报警=0
	AlarmOn int32 `protobuf:"varint,22,opt,name=alarm_on,json=alarmOn,proto3" json:"alarm_on,omitempty"`
	//报警延时
	AlarmDelay int32 `protobuf:"varint,23,opt,name=alarm_delay,json=alarmDelay,proto3" json:"alarm_delay,omitempty"`
	//节能模式（1字节）接触器=1，IGBT=0
	SaverMode int32 `protobuf:"varint,24,opt,name=saver_mode,json=saverMode,proto3" json:"saver_mode,omitempty"`
}

func (m *WlstEsu_9E00) Reset()         { *m = WlstEsu_9E00{} }
func (m *WlstEsu_9E00) String() string { return proto.CompactTextString(m) }
func (*WlstEsu_9E00) ProtoMessage()    {}
func (*WlstEsu_9E00) Descriptor() ([]byte, []int) {
	return fileDescriptor_cdb47e59a3bfe786, []int{10}
}
func (m *WlstEsu_9E00) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WlstEsu_9E00) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WlstEsu_9E00.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WlstEsu_9E00) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WlstEsu_9E00.Merge(m, src)
}
func (m *WlstEsu_9E00) XXX_Size() int {
	return m.Size()
}
func (m *WlstEsu_9E00) XXX_DiscardUnknown() {
	xxx_messageInfo_WlstEsu_9E00.DiscardUnknown(m)
}

var xxx_messageInfo_WlstEsu_9E00 proto.InternalMessageInfo

func (m *WlstEsu_9E00) GetWarmupTime() int32 {
	if m != nil {
		return m.WarmupTime
	}
	return 0
}

func (m *WlstEsu_9E00) GetOnTime() int32 {
	if m != nil {
		return m.OnTime
	}
	return 0
}

func (m *WlstEsu_9E00) GetOffTime() int32 {
	if m != nil {
		return m.OffTime
	}
	return 0
}

func (m *WlstEsu_9E00) GetTransformerA() int32 {
	if m != nil {
		return m.TransformerA
	}
	return 0
}

func (m *WlstEsu_9E00) GetTransformerB() int32 {
	if m != nil {
		return m.TransformerB
	}
	return 0
}

func (m *WlstEsu_9E00) GetTransformerC() int32 {
	if m != nil {
		return m.TransformerC
	}
	return 0
}

func (m *WlstEsu_9E00) GetTimeMode() int32 {
	if m != nil {
		return m.TimeMode
	}
	return 0
}

func (m *WlstEsu_9E00) GetRunMode() int32 {
	if m != nil {
		return m.RunMode
	}
	return 0
}

func (m *WlstEsu_9E00) GetFanStartTemperature() int32 {
	if m != nil {
		return m.FanStartTemperature
	}
	return 0
}

func (m *WlstEsu_9E00) GetFanStopTemperature() int32 {
	if m != nil {
		return m.FanStopTemperature
	}
	return 0
}

func (m *WlstEsu_9E00) GetSaverStopTemperature() int32 {
	if m != nil {
		return m.SaverStopTemperature
	}
	return 0
}

func (m *WlstEsu_9E00) GetSaverRecoverTemperature() int32 {
	if m != nil {
		return m.SaverRecoverTemperature
	}
	return 0
}

func (m *WlstEsu_9E00) GetProtectionTemperature() int32 {
	if m != nil {
		return m.ProtectionTemperature
	}
	return 0
}

func (m *WlstEsu_9E00) GetInputOvervoltage() int32 {
	if m != nil {
		return m.InputOvervoltage
	}
	return 0
}

func (m *WlstEsu_9E00) GetInputUndervoltage() int32 {
	if m != nil {
		return m.InputUndervoltage
	}
	return 0
}

func (m *WlstEsu_9E00) GetOutputOverload() int32 {
	if m != nil {
		return m.OutputOverload
	}
	return 0
}

func (m *WlstEsu_9E00) GetOutputUndervoltage() int32 {
	if m != nil {
		return m.OutputUndervoltage
	}
	return 0
}

func (m *WlstEsu_9E00) GetAdjustSpeed() int32 {
	if m != nil {
		return m.AdjustSpeed
	}
	return 0
}

func (m *WlstEsu_9E00) GetPhaseCount() int32 {
	if m != nil {
		return m.PhaseCount
	}
	return 0
}

func (m *WlstEsu_9E00) GetCommunicateMode() int32 {
	if m != nil {
		return m.CommunicateMode
	}
	return 0
}

func (m *WlstEsu_9E00) GetWorkMode() int32 {
	if m != nil {
		return m.WorkMode
	}
	return 0
}

func (m *WlstEsu_9E00) GetAlarmOn() int32 {
	if m != nil {
		return m.AlarmOn
	}
	return 0
}

func (m *WlstEsu_9E00) GetAlarmDelay() int32 {
	if m != nil {
		return m.AlarmDelay
	}
	return 0
}

func (m *WlstEsu_9E00) GetSaverMode() int32 {
	if m != nil {
		return m.SaverMode
	}
	return 0
}

func init() {
	proto.RegisterType((*WlstEsu_9000)(nil), "wlst.pb2.Wlst_esu_9000")
	proto.RegisterType((*WlstEsu_9400)(nil), "wlst.pb2.Wlst_esu_9400")
	proto.RegisterType((*WlstEsu_9200)(nil), "wlst.pb2.Wlst_esu_9200")
	proto.RegisterType((*WlstEsu_9F00)(nil), "wlst.pb2.Wlst_esu_9f00")
	proto.RegisterType((*WlstEsu_1600)(nil), "wlst.pb2.Wlst_esu_1600")
	proto.RegisterType((*WlstEsu_9500)(nil), "wlst.pb2.Wlst_esu_9500")
	proto.RegisterType((*WlstEsu_9700)(nil), "wlst.pb2.Wlst_esu_9700")
	proto.RegisterType((*WlstEsu_1800)(nil), "wlst.pb2.Wlst_esu_1800")
	proto.RegisterType((*WlstEsu_1900)(nil), "wlst.pb2.Wlst_esu_1900")
	proto.RegisterType((*WlstEsu_9A00)(nil), "wlst.pb2.Wlst_esu_9a00")
	proto.RegisterType((*WlstEsu_9E00)(nil), "wlst.pb2.Wlst_esu_9e00")
}

func init() { proto.RegisterFile("protocol_esu.proto", fileDescriptor_cdb47e59a3bfe786) }

var fileDescriptor_cdb47e59a3bfe786 = []byte{
	// 1314 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x57, 0x4b, 0x73, 0xdb, 0xb6,
	0x13, 0x8f, 0xfc, 0x92, 0xb4, 0x7a, 0xd8, 0xa6, 0x1f, 0xa1, 0x93, 0xbf, 0x15, 0x47, 0xf9, 0xa7,
	0x71, 0x5f, 0x09, 0x6d, 0x27, 0x69, 0xd3, 0x5b, 0xec, 0x4c, 0xa7, 0x39, 0x34, 0xce, 0xd8, 0x69,
	0x7a, 0xe4, 0x80, 0x14, 0xe4, 0xa8, 0xa5, 0x08, 0x0e, 0x09, 0xca, 0xf1, 0xb7, 0xe8, 0xa1, 0x5f,
	0xa3, 0xe7, 0x7e, 0x85, 0x1e, 0x73, 0xec, 0xb1, 0x93, 0x7c, 0x86, 0xde, 0x3b, 0xd8, 0x05, 0x2d,
	0x90, 0xa2, 0xd3, 0x91, 0x66, 0x7a, 0xe4, 0xef, 0x01, 0x80, 0x0b, 0xec, 0x2e, 0x00, 0x56, 0x14,
	0x0b, 0x29, 0x7c, 0x11, 0xb8, 0x3c, 0x49, 0xef, 0xe3, 0x87, 0x55, 0x3b, 0x0f, 0x12, 0x79, 0x3f,
	0xf2, 0xf6, 0xbb, 0xf7, 0xa0, 0xf5, 0x63, 0x90, 0x48, 0xc5, 0xb9, 0x4f, 0x1c, 0xc7, 0xb1, 0x36,
	0x61, 0x29, 0x91, 0x4c, 0xa6, 0x89, 0x5d, 0xd9, 0xa9, 0xec, 0x2e, 0x9e, 0xe8, 0xaf, 0xbc, 0xf0,
	0xe1, 0x47, 0x84, 0xbf, 0xce, 0x9b, 0xca, 0x7d, 0xc7, 0xb1, 0x6e, 0x41, 0xe3, 0x9c, 0xc5, 0xc3,
	0x34, 0x72, 0xe5, 0x60, 0xc8, 0xb5, 0x1c, 0x08, 0x7a, 0x35, 0x18, 0x72, 0xeb, 0x3a, 0x54, 0x45,
	0x48, 0xe4, 0x1c, 0x8d, 0x25, 0x42, 0x24, 0xb6, 0xa0, 0x26, 0xfa, 0x7d, 0x62, 0xe6, 0x91, 0xa9,
	0x8a, 0x7e, 0x1f, 0xa9, 0x7d, 0xd8, 0xe8, 0xb3, 0xd0, 0x4d, 0x24, 0x8b, 0xa5, 0x2b, 0xf9, 0x30,
	0xe2, 0x31, 0x93, 0x69, 0xcc, 0xed, 0x05, 0xd4, 0xad, 0xf5, 0x59, 0x78, 0xaa, 0xb8, 0x57, 0x63,
	0xca, 0xda, 0x06, 0x48, 0xa4, 0x88, 0xdc, 0x84, 0x8d, 0x78, 0x6c, 0x2f, 0xa2, 0xb0, 0xae, 0x90,
	0x53, 0x05, 0x58, 0x8f, 0x60, 0x53, 0x85, 0x87, 0xfb, 0x72, 0xa0, 0x96, 0x63, 0x8c, 0xb9, 0x84,
	0xd2, 0x8d, 0x31, 0x6b, 0x8e, 0xfa, 0x39, 0xac, 0x0e, 0xc2, 0x28, 0x95, 0xae, 0x18, 0xf1, 0x78,
	0x24, 0x02, 0xc9, 0xce, 0xb8, 0x5d, 0x45, 0xc7, 0x0a, 0x12, 0xc7, 0x63, 0xdc, 0xfa, 0x12, 0x2c,
	0x12, 0xa7, 0x61, 0x6f, 0xac, 0xae, 0xa1, 0x9a, 0x86, 0xf9, 0xc1, 0x20, 0xac, 0x7b, 0xb0, 0x2c,
	0x52, 0x99, 0x0d, 0x1e, 0x08, 0xd6, 0xb3, 0xeb, 0xa8, 0x6d, 0x13, 0x7c, 0xac, 0x51, 0x15, 0xe3,
	0xe8, 0x0d, 0x4b, 0xb8, 0xeb, 0x8b, 0x34, 0x94, 0x36, 0x50, 0x8c, 0x11, 0x3a, 0x52, 0x48, 0xf7,
	0xb7, 0x86, 0xb9, 0x2d, 0x7d, 0xc7, 0xb1, 0x6e, 0x42, 0xbd, 0xc7, 0x24, 0x1f, 0x6f, 0x4a, 0xfd,
	0xa4, 0xa6, 0x00, 0x0c, 0xef, 0x0e, 0x34, 0xcc, 0x00, 0xd0, 0xb6, 0x98, 0x90, 0xb5, 0x07, 0x1b,
	0xcc, 0xa5, 0x39, 0xe9, 0x8f, 0xb2, 0x9f, 0x51, 0x1b, 0x55, 0x39, 0xb1, 0xd8, 0x4b, 0xc5, 0x3d,
	0x57, 0xd4, 0x6b, 0xfd, 0x37, 0x7b, 0xb0, 0xe1, 0x95, 0x5a, 0x16, 0xc8, 0xe2, 0x95, 0x5a, 0xfc,
	0x52, 0xcb, 0x22, 0x59, 0xfc, 0x49, 0xcb, 0x01, 0x6c, 0x66, 0x0b, 0xd3, 0xb1, 0xcb, 0x3c, 0x4b,
	0xe8, 0x59, 0xa3, 0x95, 0x1d, 0x23, 0x67, 0x98, 0xbc, 0x72, 0x53, 0x95, 0x4c, 0x5e, 0xb9, 0xc9,
	0x2f, 0x37, 0xd5, 0xc8, 0xe4, 0x97, 0x9b, 0x0a, 0xcb, 0xf3, 0xd3, 0x38, 0xe6, 0xa1, 0xc4, 0x9d,
	0x2d, 0x2c, 0xef, 0x88, 0xa8, 0x92, 0xe5, 0x65, 0x26, 0x98, 0x5c, 0x9e, 0x61, 0xf2, 0xcb, 0x4d,
	0x8d, 0xc9, 0xe5, 0x65, 0xa6, 0x07, 0xb0, 0x5e, 0x58, 0x5e, 0x24, 0xce, 0x79, 0x6c, 0x37, 0xd1,
	0xb2, 0x6a, 0x2e, 0xee, 0xa5, 0x22, 0x94, 0xc1, 0x2b, 0x33, 0xb4, 0xc8, 0xe0, 0x95, 0x19, 0xfc,
	0x32, 0x43, 0x9b, 0x0c, 0xfe, 0x84, 0x61, 0x1b, 0x40, 0xa7, 0xba, 0xaa, 0x36, 0xcb, 0x94, 0xb6,
	0x94, 0xdf, 0x32, 0x4d, 0xac, 0xdb, 0xd0, 0xc4, 0x84, 0xce, 0x04, 0x2b, 0x74, 0x56, 0x11, 0xd3,
	0x92, 0x2d, 0xa8, 0xc5, 0xa9, 0xae, 0x30, 0xab, 0x54, 0x47, 0xe2, 0x94, 0x4a, 0x8c, 0xaa, 0x09,
	0xe8, 0x46, 0xd2, 0xd2, 0x35, 0x41, 0x21, 0x48, 0xdf, 0x86, 0x26, 0xeb, 0xfd, 0x94, 0x26, 0xd2,
	0x1d, 0xb1, 0x20, 0xe5, 0xf6, 0x1a, 0x2e, 0xb2, 0x41, 0xd8, 0x6b, 0x05, 0x59, 0x77, 0xa1, 0xcd,
	0xdf, 0x0e, 0x12, 0x39, 0x08, 0xcf, 0xdc, 0x3e, 0x4b, 0x03, 0x69, 0xaf, 0xe3, 0x28, 0xad, 0x0c,
	0xfd, 0x56, 0x81, 0x6a, 0xa2, 0x98, 0x27, 0x5c, 0xba, 0x3d, 0x76, 0xe1, 0xd8, 0x1b, 0x34, 0x11,
	0x22, 0xcf, 0xd8, 0x85, 0x93, 0xa3, 0xf7, 0xec, 0xcd, 0x3c, 0xbd, 0x97, 0xa3, 0xf7, 0xed, 0xeb,
	0x79, 0x7a, 0x3f, 0x47, 0x1f, 0xd8, 0x76, 0x9e, 0x3e, 0x50, 0xd5, 0x81, 0xc5, 0x67, 0x49, 0x16,
	0xa1, 0xad, 0x9d, 0xca, 0xee, 0xfc, 0x09, 0x28, 0x48, 0x07, 0xe8, 0x32, 0x0a, 0x43, 0xd1, 0xe3,
	0xf6, 0x0d, 0x23, 0x0a, 0xdf, 0x8b, 0x1e, 0xb7, 0xee, 0x40, 0x4b, 0x47, 0x21, 0x91, 0x2c, 0x08,
	0x12, 0xfb, 0x26, 0x2a, 0x74, 0x68, 0x4e, 0x11, 0xc3, 0x49, 0x48, 0x84, 0xa1, 0xfc, 0x1f, 0x95,
	0x20, 0x82, 0xb2, 0x6a, 0xae, 0x05, 0xcc, 0xde, 0xa6, 0x5d, 0xa0, 0xef, 0xa7, 0x06, 0xe5, 0xd9,
	0x1d, 0x93, 0x3a, 0x34, 0x28, 0xdf, 0xbe, 0x65, 0x52, 0x47, 0x6a, 0xc6, 0xc1, 0x99, 0x27, 0xb3,
	0xdf, 0xda, 0xa1, 0x19, 0x15, 0xa4, 0x7f, 0xeb, 0x53, 0x58, 0x41, 0x81, 0x59, 0xca, 0x6e, 0xa3,
	0x6a, 0x59, 0xe1, 0x66, 0x15, 0xdf, 0x82, 0x1a, 0x1f, 0xf1, 0x50, 0xba, 0xa1, 0xb0, 0xbb, 0x34,
	0x0d, 0x7e, 0xbf, 0x10, 0xd6, 0x67, 0xb0, 0x9a, 0x9c, 0x0f, 0xa4, 0xff, 0x46, 0x9d, 0xd7, 0x6c,
	0xb2, 0x3b, 0x34, 0x0c, 0x11, 0xc7, 0x69, 0x36, 0xe3, 0x2e, 0xac, 0x68, 0xed, 0xe0, 0xf2, 0xc4,
	0xfe, 0x9f, 0x2a, 0x36, 0xe1, 0xcf, 0xc3, 0x71, 0xc8, 0xd5, 0x99, 0xd4, 0x9a, 0xbb, 0x7a, 0xcb,
	0x52, 0x4d, 0x77, 0xbf, 0x30, 0xca, 0xf5, 0xde, 0xe3, 0x7f, 0x29, 0xd7, 0x5d, 0x66, 0x16, 0xf7,
	0x47, 0x8e, 0x63, 0x7d, 0x02, 0xad, 0xb7, 0xae, 0xb9, 0x1d, 0x95, 0x9d, 0xf9, 0xdd, 0xc5, 0xc3,
	0xb9, 0x95, 0xca, 0x49, 0xe3, 0xed, 0xd3, 0xf1, 0x9e, 0xec, 0x42, 0xfb, 0x52, 0x47, 0x27, 0x7c,
	0xee, 0x52, 0xd8, 0xd4, 0x42, 0x3c, 0xe6, 0xdd, 0xbf, 0x17, 0xcd, 0x39, 0xbe, 0x72, 0x1c, 0xab,
	0x0d, 0x73, 0xa1, 0xd0, 0xed, 0x7c, 0x2e, 0x14, 0xf9, 0x15, 0xce, 0x15, 0x1a, 0x4a, 0x31, 0x91,
	0xe6, 0x27, 0x13, 0xe9, 0xca, 0x8e, 0xb2, 0x30, 0x7d, 0x47, 0x59, 0x9c, 0xbe, 0xa3, 0x2c, 0xcd,
	0xd0, 0x51, 0xaa, 0xb3, 0x74, 0x94, 0xda, 0x2c, 0x1d, 0xa5, 0x3e, 0x4b, 0x47, 0x81, 0x59, 0x3a,
	0x4a, 0x63, 0x96, 0x8e, 0xd2, 0xbc, 0xba, 0xa3, 0xe4, 0x2b, 0x6c, 0xab, 0xa4, 0xc2, 0xe6, 0xca,
	0x77, 0x7b, 0xb2, 0x7c, 0x17, 0x2e, 0x23, 0xcb, 0x93, 0x97, 0x91, 0x6d, 0x00, 0xca, 0x5e, 0x79,
	0x11, 0x71, 0xdd, 0x01, 0xea, 0x88, 0xbc, 0xba, 0x88, 0x38, 0x16, 0x8a, 0xb0, 0x2f, 0xdc, 0x30,
	0x1d, 0x7a, 0x3c, 0xd6, 0x2d, 0x00, 0x14, 0xf4, 0x02, 0x91, 0x5c, 0x83, 0xb0, 0x72, 0x0d, 0xa2,
	0xbb, 0x6f, 0x26, 0xe2, 0xd7, 0x8e, 0x33, 0x71, 0x92, 0x29, 0x01, 0xcc, 0x93, 0xdc, 0x7d, 0x6c,
	0x7a, 0x9e, 0x38, 0x8e, 0xea, 0x11, 0x43, 0x16, 0xa6, 0x2c, 0x70, 0x7d, 0x11, 0xca, 0x58, 0x04,
	0xda, 0xd5, 0x22, 0xf4, 0x88, 0xc0, 0xee, 0xc8, 0x4c, 0x31, 0x36, 0x6d, 0x8a, 0x99, 0x3f, 0x31,
	0xff, 0xb1, 0x2e, 0xb7, 0x50, 0xd8, 0x83, 0xee, 0xef, 0x55, 0x73, 0x62, 0xfe, 0x5f, 0xdd, 0xd9,
	0xef, 0x40, 0x4b, 0xc6, 0x2c, 0x4c, 0xfa, 0x22, 0x1e, 0xf2, 0xd8, 0x65, 0x7a, 0x21, 0x4d, 0x03,
	0x7c, 0x5a, 0x14, 0x79, 0xfa, 0x9e, 0x6e, 0x8a, 0x0e, 0x8b, 0x22, 0x5f, 0xdf, 0xd0, 0x4d, 0xd1,
	0x91, 0x0a, 0x96, 0x5a, 0x05, 0xf5, 0x34, 0xba, 0x90, 0xd7, 0x14, 0x80, 0x2d, 0x4d, 0x07, 0x0b,
	0xb9, 0xda, 0x65, 0xb0, 0x90, 0xba, 0xf2, 0x69, 0x51, 0xbf, 0xfa, 0x69, 0xe1, 0xc0, 0x3a, 0x79,
	0x44, 0x94, 0xb3, 0xd0, 0x45, 0xdc, 0x42, 0x8b, 0x88, 0x4c, 0xc7, 0x43, 0xd8, 0xcc, 0xce, 0x7d,
	0xc1, 0xd3, 0x40, 0xcf, 0xba, 0xce, 0x80, 0xbc, 0xeb, 0x1b, 0xd8, 0x22, 0x57, 0xcc, 0x7d, 0x81,
	0x1b, 0x6a, 0x18, 0x9b, 0x68, 0xbc, 0x8e, 0x82, 0x13, 0xe2, 0x4d, 0xef, 0xd5, 0xef, 0x9b, 0xd6,
	0xd4, 0xef, 0x9b, 0xf6, 0x54, 0xef, 0x9b, 0xe5, 0x29, 0xde, 0x37, 0x2b, 0xa5, 0xef, 0x9b, 0x07,
	0xb0, 0xa6, 0x85, 0xb9, 0x81, 0x29, 0x93, 0x2d, 0xa2, 0x72, 0x23, 0x8f, 0xb3, 0x34, 0x89, 0x38,
	0xef, 0xe9, 0xac, 0xd6, 0x59, 0x7a, 0xaa, 0xa0, 0xe2, 0x9b, 0x69, 0xad, 0xf8, 0x66, 0x52, 0xd7,
	0x07, 0x5f, 0x0c, 0x87, 0x69, 0x38, 0xf0, 0x55, 0xd2, 0xe1, 0x59, 0xa1, 0xbb, 0xdd, 0xb2, 0x81,
	0xe3, 0x99, 0xb9, 0x09, 0xf5, 0x73, 0x11, 0xff, 0x4c, 0x1a, 0xba, 0xdc, 0xd5, 0x14, 0x90, 0x9d,
	0x35, 0x16, 0xb0, 0x78, 0xe8, 0x8a, 0x50, 0xdf, 0xec, 0xaa, 0xf8, 0x7d, 0x1c, 0xe2, 0xa5, 0x09,
	0xa9, 0x1e, 0x0f, 0xd8, 0x85, 0xbe, 0xd8, 0x01, 0x42, 0xcf, 0x14, 0x52, 0xb8, 0x99, 0xd9, 0x85,
	0x9b, 0xd9, 0xe1, 0x8d, 0x3f, 0xde, 0x77, 0x2a, 0xef, 0xde, 0x77, 0x2a, 0x7f, 0xbd, 0xef, 0x54,
	0x7e, 0xf9, 0xd0, 0xb9, 0xf6, 0xee, 0x43, 0xe7, 0xda, 0x9f, 0x1f, 0x3a, 0xd7, 0xbe, 0xab, 0x78,
	0x4b, 0xf8, 0xd8, 0x3f, 0xf8, 0x27, 0x00, 0x00, 0xff, 0xff, 0xcc, 0x7f, 0x82, 0xf5, 0x02, 0x10,
	0x00, 0x00,
}

func (m *WlstEsu_9000) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstEsu_9000) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstEsu_9000) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstEsu_9400) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstEsu_9400) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstEsu_9400) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstEsu_9200) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstEsu_9200) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstEsu_9200) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PhaseCount != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.PhaseCount))
		i--
		dAtA[i] = 0x50
	}
	if m.OutputOverload != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.OutputOverload))
		i--
		dAtA[i] = 0x48
	}
	if m.InputUndervoltage != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.InputUndervoltage))
		i--
		dAtA[i] = 0x40
	}
	if m.InputOvervoltage != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.InputOvervoltage))
		i--
		dAtA[i] = 0x38
	}
	if m.ProtectionTemperature != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.ProtectionTemperature))
		i--
		dAtA[i] = 0x30
	}
	if m.StopSaver != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.StopSaver))
		i--
		dAtA[i] = 0x28
	}
	if m.FanStartTemperature != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.FanStartTemperature))
		i--
		dAtA[i] = 0x20
	}
	if m.OffTime != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.OffTime))
		i--
		dAtA[i] = 0x18
	}
	if m.OnTime != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.OnTime))
		i--
		dAtA[i] = 0x10
	}
	if m.WarmupTime != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.WarmupTime))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstEsu_9F00) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstEsu_9F00) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstEsu_9F00) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RunStatus != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.RunStatus))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa8
	}
	if m.SwitchInStatus != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.SwitchInStatus))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa0
	}
	if m.SwitchOutStatus != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.SwitchOutStatus))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x98
	}
	if m.EventNo != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.EventNo))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if m.IgbtTemperature != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.IgbtTemperature))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.IgbtStatus != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.IgbtStatus))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.AdjustC != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.AdjustC))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.AdjustB != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.AdjustB))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.AdjustA != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.AdjustA))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.AdjustTime != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.AdjustTime))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.AdjustStalls != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.AdjustStalls))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.SaverMode != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.SaverMode))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.ArgsStatus != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.ArgsStatus))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.ResetDay3 != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.ResetDay3))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.ResetDay2 != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.ResetDay2))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.ResetDay1 != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.ResetDay1))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.ResetDay0 != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.ResetDay0))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.ExistingFault != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.ExistingFault))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.AdjustValue != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.AdjustValue))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x99
	}
	if m.SaverTime != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.SaverTime))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.RunTime != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.RunTime))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.SaverStatus != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.SaverStatus))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.FanStatus != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.FanStatus))
		i--
		dAtA[i] = 0x78
	}
	if m.CPhaseOutputPower != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CPhaseOutputPower))))
		i--
		dAtA[i] = 0x71
	}
	if m.BPhaseOutputPower != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.BPhaseOutputPower))))
		i--
		dAtA[i] = 0x69
	}
	if m.APhaseOutputPower != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.APhaseOutputPower))))
		i--
		dAtA[i] = 0x61
	}
	if m.CPhaseOutputCurrent != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CPhaseOutputCurrent))))
		i--
		dAtA[i] = 0x59
	}
	if m.BPhaseOutputCurrent != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.BPhaseOutputCurrent))))
		i--
		dAtA[i] = 0x51
	}
	if m.APhaseOutputCurrent != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.APhaseOutputCurrent))))
		i--
		dAtA[i] = 0x49
	}
	if m.CPhaseOutputVoltage != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CPhaseOutputVoltage))))
		i--
		dAtA[i] = 0x41
	}
	if m.BPhaseOutputVoltage != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.BPhaseOutputVoltage))))
		i--
		dAtA[i] = 0x39
	}
	if m.APhaseOutputVoltage != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.APhaseOutputVoltage))))
		i--
		dAtA[i] = 0x31
	}
	if m.CPhaseInputVoltage != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CPhaseInputVoltage))))
		i--
		dAtA[i] = 0x29
	}
	if m.BPhaseInputVoltage != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.BPhaseInputVoltage))))
		i--
		dAtA[i] = 0x21
	}
	if m.APhaseInputVoltage != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.APhaseInputVoltage))))
		i--
		dAtA[i] = 0x19
	}
	if m.Temperature != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.Temperature))
		i--
		dAtA[i] = 0x10
	}
	if len(m.DateTime) > 0 {
		i -= len(m.DateTime)
		copy(dAtA[i:], m.DateTime)
		i = encodeVarintProtocolEsu(dAtA, i, uint64(len(m.DateTime)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WlstEsu_1600) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstEsu_1600) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstEsu_1600) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DateTime) > 0 {
		i -= len(m.DateTime)
		copy(dAtA[i:], m.DateTime)
		i = encodeVarintProtocolEsu(dAtA, i, uint64(len(m.DateTime)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WlstEsu_9500) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstEsu_9500) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstEsu_9500) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.XAdjustValue) > 0 {
		dAtA2 := make([]byte, len(m.XAdjustValue)*10)
		var j1 int
		for _, num1 := range m.XAdjustValue {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintProtocolEsu(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x12
	}
	if len(m.XAdjustTime) > 0 {
		dAtA4 := make([]byte, len(m.XAdjustTime)*10)
		var j3 int
		for _, num1 := range m.XAdjustTime {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintProtocolEsu(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WlstEsu_9700) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstEsu_9700) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstEsu_9700) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RunTime != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.RunTime))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.InfoNumber != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.InfoNumber))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.EventType != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.EventType))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.Temperature != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.Temperature))
		i--
		dAtA[i] = 0x78
	}
	if m.SaverStatus != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.SaverStatus))
		i--
		dAtA[i] = 0x70
	}
	if m.SaverTime != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.SaverTime))
		i--
		dAtA[i] = 0x68
	}
	if m.CPhaseOutputCurrent != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CPhaseOutputCurrent))))
		i--
		dAtA[i] = 0x61
	}
	if m.BPhaseOutputCurrent != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.BPhaseOutputCurrent))))
		i--
		dAtA[i] = 0x59
	}
	if m.APhaseOutputCurrent != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.APhaseOutputCurrent))))
		i--
		dAtA[i] = 0x51
	}
	if m.CPhaseOutputVoltage != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CPhaseOutputVoltage))))
		i--
		dAtA[i] = 0x49
	}
	if m.BPhaseOutputVoltage != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.BPhaseOutputVoltage))))
		i--
		dAtA[i] = 0x41
	}
	if m.APhaseOutputVoltage != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.APhaseOutputVoltage))))
		i--
		dAtA[i] = 0x39
	}
	if m.CPhaseInputVoltage != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CPhaseInputVoltage))))
		i--
		dAtA[i] = 0x31
	}
	if m.BPhaseInputVoltage != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.BPhaseInputVoltage))))
		i--
		dAtA[i] = 0x29
	}
	if m.APhaseInputVoltage != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.APhaseInputVoltage))))
		i--
		dAtA[i] = 0x21
	}
	if m.AdjustValue != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.AdjustValue))))
		i--
		dAtA[i] = 0x19
	}
	if len(m.DateTime) > 0 {
		i -= len(m.DateTime)
		copy(dAtA[i:], m.DateTime)
		i = encodeVarintProtocolEsu(dAtA, i, uint64(len(m.DateTime)))
		i--
		dAtA[i] = 0x12
	}
	if m.No != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.No))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstEsu_1800) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstEsu_1800) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstEsu_1800) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AdjustValue != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.AdjustValue))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstEsu_1900) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstEsu_1900) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstEsu_1900) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ManualControl != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.ManualControl))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstEsu_9A00) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstEsu_9A00) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstEsu_9A00) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SaverTime != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.SaverTime))
		i--
		dAtA[i] = 0x20
	}
	if m.RunTime != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.RunTime))
		i--
		dAtA[i] = 0x18
	}
	if len(m.DateTime) > 0 {
		i -= len(m.DateTime)
		copy(dAtA[i:], m.DateTime)
		i = encodeVarintProtocolEsu(dAtA, i, uint64(len(m.DateTime)))
		i--
		dAtA[i] = 0x12
	}
	if m.No != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.No))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WlstEsu_9E00) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WlstEsu_9E00) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WlstEsu_9E00) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SaverMode != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.SaverMode))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.AlarmDelay != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.AlarmDelay))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.AlarmOn != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.AlarmOn))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.WorkMode != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.WorkMode))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.CommunicateMode != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.CommunicateMode))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.PhaseCount != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.PhaseCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.AdjustSpeed != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.AdjustSpeed))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.OutputUndervoltage != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.OutputUndervoltage))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.OutputOverload != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.OutputOverload))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.InputUndervoltage != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.InputUndervoltage))
		i--
		dAtA[i] = 0x78
	}
	if m.InputOvervoltage != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.InputOvervoltage))
		i--
		dAtA[i] = 0x70
	}
	if m.ProtectionTemperature != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.ProtectionTemperature))
		i--
		dAtA[i] = 0x68
	}
	if m.SaverRecoverTemperature != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.SaverRecoverTemperature))
		i--
		dAtA[i] = 0x60
	}
	if m.SaverStopTemperature != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.SaverStopTemperature))
		i--
		dAtA[i] = 0x58
	}
	if m.FanStopTemperature != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.FanStopTemperature))
		i--
		dAtA[i] = 0x50
	}
	if m.FanStartTemperature != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.FanStartTemperature))
		i--
		dAtA[i] = 0x48
	}
	if m.RunMode != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.RunMode))
		i--
		dAtA[i] = 0x40
	}
	if m.TimeMode != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.TimeMode))
		i--
		dAtA[i] = 0x38
	}
	if m.TransformerC != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.TransformerC))
		i--
		dAtA[i] = 0x30
	}
	if m.TransformerB != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.TransformerB))
		i--
		dAtA[i] = 0x28
	}
	if m.TransformerA != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.TransformerA))
		i--
		dAtA[i] = 0x20
	}
	if m.OffTime != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.OffTime))
		i--
		dAtA[i] = 0x18
	}
	if m.OnTime != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.OnTime))
		i--
		dAtA[i] = 0x10
	}
	if m.WarmupTime != 0 {
		i = encodeVarintProtocolEsu(dAtA, i, uint64(m.WarmupTime))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintProtocolEsu(dAtA []byte, offset int, v uint64) int {
	offset -= sovProtocolEsu(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *WlstEsu_9000) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovProtocolEsu(uint64(m.Status))
	}
	return n
}

func (m *WlstEsu_9400) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovProtocolEsu(uint64(m.Status))
	}
	return n
}

func (m *WlstEsu_9200) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WarmupTime != 0 {
		n += 1 + sovProtocolEsu(uint64(m.WarmupTime))
	}
	if m.OnTime != 0 {
		n += 1 + sovProtocolEsu(uint64(m.OnTime))
	}
	if m.OffTime != 0 {
		n += 1 + sovProtocolEsu(uint64(m.OffTime))
	}
	if m.FanStartTemperature != 0 {
		n += 1 + sovProtocolEsu(uint64(m.FanStartTemperature))
	}
	if m.StopSaver != 0 {
		n += 1 + sovProtocolEsu(uint64(m.StopSaver))
	}
	if m.ProtectionTemperature != 0 {
		n += 1 + sovProtocolEsu(uint64(m.ProtectionTemperature))
	}
	if m.InputOvervoltage != 0 {
		n += 1 + sovProtocolEsu(uint64(m.InputOvervoltage))
	}
	if m.InputUndervoltage != 0 {
		n += 1 + sovProtocolEsu(uint64(m.InputUndervoltage))
	}
	if m.OutputOverload != 0 {
		n += 1 + sovProtocolEsu(uint64(m.OutputOverload))
	}
	if m.PhaseCount != 0 {
		n += 1 + sovProtocolEsu(uint64(m.PhaseCount))
	}
	return n
}

func (m *WlstEsu_9F00) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DateTime)
	if l > 0 {
		n += 1 + l + sovProtocolEsu(uint64(l))
	}
	if m.Temperature != 0 {
		n += 1 + sovProtocolEsu(uint64(m.Temperature))
	}
	if m.APhaseInputVoltage != 0 {
		n += 9
	}
	if m.BPhaseInputVoltage != 0 {
		n += 9
	}
	if m.CPhaseInputVoltage != 0 {
		n += 9
	}
	if m.APhaseOutputVoltage != 0 {
		n += 9
	}
	if m.BPhaseOutputVoltage != 0 {
		n += 9
	}
	if m.CPhaseOutputVoltage != 0 {
		n += 9
	}
	if m.APhaseOutputCurrent != 0 {
		n += 9
	}
	if m.BPhaseOutputCurrent != 0 {
		n += 9
	}
	if m.CPhaseOutputCurrent != 0 {
		n += 9
	}
	if m.APhaseOutputPower != 0 {
		n += 9
	}
	if m.BPhaseOutputPower != 0 {
		n += 9
	}
	if m.CPhaseOutputPower != 0 {
		n += 9
	}
	if m.FanStatus != 0 {
		n += 1 + sovProtocolEsu(uint64(m.FanStatus))
	}
	if m.SaverStatus != 0 {
		n += 2 + sovProtocolEsu(uint64(m.SaverStatus))
	}
	if m.RunTime != 0 {
		n += 2 + sovProtocolEsu(uint64(m.RunTime))
	}
	if m.SaverTime != 0 {
		n += 2 + sovProtocolEsu(uint64(m.SaverTime))
	}
	if m.AdjustValue != 0 {
		n += 10
	}
	if m.ExistingFault != 0 {
		n += 2 + sovProtocolEsu(uint64(m.ExistingFault))
	}
	if m.ResetDay0 != 0 {
		n += 2 + sovProtocolEsu(uint64(m.ResetDay0))
	}
	if m.ResetDay1 != 0 {
		n += 2 + sovProtocolEsu(uint64(m.ResetDay1))
	}
	if m.ResetDay2 != 0 {
		n += 2 + sovProtocolEsu(uint64(m.ResetDay2))
	}
	if m.ResetDay3 != 0 {
		n += 2 + sovProtocolEsu(uint64(m.ResetDay3))
	}
	if m.ArgsStatus != 0 {
		n += 2 + sovProtocolEsu(uint64(m.ArgsStatus))
	}
	if m.SaverMode != 0 {
		n += 2 + sovProtocolEsu(uint64(m.SaverMode))
	}
	if m.AdjustStalls != 0 {
		n += 2 + sovProtocolEsu(uint64(m.AdjustStalls))
	}
	if m.AdjustTime != 0 {
		n += 2 + sovProtocolEsu(uint64(m.AdjustTime))
	}
	if m.AdjustA != 0 {
		n += 2 + sovProtocolEsu(uint64(m.AdjustA))
	}
	if m.AdjustB != 0 {
		n += 2 + sovProtocolEsu(uint64(m.AdjustB))
	}
	if m.AdjustC != 0 {
		n += 2 + sovProtocolEsu(uint64(m.AdjustC))
	}
	if m.IgbtStatus != 0 {
		n += 2 + sovProtocolEsu(uint64(m.IgbtStatus))
	}
	if m.IgbtTemperature != 0 {
		n += 2 + sovProtocolEsu(uint64(m.IgbtTemperature))
	}
	if m.EventNo != 0 {
		n += 2 + sovProtocolEsu(uint64(m.EventNo))
	}
	if m.SwitchOutStatus != 0 {
		n += 2 + sovProtocolEsu(uint64(m.SwitchOutStatus))
	}
	if m.SwitchInStatus != 0 {
		n += 2 + sovProtocolEsu(uint64(m.SwitchInStatus))
	}
	if m.RunStatus != 0 {
		n += 2 + sovProtocolEsu(uint64(m.RunStatus))
	}
	return n
}

func (m *WlstEsu_1600) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DateTime)
	if l > 0 {
		n += 1 + l + sovProtocolEsu(uint64(l))
	}
	return n
}

func (m *WlstEsu_9500) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.XAdjustTime) > 0 {
		l = 0
		for _, e := range m.XAdjustTime {
			l += sovProtocolEsu(uint64(e))
		}
		n += 1 + sovProtocolEsu(uint64(l)) + l
	}
	if len(m.XAdjustValue) > 0 {
		l = 0
		for _, e := range m.XAdjustValue {
			l += sovProtocolEsu(uint64(e))
		}
		n += 1 + sovProtocolEsu(uint64(l)) + l
	}
	return n
}

func (m *WlstEsu_9700) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.No != 0 {
		n += 1 + sovProtocolEsu(uint64(m.No))
	}
	l = len(m.DateTime)
	if l > 0 {
		n += 1 + l + sovProtocolEsu(uint64(l))
	}
	if m.AdjustValue != 0 {
		n += 9
	}
	if m.APhaseInputVoltage != 0 {
		n += 9
	}
	if m.BPhaseInputVoltage != 0 {
		n += 9
	}
	if m.CPhaseInputVoltage != 0 {
		n += 9
	}
	if m.APhaseOutputVoltage != 0 {
		n += 9
	}
	if m.BPhaseOutputVoltage != 0 {
		n += 9
	}
	if m.CPhaseOutputVoltage != 0 {
		n += 9
	}
	if m.APhaseOutputCurrent != 0 {
		n += 9
	}
	if m.BPhaseOutputCurrent != 0 {
		n += 9
	}
	if m.CPhaseOutputCurrent != 0 {
		n += 9
	}
	if m.SaverTime != 0 {
		n += 1 + sovProtocolEsu(uint64(m.SaverTime))
	}
	if m.SaverStatus != 0 {
		n += 1 + sovProtocolEsu(uint64(m.SaverStatus))
	}
	if m.Temperature != 0 {
		n += 1 + sovProtocolEsu(uint64(m.Temperature))
	}
	if m.EventType != 0 {
		n += 2 + sovProtocolEsu(uint64(m.EventType))
	}
	if m.InfoNumber != 0 {
		n += 2 + sovProtocolEsu(uint64(m.InfoNumber))
	}
	if m.RunTime != 0 {
		n += 2 + sovProtocolEsu(uint64(m.RunTime))
	}
	return n
}

func (m *WlstEsu_1800) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AdjustValue != 0 {
		n += 1 + sovProtocolEsu(uint64(m.AdjustValue))
	}
	return n
}

func (m *WlstEsu_1900) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ManualControl != 0 {
		n += 1 + sovProtocolEsu(uint64(m.ManualControl))
	}
	return n
}

func (m *WlstEsu_9A00) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.No != 0 {
		n += 1 + sovProtocolEsu(uint64(m.No))
	}
	l = len(m.DateTime)
	if l > 0 {
		n += 1 + l + sovProtocolEsu(uint64(l))
	}
	if m.RunTime != 0 {
		n += 1 + sovProtocolEsu(uint64(m.RunTime))
	}
	if m.SaverTime != 0 {
		n += 1 + sovProtocolEsu(uint64(m.SaverTime))
	}
	return n
}

func (m *WlstEsu_9E00) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WarmupTime != 0 {
		n += 1 + sovProtocolEsu(uint64(m.WarmupTime))
	}
	if m.OnTime != 0 {
		n += 1 + sovProtocolEsu(uint64(m.OnTime))
	}
	if m.OffTime != 0 {
		n += 1 + sovProtocolEsu(uint64(m.OffTime))
	}
	if m.TransformerA != 0 {
		n += 1 + sovProtocolEsu(uint64(m.TransformerA))
	}
	if m.TransformerB != 0 {
		n += 1 + sovProtocolEsu(uint64(m.TransformerB))
	}
	if m.TransformerC != 0 {
		n += 1 + sovProtocolEsu(uint64(m.TransformerC))
	}
	if m.TimeMode != 0 {
		n += 1 + sovProtocolEsu(uint64(m.TimeMode))
	}
	if m.RunMode != 0 {
		n += 1 + sovProtocolEsu(uint64(m.RunMode))
	}
	if m.FanStartTemperature != 0 {
		n += 1 + sovProtocolEsu(uint64(m.FanStartTemperature))
	}
	if m.FanStopTemperature != 0 {
		n += 1 + sovProtocolEsu(uint64(m.FanStopTemperature))
	}
	if m.SaverStopTemperature != 0 {
		n += 1 + sovProtocolEsu(uint64(m.SaverStopTemperature))
	}
	if m.SaverRecoverTemperature != 0 {
		n += 1 + sovProtocolEsu(uint64(m.SaverRecoverTemperature))
	}
	if m.ProtectionTemperature != 0 {
		n += 1 + sovProtocolEsu(uint64(m.ProtectionTemperature))
	}
	if m.InputOvervoltage != 0 {
		n += 1 + sovProtocolEsu(uint64(m.InputOvervoltage))
	}
	if m.InputUndervoltage != 0 {
		n += 1 + sovProtocolEsu(uint64(m.InputUndervoltage))
	}
	if m.OutputOverload != 0 {
		n += 2 + sovProtocolEsu(uint64(m.OutputOverload))
	}
	if m.OutputUndervoltage != 0 {
		n += 2 + sovProtocolEsu(uint64(m.OutputUndervoltage))
	}
	if m.AdjustSpeed != 0 {
		n += 2 + sovProtocolEsu(uint64(m.AdjustSpeed))
	}
	if m.PhaseCount != 0 {
		n += 2 + sovProtocolEsu(uint64(m.PhaseCount))
	}
	if m.CommunicateMode != 0 {
		n += 2 + sovProtocolEsu(uint64(m.CommunicateMode))
	}
	if m.WorkMode != 0 {
		n += 2 + sovProtocolEsu(uint64(m.WorkMode))
	}
	if m.AlarmOn != 0 {
		n += 2 + sovProtocolEsu(uint64(m.AlarmOn))
	}
	if m.AlarmDelay != 0 {
		n += 2 + sovProtocolEsu(uint64(m.AlarmDelay))
	}
	if m.SaverMode != 0 {
		n += 2 + sovProtocolEsu(uint64(m.SaverMode))
	}
	return n
}

func sovProtocolEsu(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozProtocolEsu(x uint64) (n int) {
	return sovProtocolEsu(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *WlstEsu_9000) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolEsu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_esu_9000: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_esu_9000: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolEsu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolEsu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolEsu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstEsu_9400) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolEsu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_esu_9400: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_esu_9400: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolEsu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolEsu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolEsu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstEsu_9200) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolEsu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_esu_9200: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_esu_9200: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WarmupTime", wireType)
			}
			m.WarmupTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WarmupTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnTime", wireType)
			}
			m.OnTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OnTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffTime", wireType)
			}
			m.OffTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OffTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FanStartTemperature", wireType)
			}
			m.FanStartTemperature = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FanStartTemperature |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StopSaver", wireType)
			}
			m.StopSaver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StopSaver |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtectionTemperature", wireType)
			}
			m.ProtectionTemperature = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProtectionTemperature |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputOvervoltage", wireType)
			}
			m.InputOvervoltage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InputOvervoltage |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputUndervoltage", wireType)
			}
			m.InputUndervoltage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InputUndervoltage |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputOverload", wireType)
			}
			m.OutputOverload = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputOverload |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhaseCount", wireType)
			}
			m.PhaseCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PhaseCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolEsu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolEsu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolEsu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstEsu_9F00) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolEsu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_esu_9f00: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_esu_9f00: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolEsu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolEsu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DateTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Temperature", wireType)
			}
			m.Temperature = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Temperature |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field APhaseInputVoltage", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.APhaseInputVoltage = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BPhaseInputVoltage", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.BPhaseInputVoltage = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CPhaseInputVoltage", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CPhaseInputVoltage = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field APhaseOutputVoltage", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.APhaseOutputVoltage = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BPhaseOutputVoltage", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.BPhaseOutputVoltage = float64(math.Float64frombits(v))
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CPhaseOutputVoltage", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CPhaseOutputVoltage = float64(math.Float64frombits(v))
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field APhaseOutputCurrent", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.APhaseOutputCurrent = float64(math.Float64frombits(v))
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BPhaseOutputCurrent", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.BPhaseOutputCurrent = float64(math.Float64frombits(v))
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CPhaseOutputCurrent", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CPhaseOutputCurrent = float64(math.Float64frombits(v))
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field APhaseOutputPower", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.APhaseOutputPower = float64(math.Float64frombits(v))
		case 13:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BPhaseOutputPower", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.BPhaseOutputPower = float64(math.Float64frombits(v))
		case 14:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CPhaseOutputPower", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CPhaseOutputPower = float64(math.Float64frombits(v))
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FanStatus", wireType)
			}
			m.FanStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FanStatus |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SaverStatus", wireType)
			}
			m.SaverStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SaverStatus |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunTime", wireType)
			}
			m.RunTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RunTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SaverTime", wireType)
			}
			m.SaverTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SaverTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdjustValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.AdjustValue = float64(math.Float64frombits(v))
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExistingFault", wireType)
			}
			m.ExistingFault = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExistingFault |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResetDay0", wireType)
			}
			m.ResetDay0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResetDay0 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResetDay1", wireType)
			}
			m.ResetDay1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResetDay1 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResetDay2", wireType)
			}
			m.ResetDay2 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResetDay2 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResetDay3", wireType)
			}
			m.ResetDay3 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResetDay3 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArgsStatus", wireType)
			}
			m.ArgsStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArgsStatus |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SaverMode", wireType)
			}
			m.SaverMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SaverMode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdjustStalls", wireType)
			}
			m.AdjustStalls = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdjustStalls |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdjustTime", wireType)
			}
			m.AdjustTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdjustTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdjustA", wireType)
			}
			m.AdjustA = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdjustA |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdjustB", wireType)
			}
			m.AdjustB = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdjustB |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdjustC", wireType)
			}
			m.AdjustC = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdjustC |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgbtStatus", wireType)
			}
			m.IgbtStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IgbtStatus |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgbtTemperature", wireType)
			}
			m.IgbtTemperature = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IgbtTemperature |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventNo", wireType)
			}
			m.EventNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventNo |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchOutStatus", wireType)
			}
			m.SwitchOutStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SwitchOutStatus |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchInStatus", wireType)
			}
			m.SwitchInStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SwitchInStatus |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunStatus", wireType)
			}
			m.RunStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RunStatus |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolEsu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolEsu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolEsu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstEsu_1600) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolEsu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_esu_1600: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_esu_1600: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolEsu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolEsu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DateTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolEsu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolEsu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolEsu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstEsu_9500) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolEsu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_esu_9500: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_esu_9500: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolEsu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.XAdjustTime = append(m.XAdjustTime, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolEsu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolEsu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolEsu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.XAdjustTime) == 0 {
					m.XAdjustTime = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolEsu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.XAdjustTime = append(m.XAdjustTime, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field XAdjustTime", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolEsu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.XAdjustValue = append(m.XAdjustValue, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProtocolEsu
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProtocolEsu
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProtocolEsu
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.XAdjustValue) == 0 {
					m.XAdjustValue = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProtocolEsu
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.XAdjustValue = append(m.XAdjustValue, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field XAdjustValue", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolEsu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolEsu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolEsu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstEsu_9700) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolEsu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_esu_9700: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_esu_9700: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field No", wireType)
			}
			m.No = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.No |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolEsu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolEsu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DateTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdjustValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.AdjustValue = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field APhaseInputVoltage", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.APhaseInputVoltage = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BPhaseInputVoltage", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.BPhaseInputVoltage = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CPhaseInputVoltage", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CPhaseInputVoltage = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field APhaseOutputVoltage", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.APhaseOutputVoltage = float64(math.Float64frombits(v))
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BPhaseOutputVoltage", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.BPhaseOutputVoltage = float64(math.Float64frombits(v))
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CPhaseOutputVoltage", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CPhaseOutputVoltage = float64(math.Float64frombits(v))
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field APhaseOutputCurrent", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.APhaseOutputCurrent = float64(math.Float64frombits(v))
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BPhaseOutputCurrent", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.BPhaseOutputCurrent = float64(math.Float64frombits(v))
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CPhaseOutputCurrent", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CPhaseOutputCurrent = float64(math.Float64frombits(v))
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SaverTime", wireType)
			}
			m.SaverTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SaverTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SaverStatus", wireType)
			}
			m.SaverStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SaverStatus |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Temperature", wireType)
			}
			m.Temperature = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Temperature |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfoNumber", wireType)
			}
			m.InfoNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InfoNumber |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunTime", wireType)
			}
			m.RunTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RunTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolEsu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolEsu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolEsu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstEsu_1800) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolEsu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_esu_1800: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_esu_1800: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdjustValue", wireType)
			}
			m.AdjustValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdjustValue |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolEsu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolEsu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolEsu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstEsu_1900) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolEsu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_esu_1900: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_esu_1900: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManualControl", wireType)
			}
			m.ManualControl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ManualControl |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolEsu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolEsu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolEsu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstEsu_9A00) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolEsu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_esu_9a00: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_esu_9a00: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field No", wireType)
			}
			m.No = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.No |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolEsu
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolEsu
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DateTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunTime", wireType)
			}
			m.RunTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RunTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SaverTime", wireType)
			}
			m.SaverTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SaverTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolEsu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolEsu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolEsu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WlstEsu_9E00) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolEsu
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wlst_esu_9e00: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wlst_esu_9e00: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WarmupTime", wireType)
			}
			m.WarmupTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WarmupTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnTime", wireType)
			}
			m.OnTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OnTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffTime", wireType)
			}
			m.OffTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OffTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransformerA", wireType)
			}
			m.TransformerA = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransformerA |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransformerB", wireType)
			}
			m.TransformerB = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransformerB |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransformerC", wireType)
			}
			m.TransformerC = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransformerC |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeMode", wireType)
			}
			m.TimeMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeMode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunMode", wireType)
			}
			m.RunMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RunMode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FanStartTemperature", wireType)
			}
			m.FanStartTemperature = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FanStartTemperature |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FanStopTemperature", wireType)
			}
			m.FanStopTemperature = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FanStopTemperature |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SaverStopTemperature", wireType)
			}
			m.SaverStopTemperature = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SaverStopTemperature |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SaverRecoverTemperature", wireType)
			}
			m.SaverRecoverTemperature = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SaverRecoverTemperature |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtectionTemperature", wireType)
			}
			m.ProtectionTemperature = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProtectionTemperature |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputOvervoltage", wireType)
			}
			m.InputOvervoltage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InputOvervoltage |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputUndervoltage", wireType)
			}
			m.InputUndervoltage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InputUndervoltage |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputOverload", wireType)
			}
			m.OutputOverload = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputOverload |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputUndervoltage", wireType)
			}
			m.OutputUndervoltage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputUndervoltage |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdjustSpeed", wireType)
			}
			m.AdjustSpeed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdjustSpeed |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhaseCount", wireType)
			}
			m.PhaseCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PhaseCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommunicateMode", wireType)
			}
			m.CommunicateMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommunicateMode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkMode", wireType)
			}
			m.WorkMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkMode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlarmOn", wireType)
			}
			m.AlarmOn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlarmOn |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlarmDelay", wireType)
			}
			m.AlarmDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlarmDelay |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SaverMode", wireType)
			}
			m.SaverMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SaverMode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolEsu(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolEsu
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolEsu
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipProtocolEsu(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProtocolEsu
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProtocolEsu
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthProtocolEsu
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthProtocolEsu
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowProtocolEsu
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipProtocolEsu(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthProtocolEsu
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthProtocolEsu = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProtocolEsu   = fmt.Errorf("proto: integer overflow")
)
